
H1BR6x.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000bc  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00018ecc  080000bc  080000bc  000100bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000038ac  08018f88  08018f88  00028f88  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0801c834  0801c834  00030a80  2**0
                  CONTENTS
  4 .ARM          00000008  0801c834  0801c834  0002c834  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0801c83c  0801c83c  00030a80  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  0801c83c  0801c83c  0002c83c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0801c844  0801c844  0002c844  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000a80  20000000  0801c848  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00007068  20000a80  0801d2c8  00030a80  2**3
                  ALLOC
 10 ._user_heap_stack 00000400  20007ae8  0801d2c8  00037ae8  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00030a80  2**0
                  CONTENTS, READONLY
 12 .debug_info   0006a337  00000000  00000000  00030aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000aa16  00000000  00000000  0009addf  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00020c4c  00000000  00000000  000a57f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00001f60  00000000  00000000  000c6448  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00003230  00000000  00000000  000c83a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  0001d104  00000000  00000000  000cb5d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   0002abda  00000000  00000000  000e86dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    00085dca  00000000  00000000  001132b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  00199080  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000071c0  00000000  00000000  001990fc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000bc <__do_global_dtors_aux>:
 80000bc:	b510      	push	{r4, lr}
 80000be:	4c06      	ldr	r4, [pc, #24]	; (80000d8 <__do_global_dtors_aux+0x1c>)
 80000c0:	7823      	ldrb	r3, [r4, #0]
 80000c2:	2b00      	cmp	r3, #0
 80000c4:	d107      	bne.n	80000d6 <__do_global_dtors_aux+0x1a>
 80000c6:	4b05      	ldr	r3, [pc, #20]	; (80000dc <__do_global_dtors_aux+0x20>)
 80000c8:	2b00      	cmp	r3, #0
 80000ca:	d002      	beq.n	80000d2 <__do_global_dtors_aux+0x16>
 80000cc:	4804      	ldr	r0, [pc, #16]	; (80000e0 <__do_global_dtors_aux+0x24>)
 80000ce:	e000      	b.n	80000d2 <__do_global_dtors_aux+0x16>
 80000d0:	bf00      	nop
 80000d2:	2301      	movs	r3, #1
 80000d4:	7023      	strb	r3, [r4, #0]
 80000d6:	bd10      	pop	{r4, pc}
 80000d8:	20000a80 	.word	0x20000a80
 80000dc:	00000000 	.word	0x00000000
 80000e0:	08018f70 	.word	0x08018f70

080000e4 <frame_dummy>:
 80000e4:	4b04      	ldr	r3, [pc, #16]	; (80000f8 <frame_dummy+0x14>)
 80000e6:	b510      	push	{r4, lr}
 80000e8:	2b00      	cmp	r3, #0
 80000ea:	d003      	beq.n	80000f4 <frame_dummy+0x10>
 80000ec:	4903      	ldr	r1, [pc, #12]	; (80000fc <frame_dummy+0x18>)
 80000ee:	4804      	ldr	r0, [pc, #16]	; (8000100 <frame_dummy+0x1c>)
 80000f0:	e000      	b.n	80000f4 <frame_dummy+0x10>
 80000f2:	bf00      	nop
 80000f4:	bd10      	pop	{r4, pc}
 80000f6:	46c0      	nop			; (mov r8, r8)
 80000f8:	00000000 	.word	0x00000000
 80000fc:	20000a84 	.word	0x20000a84
 8000100:	08018f70 	.word	0x08018f70

08000104 <strcmp>:
 8000104:	7802      	ldrb	r2, [r0, #0]
 8000106:	780b      	ldrb	r3, [r1, #0]
 8000108:	2a00      	cmp	r2, #0
 800010a:	d003      	beq.n	8000114 <strcmp+0x10>
 800010c:	3001      	adds	r0, #1
 800010e:	3101      	adds	r1, #1
 8000110:	429a      	cmp	r2, r3
 8000112:	d0f7      	beq.n	8000104 <strcmp>
 8000114:	1ad0      	subs	r0, r2, r3
 8000116:	4770      	bx	lr

08000118 <strlen>:
 8000118:	2300      	movs	r3, #0
 800011a:	5cc2      	ldrb	r2, [r0, r3]
 800011c:	3301      	adds	r3, #1
 800011e:	2a00      	cmp	r2, #0
 8000120:	d1fb      	bne.n	800011a <strlen+0x2>
 8000122:	1e58      	subs	r0, r3, #1
 8000124:	4770      	bx	lr
	...

08000128 <__gnu_thumb1_case_sqi>:
 8000128:	b402      	push	{r1}
 800012a:	4671      	mov	r1, lr
 800012c:	0849      	lsrs	r1, r1, #1
 800012e:	0049      	lsls	r1, r1, #1
 8000130:	5609      	ldrsb	r1, [r1, r0]
 8000132:	0049      	lsls	r1, r1, #1
 8000134:	448e      	add	lr, r1
 8000136:	bc02      	pop	{r1}
 8000138:	4770      	bx	lr
 800013a:	46c0      	nop			; (mov r8, r8)

0800013c <__gnu_thumb1_case_uqi>:
 800013c:	b402      	push	{r1}
 800013e:	4671      	mov	r1, lr
 8000140:	0849      	lsrs	r1, r1, #1
 8000142:	0049      	lsls	r1, r1, #1
 8000144:	5c09      	ldrb	r1, [r1, r0]
 8000146:	0049      	lsls	r1, r1, #1
 8000148:	448e      	add	lr, r1
 800014a:	bc02      	pop	{r1}
 800014c:	4770      	bx	lr
 800014e:	46c0      	nop			; (mov r8, r8)

08000150 <__gnu_thumb1_case_shi>:
 8000150:	b403      	push	{r0, r1}
 8000152:	4671      	mov	r1, lr
 8000154:	0849      	lsrs	r1, r1, #1
 8000156:	0040      	lsls	r0, r0, #1
 8000158:	0049      	lsls	r1, r1, #1
 800015a:	5e09      	ldrsh	r1, [r1, r0]
 800015c:	0049      	lsls	r1, r1, #1
 800015e:	448e      	add	lr, r1
 8000160:	bc03      	pop	{r0, r1}
 8000162:	4770      	bx	lr

08000164 <__gnu_thumb1_case_uhi>:
 8000164:	b403      	push	{r0, r1}
 8000166:	4671      	mov	r1, lr
 8000168:	0849      	lsrs	r1, r1, #1
 800016a:	0040      	lsls	r0, r0, #1
 800016c:	0049      	lsls	r1, r1, #1
 800016e:	5a09      	ldrh	r1, [r1, r0]
 8000170:	0049      	lsls	r1, r1, #1
 8000172:	448e      	add	lr, r1
 8000174:	bc03      	pop	{r0, r1}
 8000176:	4770      	bx	lr

08000178 <__udivsi3>:
 8000178:	2200      	movs	r2, #0
 800017a:	0843      	lsrs	r3, r0, #1
 800017c:	428b      	cmp	r3, r1
 800017e:	d374      	bcc.n	800026a <__udivsi3+0xf2>
 8000180:	0903      	lsrs	r3, r0, #4
 8000182:	428b      	cmp	r3, r1
 8000184:	d35f      	bcc.n	8000246 <__udivsi3+0xce>
 8000186:	0a03      	lsrs	r3, r0, #8
 8000188:	428b      	cmp	r3, r1
 800018a:	d344      	bcc.n	8000216 <__udivsi3+0x9e>
 800018c:	0b03      	lsrs	r3, r0, #12
 800018e:	428b      	cmp	r3, r1
 8000190:	d328      	bcc.n	80001e4 <__udivsi3+0x6c>
 8000192:	0c03      	lsrs	r3, r0, #16
 8000194:	428b      	cmp	r3, r1
 8000196:	d30d      	bcc.n	80001b4 <__udivsi3+0x3c>
 8000198:	22ff      	movs	r2, #255	; 0xff
 800019a:	0209      	lsls	r1, r1, #8
 800019c:	ba12      	rev	r2, r2
 800019e:	0c03      	lsrs	r3, r0, #16
 80001a0:	428b      	cmp	r3, r1
 80001a2:	d302      	bcc.n	80001aa <__udivsi3+0x32>
 80001a4:	1212      	asrs	r2, r2, #8
 80001a6:	0209      	lsls	r1, r1, #8
 80001a8:	d065      	beq.n	8000276 <__udivsi3+0xfe>
 80001aa:	0b03      	lsrs	r3, r0, #12
 80001ac:	428b      	cmp	r3, r1
 80001ae:	d319      	bcc.n	80001e4 <__udivsi3+0x6c>
 80001b0:	e000      	b.n	80001b4 <__udivsi3+0x3c>
 80001b2:	0a09      	lsrs	r1, r1, #8
 80001b4:	0bc3      	lsrs	r3, r0, #15
 80001b6:	428b      	cmp	r3, r1
 80001b8:	d301      	bcc.n	80001be <__udivsi3+0x46>
 80001ba:	03cb      	lsls	r3, r1, #15
 80001bc:	1ac0      	subs	r0, r0, r3
 80001be:	4152      	adcs	r2, r2
 80001c0:	0b83      	lsrs	r3, r0, #14
 80001c2:	428b      	cmp	r3, r1
 80001c4:	d301      	bcc.n	80001ca <__udivsi3+0x52>
 80001c6:	038b      	lsls	r3, r1, #14
 80001c8:	1ac0      	subs	r0, r0, r3
 80001ca:	4152      	adcs	r2, r2
 80001cc:	0b43      	lsrs	r3, r0, #13
 80001ce:	428b      	cmp	r3, r1
 80001d0:	d301      	bcc.n	80001d6 <__udivsi3+0x5e>
 80001d2:	034b      	lsls	r3, r1, #13
 80001d4:	1ac0      	subs	r0, r0, r3
 80001d6:	4152      	adcs	r2, r2
 80001d8:	0b03      	lsrs	r3, r0, #12
 80001da:	428b      	cmp	r3, r1
 80001dc:	d301      	bcc.n	80001e2 <__udivsi3+0x6a>
 80001de:	030b      	lsls	r3, r1, #12
 80001e0:	1ac0      	subs	r0, r0, r3
 80001e2:	4152      	adcs	r2, r2
 80001e4:	0ac3      	lsrs	r3, r0, #11
 80001e6:	428b      	cmp	r3, r1
 80001e8:	d301      	bcc.n	80001ee <__udivsi3+0x76>
 80001ea:	02cb      	lsls	r3, r1, #11
 80001ec:	1ac0      	subs	r0, r0, r3
 80001ee:	4152      	adcs	r2, r2
 80001f0:	0a83      	lsrs	r3, r0, #10
 80001f2:	428b      	cmp	r3, r1
 80001f4:	d301      	bcc.n	80001fa <__udivsi3+0x82>
 80001f6:	028b      	lsls	r3, r1, #10
 80001f8:	1ac0      	subs	r0, r0, r3
 80001fa:	4152      	adcs	r2, r2
 80001fc:	0a43      	lsrs	r3, r0, #9
 80001fe:	428b      	cmp	r3, r1
 8000200:	d301      	bcc.n	8000206 <__udivsi3+0x8e>
 8000202:	024b      	lsls	r3, r1, #9
 8000204:	1ac0      	subs	r0, r0, r3
 8000206:	4152      	adcs	r2, r2
 8000208:	0a03      	lsrs	r3, r0, #8
 800020a:	428b      	cmp	r3, r1
 800020c:	d301      	bcc.n	8000212 <__udivsi3+0x9a>
 800020e:	020b      	lsls	r3, r1, #8
 8000210:	1ac0      	subs	r0, r0, r3
 8000212:	4152      	adcs	r2, r2
 8000214:	d2cd      	bcs.n	80001b2 <__udivsi3+0x3a>
 8000216:	09c3      	lsrs	r3, r0, #7
 8000218:	428b      	cmp	r3, r1
 800021a:	d301      	bcc.n	8000220 <__udivsi3+0xa8>
 800021c:	01cb      	lsls	r3, r1, #7
 800021e:	1ac0      	subs	r0, r0, r3
 8000220:	4152      	adcs	r2, r2
 8000222:	0983      	lsrs	r3, r0, #6
 8000224:	428b      	cmp	r3, r1
 8000226:	d301      	bcc.n	800022c <__udivsi3+0xb4>
 8000228:	018b      	lsls	r3, r1, #6
 800022a:	1ac0      	subs	r0, r0, r3
 800022c:	4152      	adcs	r2, r2
 800022e:	0943      	lsrs	r3, r0, #5
 8000230:	428b      	cmp	r3, r1
 8000232:	d301      	bcc.n	8000238 <__udivsi3+0xc0>
 8000234:	014b      	lsls	r3, r1, #5
 8000236:	1ac0      	subs	r0, r0, r3
 8000238:	4152      	adcs	r2, r2
 800023a:	0903      	lsrs	r3, r0, #4
 800023c:	428b      	cmp	r3, r1
 800023e:	d301      	bcc.n	8000244 <__udivsi3+0xcc>
 8000240:	010b      	lsls	r3, r1, #4
 8000242:	1ac0      	subs	r0, r0, r3
 8000244:	4152      	adcs	r2, r2
 8000246:	08c3      	lsrs	r3, r0, #3
 8000248:	428b      	cmp	r3, r1
 800024a:	d301      	bcc.n	8000250 <__udivsi3+0xd8>
 800024c:	00cb      	lsls	r3, r1, #3
 800024e:	1ac0      	subs	r0, r0, r3
 8000250:	4152      	adcs	r2, r2
 8000252:	0883      	lsrs	r3, r0, #2
 8000254:	428b      	cmp	r3, r1
 8000256:	d301      	bcc.n	800025c <__udivsi3+0xe4>
 8000258:	008b      	lsls	r3, r1, #2
 800025a:	1ac0      	subs	r0, r0, r3
 800025c:	4152      	adcs	r2, r2
 800025e:	0843      	lsrs	r3, r0, #1
 8000260:	428b      	cmp	r3, r1
 8000262:	d301      	bcc.n	8000268 <__udivsi3+0xf0>
 8000264:	004b      	lsls	r3, r1, #1
 8000266:	1ac0      	subs	r0, r0, r3
 8000268:	4152      	adcs	r2, r2
 800026a:	1a41      	subs	r1, r0, r1
 800026c:	d200      	bcs.n	8000270 <__udivsi3+0xf8>
 800026e:	4601      	mov	r1, r0
 8000270:	4152      	adcs	r2, r2
 8000272:	4610      	mov	r0, r2
 8000274:	4770      	bx	lr
 8000276:	e7ff      	b.n	8000278 <__udivsi3+0x100>
 8000278:	b501      	push	{r0, lr}
 800027a:	2000      	movs	r0, #0
 800027c:	f000 f8f0 	bl	8000460 <__aeabi_idiv0>
 8000280:	bd02      	pop	{r1, pc}
 8000282:	46c0      	nop			; (mov r8, r8)

08000284 <__aeabi_uidivmod>:
 8000284:	2900      	cmp	r1, #0
 8000286:	d0f7      	beq.n	8000278 <__udivsi3+0x100>
 8000288:	e776      	b.n	8000178 <__udivsi3>
 800028a:	4770      	bx	lr

0800028c <__divsi3>:
 800028c:	4603      	mov	r3, r0
 800028e:	430b      	orrs	r3, r1
 8000290:	d47f      	bmi.n	8000392 <__divsi3+0x106>
 8000292:	2200      	movs	r2, #0
 8000294:	0843      	lsrs	r3, r0, #1
 8000296:	428b      	cmp	r3, r1
 8000298:	d374      	bcc.n	8000384 <__divsi3+0xf8>
 800029a:	0903      	lsrs	r3, r0, #4
 800029c:	428b      	cmp	r3, r1
 800029e:	d35f      	bcc.n	8000360 <__divsi3+0xd4>
 80002a0:	0a03      	lsrs	r3, r0, #8
 80002a2:	428b      	cmp	r3, r1
 80002a4:	d344      	bcc.n	8000330 <__divsi3+0xa4>
 80002a6:	0b03      	lsrs	r3, r0, #12
 80002a8:	428b      	cmp	r3, r1
 80002aa:	d328      	bcc.n	80002fe <__divsi3+0x72>
 80002ac:	0c03      	lsrs	r3, r0, #16
 80002ae:	428b      	cmp	r3, r1
 80002b0:	d30d      	bcc.n	80002ce <__divsi3+0x42>
 80002b2:	22ff      	movs	r2, #255	; 0xff
 80002b4:	0209      	lsls	r1, r1, #8
 80002b6:	ba12      	rev	r2, r2
 80002b8:	0c03      	lsrs	r3, r0, #16
 80002ba:	428b      	cmp	r3, r1
 80002bc:	d302      	bcc.n	80002c4 <__divsi3+0x38>
 80002be:	1212      	asrs	r2, r2, #8
 80002c0:	0209      	lsls	r1, r1, #8
 80002c2:	d065      	beq.n	8000390 <__divsi3+0x104>
 80002c4:	0b03      	lsrs	r3, r0, #12
 80002c6:	428b      	cmp	r3, r1
 80002c8:	d319      	bcc.n	80002fe <__divsi3+0x72>
 80002ca:	e000      	b.n	80002ce <__divsi3+0x42>
 80002cc:	0a09      	lsrs	r1, r1, #8
 80002ce:	0bc3      	lsrs	r3, r0, #15
 80002d0:	428b      	cmp	r3, r1
 80002d2:	d301      	bcc.n	80002d8 <__divsi3+0x4c>
 80002d4:	03cb      	lsls	r3, r1, #15
 80002d6:	1ac0      	subs	r0, r0, r3
 80002d8:	4152      	adcs	r2, r2
 80002da:	0b83      	lsrs	r3, r0, #14
 80002dc:	428b      	cmp	r3, r1
 80002de:	d301      	bcc.n	80002e4 <__divsi3+0x58>
 80002e0:	038b      	lsls	r3, r1, #14
 80002e2:	1ac0      	subs	r0, r0, r3
 80002e4:	4152      	adcs	r2, r2
 80002e6:	0b43      	lsrs	r3, r0, #13
 80002e8:	428b      	cmp	r3, r1
 80002ea:	d301      	bcc.n	80002f0 <__divsi3+0x64>
 80002ec:	034b      	lsls	r3, r1, #13
 80002ee:	1ac0      	subs	r0, r0, r3
 80002f0:	4152      	adcs	r2, r2
 80002f2:	0b03      	lsrs	r3, r0, #12
 80002f4:	428b      	cmp	r3, r1
 80002f6:	d301      	bcc.n	80002fc <__divsi3+0x70>
 80002f8:	030b      	lsls	r3, r1, #12
 80002fa:	1ac0      	subs	r0, r0, r3
 80002fc:	4152      	adcs	r2, r2
 80002fe:	0ac3      	lsrs	r3, r0, #11
 8000300:	428b      	cmp	r3, r1
 8000302:	d301      	bcc.n	8000308 <__divsi3+0x7c>
 8000304:	02cb      	lsls	r3, r1, #11
 8000306:	1ac0      	subs	r0, r0, r3
 8000308:	4152      	adcs	r2, r2
 800030a:	0a83      	lsrs	r3, r0, #10
 800030c:	428b      	cmp	r3, r1
 800030e:	d301      	bcc.n	8000314 <__divsi3+0x88>
 8000310:	028b      	lsls	r3, r1, #10
 8000312:	1ac0      	subs	r0, r0, r3
 8000314:	4152      	adcs	r2, r2
 8000316:	0a43      	lsrs	r3, r0, #9
 8000318:	428b      	cmp	r3, r1
 800031a:	d301      	bcc.n	8000320 <__divsi3+0x94>
 800031c:	024b      	lsls	r3, r1, #9
 800031e:	1ac0      	subs	r0, r0, r3
 8000320:	4152      	adcs	r2, r2
 8000322:	0a03      	lsrs	r3, r0, #8
 8000324:	428b      	cmp	r3, r1
 8000326:	d301      	bcc.n	800032c <__divsi3+0xa0>
 8000328:	020b      	lsls	r3, r1, #8
 800032a:	1ac0      	subs	r0, r0, r3
 800032c:	4152      	adcs	r2, r2
 800032e:	d2cd      	bcs.n	80002cc <__divsi3+0x40>
 8000330:	09c3      	lsrs	r3, r0, #7
 8000332:	428b      	cmp	r3, r1
 8000334:	d301      	bcc.n	800033a <__divsi3+0xae>
 8000336:	01cb      	lsls	r3, r1, #7
 8000338:	1ac0      	subs	r0, r0, r3
 800033a:	4152      	adcs	r2, r2
 800033c:	0983      	lsrs	r3, r0, #6
 800033e:	428b      	cmp	r3, r1
 8000340:	d301      	bcc.n	8000346 <__divsi3+0xba>
 8000342:	018b      	lsls	r3, r1, #6
 8000344:	1ac0      	subs	r0, r0, r3
 8000346:	4152      	adcs	r2, r2
 8000348:	0943      	lsrs	r3, r0, #5
 800034a:	428b      	cmp	r3, r1
 800034c:	d301      	bcc.n	8000352 <__divsi3+0xc6>
 800034e:	014b      	lsls	r3, r1, #5
 8000350:	1ac0      	subs	r0, r0, r3
 8000352:	4152      	adcs	r2, r2
 8000354:	0903      	lsrs	r3, r0, #4
 8000356:	428b      	cmp	r3, r1
 8000358:	d301      	bcc.n	800035e <__divsi3+0xd2>
 800035a:	010b      	lsls	r3, r1, #4
 800035c:	1ac0      	subs	r0, r0, r3
 800035e:	4152      	adcs	r2, r2
 8000360:	08c3      	lsrs	r3, r0, #3
 8000362:	428b      	cmp	r3, r1
 8000364:	d301      	bcc.n	800036a <__divsi3+0xde>
 8000366:	00cb      	lsls	r3, r1, #3
 8000368:	1ac0      	subs	r0, r0, r3
 800036a:	4152      	adcs	r2, r2
 800036c:	0883      	lsrs	r3, r0, #2
 800036e:	428b      	cmp	r3, r1
 8000370:	d301      	bcc.n	8000376 <__divsi3+0xea>
 8000372:	008b      	lsls	r3, r1, #2
 8000374:	1ac0      	subs	r0, r0, r3
 8000376:	4152      	adcs	r2, r2
 8000378:	0843      	lsrs	r3, r0, #1
 800037a:	428b      	cmp	r3, r1
 800037c:	d301      	bcc.n	8000382 <__divsi3+0xf6>
 800037e:	004b      	lsls	r3, r1, #1
 8000380:	1ac0      	subs	r0, r0, r3
 8000382:	4152      	adcs	r2, r2
 8000384:	1a41      	subs	r1, r0, r1
 8000386:	d200      	bcs.n	800038a <__divsi3+0xfe>
 8000388:	4601      	mov	r1, r0
 800038a:	4152      	adcs	r2, r2
 800038c:	4610      	mov	r0, r2
 800038e:	4770      	bx	lr
 8000390:	e05d      	b.n	800044e <__divsi3+0x1c2>
 8000392:	0fca      	lsrs	r2, r1, #31
 8000394:	d000      	beq.n	8000398 <__divsi3+0x10c>
 8000396:	4249      	negs	r1, r1
 8000398:	1003      	asrs	r3, r0, #32
 800039a:	d300      	bcc.n	800039e <__divsi3+0x112>
 800039c:	4240      	negs	r0, r0
 800039e:	4053      	eors	r3, r2
 80003a0:	2200      	movs	r2, #0
 80003a2:	469c      	mov	ip, r3
 80003a4:	0903      	lsrs	r3, r0, #4
 80003a6:	428b      	cmp	r3, r1
 80003a8:	d32d      	bcc.n	8000406 <__divsi3+0x17a>
 80003aa:	0a03      	lsrs	r3, r0, #8
 80003ac:	428b      	cmp	r3, r1
 80003ae:	d312      	bcc.n	80003d6 <__divsi3+0x14a>
 80003b0:	22fc      	movs	r2, #252	; 0xfc
 80003b2:	0189      	lsls	r1, r1, #6
 80003b4:	ba12      	rev	r2, r2
 80003b6:	0a03      	lsrs	r3, r0, #8
 80003b8:	428b      	cmp	r3, r1
 80003ba:	d30c      	bcc.n	80003d6 <__divsi3+0x14a>
 80003bc:	0189      	lsls	r1, r1, #6
 80003be:	1192      	asrs	r2, r2, #6
 80003c0:	428b      	cmp	r3, r1
 80003c2:	d308      	bcc.n	80003d6 <__divsi3+0x14a>
 80003c4:	0189      	lsls	r1, r1, #6
 80003c6:	1192      	asrs	r2, r2, #6
 80003c8:	428b      	cmp	r3, r1
 80003ca:	d304      	bcc.n	80003d6 <__divsi3+0x14a>
 80003cc:	0189      	lsls	r1, r1, #6
 80003ce:	d03a      	beq.n	8000446 <__divsi3+0x1ba>
 80003d0:	1192      	asrs	r2, r2, #6
 80003d2:	e000      	b.n	80003d6 <__divsi3+0x14a>
 80003d4:	0989      	lsrs	r1, r1, #6
 80003d6:	09c3      	lsrs	r3, r0, #7
 80003d8:	428b      	cmp	r3, r1
 80003da:	d301      	bcc.n	80003e0 <__divsi3+0x154>
 80003dc:	01cb      	lsls	r3, r1, #7
 80003de:	1ac0      	subs	r0, r0, r3
 80003e0:	4152      	adcs	r2, r2
 80003e2:	0983      	lsrs	r3, r0, #6
 80003e4:	428b      	cmp	r3, r1
 80003e6:	d301      	bcc.n	80003ec <__divsi3+0x160>
 80003e8:	018b      	lsls	r3, r1, #6
 80003ea:	1ac0      	subs	r0, r0, r3
 80003ec:	4152      	adcs	r2, r2
 80003ee:	0943      	lsrs	r3, r0, #5
 80003f0:	428b      	cmp	r3, r1
 80003f2:	d301      	bcc.n	80003f8 <__divsi3+0x16c>
 80003f4:	014b      	lsls	r3, r1, #5
 80003f6:	1ac0      	subs	r0, r0, r3
 80003f8:	4152      	adcs	r2, r2
 80003fa:	0903      	lsrs	r3, r0, #4
 80003fc:	428b      	cmp	r3, r1
 80003fe:	d301      	bcc.n	8000404 <__divsi3+0x178>
 8000400:	010b      	lsls	r3, r1, #4
 8000402:	1ac0      	subs	r0, r0, r3
 8000404:	4152      	adcs	r2, r2
 8000406:	08c3      	lsrs	r3, r0, #3
 8000408:	428b      	cmp	r3, r1
 800040a:	d301      	bcc.n	8000410 <__divsi3+0x184>
 800040c:	00cb      	lsls	r3, r1, #3
 800040e:	1ac0      	subs	r0, r0, r3
 8000410:	4152      	adcs	r2, r2
 8000412:	0883      	lsrs	r3, r0, #2
 8000414:	428b      	cmp	r3, r1
 8000416:	d301      	bcc.n	800041c <__divsi3+0x190>
 8000418:	008b      	lsls	r3, r1, #2
 800041a:	1ac0      	subs	r0, r0, r3
 800041c:	4152      	adcs	r2, r2
 800041e:	d2d9      	bcs.n	80003d4 <__divsi3+0x148>
 8000420:	0843      	lsrs	r3, r0, #1
 8000422:	428b      	cmp	r3, r1
 8000424:	d301      	bcc.n	800042a <__divsi3+0x19e>
 8000426:	004b      	lsls	r3, r1, #1
 8000428:	1ac0      	subs	r0, r0, r3
 800042a:	4152      	adcs	r2, r2
 800042c:	1a41      	subs	r1, r0, r1
 800042e:	d200      	bcs.n	8000432 <__divsi3+0x1a6>
 8000430:	4601      	mov	r1, r0
 8000432:	4663      	mov	r3, ip
 8000434:	4152      	adcs	r2, r2
 8000436:	105b      	asrs	r3, r3, #1
 8000438:	4610      	mov	r0, r2
 800043a:	d301      	bcc.n	8000440 <__divsi3+0x1b4>
 800043c:	4240      	negs	r0, r0
 800043e:	2b00      	cmp	r3, #0
 8000440:	d500      	bpl.n	8000444 <__divsi3+0x1b8>
 8000442:	4249      	negs	r1, r1
 8000444:	4770      	bx	lr
 8000446:	4663      	mov	r3, ip
 8000448:	105b      	asrs	r3, r3, #1
 800044a:	d300      	bcc.n	800044e <__divsi3+0x1c2>
 800044c:	4240      	negs	r0, r0
 800044e:	b501      	push	{r0, lr}
 8000450:	2000      	movs	r0, #0
 8000452:	f000 f805 	bl	8000460 <__aeabi_idiv0>
 8000456:	bd02      	pop	{r1, pc}

08000458 <__aeabi_idivmod>:
 8000458:	2900      	cmp	r1, #0
 800045a:	d0f8      	beq.n	800044e <__divsi3+0x1c2>
 800045c:	e716      	b.n	800028c <__divsi3>
 800045e:	4770      	bx	lr

08000460 <__aeabi_idiv0>:
 8000460:	4770      	bx	lr
 8000462:	46c0      	nop			; (mov r8, r8)

08000464 <__aeabi_llsr>:
 8000464:	40d0      	lsrs	r0, r2
 8000466:	1c0b      	adds	r3, r1, #0
 8000468:	40d1      	lsrs	r1, r2
 800046a:	469c      	mov	ip, r3
 800046c:	3a20      	subs	r2, #32
 800046e:	40d3      	lsrs	r3, r2
 8000470:	4318      	orrs	r0, r3
 8000472:	4252      	negs	r2, r2
 8000474:	4663      	mov	r3, ip
 8000476:	4093      	lsls	r3, r2
 8000478:	4318      	orrs	r0, r3
 800047a:	4770      	bx	lr

0800047c <__aeabi_cdrcmple>:
 800047c:	4684      	mov	ip, r0
 800047e:	1c10      	adds	r0, r2, #0
 8000480:	4662      	mov	r2, ip
 8000482:	468c      	mov	ip, r1
 8000484:	1c19      	adds	r1, r3, #0
 8000486:	4663      	mov	r3, ip
 8000488:	e000      	b.n	800048c <__aeabi_cdcmpeq>
 800048a:	46c0      	nop			; (mov r8, r8)

0800048c <__aeabi_cdcmpeq>:
 800048c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800048e:	f001 fc29 	bl	8001ce4 <__ledf2>
 8000492:	2800      	cmp	r0, #0
 8000494:	d401      	bmi.n	800049a <__aeabi_cdcmpeq+0xe>
 8000496:	2100      	movs	r1, #0
 8000498:	42c8      	cmn	r0, r1
 800049a:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

0800049c <__aeabi_dcmpeq>:
 800049c:	b510      	push	{r4, lr}
 800049e:	f001 fb81 	bl	8001ba4 <__eqdf2>
 80004a2:	4240      	negs	r0, r0
 80004a4:	3001      	adds	r0, #1
 80004a6:	bd10      	pop	{r4, pc}

080004a8 <__aeabi_dcmplt>:
 80004a8:	b510      	push	{r4, lr}
 80004aa:	f001 fc1b 	bl	8001ce4 <__ledf2>
 80004ae:	2800      	cmp	r0, #0
 80004b0:	db01      	blt.n	80004b6 <__aeabi_dcmplt+0xe>
 80004b2:	2000      	movs	r0, #0
 80004b4:	bd10      	pop	{r4, pc}
 80004b6:	2001      	movs	r0, #1
 80004b8:	bd10      	pop	{r4, pc}
 80004ba:	46c0      	nop			; (mov r8, r8)

080004bc <__aeabi_dcmple>:
 80004bc:	b510      	push	{r4, lr}
 80004be:	f001 fc11 	bl	8001ce4 <__ledf2>
 80004c2:	2800      	cmp	r0, #0
 80004c4:	dd01      	ble.n	80004ca <__aeabi_dcmple+0xe>
 80004c6:	2000      	movs	r0, #0
 80004c8:	bd10      	pop	{r4, pc}
 80004ca:	2001      	movs	r0, #1
 80004cc:	bd10      	pop	{r4, pc}
 80004ce:	46c0      	nop			; (mov r8, r8)

080004d0 <__aeabi_dcmpgt>:
 80004d0:	b510      	push	{r4, lr}
 80004d2:	f001 fba3 	bl	8001c1c <__gedf2>
 80004d6:	2800      	cmp	r0, #0
 80004d8:	dc01      	bgt.n	80004de <__aeabi_dcmpgt+0xe>
 80004da:	2000      	movs	r0, #0
 80004dc:	bd10      	pop	{r4, pc}
 80004de:	2001      	movs	r0, #1
 80004e0:	bd10      	pop	{r4, pc}
 80004e2:	46c0      	nop			; (mov r8, r8)

080004e4 <__aeabi_dcmpge>:
 80004e4:	b510      	push	{r4, lr}
 80004e6:	f001 fb99 	bl	8001c1c <__gedf2>
 80004ea:	2800      	cmp	r0, #0
 80004ec:	da01      	bge.n	80004f2 <__aeabi_dcmpge+0xe>
 80004ee:	2000      	movs	r0, #0
 80004f0:	bd10      	pop	{r4, pc}
 80004f2:	2001      	movs	r0, #1
 80004f4:	bd10      	pop	{r4, pc}
 80004f6:	46c0      	nop			; (mov r8, r8)

080004f8 <__aeabi_cfrcmple>:
 80004f8:	4684      	mov	ip, r0
 80004fa:	1c08      	adds	r0, r1, #0
 80004fc:	4661      	mov	r1, ip
 80004fe:	e7ff      	b.n	8000500 <__aeabi_cfcmpeq>

08000500 <__aeabi_cfcmpeq>:
 8000500:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8000502:	f000 fafd 	bl	8000b00 <__lesf2>
 8000506:	2800      	cmp	r0, #0
 8000508:	d401      	bmi.n	800050e <__aeabi_cfcmpeq+0xe>
 800050a:	2100      	movs	r1, #0
 800050c:	42c8      	cmn	r0, r1
 800050e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08000510 <__aeabi_fcmpeq>:
 8000510:	b510      	push	{r4, lr}
 8000512:	f000 fa7f 	bl	8000a14 <__eqsf2>
 8000516:	4240      	negs	r0, r0
 8000518:	3001      	adds	r0, #1
 800051a:	bd10      	pop	{r4, pc}

0800051c <__aeabi_fcmplt>:
 800051c:	b510      	push	{r4, lr}
 800051e:	f000 faef 	bl	8000b00 <__lesf2>
 8000522:	2800      	cmp	r0, #0
 8000524:	db01      	blt.n	800052a <__aeabi_fcmplt+0xe>
 8000526:	2000      	movs	r0, #0
 8000528:	bd10      	pop	{r4, pc}
 800052a:	2001      	movs	r0, #1
 800052c:	bd10      	pop	{r4, pc}
 800052e:	46c0      	nop			; (mov r8, r8)

08000530 <__aeabi_fcmple>:
 8000530:	b510      	push	{r4, lr}
 8000532:	f000 fae5 	bl	8000b00 <__lesf2>
 8000536:	2800      	cmp	r0, #0
 8000538:	dd01      	ble.n	800053e <__aeabi_fcmple+0xe>
 800053a:	2000      	movs	r0, #0
 800053c:	bd10      	pop	{r4, pc}
 800053e:	2001      	movs	r0, #1
 8000540:	bd10      	pop	{r4, pc}
 8000542:	46c0      	nop			; (mov r8, r8)

08000544 <__aeabi_fcmpgt>:
 8000544:	b510      	push	{r4, lr}
 8000546:	f000 fa8d 	bl	8000a64 <__gesf2>
 800054a:	2800      	cmp	r0, #0
 800054c:	dc01      	bgt.n	8000552 <__aeabi_fcmpgt+0xe>
 800054e:	2000      	movs	r0, #0
 8000550:	bd10      	pop	{r4, pc}
 8000552:	2001      	movs	r0, #1
 8000554:	bd10      	pop	{r4, pc}
 8000556:	46c0      	nop			; (mov r8, r8)

08000558 <__aeabi_fcmpge>:
 8000558:	b510      	push	{r4, lr}
 800055a:	f000 fa83 	bl	8000a64 <__gesf2>
 800055e:	2800      	cmp	r0, #0
 8000560:	da01      	bge.n	8000566 <__aeabi_fcmpge+0xe>
 8000562:	2000      	movs	r0, #0
 8000564:	bd10      	pop	{r4, pc}
 8000566:	2001      	movs	r0, #1
 8000568:	bd10      	pop	{r4, pc}
 800056a:	46c0      	nop			; (mov r8, r8)

0800056c <__aeabi_uldivmod>:
 800056c:	2b00      	cmp	r3, #0
 800056e:	d111      	bne.n	8000594 <__aeabi_uldivmod+0x28>
 8000570:	2a00      	cmp	r2, #0
 8000572:	d10f      	bne.n	8000594 <__aeabi_uldivmod+0x28>
 8000574:	2900      	cmp	r1, #0
 8000576:	d100      	bne.n	800057a <__aeabi_uldivmod+0xe>
 8000578:	2800      	cmp	r0, #0
 800057a:	d002      	beq.n	8000582 <__aeabi_uldivmod+0x16>
 800057c:	2100      	movs	r1, #0
 800057e:	43c9      	mvns	r1, r1
 8000580:	1c08      	adds	r0, r1, #0
 8000582:	b407      	push	{r0, r1, r2}
 8000584:	4802      	ldr	r0, [pc, #8]	; (8000590 <__aeabi_uldivmod+0x24>)
 8000586:	a102      	add	r1, pc, #8	; (adr r1, 8000590 <__aeabi_uldivmod+0x24>)
 8000588:	1840      	adds	r0, r0, r1
 800058a:	9002      	str	r0, [sp, #8]
 800058c:	bd03      	pop	{r0, r1, pc}
 800058e:	46c0      	nop			; (mov r8, r8)
 8000590:	fffffed1 	.word	0xfffffed1
 8000594:	b403      	push	{r0, r1}
 8000596:	4668      	mov	r0, sp
 8000598:	b501      	push	{r0, lr}
 800059a:	9802      	ldr	r0, [sp, #8]
 800059c:	f000 f866 	bl	800066c <__udivmoddi4>
 80005a0:	9b01      	ldr	r3, [sp, #4]
 80005a2:	469e      	mov	lr, r3
 80005a4:	b002      	add	sp, #8
 80005a6:	bc0c      	pop	{r2, r3}
 80005a8:	4770      	bx	lr
 80005aa:	46c0      	nop			; (mov r8, r8)

080005ac <__aeabi_lmul>:
 80005ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80005ae:	46ce      	mov	lr, r9
 80005b0:	4647      	mov	r7, r8
 80005b2:	0415      	lsls	r5, r2, #16
 80005b4:	0c2d      	lsrs	r5, r5, #16
 80005b6:	002e      	movs	r6, r5
 80005b8:	b580      	push	{r7, lr}
 80005ba:	0407      	lsls	r7, r0, #16
 80005bc:	0c14      	lsrs	r4, r2, #16
 80005be:	0c3f      	lsrs	r7, r7, #16
 80005c0:	4699      	mov	r9, r3
 80005c2:	0c03      	lsrs	r3, r0, #16
 80005c4:	437e      	muls	r6, r7
 80005c6:	435d      	muls	r5, r3
 80005c8:	4367      	muls	r7, r4
 80005ca:	4363      	muls	r3, r4
 80005cc:	197f      	adds	r7, r7, r5
 80005ce:	0c34      	lsrs	r4, r6, #16
 80005d0:	19e4      	adds	r4, r4, r7
 80005d2:	469c      	mov	ip, r3
 80005d4:	42a5      	cmp	r5, r4
 80005d6:	d903      	bls.n	80005e0 <__aeabi_lmul+0x34>
 80005d8:	2380      	movs	r3, #128	; 0x80
 80005da:	025b      	lsls	r3, r3, #9
 80005dc:	4698      	mov	r8, r3
 80005de:	44c4      	add	ip, r8
 80005e0:	464b      	mov	r3, r9
 80005e2:	4343      	muls	r3, r0
 80005e4:	4351      	muls	r1, r2
 80005e6:	0c25      	lsrs	r5, r4, #16
 80005e8:	0436      	lsls	r6, r6, #16
 80005ea:	4465      	add	r5, ip
 80005ec:	0c36      	lsrs	r6, r6, #16
 80005ee:	0424      	lsls	r4, r4, #16
 80005f0:	19a4      	adds	r4, r4, r6
 80005f2:	195b      	adds	r3, r3, r5
 80005f4:	1859      	adds	r1, r3, r1
 80005f6:	0020      	movs	r0, r4
 80005f8:	bc0c      	pop	{r2, r3}
 80005fa:	4690      	mov	r8, r2
 80005fc:	4699      	mov	r9, r3
 80005fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000600 <__aeabi_f2uiz>:
 8000600:	219e      	movs	r1, #158	; 0x9e
 8000602:	b510      	push	{r4, lr}
 8000604:	05c9      	lsls	r1, r1, #23
 8000606:	1c04      	adds	r4, r0, #0
 8000608:	f7ff ffa6 	bl	8000558 <__aeabi_fcmpge>
 800060c:	2800      	cmp	r0, #0
 800060e:	d103      	bne.n	8000618 <__aeabi_f2uiz+0x18>
 8000610:	1c20      	adds	r0, r4, #0
 8000612:	f000 fc89 	bl	8000f28 <__aeabi_f2iz>
 8000616:	bd10      	pop	{r4, pc}
 8000618:	219e      	movs	r1, #158	; 0x9e
 800061a:	1c20      	adds	r0, r4, #0
 800061c:	05c9      	lsls	r1, r1, #23
 800061e:	f000 fabf 	bl	8000ba0 <__aeabi_fsub>
 8000622:	f000 fc81 	bl	8000f28 <__aeabi_f2iz>
 8000626:	2380      	movs	r3, #128	; 0x80
 8000628:	061b      	lsls	r3, r3, #24
 800062a:	469c      	mov	ip, r3
 800062c:	4460      	add	r0, ip
 800062e:	e7f2      	b.n	8000616 <__aeabi_f2uiz+0x16>

08000630 <__aeabi_d2uiz>:
 8000630:	b570      	push	{r4, r5, r6, lr}
 8000632:	2200      	movs	r2, #0
 8000634:	4b0c      	ldr	r3, [pc, #48]	; (8000668 <__aeabi_d2uiz+0x38>)
 8000636:	0004      	movs	r4, r0
 8000638:	000d      	movs	r5, r1
 800063a:	f7ff ff53 	bl	80004e4 <__aeabi_dcmpge>
 800063e:	2800      	cmp	r0, #0
 8000640:	d104      	bne.n	800064c <__aeabi_d2uiz+0x1c>
 8000642:	0020      	movs	r0, r4
 8000644:	0029      	movs	r1, r5
 8000646:	f002 f98b 	bl	8002960 <__aeabi_d2iz>
 800064a:	bd70      	pop	{r4, r5, r6, pc}
 800064c:	4b06      	ldr	r3, [pc, #24]	; (8000668 <__aeabi_d2uiz+0x38>)
 800064e:	2200      	movs	r2, #0
 8000650:	0020      	movs	r0, r4
 8000652:	0029      	movs	r1, r5
 8000654:	f001 fe20 	bl	8002298 <__aeabi_dsub>
 8000658:	f002 f982 	bl	8002960 <__aeabi_d2iz>
 800065c:	2380      	movs	r3, #128	; 0x80
 800065e:	061b      	lsls	r3, r3, #24
 8000660:	469c      	mov	ip, r3
 8000662:	4460      	add	r0, ip
 8000664:	e7f1      	b.n	800064a <__aeabi_d2uiz+0x1a>
 8000666:	46c0      	nop			; (mov r8, r8)
 8000668:	41e00000 	.word	0x41e00000

0800066c <__udivmoddi4>:
 800066c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800066e:	464f      	mov	r7, r9
 8000670:	4646      	mov	r6, r8
 8000672:	46d6      	mov	lr, sl
 8000674:	b5c0      	push	{r6, r7, lr}
 8000676:	0004      	movs	r4, r0
 8000678:	b082      	sub	sp, #8
 800067a:	000d      	movs	r5, r1
 800067c:	4691      	mov	r9, r2
 800067e:	4698      	mov	r8, r3
 8000680:	428b      	cmp	r3, r1
 8000682:	d82f      	bhi.n	80006e4 <__udivmoddi4+0x78>
 8000684:	d02c      	beq.n	80006e0 <__udivmoddi4+0x74>
 8000686:	4641      	mov	r1, r8
 8000688:	4648      	mov	r0, r9
 800068a:	f002 faff 	bl	8002c8c <__clzdi2>
 800068e:	0029      	movs	r1, r5
 8000690:	0006      	movs	r6, r0
 8000692:	0020      	movs	r0, r4
 8000694:	f002 fafa 	bl	8002c8c <__clzdi2>
 8000698:	1a33      	subs	r3, r6, r0
 800069a:	469c      	mov	ip, r3
 800069c:	3b20      	subs	r3, #32
 800069e:	469a      	mov	sl, r3
 80006a0:	d500      	bpl.n	80006a4 <__udivmoddi4+0x38>
 80006a2:	e076      	b.n	8000792 <__udivmoddi4+0x126>
 80006a4:	464b      	mov	r3, r9
 80006a6:	4652      	mov	r2, sl
 80006a8:	4093      	lsls	r3, r2
 80006aa:	001f      	movs	r7, r3
 80006ac:	464b      	mov	r3, r9
 80006ae:	4662      	mov	r2, ip
 80006b0:	4093      	lsls	r3, r2
 80006b2:	001e      	movs	r6, r3
 80006b4:	42af      	cmp	r7, r5
 80006b6:	d828      	bhi.n	800070a <__udivmoddi4+0x9e>
 80006b8:	d025      	beq.n	8000706 <__udivmoddi4+0x9a>
 80006ba:	4653      	mov	r3, sl
 80006bc:	1ba4      	subs	r4, r4, r6
 80006be:	41bd      	sbcs	r5, r7
 80006c0:	2b00      	cmp	r3, #0
 80006c2:	da00      	bge.n	80006c6 <__udivmoddi4+0x5a>
 80006c4:	e07b      	b.n	80007be <__udivmoddi4+0x152>
 80006c6:	2200      	movs	r2, #0
 80006c8:	2300      	movs	r3, #0
 80006ca:	9200      	str	r2, [sp, #0]
 80006cc:	9301      	str	r3, [sp, #4]
 80006ce:	2301      	movs	r3, #1
 80006d0:	4652      	mov	r2, sl
 80006d2:	4093      	lsls	r3, r2
 80006d4:	9301      	str	r3, [sp, #4]
 80006d6:	2301      	movs	r3, #1
 80006d8:	4662      	mov	r2, ip
 80006da:	4093      	lsls	r3, r2
 80006dc:	9300      	str	r3, [sp, #0]
 80006de:	e018      	b.n	8000712 <__udivmoddi4+0xa6>
 80006e0:	4282      	cmp	r2, r0
 80006e2:	d9d0      	bls.n	8000686 <__udivmoddi4+0x1a>
 80006e4:	2200      	movs	r2, #0
 80006e6:	2300      	movs	r3, #0
 80006e8:	9200      	str	r2, [sp, #0]
 80006ea:	9301      	str	r3, [sp, #4]
 80006ec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80006ee:	2b00      	cmp	r3, #0
 80006f0:	d001      	beq.n	80006f6 <__udivmoddi4+0x8a>
 80006f2:	601c      	str	r4, [r3, #0]
 80006f4:	605d      	str	r5, [r3, #4]
 80006f6:	9800      	ldr	r0, [sp, #0]
 80006f8:	9901      	ldr	r1, [sp, #4]
 80006fa:	b002      	add	sp, #8
 80006fc:	bc1c      	pop	{r2, r3, r4}
 80006fe:	4690      	mov	r8, r2
 8000700:	4699      	mov	r9, r3
 8000702:	46a2      	mov	sl, r4
 8000704:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000706:	42a3      	cmp	r3, r4
 8000708:	d9d7      	bls.n	80006ba <__udivmoddi4+0x4e>
 800070a:	2200      	movs	r2, #0
 800070c:	2300      	movs	r3, #0
 800070e:	9200      	str	r2, [sp, #0]
 8000710:	9301      	str	r3, [sp, #4]
 8000712:	4663      	mov	r3, ip
 8000714:	2b00      	cmp	r3, #0
 8000716:	d0e9      	beq.n	80006ec <__udivmoddi4+0x80>
 8000718:	07fb      	lsls	r3, r7, #31
 800071a:	4698      	mov	r8, r3
 800071c:	4641      	mov	r1, r8
 800071e:	0872      	lsrs	r2, r6, #1
 8000720:	430a      	orrs	r2, r1
 8000722:	087b      	lsrs	r3, r7, #1
 8000724:	4666      	mov	r6, ip
 8000726:	e00e      	b.n	8000746 <__udivmoddi4+0xda>
 8000728:	42ab      	cmp	r3, r5
 800072a:	d101      	bne.n	8000730 <__udivmoddi4+0xc4>
 800072c:	42a2      	cmp	r2, r4
 800072e:	d80c      	bhi.n	800074a <__udivmoddi4+0xde>
 8000730:	1aa4      	subs	r4, r4, r2
 8000732:	419d      	sbcs	r5, r3
 8000734:	2001      	movs	r0, #1
 8000736:	1924      	adds	r4, r4, r4
 8000738:	416d      	adcs	r5, r5
 800073a:	2100      	movs	r1, #0
 800073c:	3e01      	subs	r6, #1
 800073e:	1824      	adds	r4, r4, r0
 8000740:	414d      	adcs	r5, r1
 8000742:	2e00      	cmp	r6, #0
 8000744:	d006      	beq.n	8000754 <__udivmoddi4+0xe8>
 8000746:	42ab      	cmp	r3, r5
 8000748:	d9ee      	bls.n	8000728 <__udivmoddi4+0xbc>
 800074a:	3e01      	subs	r6, #1
 800074c:	1924      	adds	r4, r4, r4
 800074e:	416d      	adcs	r5, r5
 8000750:	2e00      	cmp	r6, #0
 8000752:	d1f8      	bne.n	8000746 <__udivmoddi4+0xda>
 8000754:	9800      	ldr	r0, [sp, #0]
 8000756:	9901      	ldr	r1, [sp, #4]
 8000758:	4653      	mov	r3, sl
 800075a:	1900      	adds	r0, r0, r4
 800075c:	4169      	adcs	r1, r5
 800075e:	2b00      	cmp	r3, #0
 8000760:	db23      	blt.n	80007aa <__udivmoddi4+0x13e>
 8000762:	002b      	movs	r3, r5
 8000764:	4652      	mov	r2, sl
 8000766:	40d3      	lsrs	r3, r2
 8000768:	002a      	movs	r2, r5
 800076a:	4664      	mov	r4, ip
 800076c:	40e2      	lsrs	r2, r4
 800076e:	001c      	movs	r4, r3
 8000770:	4653      	mov	r3, sl
 8000772:	0015      	movs	r5, r2
 8000774:	2b00      	cmp	r3, #0
 8000776:	db2d      	blt.n	80007d4 <__udivmoddi4+0x168>
 8000778:	0026      	movs	r6, r4
 800077a:	4657      	mov	r7, sl
 800077c:	40be      	lsls	r6, r7
 800077e:	0033      	movs	r3, r6
 8000780:	0026      	movs	r6, r4
 8000782:	4667      	mov	r7, ip
 8000784:	40be      	lsls	r6, r7
 8000786:	0032      	movs	r2, r6
 8000788:	1a80      	subs	r0, r0, r2
 800078a:	4199      	sbcs	r1, r3
 800078c:	9000      	str	r0, [sp, #0]
 800078e:	9101      	str	r1, [sp, #4]
 8000790:	e7ac      	b.n	80006ec <__udivmoddi4+0x80>
 8000792:	4662      	mov	r2, ip
 8000794:	2320      	movs	r3, #32
 8000796:	1a9b      	subs	r3, r3, r2
 8000798:	464a      	mov	r2, r9
 800079a:	40da      	lsrs	r2, r3
 800079c:	4661      	mov	r1, ip
 800079e:	0013      	movs	r3, r2
 80007a0:	4642      	mov	r2, r8
 80007a2:	408a      	lsls	r2, r1
 80007a4:	0017      	movs	r7, r2
 80007a6:	431f      	orrs	r7, r3
 80007a8:	e780      	b.n	80006ac <__udivmoddi4+0x40>
 80007aa:	4662      	mov	r2, ip
 80007ac:	2320      	movs	r3, #32
 80007ae:	1a9b      	subs	r3, r3, r2
 80007b0:	002a      	movs	r2, r5
 80007b2:	4666      	mov	r6, ip
 80007b4:	409a      	lsls	r2, r3
 80007b6:	0023      	movs	r3, r4
 80007b8:	40f3      	lsrs	r3, r6
 80007ba:	4313      	orrs	r3, r2
 80007bc:	e7d4      	b.n	8000768 <__udivmoddi4+0xfc>
 80007be:	4662      	mov	r2, ip
 80007c0:	2320      	movs	r3, #32
 80007c2:	2100      	movs	r1, #0
 80007c4:	1a9b      	subs	r3, r3, r2
 80007c6:	2200      	movs	r2, #0
 80007c8:	9100      	str	r1, [sp, #0]
 80007ca:	9201      	str	r2, [sp, #4]
 80007cc:	2201      	movs	r2, #1
 80007ce:	40da      	lsrs	r2, r3
 80007d0:	9201      	str	r2, [sp, #4]
 80007d2:	e780      	b.n	80006d6 <__udivmoddi4+0x6a>
 80007d4:	2320      	movs	r3, #32
 80007d6:	4662      	mov	r2, ip
 80007d8:	0026      	movs	r6, r4
 80007da:	1a9b      	subs	r3, r3, r2
 80007dc:	40de      	lsrs	r6, r3
 80007de:	002f      	movs	r7, r5
 80007e0:	46b0      	mov	r8, r6
 80007e2:	4666      	mov	r6, ip
 80007e4:	40b7      	lsls	r7, r6
 80007e6:	4646      	mov	r6, r8
 80007e8:	003b      	movs	r3, r7
 80007ea:	4333      	orrs	r3, r6
 80007ec:	e7c8      	b.n	8000780 <__udivmoddi4+0x114>
 80007ee:	46c0      	nop			; (mov r8, r8)

080007f0 <__aeabi_fdiv>:
 80007f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80007f2:	4657      	mov	r7, sl
 80007f4:	464e      	mov	r6, r9
 80007f6:	4645      	mov	r5, r8
 80007f8:	46de      	mov	lr, fp
 80007fa:	0244      	lsls	r4, r0, #9
 80007fc:	b5e0      	push	{r5, r6, r7, lr}
 80007fe:	0046      	lsls	r6, r0, #1
 8000800:	4688      	mov	r8, r1
 8000802:	0a64      	lsrs	r4, r4, #9
 8000804:	0e36      	lsrs	r6, r6, #24
 8000806:	0fc7      	lsrs	r7, r0, #31
 8000808:	2e00      	cmp	r6, #0
 800080a:	d063      	beq.n	80008d4 <__aeabi_fdiv+0xe4>
 800080c:	2eff      	cmp	r6, #255	; 0xff
 800080e:	d024      	beq.n	800085a <__aeabi_fdiv+0x6a>
 8000810:	2380      	movs	r3, #128	; 0x80
 8000812:	00e4      	lsls	r4, r4, #3
 8000814:	04db      	lsls	r3, r3, #19
 8000816:	431c      	orrs	r4, r3
 8000818:	2300      	movs	r3, #0
 800081a:	4699      	mov	r9, r3
 800081c:	469b      	mov	fp, r3
 800081e:	3e7f      	subs	r6, #127	; 0x7f
 8000820:	4643      	mov	r3, r8
 8000822:	4642      	mov	r2, r8
 8000824:	025d      	lsls	r5, r3, #9
 8000826:	0fd2      	lsrs	r2, r2, #31
 8000828:	005b      	lsls	r3, r3, #1
 800082a:	0a6d      	lsrs	r5, r5, #9
 800082c:	0e1b      	lsrs	r3, r3, #24
 800082e:	4690      	mov	r8, r2
 8000830:	4692      	mov	sl, r2
 8000832:	d065      	beq.n	8000900 <__aeabi_fdiv+0x110>
 8000834:	2bff      	cmp	r3, #255	; 0xff
 8000836:	d055      	beq.n	80008e4 <__aeabi_fdiv+0xf4>
 8000838:	2280      	movs	r2, #128	; 0x80
 800083a:	2100      	movs	r1, #0
 800083c:	00ed      	lsls	r5, r5, #3
 800083e:	04d2      	lsls	r2, r2, #19
 8000840:	3b7f      	subs	r3, #127	; 0x7f
 8000842:	4315      	orrs	r5, r2
 8000844:	1af6      	subs	r6, r6, r3
 8000846:	4643      	mov	r3, r8
 8000848:	464a      	mov	r2, r9
 800084a:	407b      	eors	r3, r7
 800084c:	2a0f      	cmp	r2, #15
 800084e:	d900      	bls.n	8000852 <__aeabi_fdiv+0x62>
 8000850:	e08d      	b.n	800096e <__aeabi_fdiv+0x17e>
 8000852:	486d      	ldr	r0, [pc, #436]	; (8000a08 <__aeabi_fdiv+0x218>)
 8000854:	0092      	lsls	r2, r2, #2
 8000856:	5882      	ldr	r2, [r0, r2]
 8000858:	4697      	mov	pc, r2
 800085a:	2c00      	cmp	r4, #0
 800085c:	d154      	bne.n	8000908 <__aeabi_fdiv+0x118>
 800085e:	2308      	movs	r3, #8
 8000860:	4699      	mov	r9, r3
 8000862:	3b06      	subs	r3, #6
 8000864:	26ff      	movs	r6, #255	; 0xff
 8000866:	469b      	mov	fp, r3
 8000868:	e7da      	b.n	8000820 <__aeabi_fdiv+0x30>
 800086a:	2500      	movs	r5, #0
 800086c:	4653      	mov	r3, sl
 800086e:	2902      	cmp	r1, #2
 8000870:	d01b      	beq.n	80008aa <__aeabi_fdiv+0xba>
 8000872:	2903      	cmp	r1, #3
 8000874:	d100      	bne.n	8000878 <__aeabi_fdiv+0x88>
 8000876:	e0bf      	b.n	80009f8 <__aeabi_fdiv+0x208>
 8000878:	2901      	cmp	r1, #1
 800087a:	d028      	beq.n	80008ce <__aeabi_fdiv+0xde>
 800087c:	0030      	movs	r0, r6
 800087e:	307f      	adds	r0, #127	; 0x7f
 8000880:	2800      	cmp	r0, #0
 8000882:	dd20      	ble.n	80008c6 <__aeabi_fdiv+0xd6>
 8000884:	076a      	lsls	r2, r5, #29
 8000886:	d004      	beq.n	8000892 <__aeabi_fdiv+0xa2>
 8000888:	220f      	movs	r2, #15
 800088a:	402a      	ands	r2, r5
 800088c:	2a04      	cmp	r2, #4
 800088e:	d000      	beq.n	8000892 <__aeabi_fdiv+0xa2>
 8000890:	3504      	adds	r5, #4
 8000892:	012a      	lsls	r2, r5, #4
 8000894:	d503      	bpl.n	800089e <__aeabi_fdiv+0xae>
 8000896:	0030      	movs	r0, r6
 8000898:	4a5c      	ldr	r2, [pc, #368]	; (8000a0c <__aeabi_fdiv+0x21c>)
 800089a:	3080      	adds	r0, #128	; 0x80
 800089c:	4015      	ands	r5, r2
 800089e:	28fe      	cmp	r0, #254	; 0xfe
 80008a0:	dc03      	bgt.n	80008aa <__aeabi_fdiv+0xba>
 80008a2:	01ac      	lsls	r4, r5, #6
 80008a4:	0a64      	lsrs	r4, r4, #9
 80008a6:	b2c2      	uxtb	r2, r0
 80008a8:	e001      	b.n	80008ae <__aeabi_fdiv+0xbe>
 80008aa:	22ff      	movs	r2, #255	; 0xff
 80008ac:	2400      	movs	r4, #0
 80008ae:	0264      	lsls	r4, r4, #9
 80008b0:	05d2      	lsls	r2, r2, #23
 80008b2:	0a60      	lsrs	r0, r4, #9
 80008b4:	07db      	lsls	r3, r3, #31
 80008b6:	4310      	orrs	r0, r2
 80008b8:	4318      	orrs	r0, r3
 80008ba:	bc3c      	pop	{r2, r3, r4, r5}
 80008bc:	4690      	mov	r8, r2
 80008be:	4699      	mov	r9, r3
 80008c0:	46a2      	mov	sl, r4
 80008c2:	46ab      	mov	fp, r5
 80008c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80008c6:	2201      	movs	r2, #1
 80008c8:	1a10      	subs	r0, r2, r0
 80008ca:	281b      	cmp	r0, #27
 80008cc:	dd7c      	ble.n	80009c8 <__aeabi_fdiv+0x1d8>
 80008ce:	2200      	movs	r2, #0
 80008d0:	2400      	movs	r4, #0
 80008d2:	e7ec      	b.n	80008ae <__aeabi_fdiv+0xbe>
 80008d4:	2c00      	cmp	r4, #0
 80008d6:	d11d      	bne.n	8000914 <__aeabi_fdiv+0x124>
 80008d8:	2304      	movs	r3, #4
 80008da:	4699      	mov	r9, r3
 80008dc:	3b03      	subs	r3, #3
 80008de:	2600      	movs	r6, #0
 80008e0:	469b      	mov	fp, r3
 80008e2:	e79d      	b.n	8000820 <__aeabi_fdiv+0x30>
 80008e4:	3eff      	subs	r6, #255	; 0xff
 80008e6:	2d00      	cmp	r5, #0
 80008e8:	d120      	bne.n	800092c <__aeabi_fdiv+0x13c>
 80008ea:	2102      	movs	r1, #2
 80008ec:	4643      	mov	r3, r8
 80008ee:	464a      	mov	r2, r9
 80008f0:	407b      	eors	r3, r7
 80008f2:	430a      	orrs	r2, r1
 80008f4:	2a0f      	cmp	r2, #15
 80008f6:	d8d8      	bhi.n	80008aa <__aeabi_fdiv+0xba>
 80008f8:	4845      	ldr	r0, [pc, #276]	; (8000a10 <__aeabi_fdiv+0x220>)
 80008fa:	0092      	lsls	r2, r2, #2
 80008fc:	5882      	ldr	r2, [r0, r2]
 80008fe:	4697      	mov	pc, r2
 8000900:	2d00      	cmp	r5, #0
 8000902:	d119      	bne.n	8000938 <__aeabi_fdiv+0x148>
 8000904:	2101      	movs	r1, #1
 8000906:	e7f1      	b.n	80008ec <__aeabi_fdiv+0xfc>
 8000908:	230c      	movs	r3, #12
 800090a:	4699      	mov	r9, r3
 800090c:	3b09      	subs	r3, #9
 800090e:	26ff      	movs	r6, #255	; 0xff
 8000910:	469b      	mov	fp, r3
 8000912:	e785      	b.n	8000820 <__aeabi_fdiv+0x30>
 8000914:	0020      	movs	r0, r4
 8000916:	f002 f99b 	bl	8002c50 <__clzsi2>
 800091a:	2676      	movs	r6, #118	; 0x76
 800091c:	1f43      	subs	r3, r0, #5
 800091e:	409c      	lsls	r4, r3
 8000920:	2300      	movs	r3, #0
 8000922:	4276      	negs	r6, r6
 8000924:	1a36      	subs	r6, r6, r0
 8000926:	4699      	mov	r9, r3
 8000928:	469b      	mov	fp, r3
 800092a:	e779      	b.n	8000820 <__aeabi_fdiv+0x30>
 800092c:	464a      	mov	r2, r9
 800092e:	2303      	movs	r3, #3
 8000930:	431a      	orrs	r2, r3
 8000932:	4691      	mov	r9, r2
 8000934:	2103      	movs	r1, #3
 8000936:	e786      	b.n	8000846 <__aeabi_fdiv+0x56>
 8000938:	0028      	movs	r0, r5
 800093a:	f002 f989 	bl	8002c50 <__clzsi2>
 800093e:	1f43      	subs	r3, r0, #5
 8000940:	1836      	adds	r6, r6, r0
 8000942:	409d      	lsls	r5, r3
 8000944:	3676      	adds	r6, #118	; 0x76
 8000946:	2100      	movs	r1, #0
 8000948:	e77d      	b.n	8000846 <__aeabi_fdiv+0x56>
 800094a:	2480      	movs	r4, #128	; 0x80
 800094c:	2300      	movs	r3, #0
 800094e:	03e4      	lsls	r4, r4, #15
 8000950:	22ff      	movs	r2, #255	; 0xff
 8000952:	e7ac      	b.n	80008ae <__aeabi_fdiv+0xbe>
 8000954:	2500      	movs	r5, #0
 8000956:	2380      	movs	r3, #128	; 0x80
 8000958:	03db      	lsls	r3, r3, #15
 800095a:	421c      	tst	r4, r3
 800095c:	d028      	beq.n	80009b0 <__aeabi_fdiv+0x1c0>
 800095e:	421d      	tst	r5, r3
 8000960:	d126      	bne.n	80009b0 <__aeabi_fdiv+0x1c0>
 8000962:	432b      	orrs	r3, r5
 8000964:	025c      	lsls	r4, r3, #9
 8000966:	0a64      	lsrs	r4, r4, #9
 8000968:	4643      	mov	r3, r8
 800096a:	22ff      	movs	r2, #255	; 0xff
 800096c:	e79f      	b.n	80008ae <__aeabi_fdiv+0xbe>
 800096e:	0162      	lsls	r2, r4, #5
 8000970:	016c      	lsls	r4, r5, #5
 8000972:	42a2      	cmp	r2, r4
 8000974:	d224      	bcs.n	80009c0 <__aeabi_fdiv+0x1d0>
 8000976:	211b      	movs	r1, #27
 8000978:	2500      	movs	r5, #0
 800097a:	3e01      	subs	r6, #1
 800097c:	2701      	movs	r7, #1
 800097e:	0010      	movs	r0, r2
 8000980:	006d      	lsls	r5, r5, #1
 8000982:	0052      	lsls	r2, r2, #1
 8000984:	2800      	cmp	r0, #0
 8000986:	db01      	blt.n	800098c <__aeabi_fdiv+0x19c>
 8000988:	4294      	cmp	r4, r2
 800098a:	d801      	bhi.n	8000990 <__aeabi_fdiv+0x1a0>
 800098c:	1b12      	subs	r2, r2, r4
 800098e:	433d      	orrs	r5, r7
 8000990:	3901      	subs	r1, #1
 8000992:	2900      	cmp	r1, #0
 8000994:	d1f3      	bne.n	800097e <__aeabi_fdiv+0x18e>
 8000996:	0014      	movs	r4, r2
 8000998:	1e62      	subs	r2, r4, #1
 800099a:	4194      	sbcs	r4, r2
 800099c:	4325      	orrs	r5, r4
 800099e:	e76d      	b.n	800087c <__aeabi_fdiv+0x8c>
 80009a0:	46ba      	mov	sl, r7
 80009a2:	4659      	mov	r1, fp
 80009a4:	0025      	movs	r5, r4
 80009a6:	4653      	mov	r3, sl
 80009a8:	2902      	cmp	r1, #2
 80009aa:	d000      	beq.n	80009ae <__aeabi_fdiv+0x1be>
 80009ac:	e761      	b.n	8000872 <__aeabi_fdiv+0x82>
 80009ae:	e77c      	b.n	80008aa <__aeabi_fdiv+0xba>
 80009b0:	2380      	movs	r3, #128	; 0x80
 80009b2:	03db      	lsls	r3, r3, #15
 80009b4:	431c      	orrs	r4, r3
 80009b6:	0264      	lsls	r4, r4, #9
 80009b8:	0a64      	lsrs	r4, r4, #9
 80009ba:	003b      	movs	r3, r7
 80009bc:	22ff      	movs	r2, #255	; 0xff
 80009be:	e776      	b.n	80008ae <__aeabi_fdiv+0xbe>
 80009c0:	1b12      	subs	r2, r2, r4
 80009c2:	211a      	movs	r1, #26
 80009c4:	2501      	movs	r5, #1
 80009c6:	e7d9      	b.n	800097c <__aeabi_fdiv+0x18c>
 80009c8:	369e      	adds	r6, #158	; 0x9e
 80009ca:	002a      	movs	r2, r5
 80009cc:	40b5      	lsls	r5, r6
 80009ce:	002c      	movs	r4, r5
 80009d0:	40c2      	lsrs	r2, r0
 80009d2:	1e65      	subs	r5, r4, #1
 80009d4:	41ac      	sbcs	r4, r5
 80009d6:	4314      	orrs	r4, r2
 80009d8:	0762      	lsls	r2, r4, #29
 80009da:	d004      	beq.n	80009e6 <__aeabi_fdiv+0x1f6>
 80009dc:	220f      	movs	r2, #15
 80009de:	4022      	ands	r2, r4
 80009e0:	2a04      	cmp	r2, #4
 80009e2:	d000      	beq.n	80009e6 <__aeabi_fdiv+0x1f6>
 80009e4:	3404      	adds	r4, #4
 80009e6:	0162      	lsls	r2, r4, #5
 80009e8:	d403      	bmi.n	80009f2 <__aeabi_fdiv+0x202>
 80009ea:	01a4      	lsls	r4, r4, #6
 80009ec:	0a64      	lsrs	r4, r4, #9
 80009ee:	2200      	movs	r2, #0
 80009f0:	e75d      	b.n	80008ae <__aeabi_fdiv+0xbe>
 80009f2:	2201      	movs	r2, #1
 80009f4:	2400      	movs	r4, #0
 80009f6:	e75a      	b.n	80008ae <__aeabi_fdiv+0xbe>
 80009f8:	2480      	movs	r4, #128	; 0x80
 80009fa:	03e4      	lsls	r4, r4, #15
 80009fc:	432c      	orrs	r4, r5
 80009fe:	0264      	lsls	r4, r4, #9
 8000a00:	0a64      	lsrs	r4, r4, #9
 8000a02:	22ff      	movs	r2, #255	; 0xff
 8000a04:	e753      	b.n	80008ae <__aeabi_fdiv+0xbe>
 8000a06:	46c0      	nop			; (mov r8, r8)
 8000a08:	08018fb8 	.word	0x08018fb8
 8000a0c:	f7ffffff 	.word	0xf7ffffff
 8000a10:	08018ff8 	.word	0x08018ff8

08000a14 <__eqsf2>:
 8000a14:	b570      	push	{r4, r5, r6, lr}
 8000a16:	0042      	lsls	r2, r0, #1
 8000a18:	024e      	lsls	r6, r1, #9
 8000a1a:	004c      	lsls	r4, r1, #1
 8000a1c:	0245      	lsls	r5, r0, #9
 8000a1e:	0a6d      	lsrs	r5, r5, #9
 8000a20:	0e12      	lsrs	r2, r2, #24
 8000a22:	0fc3      	lsrs	r3, r0, #31
 8000a24:	0a76      	lsrs	r6, r6, #9
 8000a26:	0e24      	lsrs	r4, r4, #24
 8000a28:	0fc9      	lsrs	r1, r1, #31
 8000a2a:	2aff      	cmp	r2, #255	; 0xff
 8000a2c:	d00f      	beq.n	8000a4e <__eqsf2+0x3a>
 8000a2e:	2cff      	cmp	r4, #255	; 0xff
 8000a30:	d011      	beq.n	8000a56 <__eqsf2+0x42>
 8000a32:	2001      	movs	r0, #1
 8000a34:	42a2      	cmp	r2, r4
 8000a36:	d000      	beq.n	8000a3a <__eqsf2+0x26>
 8000a38:	bd70      	pop	{r4, r5, r6, pc}
 8000a3a:	42b5      	cmp	r5, r6
 8000a3c:	d1fc      	bne.n	8000a38 <__eqsf2+0x24>
 8000a3e:	428b      	cmp	r3, r1
 8000a40:	d00d      	beq.n	8000a5e <__eqsf2+0x4a>
 8000a42:	2a00      	cmp	r2, #0
 8000a44:	d1f8      	bne.n	8000a38 <__eqsf2+0x24>
 8000a46:	0028      	movs	r0, r5
 8000a48:	1e45      	subs	r5, r0, #1
 8000a4a:	41a8      	sbcs	r0, r5
 8000a4c:	e7f4      	b.n	8000a38 <__eqsf2+0x24>
 8000a4e:	2001      	movs	r0, #1
 8000a50:	2d00      	cmp	r5, #0
 8000a52:	d1f1      	bne.n	8000a38 <__eqsf2+0x24>
 8000a54:	e7eb      	b.n	8000a2e <__eqsf2+0x1a>
 8000a56:	2001      	movs	r0, #1
 8000a58:	2e00      	cmp	r6, #0
 8000a5a:	d1ed      	bne.n	8000a38 <__eqsf2+0x24>
 8000a5c:	e7e9      	b.n	8000a32 <__eqsf2+0x1e>
 8000a5e:	2000      	movs	r0, #0
 8000a60:	e7ea      	b.n	8000a38 <__eqsf2+0x24>
 8000a62:	46c0      	nop			; (mov r8, r8)

08000a64 <__gesf2>:
 8000a64:	b570      	push	{r4, r5, r6, lr}
 8000a66:	004a      	lsls	r2, r1, #1
 8000a68:	024e      	lsls	r6, r1, #9
 8000a6a:	0245      	lsls	r5, r0, #9
 8000a6c:	0044      	lsls	r4, r0, #1
 8000a6e:	0a6d      	lsrs	r5, r5, #9
 8000a70:	0e24      	lsrs	r4, r4, #24
 8000a72:	0fc3      	lsrs	r3, r0, #31
 8000a74:	0a76      	lsrs	r6, r6, #9
 8000a76:	0e12      	lsrs	r2, r2, #24
 8000a78:	0fc9      	lsrs	r1, r1, #31
 8000a7a:	2cff      	cmp	r4, #255	; 0xff
 8000a7c:	d015      	beq.n	8000aaa <__gesf2+0x46>
 8000a7e:	2aff      	cmp	r2, #255	; 0xff
 8000a80:	d00e      	beq.n	8000aa0 <__gesf2+0x3c>
 8000a82:	2c00      	cmp	r4, #0
 8000a84:	d115      	bne.n	8000ab2 <__gesf2+0x4e>
 8000a86:	2a00      	cmp	r2, #0
 8000a88:	d101      	bne.n	8000a8e <__gesf2+0x2a>
 8000a8a:	2e00      	cmp	r6, #0
 8000a8c:	d01c      	beq.n	8000ac8 <__gesf2+0x64>
 8000a8e:	2d00      	cmp	r5, #0
 8000a90:	d014      	beq.n	8000abc <__gesf2+0x58>
 8000a92:	428b      	cmp	r3, r1
 8000a94:	d027      	beq.n	8000ae6 <__gesf2+0x82>
 8000a96:	2002      	movs	r0, #2
 8000a98:	3b01      	subs	r3, #1
 8000a9a:	4018      	ands	r0, r3
 8000a9c:	3801      	subs	r0, #1
 8000a9e:	bd70      	pop	{r4, r5, r6, pc}
 8000aa0:	2e00      	cmp	r6, #0
 8000aa2:	d0ee      	beq.n	8000a82 <__gesf2+0x1e>
 8000aa4:	2002      	movs	r0, #2
 8000aa6:	4240      	negs	r0, r0
 8000aa8:	e7f9      	b.n	8000a9e <__gesf2+0x3a>
 8000aaa:	2d00      	cmp	r5, #0
 8000aac:	d1fa      	bne.n	8000aa4 <__gesf2+0x40>
 8000aae:	2aff      	cmp	r2, #255	; 0xff
 8000ab0:	d00e      	beq.n	8000ad0 <__gesf2+0x6c>
 8000ab2:	2a00      	cmp	r2, #0
 8000ab4:	d10e      	bne.n	8000ad4 <__gesf2+0x70>
 8000ab6:	2e00      	cmp	r6, #0
 8000ab8:	d0ed      	beq.n	8000a96 <__gesf2+0x32>
 8000aba:	e00b      	b.n	8000ad4 <__gesf2+0x70>
 8000abc:	2301      	movs	r3, #1
 8000abe:	3901      	subs	r1, #1
 8000ac0:	4399      	bics	r1, r3
 8000ac2:	0008      	movs	r0, r1
 8000ac4:	3001      	adds	r0, #1
 8000ac6:	e7ea      	b.n	8000a9e <__gesf2+0x3a>
 8000ac8:	2000      	movs	r0, #0
 8000aca:	2d00      	cmp	r5, #0
 8000acc:	d0e7      	beq.n	8000a9e <__gesf2+0x3a>
 8000ace:	e7e2      	b.n	8000a96 <__gesf2+0x32>
 8000ad0:	2e00      	cmp	r6, #0
 8000ad2:	d1e7      	bne.n	8000aa4 <__gesf2+0x40>
 8000ad4:	428b      	cmp	r3, r1
 8000ad6:	d1de      	bne.n	8000a96 <__gesf2+0x32>
 8000ad8:	4294      	cmp	r4, r2
 8000ada:	dd05      	ble.n	8000ae8 <__gesf2+0x84>
 8000adc:	2102      	movs	r1, #2
 8000ade:	1e58      	subs	r0, r3, #1
 8000ae0:	4008      	ands	r0, r1
 8000ae2:	3801      	subs	r0, #1
 8000ae4:	e7db      	b.n	8000a9e <__gesf2+0x3a>
 8000ae6:	2400      	movs	r4, #0
 8000ae8:	42a2      	cmp	r2, r4
 8000aea:	dc04      	bgt.n	8000af6 <__gesf2+0x92>
 8000aec:	42b5      	cmp	r5, r6
 8000aee:	d8d2      	bhi.n	8000a96 <__gesf2+0x32>
 8000af0:	2000      	movs	r0, #0
 8000af2:	42b5      	cmp	r5, r6
 8000af4:	d2d3      	bcs.n	8000a9e <__gesf2+0x3a>
 8000af6:	1e58      	subs	r0, r3, #1
 8000af8:	2301      	movs	r3, #1
 8000afa:	4398      	bics	r0, r3
 8000afc:	3001      	adds	r0, #1
 8000afe:	e7ce      	b.n	8000a9e <__gesf2+0x3a>

08000b00 <__lesf2>:
 8000b00:	b530      	push	{r4, r5, lr}
 8000b02:	0042      	lsls	r2, r0, #1
 8000b04:	0244      	lsls	r4, r0, #9
 8000b06:	024d      	lsls	r5, r1, #9
 8000b08:	0fc3      	lsrs	r3, r0, #31
 8000b0a:	0048      	lsls	r0, r1, #1
 8000b0c:	0a64      	lsrs	r4, r4, #9
 8000b0e:	0e12      	lsrs	r2, r2, #24
 8000b10:	0a6d      	lsrs	r5, r5, #9
 8000b12:	0e00      	lsrs	r0, r0, #24
 8000b14:	0fc9      	lsrs	r1, r1, #31
 8000b16:	2aff      	cmp	r2, #255	; 0xff
 8000b18:	d012      	beq.n	8000b40 <__lesf2+0x40>
 8000b1a:	28ff      	cmp	r0, #255	; 0xff
 8000b1c:	d00c      	beq.n	8000b38 <__lesf2+0x38>
 8000b1e:	2a00      	cmp	r2, #0
 8000b20:	d112      	bne.n	8000b48 <__lesf2+0x48>
 8000b22:	2800      	cmp	r0, #0
 8000b24:	d119      	bne.n	8000b5a <__lesf2+0x5a>
 8000b26:	2d00      	cmp	r5, #0
 8000b28:	d117      	bne.n	8000b5a <__lesf2+0x5a>
 8000b2a:	2c00      	cmp	r4, #0
 8000b2c:	d02b      	beq.n	8000b86 <__lesf2+0x86>
 8000b2e:	2002      	movs	r0, #2
 8000b30:	3b01      	subs	r3, #1
 8000b32:	4018      	ands	r0, r3
 8000b34:	3801      	subs	r0, #1
 8000b36:	e026      	b.n	8000b86 <__lesf2+0x86>
 8000b38:	2d00      	cmp	r5, #0
 8000b3a:	d0f0      	beq.n	8000b1e <__lesf2+0x1e>
 8000b3c:	2002      	movs	r0, #2
 8000b3e:	e022      	b.n	8000b86 <__lesf2+0x86>
 8000b40:	2c00      	cmp	r4, #0
 8000b42:	d1fb      	bne.n	8000b3c <__lesf2+0x3c>
 8000b44:	28ff      	cmp	r0, #255	; 0xff
 8000b46:	d01f      	beq.n	8000b88 <__lesf2+0x88>
 8000b48:	2800      	cmp	r0, #0
 8000b4a:	d11f      	bne.n	8000b8c <__lesf2+0x8c>
 8000b4c:	2d00      	cmp	r5, #0
 8000b4e:	d11d      	bne.n	8000b8c <__lesf2+0x8c>
 8000b50:	2002      	movs	r0, #2
 8000b52:	3b01      	subs	r3, #1
 8000b54:	4018      	ands	r0, r3
 8000b56:	3801      	subs	r0, #1
 8000b58:	e015      	b.n	8000b86 <__lesf2+0x86>
 8000b5a:	2c00      	cmp	r4, #0
 8000b5c:	d00e      	beq.n	8000b7c <__lesf2+0x7c>
 8000b5e:	428b      	cmp	r3, r1
 8000b60:	d1e5      	bne.n	8000b2e <__lesf2+0x2e>
 8000b62:	2200      	movs	r2, #0
 8000b64:	4290      	cmp	r0, r2
 8000b66:	dc04      	bgt.n	8000b72 <__lesf2+0x72>
 8000b68:	42ac      	cmp	r4, r5
 8000b6a:	d8e0      	bhi.n	8000b2e <__lesf2+0x2e>
 8000b6c:	2000      	movs	r0, #0
 8000b6e:	42ac      	cmp	r4, r5
 8000b70:	d209      	bcs.n	8000b86 <__lesf2+0x86>
 8000b72:	1e58      	subs	r0, r3, #1
 8000b74:	2301      	movs	r3, #1
 8000b76:	4398      	bics	r0, r3
 8000b78:	3001      	adds	r0, #1
 8000b7a:	e004      	b.n	8000b86 <__lesf2+0x86>
 8000b7c:	2301      	movs	r3, #1
 8000b7e:	3901      	subs	r1, #1
 8000b80:	4399      	bics	r1, r3
 8000b82:	0008      	movs	r0, r1
 8000b84:	3001      	adds	r0, #1
 8000b86:	bd30      	pop	{r4, r5, pc}
 8000b88:	2d00      	cmp	r5, #0
 8000b8a:	d1d7      	bne.n	8000b3c <__lesf2+0x3c>
 8000b8c:	428b      	cmp	r3, r1
 8000b8e:	d1ce      	bne.n	8000b2e <__lesf2+0x2e>
 8000b90:	4282      	cmp	r2, r0
 8000b92:	dde7      	ble.n	8000b64 <__lesf2+0x64>
 8000b94:	2102      	movs	r1, #2
 8000b96:	1e58      	subs	r0, r3, #1
 8000b98:	4008      	ands	r0, r1
 8000b9a:	3801      	subs	r0, #1
 8000b9c:	e7f3      	b.n	8000b86 <__lesf2+0x86>
 8000b9e:	46c0      	nop			; (mov r8, r8)

08000ba0 <__aeabi_fsub>:
 8000ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ba2:	4647      	mov	r7, r8
 8000ba4:	46ce      	mov	lr, r9
 8000ba6:	0044      	lsls	r4, r0, #1
 8000ba8:	0fc2      	lsrs	r2, r0, #31
 8000baa:	b580      	push	{r7, lr}
 8000bac:	0247      	lsls	r7, r0, #9
 8000bae:	0248      	lsls	r0, r1, #9
 8000bb0:	0a40      	lsrs	r0, r0, #9
 8000bb2:	4684      	mov	ip, r0
 8000bb4:	4666      	mov	r6, ip
 8000bb6:	0048      	lsls	r0, r1, #1
 8000bb8:	0a7f      	lsrs	r7, r7, #9
 8000bba:	0e24      	lsrs	r4, r4, #24
 8000bbc:	00f6      	lsls	r6, r6, #3
 8000bbe:	0025      	movs	r5, r4
 8000bc0:	4690      	mov	r8, r2
 8000bc2:	00fb      	lsls	r3, r7, #3
 8000bc4:	0e00      	lsrs	r0, r0, #24
 8000bc6:	0fc9      	lsrs	r1, r1, #31
 8000bc8:	46b1      	mov	r9, r6
 8000bca:	28ff      	cmp	r0, #255	; 0xff
 8000bcc:	d100      	bne.n	8000bd0 <__aeabi_fsub+0x30>
 8000bce:	e085      	b.n	8000cdc <__aeabi_fsub+0x13c>
 8000bd0:	2601      	movs	r6, #1
 8000bd2:	4071      	eors	r1, r6
 8000bd4:	1a26      	subs	r6, r4, r0
 8000bd6:	4291      	cmp	r1, r2
 8000bd8:	d057      	beq.n	8000c8a <__aeabi_fsub+0xea>
 8000bda:	2e00      	cmp	r6, #0
 8000bdc:	dd43      	ble.n	8000c66 <__aeabi_fsub+0xc6>
 8000bde:	2800      	cmp	r0, #0
 8000be0:	d000      	beq.n	8000be4 <__aeabi_fsub+0x44>
 8000be2:	e07f      	b.n	8000ce4 <__aeabi_fsub+0x144>
 8000be4:	4649      	mov	r1, r9
 8000be6:	2900      	cmp	r1, #0
 8000be8:	d100      	bne.n	8000bec <__aeabi_fsub+0x4c>
 8000bea:	e0aa      	b.n	8000d42 <__aeabi_fsub+0x1a2>
 8000bec:	3e01      	subs	r6, #1
 8000bee:	2e00      	cmp	r6, #0
 8000bf0:	d000      	beq.n	8000bf4 <__aeabi_fsub+0x54>
 8000bf2:	e0f7      	b.n	8000de4 <__aeabi_fsub+0x244>
 8000bf4:	1a5b      	subs	r3, r3, r1
 8000bf6:	015a      	lsls	r2, r3, #5
 8000bf8:	d400      	bmi.n	8000bfc <__aeabi_fsub+0x5c>
 8000bfa:	e08b      	b.n	8000d14 <__aeabi_fsub+0x174>
 8000bfc:	019b      	lsls	r3, r3, #6
 8000bfe:	099c      	lsrs	r4, r3, #6
 8000c00:	0020      	movs	r0, r4
 8000c02:	f002 f825 	bl	8002c50 <__clzsi2>
 8000c06:	3805      	subs	r0, #5
 8000c08:	4084      	lsls	r4, r0
 8000c0a:	4285      	cmp	r5, r0
 8000c0c:	dd00      	ble.n	8000c10 <__aeabi_fsub+0x70>
 8000c0e:	e0d3      	b.n	8000db8 <__aeabi_fsub+0x218>
 8000c10:	1b45      	subs	r5, r0, r5
 8000c12:	0023      	movs	r3, r4
 8000c14:	2020      	movs	r0, #32
 8000c16:	3501      	adds	r5, #1
 8000c18:	40eb      	lsrs	r3, r5
 8000c1a:	1b45      	subs	r5, r0, r5
 8000c1c:	40ac      	lsls	r4, r5
 8000c1e:	1e62      	subs	r2, r4, #1
 8000c20:	4194      	sbcs	r4, r2
 8000c22:	4323      	orrs	r3, r4
 8000c24:	2407      	movs	r4, #7
 8000c26:	2500      	movs	r5, #0
 8000c28:	401c      	ands	r4, r3
 8000c2a:	2201      	movs	r2, #1
 8000c2c:	4641      	mov	r1, r8
 8000c2e:	400a      	ands	r2, r1
 8000c30:	2c00      	cmp	r4, #0
 8000c32:	d004      	beq.n	8000c3e <__aeabi_fsub+0x9e>
 8000c34:	210f      	movs	r1, #15
 8000c36:	4019      	ands	r1, r3
 8000c38:	2904      	cmp	r1, #4
 8000c3a:	d000      	beq.n	8000c3e <__aeabi_fsub+0x9e>
 8000c3c:	3304      	adds	r3, #4
 8000c3e:	0159      	lsls	r1, r3, #5
 8000c40:	d400      	bmi.n	8000c44 <__aeabi_fsub+0xa4>
 8000c42:	e080      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000c44:	3501      	adds	r5, #1
 8000c46:	b2ec      	uxtb	r4, r5
 8000c48:	2dff      	cmp	r5, #255	; 0xff
 8000c4a:	d000      	beq.n	8000c4e <__aeabi_fsub+0xae>
 8000c4c:	e0a3      	b.n	8000d96 <__aeabi_fsub+0x1f6>
 8000c4e:	24ff      	movs	r4, #255	; 0xff
 8000c50:	2300      	movs	r3, #0
 8000c52:	025b      	lsls	r3, r3, #9
 8000c54:	05e4      	lsls	r4, r4, #23
 8000c56:	0a58      	lsrs	r0, r3, #9
 8000c58:	07d2      	lsls	r2, r2, #31
 8000c5a:	4320      	orrs	r0, r4
 8000c5c:	4310      	orrs	r0, r2
 8000c5e:	bc0c      	pop	{r2, r3}
 8000c60:	4690      	mov	r8, r2
 8000c62:	4699      	mov	r9, r3
 8000c64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c66:	2e00      	cmp	r6, #0
 8000c68:	d174      	bne.n	8000d54 <__aeabi_fsub+0x1b4>
 8000c6a:	1c60      	adds	r0, r4, #1
 8000c6c:	b2c0      	uxtb	r0, r0
 8000c6e:	2801      	cmp	r0, #1
 8000c70:	dc00      	bgt.n	8000c74 <__aeabi_fsub+0xd4>
 8000c72:	e0a7      	b.n	8000dc4 <__aeabi_fsub+0x224>
 8000c74:	464a      	mov	r2, r9
 8000c76:	1a9c      	subs	r4, r3, r2
 8000c78:	0162      	lsls	r2, r4, #5
 8000c7a:	d500      	bpl.n	8000c7e <__aeabi_fsub+0xde>
 8000c7c:	e0b6      	b.n	8000dec <__aeabi_fsub+0x24c>
 8000c7e:	2c00      	cmp	r4, #0
 8000c80:	d1be      	bne.n	8000c00 <__aeabi_fsub+0x60>
 8000c82:	2200      	movs	r2, #0
 8000c84:	2400      	movs	r4, #0
 8000c86:	2300      	movs	r3, #0
 8000c88:	e7e3      	b.n	8000c52 <__aeabi_fsub+0xb2>
 8000c8a:	2e00      	cmp	r6, #0
 8000c8c:	dc00      	bgt.n	8000c90 <__aeabi_fsub+0xf0>
 8000c8e:	e085      	b.n	8000d9c <__aeabi_fsub+0x1fc>
 8000c90:	2800      	cmp	r0, #0
 8000c92:	d046      	beq.n	8000d22 <__aeabi_fsub+0x182>
 8000c94:	2cff      	cmp	r4, #255	; 0xff
 8000c96:	d049      	beq.n	8000d2c <__aeabi_fsub+0x18c>
 8000c98:	2280      	movs	r2, #128	; 0x80
 8000c9a:	4648      	mov	r0, r9
 8000c9c:	04d2      	lsls	r2, r2, #19
 8000c9e:	4310      	orrs	r0, r2
 8000ca0:	4681      	mov	r9, r0
 8000ca2:	2201      	movs	r2, #1
 8000ca4:	2e1b      	cmp	r6, #27
 8000ca6:	dc09      	bgt.n	8000cbc <__aeabi_fsub+0x11c>
 8000ca8:	2020      	movs	r0, #32
 8000caa:	464c      	mov	r4, r9
 8000cac:	1b80      	subs	r0, r0, r6
 8000cae:	4084      	lsls	r4, r0
 8000cb0:	464a      	mov	r2, r9
 8000cb2:	0020      	movs	r0, r4
 8000cb4:	40f2      	lsrs	r2, r6
 8000cb6:	1e44      	subs	r4, r0, #1
 8000cb8:	41a0      	sbcs	r0, r4
 8000cba:	4302      	orrs	r2, r0
 8000cbc:	189b      	adds	r3, r3, r2
 8000cbe:	015a      	lsls	r2, r3, #5
 8000cc0:	d528      	bpl.n	8000d14 <__aeabi_fsub+0x174>
 8000cc2:	3501      	adds	r5, #1
 8000cc4:	2dff      	cmp	r5, #255	; 0xff
 8000cc6:	d100      	bne.n	8000cca <__aeabi_fsub+0x12a>
 8000cc8:	e0a8      	b.n	8000e1c <__aeabi_fsub+0x27c>
 8000cca:	2201      	movs	r2, #1
 8000ccc:	2407      	movs	r4, #7
 8000cce:	4994      	ldr	r1, [pc, #592]	; (8000f20 <__aeabi_fsub+0x380>)
 8000cd0:	401a      	ands	r2, r3
 8000cd2:	085b      	lsrs	r3, r3, #1
 8000cd4:	400b      	ands	r3, r1
 8000cd6:	4313      	orrs	r3, r2
 8000cd8:	401c      	ands	r4, r3
 8000cda:	e7a6      	b.n	8000c2a <__aeabi_fsub+0x8a>
 8000cdc:	2e00      	cmp	r6, #0
 8000cde:	d000      	beq.n	8000ce2 <__aeabi_fsub+0x142>
 8000ce0:	e778      	b.n	8000bd4 <__aeabi_fsub+0x34>
 8000ce2:	e775      	b.n	8000bd0 <__aeabi_fsub+0x30>
 8000ce4:	2cff      	cmp	r4, #255	; 0xff
 8000ce6:	d054      	beq.n	8000d92 <__aeabi_fsub+0x1f2>
 8000ce8:	2280      	movs	r2, #128	; 0x80
 8000cea:	4649      	mov	r1, r9
 8000cec:	04d2      	lsls	r2, r2, #19
 8000cee:	4311      	orrs	r1, r2
 8000cf0:	4689      	mov	r9, r1
 8000cf2:	2201      	movs	r2, #1
 8000cf4:	2e1b      	cmp	r6, #27
 8000cf6:	dc09      	bgt.n	8000d0c <__aeabi_fsub+0x16c>
 8000cf8:	2120      	movs	r1, #32
 8000cfa:	4648      	mov	r0, r9
 8000cfc:	1b89      	subs	r1, r1, r6
 8000cfe:	4088      	lsls	r0, r1
 8000d00:	464a      	mov	r2, r9
 8000d02:	0001      	movs	r1, r0
 8000d04:	40f2      	lsrs	r2, r6
 8000d06:	1e48      	subs	r0, r1, #1
 8000d08:	4181      	sbcs	r1, r0
 8000d0a:	430a      	orrs	r2, r1
 8000d0c:	1a9b      	subs	r3, r3, r2
 8000d0e:	015a      	lsls	r2, r3, #5
 8000d10:	d500      	bpl.n	8000d14 <__aeabi_fsub+0x174>
 8000d12:	e773      	b.n	8000bfc <__aeabi_fsub+0x5c>
 8000d14:	2201      	movs	r2, #1
 8000d16:	4641      	mov	r1, r8
 8000d18:	400a      	ands	r2, r1
 8000d1a:	0759      	lsls	r1, r3, #29
 8000d1c:	d000      	beq.n	8000d20 <__aeabi_fsub+0x180>
 8000d1e:	e789      	b.n	8000c34 <__aeabi_fsub+0x94>
 8000d20:	e011      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000d22:	4648      	mov	r0, r9
 8000d24:	2800      	cmp	r0, #0
 8000d26:	d158      	bne.n	8000dda <__aeabi_fsub+0x23a>
 8000d28:	2cff      	cmp	r4, #255	; 0xff
 8000d2a:	d10c      	bne.n	8000d46 <__aeabi_fsub+0x1a6>
 8000d2c:	08db      	lsrs	r3, r3, #3
 8000d2e:	2b00      	cmp	r3, #0
 8000d30:	d100      	bne.n	8000d34 <__aeabi_fsub+0x194>
 8000d32:	e78c      	b.n	8000c4e <__aeabi_fsub+0xae>
 8000d34:	2080      	movs	r0, #128	; 0x80
 8000d36:	03c0      	lsls	r0, r0, #15
 8000d38:	4303      	orrs	r3, r0
 8000d3a:	025b      	lsls	r3, r3, #9
 8000d3c:	0a5b      	lsrs	r3, r3, #9
 8000d3e:	24ff      	movs	r4, #255	; 0xff
 8000d40:	e787      	b.n	8000c52 <__aeabi_fsub+0xb2>
 8000d42:	2cff      	cmp	r4, #255	; 0xff
 8000d44:	d025      	beq.n	8000d92 <__aeabi_fsub+0x1f2>
 8000d46:	08db      	lsrs	r3, r3, #3
 8000d48:	2dff      	cmp	r5, #255	; 0xff
 8000d4a:	d0f0      	beq.n	8000d2e <__aeabi_fsub+0x18e>
 8000d4c:	025b      	lsls	r3, r3, #9
 8000d4e:	0a5b      	lsrs	r3, r3, #9
 8000d50:	b2ec      	uxtb	r4, r5
 8000d52:	e77e      	b.n	8000c52 <__aeabi_fsub+0xb2>
 8000d54:	2c00      	cmp	r4, #0
 8000d56:	d04d      	beq.n	8000df4 <__aeabi_fsub+0x254>
 8000d58:	28ff      	cmp	r0, #255	; 0xff
 8000d5a:	d018      	beq.n	8000d8e <__aeabi_fsub+0x1ee>
 8000d5c:	2480      	movs	r4, #128	; 0x80
 8000d5e:	04e4      	lsls	r4, r4, #19
 8000d60:	4272      	negs	r2, r6
 8000d62:	4323      	orrs	r3, r4
 8000d64:	2a1b      	cmp	r2, #27
 8000d66:	dd00      	ble.n	8000d6a <__aeabi_fsub+0x1ca>
 8000d68:	e0c4      	b.n	8000ef4 <__aeabi_fsub+0x354>
 8000d6a:	001c      	movs	r4, r3
 8000d6c:	2520      	movs	r5, #32
 8000d6e:	40d4      	lsrs	r4, r2
 8000d70:	1aaa      	subs	r2, r5, r2
 8000d72:	4093      	lsls	r3, r2
 8000d74:	1e5a      	subs	r2, r3, #1
 8000d76:	4193      	sbcs	r3, r2
 8000d78:	4323      	orrs	r3, r4
 8000d7a:	464a      	mov	r2, r9
 8000d7c:	0005      	movs	r5, r0
 8000d7e:	1ad3      	subs	r3, r2, r3
 8000d80:	4688      	mov	r8, r1
 8000d82:	e738      	b.n	8000bf6 <__aeabi_fsub+0x56>
 8000d84:	1c72      	adds	r2, r6, #1
 8000d86:	d0f8      	beq.n	8000d7a <__aeabi_fsub+0x1da>
 8000d88:	43f2      	mvns	r2, r6
 8000d8a:	28ff      	cmp	r0, #255	; 0xff
 8000d8c:	d1ea      	bne.n	8000d64 <__aeabi_fsub+0x1c4>
 8000d8e:	000a      	movs	r2, r1
 8000d90:	464b      	mov	r3, r9
 8000d92:	25ff      	movs	r5, #255	; 0xff
 8000d94:	e7d7      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000d96:	019b      	lsls	r3, r3, #6
 8000d98:	0a5b      	lsrs	r3, r3, #9
 8000d9a:	e75a      	b.n	8000c52 <__aeabi_fsub+0xb2>
 8000d9c:	2e00      	cmp	r6, #0
 8000d9e:	d141      	bne.n	8000e24 <__aeabi_fsub+0x284>
 8000da0:	1c65      	adds	r5, r4, #1
 8000da2:	b2e9      	uxtb	r1, r5
 8000da4:	2901      	cmp	r1, #1
 8000da6:	dd45      	ble.n	8000e34 <__aeabi_fsub+0x294>
 8000da8:	2dff      	cmp	r5, #255	; 0xff
 8000daa:	d100      	bne.n	8000dae <__aeabi_fsub+0x20e>
 8000dac:	e74f      	b.n	8000c4e <__aeabi_fsub+0xae>
 8000dae:	2407      	movs	r4, #7
 8000db0:	444b      	add	r3, r9
 8000db2:	085b      	lsrs	r3, r3, #1
 8000db4:	401c      	ands	r4, r3
 8000db6:	e738      	b.n	8000c2a <__aeabi_fsub+0x8a>
 8000db8:	2207      	movs	r2, #7
 8000dba:	4b5a      	ldr	r3, [pc, #360]	; (8000f24 <__aeabi_fsub+0x384>)
 8000dbc:	1a2d      	subs	r5, r5, r0
 8000dbe:	4023      	ands	r3, r4
 8000dc0:	4014      	ands	r4, r2
 8000dc2:	e732      	b.n	8000c2a <__aeabi_fsub+0x8a>
 8000dc4:	2c00      	cmp	r4, #0
 8000dc6:	d11d      	bne.n	8000e04 <__aeabi_fsub+0x264>
 8000dc8:	2b00      	cmp	r3, #0
 8000dca:	d17a      	bne.n	8000ec2 <__aeabi_fsub+0x322>
 8000dcc:	464b      	mov	r3, r9
 8000dce:	2b00      	cmp	r3, #0
 8000dd0:	d100      	bne.n	8000dd4 <__aeabi_fsub+0x234>
 8000dd2:	e091      	b.n	8000ef8 <__aeabi_fsub+0x358>
 8000dd4:	000a      	movs	r2, r1
 8000dd6:	2500      	movs	r5, #0
 8000dd8:	e7b5      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000dda:	3e01      	subs	r6, #1
 8000ddc:	2e00      	cmp	r6, #0
 8000dde:	d119      	bne.n	8000e14 <__aeabi_fsub+0x274>
 8000de0:	444b      	add	r3, r9
 8000de2:	e76c      	b.n	8000cbe <__aeabi_fsub+0x11e>
 8000de4:	2cff      	cmp	r4, #255	; 0xff
 8000de6:	d184      	bne.n	8000cf2 <__aeabi_fsub+0x152>
 8000de8:	25ff      	movs	r5, #255	; 0xff
 8000dea:	e7ac      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000dec:	464a      	mov	r2, r9
 8000dee:	4688      	mov	r8, r1
 8000df0:	1ad4      	subs	r4, r2, r3
 8000df2:	e705      	b.n	8000c00 <__aeabi_fsub+0x60>
 8000df4:	2b00      	cmp	r3, #0
 8000df6:	d1c5      	bne.n	8000d84 <__aeabi_fsub+0x1e4>
 8000df8:	000a      	movs	r2, r1
 8000dfa:	28ff      	cmp	r0, #255	; 0xff
 8000dfc:	d0c8      	beq.n	8000d90 <__aeabi_fsub+0x1f0>
 8000dfe:	0005      	movs	r5, r0
 8000e00:	464b      	mov	r3, r9
 8000e02:	e7a0      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000e04:	2b00      	cmp	r3, #0
 8000e06:	d149      	bne.n	8000e9c <__aeabi_fsub+0x2fc>
 8000e08:	464b      	mov	r3, r9
 8000e0a:	2b00      	cmp	r3, #0
 8000e0c:	d077      	beq.n	8000efe <__aeabi_fsub+0x35e>
 8000e0e:	000a      	movs	r2, r1
 8000e10:	25ff      	movs	r5, #255	; 0xff
 8000e12:	e798      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000e14:	2cff      	cmp	r4, #255	; 0xff
 8000e16:	d000      	beq.n	8000e1a <__aeabi_fsub+0x27a>
 8000e18:	e743      	b.n	8000ca2 <__aeabi_fsub+0x102>
 8000e1a:	e787      	b.n	8000d2c <__aeabi_fsub+0x18c>
 8000e1c:	000a      	movs	r2, r1
 8000e1e:	24ff      	movs	r4, #255	; 0xff
 8000e20:	2300      	movs	r3, #0
 8000e22:	e716      	b.n	8000c52 <__aeabi_fsub+0xb2>
 8000e24:	2c00      	cmp	r4, #0
 8000e26:	d115      	bne.n	8000e54 <__aeabi_fsub+0x2b4>
 8000e28:	2b00      	cmp	r3, #0
 8000e2a:	d157      	bne.n	8000edc <__aeabi_fsub+0x33c>
 8000e2c:	28ff      	cmp	r0, #255	; 0xff
 8000e2e:	d1e6      	bne.n	8000dfe <__aeabi_fsub+0x25e>
 8000e30:	464b      	mov	r3, r9
 8000e32:	e77b      	b.n	8000d2c <__aeabi_fsub+0x18c>
 8000e34:	2c00      	cmp	r4, #0
 8000e36:	d120      	bne.n	8000e7a <__aeabi_fsub+0x2da>
 8000e38:	2b00      	cmp	r3, #0
 8000e3a:	d057      	beq.n	8000eec <__aeabi_fsub+0x34c>
 8000e3c:	4649      	mov	r1, r9
 8000e3e:	2900      	cmp	r1, #0
 8000e40:	d053      	beq.n	8000eea <__aeabi_fsub+0x34a>
 8000e42:	444b      	add	r3, r9
 8000e44:	015a      	lsls	r2, r3, #5
 8000e46:	d568      	bpl.n	8000f1a <__aeabi_fsub+0x37a>
 8000e48:	2407      	movs	r4, #7
 8000e4a:	4a36      	ldr	r2, [pc, #216]	; (8000f24 <__aeabi_fsub+0x384>)
 8000e4c:	401c      	ands	r4, r3
 8000e4e:	2501      	movs	r5, #1
 8000e50:	4013      	ands	r3, r2
 8000e52:	e6ea      	b.n	8000c2a <__aeabi_fsub+0x8a>
 8000e54:	28ff      	cmp	r0, #255	; 0xff
 8000e56:	d0eb      	beq.n	8000e30 <__aeabi_fsub+0x290>
 8000e58:	2280      	movs	r2, #128	; 0x80
 8000e5a:	04d2      	lsls	r2, r2, #19
 8000e5c:	4276      	negs	r6, r6
 8000e5e:	4313      	orrs	r3, r2
 8000e60:	2e1b      	cmp	r6, #27
 8000e62:	dc53      	bgt.n	8000f0c <__aeabi_fsub+0x36c>
 8000e64:	2520      	movs	r5, #32
 8000e66:	1bad      	subs	r5, r5, r6
 8000e68:	001a      	movs	r2, r3
 8000e6a:	40ab      	lsls	r3, r5
 8000e6c:	40f2      	lsrs	r2, r6
 8000e6e:	1e5c      	subs	r4, r3, #1
 8000e70:	41a3      	sbcs	r3, r4
 8000e72:	4313      	orrs	r3, r2
 8000e74:	444b      	add	r3, r9
 8000e76:	0005      	movs	r5, r0
 8000e78:	e721      	b.n	8000cbe <__aeabi_fsub+0x11e>
 8000e7a:	2b00      	cmp	r3, #0
 8000e7c:	d0d8      	beq.n	8000e30 <__aeabi_fsub+0x290>
 8000e7e:	4649      	mov	r1, r9
 8000e80:	2900      	cmp	r1, #0
 8000e82:	d100      	bne.n	8000e86 <__aeabi_fsub+0x2e6>
 8000e84:	e752      	b.n	8000d2c <__aeabi_fsub+0x18c>
 8000e86:	2180      	movs	r1, #128	; 0x80
 8000e88:	03c9      	lsls	r1, r1, #15
 8000e8a:	420f      	tst	r7, r1
 8000e8c:	d100      	bne.n	8000e90 <__aeabi_fsub+0x2f0>
 8000e8e:	e74d      	b.n	8000d2c <__aeabi_fsub+0x18c>
 8000e90:	4660      	mov	r0, ip
 8000e92:	4208      	tst	r0, r1
 8000e94:	d000      	beq.n	8000e98 <__aeabi_fsub+0x2f8>
 8000e96:	e749      	b.n	8000d2c <__aeabi_fsub+0x18c>
 8000e98:	464b      	mov	r3, r9
 8000e9a:	e747      	b.n	8000d2c <__aeabi_fsub+0x18c>
 8000e9c:	4648      	mov	r0, r9
 8000e9e:	25ff      	movs	r5, #255	; 0xff
 8000ea0:	2800      	cmp	r0, #0
 8000ea2:	d100      	bne.n	8000ea6 <__aeabi_fsub+0x306>
 8000ea4:	e74f      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000ea6:	2280      	movs	r2, #128	; 0x80
 8000ea8:	03d2      	lsls	r2, r2, #15
 8000eaa:	4217      	tst	r7, r2
 8000eac:	d004      	beq.n	8000eb8 <__aeabi_fsub+0x318>
 8000eae:	4660      	mov	r0, ip
 8000eb0:	4210      	tst	r0, r2
 8000eb2:	d101      	bne.n	8000eb8 <__aeabi_fsub+0x318>
 8000eb4:	464b      	mov	r3, r9
 8000eb6:	4688      	mov	r8, r1
 8000eb8:	2201      	movs	r2, #1
 8000eba:	4641      	mov	r1, r8
 8000ebc:	25ff      	movs	r5, #255	; 0xff
 8000ebe:	400a      	ands	r2, r1
 8000ec0:	e741      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000ec2:	4648      	mov	r0, r9
 8000ec4:	2800      	cmp	r0, #0
 8000ec6:	d01f      	beq.n	8000f08 <__aeabi_fsub+0x368>
 8000ec8:	1a1a      	subs	r2, r3, r0
 8000eca:	0150      	lsls	r0, r2, #5
 8000ecc:	d520      	bpl.n	8000f10 <__aeabi_fsub+0x370>
 8000ece:	464a      	mov	r2, r9
 8000ed0:	2407      	movs	r4, #7
 8000ed2:	1ad3      	subs	r3, r2, r3
 8000ed4:	401c      	ands	r4, r3
 8000ed6:	4688      	mov	r8, r1
 8000ed8:	2500      	movs	r5, #0
 8000eda:	e6a6      	b.n	8000c2a <__aeabi_fsub+0x8a>
 8000edc:	1c74      	adds	r4, r6, #1
 8000ede:	d0c9      	beq.n	8000e74 <__aeabi_fsub+0x2d4>
 8000ee0:	43f6      	mvns	r6, r6
 8000ee2:	28ff      	cmp	r0, #255	; 0xff
 8000ee4:	d1bc      	bne.n	8000e60 <__aeabi_fsub+0x2c0>
 8000ee6:	464b      	mov	r3, r9
 8000ee8:	e720      	b.n	8000d2c <__aeabi_fsub+0x18c>
 8000eea:	4699      	mov	r9, r3
 8000eec:	464b      	mov	r3, r9
 8000eee:	2500      	movs	r5, #0
 8000ef0:	08db      	lsrs	r3, r3, #3
 8000ef2:	e72b      	b.n	8000d4c <__aeabi_fsub+0x1ac>
 8000ef4:	2301      	movs	r3, #1
 8000ef6:	e740      	b.n	8000d7a <__aeabi_fsub+0x1da>
 8000ef8:	2200      	movs	r2, #0
 8000efa:	2300      	movs	r3, #0
 8000efc:	e6a9      	b.n	8000c52 <__aeabi_fsub+0xb2>
 8000efe:	2380      	movs	r3, #128	; 0x80
 8000f00:	2200      	movs	r2, #0
 8000f02:	03db      	lsls	r3, r3, #15
 8000f04:	24ff      	movs	r4, #255	; 0xff
 8000f06:	e6a4      	b.n	8000c52 <__aeabi_fsub+0xb2>
 8000f08:	2500      	movs	r5, #0
 8000f0a:	e71c      	b.n	8000d46 <__aeabi_fsub+0x1a6>
 8000f0c:	2301      	movs	r3, #1
 8000f0e:	e7b1      	b.n	8000e74 <__aeabi_fsub+0x2d4>
 8000f10:	2a00      	cmp	r2, #0
 8000f12:	d0f1      	beq.n	8000ef8 <__aeabi_fsub+0x358>
 8000f14:	0013      	movs	r3, r2
 8000f16:	2500      	movs	r5, #0
 8000f18:	e6fc      	b.n	8000d14 <__aeabi_fsub+0x174>
 8000f1a:	2500      	movs	r5, #0
 8000f1c:	e6fa      	b.n	8000d14 <__aeabi_fsub+0x174>
 8000f1e:	46c0      	nop			; (mov r8, r8)
 8000f20:	7dffffff 	.word	0x7dffffff
 8000f24:	fbffffff 	.word	0xfbffffff

08000f28 <__aeabi_f2iz>:
 8000f28:	0241      	lsls	r1, r0, #9
 8000f2a:	0042      	lsls	r2, r0, #1
 8000f2c:	0fc3      	lsrs	r3, r0, #31
 8000f2e:	0a49      	lsrs	r1, r1, #9
 8000f30:	0e12      	lsrs	r2, r2, #24
 8000f32:	2000      	movs	r0, #0
 8000f34:	2a7e      	cmp	r2, #126	; 0x7e
 8000f36:	d90d      	bls.n	8000f54 <__aeabi_f2iz+0x2c>
 8000f38:	2a9d      	cmp	r2, #157	; 0x9d
 8000f3a:	d80c      	bhi.n	8000f56 <__aeabi_f2iz+0x2e>
 8000f3c:	2080      	movs	r0, #128	; 0x80
 8000f3e:	0400      	lsls	r0, r0, #16
 8000f40:	4301      	orrs	r1, r0
 8000f42:	2a95      	cmp	r2, #149	; 0x95
 8000f44:	dc0a      	bgt.n	8000f5c <__aeabi_f2iz+0x34>
 8000f46:	2096      	movs	r0, #150	; 0x96
 8000f48:	1a82      	subs	r2, r0, r2
 8000f4a:	40d1      	lsrs	r1, r2
 8000f4c:	4248      	negs	r0, r1
 8000f4e:	2b00      	cmp	r3, #0
 8000f50:	d100      	bne.n	8000f54 <__aeabi_f2iz+0x2c>
 8000f52:	0008      	movs	r0, r1
 8000f54:	4770      	bx	lr
 8000f56:	4a03      	ldr	r2, [pc, #12]	; (8000f64 <__aeabi_f2iz+0x3c>)
 8000f58:	1898      	adds	r0, r3, r2
 8000f5a:	e7fb      	b.n	8000f54 <__aeabi_f2iz+0x2c>
 8000f5c:	3a96      	subs	r2, #150	; 0x96
 8000f5e:	4091      	lsls	r1, r2
 8000f60:	e7f4      	b.n	8000f4c <__aeabi_f2iz+0x24>
 8000f62:	46c0      	nop			; (mov r8, r8)
 8000f64:	7fffffff 	.word	0x7fffffff

08000f68 <__aeabi_dadd>:
 8000f68:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000f6a:	464f      	mov	r7, r9
 8000f6c:	4646      	mov	r6, r8
 8000f6e:	46d6      	mov	lr, sl
 8000f70:	000c      	movs	r4, r1
 8000f72:	0309      	lsls	r1, r1, #12
 8000f74:	b5c0      	push	{r6, r7, lr}
 8000f76:	0a49      	lsrs	r1, r1, #9
 8000f78:	0f47      	lsrs	r7, r0, #29
 8000f7a:	005e      	lsls	r6, r3, #1
 8000f7c:	4339      	orrs	r1, r7
 8000f7e:	031f      	lsls	r7, r3, #12
 8000f80:	0fdb      	lsrs	r3, r3, #31
 8000f82:	469c      	mov	ip, r3
 8000f84:	0065      	lsls	r5, r4, #1
 8000f86:	0a7b      	lsrs	r3, r7, #9
 8000f88:	0f57      	lsrs	r7, r2, #29
 8000f8a:	431f      	orrs	r7, r3
 8000f8c:	0d6d      	lsrs	r5, r5, #21
 8000f8e:	0fe4      	lsrs	r4, r4, #31
 8000f90:	0d76      	lsrs	r6, r6, #21
 8000f92:	46a1      	mov	r9, r4
 8000f94:	00c0      	lsls	r0, r0, #3
 8000f96:	46b8      	mov	r8, r7
 8000f98:	00d2      	lsls	r2, r2, #3
 8000f9a:	1bab      	subs	r3, r5, r6
 8000f9c:	4564      	cmp	r4, ip
 8000f9e:	d07b      	beq.n	8001098 <__aeabi_dadd+0x130>
 8000fa0:	2b00      	cmp	r3, #0
 8000fa2:	dd5f      	ble.n	8001064 <__aeabi_dadd+0xfc>
 8000fa4:	2e00      	cmp	r6, #0
 8000fa6:	d000      	beq.n	8000faa <__aeabi_dadd+0x42>
 8000fa8:	e0a4      	b.n	80010f4 <__aeabi_dadd+0x18c>
 8000faa:	003e      	movs	r6, r7
 8000fac:	4316      	orrs	r6, r2
 8000fae:	d100      	bne.n	8000fb2 <__aeabi_dadd+0x4a>
 8000fb0:	e112      	b.n	80011d8 <__aeabi_dadd+0x270>
 8000fb2:	1e5e      	subs	r6, r3, #1
 8000fb4:	2e00      	cmp	r6, #0
 8000fb6:	d000      	beq.n	8000fba <__aeabi_dadd+0x52>
 8000fb8:	e19e      	b.n	80012f8 <__aeabi_dadd+0x390>
 8000fba:	1a87      	subs	r7, r0, r2
 8000fbc:	4643      	mov	r3, r8
 8000fbe:	42b8      	cmp	r0, r7
 8000fc0:	4180      	sbcs	r0, r0
 8000fc2:	2501      	movs	r5, #1
 8000fc4:	1ac9      	subs	r1, r1, r3
 8000fc6:	4240      	negs	r0, r0
 8000fc8:	1a09      	subs	r1, r1, r0
 8000fca:	020b      	lsls	r3, r1, #8
 8000fcc:	d400      	bmi.n	8000fd0 <__aeabi_dadd+0x68>
 8000fce:	e131      	b.n	8001234 <__aeabi_dadd+0x2cc>
 8000fd0:	0249      	lsls	r1, r1, #9
 8000fd2:	0a4e      	lsrs	r6, r1, #9
 8000fd4:	2e00      	cmp	r6, #0
 8000fd6:	d100      	bne.n	8000fda <__aeabi_dadd+0x72>
 8000fd8:	e16e      	b.n	80012b8 <__aeabi_dadd+0x350>
 8000fda:	0030      	movs	r0, r6
 8000fdc:	f001 fe38 	bl	8002c50 <__clzsi2>
 8000fe0:	0003      	movs	r3, r0
 8000fe2:	3b08      	subs	r3, #8
 8000fe4:	2b1f      	cmp	r3, #31
 8000fe6:	dd00      	ble.n	8000fea <__aeabi_dadd+0x82>
 8000fe8:	e161      	b.n	80012ae <__aeabi_dadd+0x346>
 8000fea:	2220      	movs	r2, #32
 8000fec:	0039      	movs	r1, r7
 8000fee:	1ad2      	subs	r2, r2, r3
 8000ff0:	409e      	lsls	r6, r3
 8000ff2:	40d1      	lsrs	r1, r2
 8000ff4:	409f      	lsls	r7, r3
 8000ff6:	430e      	orrs	r6, r1
 8000ff8:	429d      	cmp	r5, r3
 8000ffa:	dd00      	ble.n	8000ffe <__aeabi_dadd+0x96>
 8000ffc:	e151      	b.n	80012a2 <__aeabi_dadd+0x33a>
 8000ffe:	1b5d      	subs	r5, r3, r5
 8001000:	1c6b      	adds	r3, r5, #1
 8001002:	2b1f      	cmp	r3, #31
 8001004:	dd00      	ble.n	8001008 <__aeabi_dadd+0xa0>
 8001006:	e17c      	b.n	8001302 <__aeabi_dadd+0x39a>
 8001008:	2120      	movs	r1, #32
 800100a:	1ac9      	subs	r1, r1, r3
 800100c:	003d      	movs	r5, r7
 800100e:	0030      	movs	r0, r6
 8001010:	408f      	lsls	r7, r1
 8001012:	4088      	lsls	r0, r1
 8001014:	40dd      	lsrs	r5, r3
 8001016:	1e79      	subs	r1, r7, #1
 8001018:	418f      	sbcs	r7, r1
 800101a:	0031      	movs	r1, r6
 800101c:	2207      	movs	r2, #7
 800101e:	4328      	orrs	r0, r5
 8001020:	40d9      	lsrs	r1, r3
 8001022:	2500      	movs	r5, #0
 8001024:	4307      	orrs	r7, r0
 8001026:	403a      	ands	r2, r7
 8001028:	2a00      	cmp	r2, #0
 800102a:	d009      	beq.n	8001040 <__aeabi_dadd+0xd8>
 800102c:	230f      	movs	r3, #15
 800102e:	403b      	ands	r3, r7
 8001030:	2b04      	cmp	r3, #4
 8001032:	d005      	beq.n	8001040 <__aeabi_dadd+0xd8>
 8001034:	1d3b      	adds	r3, r7, #4
 8001036:	42bb      	cmp	r3, r7
 8001038:	41bf      	sbcs	r7, r7
 800103a:	427f      	negs	r7, r7
 800103c:	19c9      	adds	r1, r1, r7
 800103e:	001f      	movs	r7, r3
 8001040:	020b      	lsls	r3, r1, #8
 8001042:	d400      	bmi.n	8001046 <__aeabi_dadd+0xde>
 8001044:	e226      	b.n	8001494 <__aeabi_dadd+0x52c>
 8001046:	1c6a      	adds	r2, r5, #1
 8001048:	4bc6      	ldr	r3, [pc, #792]	; (8001364 <__aeabi_dadd+0x3fc>)
 800104a:	0555      	lsls	r5, r2, #21
 800104c:	0d6d      	lsrs	r5, r5, #21
 800104e:	429a      	cmp	r2, r3
 8001050:	d100      	bne.n	8001054 <__aeabi_dadd+0xec>
 8001052:	e106      	b.n	8001262 <__aeabi_dadd+0x2fa>
 8001054:	4ac4      	ldr	r2, [pc, #784]	; (8001368 <__aeabi_dadd+0x400>)
 8001056:	08ff      	lsrs	r7, r7, #3
 8001058:	400a      	ands	r2, r1
 800105a:	0753      	lsls	r3, r2, #29
 800105c:	0252      	lsls	r2, r2, #9
 800105e:	433b      	orrs	r3, r7
 8001060:	0b12      	lsrs	r2, r2, #12
 8001062:	e08e      	b.n	8001182 <__aeabi_dadd+0x21a>
 8001064:	2b00      	cmp	r3, #0
 8001066:	d000      	beq.n	800106a <__aeabi_dadd+0x102>
 8001068:	e0b8      	b.n	80011dc <__aeabi_dadd+0x274>
 800106a:	1c6b      	adds	r3, r5, #1
 800106c:	055b      	lsls	r3, r3, #21
 800106e:	0d5b      	lsrs	r3, r3, #21
 8001070:	2b01      	cmp	r3, #1
 8001072:	dc00      	bgt.n	8001076 <__aeabi_dadd+0x10e>
 8001074:	e130      	b.n	80012d8 <__aeabi_dadd+0x370>
 8001076:	1a87      	subs	r7, r0, r2
 8001078:	4643      	mov	r3, r8
 800107a:	42b8      	cmp	r0, r7
 800107c:	41b6      	sbcs	r6, r6
 800107e:	1acb      	subs	r3, r1, r3
 8001080:	4276      	negs	r6, r6
 8001082:	1b9e      	subs	r6, r3, r6
 8001084:	0233      	lsls	r3, r6, #8
 8001086:	d500      	bpl.n	800108a <__aeabi_dadd+0x122>
 8001088:	e14c      	b.n	8001324 <__aeabi_dadd+0x3bc>
 800108a:	003b      	movs	r3, r7
 800108c:	4333      	orrs	r3, r6
 800108e:	d1a1      	bne.n	8000fd4 <__aeabi_dadd+0x6c>
 8001090:	2200      	movs	r2, #0
 8001092:	2400      	movs	r4, #0
 8001094:	2500      	movs	r5, #0
 8001096:	e070      	b.n	800117a <__aeabi_dadd+0x212>
 8001098:	2b00      	cmp	r3, #0
 800109a:	dc00      	bgt.n	800109e <__aeabi_dadd+0x136>
 800109c:	e0e5      	b.n	800126a <__aeabi_dadd+0x302>
 800109e:	2e00      	cmp	r6, #0
 80010a0:	d100      	bne.n	80010a4 <__aeabi_dadd+0x13c>
 80010a2:	e083      	b.n	80011ac <__aeabi_dadd+0x244>
 80010a4:	4eaf      	ldr	r6, [pc, #700]	; (8001364 <__aeabi_dadd+0x3fc>)
 80010a6:	42b5      	cmp	r5, r6
 80010a8:	d060      	beq.n	800116c <__aeabi_dadd+0x204>
 80010aa:	2680      	movs	r6, #128	; 0x80
 80010ac:	0436      	lsls	r6, r6, #16
 80010ae:	4337      	orrs	r7, r6
 80010b0:	46b8      	mov	r8, r7
 80010b2:	2b38      	cmp	r3, #56	; 0x38
 80010b4:	dc00      	bgt.n	80010b8 <__aeabi_dadd+0x150>
 80010b6:	e13e      	b.n	8001336 <__aeabi_dadd+0x3ce>
 80010b8:	4643      	mov	r3, r8
 80010ba:	4313      	orrs	r3, r2
 80010bc:	001f      	movs	r7, r3
 80010be:	1e7a      	subs	r2, r7, #1
 80010c0:	4197      	sbcs	r7, r2
 80010c2:	183f      	adds	r7, r7, r0
 80010c4:	4287      	cmp	r7, r0
 80010c6:	4180      	sbcs	r0, r0
 80010c8:	4240      	negs	r0, r0
 80010ca:	1809      	adds	r1, r1, r0
 80010cc:	020b      	lsls	r3, r1, #8
 80010ce:	d400      	bmi.n	80010d2 <__aeabi_dadd+0x16a>
 80010d0:	e0b0      	b.n	8001234 <__aeabi_dadd+0x2cc>
 80010d2:	4ba4      	ldr	r3, [pc, #656]	; (8001364 <__aeabi_dadd+0x3fc>)
 80010d4:	3501      	adds	r5, #1
 80010d6:	429d      	cmp	r5, r3
 80010d8:	d100      	bne.n	80010dc <__aeabi_dadd+0x174>
 80010da:	e0c3      	b.n	8001264 <__aeabi_dadd+0x2fc>
 80010dc:	4aa2      	ldr	r2, [pc, #648]	; (8001368 <__aeabi_dadd+0x400>)
 80010de:	087b      	lsrs	r3, r7, #1
 80010e0:	400a      	ands	r2, r1
 80010e2:	2101      	movs	r1, #1
 80010e4:	400f      	ands	r7, r1
 80010e6:	431f      	orrs	r7, r3
 80010e8:	0851      	lsrs	r1, r2, #1
 80010ea:	07d3      	lsls	r3, r2, #31
 80010ec:	2207      	movs	r2, #7
 80010ee:	431f      	orrs	r7, r3
 80010f0:	403a      	ands	r2, r7
 80010f2:	e799      	b.n	8001028 <__aeabi_dadd+0xc0>
 80010f4:	4e9b      	ldr	r6, [pc, #620]	; (8001364 <__aeabi_dadd+0x3fc>)
 80010f6:	42b5      	cmp	r5, r6
 80010f8:	d038      	beq.n	800116c <__aeabi_dadd+0x204>
 80010fa:	2680      	movs	r6, #128	; 0x80
 80010fc:	0436      	lsls	r6, r6, #16
 80010fe:	4337      	orrs	r7, r6
 8001100:	46b8      	mov	r8, r7
 8001102:	2b38      	cmp	r3, #56	; 0x38
 8001104:	dd00      	ble.n	8001108 <__aeabi_dadd+0x1a0>
 8001106:	e0dc      	b.n	80012c2 <__aeabi_dadd+0x35a>
 8001108:	2b1f      	cmp	r3, #31
 800110a:	dc00      	bgt.n	800110e <__aeabi_dadd+0x1a6>
 800110c:	e130      	b.n	8001370 <__aeabi_dadd+0x408>
 800110e:	001e      	movs	r6, r3
 8001110:	4647      	mov	r7, r8
 8001112:	3e20      	subs	r6, #32
 8001114:	40f7      	lsrs	r7, r6
 8001116:	46bc      	mov	ip, r7
 8001118:	2b20      	cmp	r3, #32
 800111a:	d004      	beq.n	8001126 <__aeabi_dadd+0x1be>
 800111c:	2640      	movs	r6, #64	; 0x40
 800111e:	1af3      	subs	r3, r6, r3
 8001120:	4646      	mov	r6, r8
 8001122:	409e      	lsls	r6, r3
 8001124:	4332      	orrs	r2, r6
 8001126:	0017      	movs	r7, r2
 8001128:	4663      	mov	r3, ip
 800112a:	1e7a      	subs	r2, r7, #1
 800112c:	4197      	sbcs	r7, r2
 800112e:	431f      	orrs	r7, r3
 8001130:	e0cc      	b.n	80012cc <__aeabi_dadd+0x364>
 8001132:	2b00      	cmp	r3, #0
 8001134:	d100      	bne.n	8001138 <__aeabi_dadd+0x1d0>
 8001136:	e204      	b.n	8001542 <__aeabi_dadd+0x5da>
 8001138:	4643      	mov	r3, r8
 800113a:	4313      	orrs	r3, r2
 800113c:	d100      	bne.n	8001140 <__aeabi_dadd+0x1d8>
 800113e:	e159      	b.n	80013f4 <__aeabi_dadd+0x48c>
 8001140:	074b      	lsls	r3, r1, #29
 8001142:	08c0      	lsrs	r0, r0, #3
 8001144:	4318      	orrs	r0, r3
 8001146:	2380      	movs	r3, #128	; 0x80
 8001148:	08c9      	lsrs	r1, r1, #3
 800114a:	031b      	lsls	r3, r3, #12
 800114c:	4219      	tst	r1, r3
 800114e:	d008      	beq.n	8001162 <__aeabi_dadd+0x1fa>
 8001150:	4645      	mov	r5, r8
 8001152:	08ed      	lsrs	r5, r5, #3
 8001154:	421d      	tst	r5, r3
 8001156:	d104      	bne.n	8001162 <__aeabi_dadd+0x1fa>
 8001158:	4643      	mov	r3, r8
 800115a:	08d0      	lsrs	r0, r2, #3
 800115c:	0759      	lsls	r1, r3, #29
 800115e:	4308      	orrs	r0, r1
 8001160:	0029      	movs	r1, r5
 8001162:	0f42      	lsrs	r2, r0, #29
 8001164:	00c9      	lsls	r1, r1, #3
 8001166:	4d7f      	ldr	r5, [pc, #508]	; (8001364 <__aeabi_dadd+0x3fc>)
 8001168:	4311      	orrs	r1, r2
 800116a:	00c0      	lsls	r0, r0, #3
 800116c:	074b      	lsls	r3, r1, #29
 800116e:	08ca      	lsrs	r2, r1, #3
 8001170:	497c      	ldr	r1, [pc, #496]	; (8001364 <__aeabi_dadd+0x3fc>)
 8001172:	08c0      	lsrs	r0, r0, #3
 8001174:	4303      	orrs	r3, r0
 8001176:	428d      	cmp	r5, r1
 8001178:	d068      	beq.n	800124c <__aeabi_dadd+0x2e4>
 800117a:	0312      	lsls	r2, r2, #12
 800117c:	056d      	lsls	r5, r5, #21
 800117e:	0b12      	lsrs	r2, r2, #12
 8001180:	0d6d      	lsrs	r5, r5, #21
 8001182:	2100      	movs	r1, #0
 8001184:	0312      	lsls	r2, r2, #12
 8001186:	0018      	movs	r0, r3
 8001188:	0b13      	lsrs	r3, r2, #12
 800118a:	0d0a      	lsrs	r2, r1, #20
 800118c:	0512      	lsls	r2, r2, #20
 800118e:	431a      	orrs	r2, r3
 8001190:	4b76      	ldr	r3, [pc, #472]	; (800136c <__aeabi_dadd+0x404>)
 8001192:	052d      	lsls	r5, r5, #20
 8001194:	4013      	ands	r3, r2
 8001196:	432b      	orrs	r3, r5
 8001198:	005b      	lsls	r3, r3, #1
 800119a:	07e4      	lsls	r4, r4, #31
 800119c:	085b      	lsrs	r3, r3, #1
 800119e:	4323      	orrs	r3, r4
 80011a0:	0019      	movs	r1, r3
 80011a2:	bc1c      	pop	{r2, r3, r4}
 80011a4:	4690      	mov	r8, r2
 80011a6:	4699      	mov	r9, r3
 80011a8:	46a2      	mov	sl, r4
 80011aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80011ac:	003e      	movs	r6, r7
 80011ae:	4316      	orrs	r6, r2
 80011b0:	d012      	beq.n	80011d8 <__aeabi_dadd+0x270>
 80011b2:	1e5e      	subs	r6, r3, #1
 80011b4:	2e00      	cmp	r6, #0
 80011b6:	d000      	beq.n	80011ba <__aeabi_dadd+0x252>
 80011b8:	e100      	b.n	80013bc <__aeabi_dadd+0x454>
 80011ba:	1887      	adds	r7, r0, r2
 80011bc:	4287      	cmp	r7, r0
 80011be:	4180      	sbcs	r0, r0
 80011c0:	4441      	add	r1, r8
 80011c2:	4240      	negs	r0, r0
 80011c4:	1809      	adds	r1, r1, r0
 80011c6:	2501      	movs	r5, #1
 80011c8:	020b      	lsls	r3, r1, #8
 80011ca:	d533      	bpl.n	8001234 <__aeabi_dadd+0x2cc>
 80011cc:	2502      	movs	r5, #2
 80011ce:	e785      	b.n	80010dc <__aeabi_dadd+0x174>
 80011d0:	4664      	mov	r4, ip
 80011d2:	0033      	movs	r3, r6
 80011d4:	4641      	mov	r1, r8
 80011d6:	0010      	movs	r0, r2
 80011d8:	001d      	movs	r5, r3
 80011da:	e7c7      	b.n	800116c <__aeabi_dadd+0x204>
 80011dc:	2d00      	cmp	r5, #0
 80011de:	d000      	beq.n	80011e2 <__aeabi_dadd+0x27a>
 80011e0:	e0da      	b.n	8001398 <__aeabi_dadd+0x430>
 80011e2:	000c      	movs	r4, r1
 80011e4:	4304      	orrs	r4, r0
 80011e6:	d0f3      	beq.n	80011d0 <__aeabi_dadd+0x268>
 80011e8:	1c5c      	adds	r4, r3, #1
 80011ea:	d100      	bne.n	80011ee <__aeabi_dadd+0x286>
 80011ec:	e19f      	b.n	800152e <__aeabi_dadd+0x5c6>
 80011ee:	4c5d      	ldr	r4, [pc, #372]	; (8001364 <__aeabi_dadd+0x3fc>)
 80011f0:	42a6      	cmp	r6, r4
 80011f2:	d100      	bne.n	80011f6 <__aeabi_dadd+0x28e>
 80011f4:	e12f      	b.n	8001456 <__aeabi_dadd+0x4ee>
 80011f6:	43db      	mvns	r3, r3
 80011f8:	2b38      	cmp	r3, #56	; 0x38
 80011fa:	dd00      	ble.n	80011fe <__aeabi_dadd+0x296>
 80011fc:	e166      	b.n	80014cc <__aeabi_dadd+0x564>
 80011fe:	2b1f      	cmp	r3, #31
 8001200:	dd00      	ble.n	8001204 <__aeabi_dadd+0x29c>
 8001202:	e183      	b.n	800150c <__aeabi_dadd+0x5a4>
 8001204:	2420      	movs	r4, #32
 8001206:	0005      	movs	r5, r0
 8001208:	1ae4      	subs	r4, r4, r3
 800120a:	000f      	movs	r7, r1
 800120c:	40dd      	lsrs	r5, r3
 800120e:	40d9      	lsrs	r1, r3
 8001210:	40a0      	lsls	r0, r4
 8001212:	4643      	mov	r3, r8
 8001214:	40a7      	lsls	r7, r4
 8001216:	1a5b      	subs	r3, r3, r1
 8001218:	1e44      	subs	r4, r0, #1
 800121a:	41a0      	sbcs	r0, r4
 800121c:	4698      	mov	r8, r3
 800121e:	432f      	orrs	r7, r5
 8001220:	4338      	orrs	r0, r7
 8001222:	1a17      	subs	r7, r2, r0
 8001224:	42ba      	cmp	r2, r7
 8001226:	4192      	sbcs	r2, r2
 8001228:	4643      	mov	r3, r8
 800122a:	4252      	negs	r2, r2
 800122c:	1a99      	subs	r1, r3, r2
 800122e:	4664      	mov	r4, ip
 8001230:	0035      	movs	r5, r6
 8001232:	e6ca      	b.n	8000fca <__aeabi_dadd+0x62>
 8001234:	2207      	movs	r2, #7
 8001236:	403a      	ands	r2, r7
 8001238:	2a00      	cmp	r2, #0
 800123a:	d000      	beq.n	800123e <__aeabi_dadd+0x2d6>
 800123c:	e6f6      	b.n	800102c <__aeabi_dadd+0xc4>
 800123e:	074b      	lsls	r3, r1, #29
 8001240:	08ca      	lsrs	r2, r1, #3
 8001242:	4948      	ldr	r1, [pc, #288]	; (8001364 <__aeabi_dadd+0x3fc>)
 8001244:	08ff      	lsrs	r7, r7, #3
 8001246:	433b      	orrs	r3, r7
 8001248:	428d      	cmp	r5, r1
 800124a:	d196      	bne.n	800117a <__aeabi_dadd+0x212>
 800124c:	0019      	movs	r1, r3
 800124e:	4311      	orrs	r1, r2
 8001250:	d100      	bne.n	8001254 <__aeabi_dadd+0x2ec>
 8001252:	e19e      	b.n	8001592 <__aeabi_dadd+0x62a>
 8001254:	2180      	movs	r1, #128	; 0x80
 8001256:	0309      	lsls	r1, r1, #12
 8001258:	430a      	orrs	r2, r1
 800125a:	0312      	lsls	r2, r2, #12
 800125c:	0b12      	lsrs	r2, r2, #12
 800125e:	4d41      	ldr	r5, [pc, #260]	; (8001364 <__aeabi_dadd+0x3fc>)
 8001260:	e78f      	b.n	8001182 <__aeabi_dadd+0x21a>
 8001262:	0015      	movs	r5, r2
 8001264:	2200      	movs	r2, #0
 8001266:	2300      	movs	r3, #0
 8001268:	e78b      	b.n	8001182 <__aeabi_dadd+0x21a>
 800126a:	2b00      	cmp	r3, #0
 800126c:	d000      	beq.n	8001270 <__aeabi_dadd+0x308>
 800126e:	e0c7      	b.n	8001400 <__aeabi_dadd+0x498>
 8001270:	1c6b      	adds	r3, r5, #1
 8001272:	055f      	lsls	r7, r3, #21
 8001274:	0d7f      	lsrs	r7, r7, #21
 8001276:	2f01      	cmp	r7, #1
 8001278:	dc00      	bgt.n	800127c <__aeabi_dadd+0x314>
 800127a:	e0f1      	b.n	8001460 <__aeabi_dadd+0x4f8>
 800127c:	4d39      	ldr	r5, [pc, #228]	; (8001364 <__aeabi_dadd+0x3fc>)
 800127e:	42ab      	cmp	r3, r5
 8001280:	d100      	bne.n	8001284 <__aeabi_dadd+0x31c>
 8001282:	e0b9      	b.n	80013f8 <__aeabi_dadd+0x490>
 8001284:	1885      	adds	r5, r0, r2
 8001286:	000a      	movs	r2, r1
 8001288:	4285      	cmp	r5, r0
 800128a:	4189      	sbcs	r1, r1
 800128c:	4442      	add	r2, r8
 800128e:	4249      	negs	r1, r1
 8001290:	1851      	adds	r1, r2, r1
 8001292:	2207      	movs	r2, #7
 8001294:	07cf      	lsls	r7, r1, #31
 8001296:	086d      	lsrs	r5, r5, #1
 8001298:	432f      	orrs	r7, r5
 800129a:	0849      	lsrs	r1, r1, #1
 800129c:	403a      	ands	r2, r7
 800129e:	001d      	movs	r5, r3
 80012a0:	e6c2      	b.n	8001028 <__aeabi_dadd+0xc0>
 80012a2:	2207      	movs	r2, #7
 80012a4:	4930      	ldr	r1, [pc, #192]	; (8001368 <__aeabi_dadd+0x400>)
 80012a6:	1aed      	subs	r5, r5, r3
 80012a8:	4031      	ands	r1, r6
 80012aa:	403a      	ands	r2, r7
 80012ac:	e6bc      	b.n	8001028 <__aeabi_dadd+0xc0>
 80012ae:	003e      	movs	r6, r7
 80012b0:	3828      	subs	r0, #40	; 0x28
 80012b2:	4086      	lsls	r6, r0
 80012b4:	2700      	movs	r7, #0
 80012b6:	e69f      	b.n	8000ff8 <__aeabi_dadd+0x90>
 80012b8:	0038      	movs	r0, r7
 80012ba:	f001 fcc9 	bl	8002c50 <__clzsi2>
 80012be:	3020      	adds	r0, #32
 80012c0:	e68e      	b.n	8000fe0 <__aeabi_dadd+0x78>
 80012c2:	4643      	mov	r3, r8
 80012c4:	4313      	orrs	r3, r2
 80012c6:	001f      	movs	r7, r3
 80012c8:	1e7a      	subs	r2, r7, #1
 80012ca:	4197      	sbcs	r7, r2
 80012cc:	1bc7      	subs	r7, r0, r7
 80012ce:	42b8      	cmp	r0, r7
 80012d0:	4180      	sbcs	r0, r0
 80012d2:	4240      	negs	r0, r0
 80012d4:	1a09      	subs	r1, r1, r0
 80012d6:	e678      	b.n	8000fca <__aeabi_dadd+0x62>
 80012d8:	000e      	movs	r6, r1
 80012da:	003b      	movs	r3, r7
 80012dc:	4306      	orrs	r6, r0
 80012de:	4313      	orrs	r3, r2
 80012e0:	2d00      	cmp	r5, #0
 80012e2:	d161      	bne.n	80013a8 <__aeabi_dadd+0x440>
 80012e4:	2e00      	cmp	r6, #0
 80012e6:	d000      	beq.n	80012ea <__aeabi_dadd+0x382>
 80012e8:	e0f4      	b.n	80014d4 <__aeabi_dadd+0x56c>
 80012ea:	2b00      	cmp	r3, #0
 80012ec:	d100      	bne.n	80012f0 <__aeabi_dadd+0x388>
 80012ee:	e11b      	b.n	8001528 <__aeabi_dadd+0x5c0>
 80012f0:	4664      	mov	r4, ip
 80012f2:	0039      	movs	r1, r7
 80012f4:	0010      	movs	r0, r2
 80012f6:	e739      	b.n	800116c <__aeabi_dadd+0x204>
 80012f8:	4f1a      	ldr	r7, [pc, #104]	; (8001364 <__aeabi_dadd+0x3fc>)
 80012fa:	42bb      	cmp	r3, r7
 80012fc:	d07a      	beq.n	80013f4 <__aeabi_dadd+0x48c>
 80012fe:	0033      	movs	r3, r6
 8001300:	e6ff      	b.n	8001102 <__aeabi_dadd+0x19a>
 8001302:	0030      	movs	r0, r6
 8001304:	3d1f      	subs	r5, #31
 8001306:	40e8      	lsrs	r0, r5
 8001308:	2b20      	cmp	r3, #32
 800130a:	d003      	beq.n	8001314 <__aeabi_dadd+0x3ac>
 800130c:	2140      	movs	r1, #64	; 0x40
 800130e:	1acb      	subs	r3, r1, r3
 8001310:	409e      	lsls	r6, r3
 8001312:	4337      	orrs	r7, r6
 8001314:	1e7b      	subs	r3, r7, #1
 8001316:	419f      	sbcs	r7, r3
 8001318:	2207      	movs	r2, #7
 800131a:	4307      	orrs	r7, r0
 800131c:	403a      	ands	r2, r7
 800131e:	2100      	movs	r1, #0
 8001320:	2500      	movs	r5, #0
 8001322:	e789      	b.n	8001238 <__aeabi_dadd+0x2d0>
 8001324:	1a17      	subs	r7, r2, r0
 8001326:	4643      	mov	r3, r8
 8001328:	42ba      	cmp	r2, r7
 800132a:	41b6      	sbcs	r6, r6
 800132c:	1a59      	subs	r1, r3, r1
 800132e:	4276      	negs	r6, r6
 8001330:	1b8e      	subs	r6, r1, r6
 8001332:	4664      	mov	r4, ip
 8001334:	e64e      	b.n	8000fd4 <__aeabi_dadd+0x6c>
 8001336:	2b1f      	cmp	r3, #31
 8001338:	dd00      	ble.n	800133c <__aeabi_dadd+0x3d4>
 800133a:	e0ad      	b.n	8001498 <__aeabi_dadd+0x530>
 800133c:	2620      	movs	r6, #32
 800133e:	4647      	mov	r7, r8
 8001340:	1af6      	subs	r6, r6, r3
 8001342:	40b7      	lsls	r7, r6
 8001344:	46b9      	mov	r9, r7
 8001346:	0017      	movs	r7, r2
 8001348:	46b2      	mov	sl, r6
 800134a:	40df      	lsrs	r7, r3
 800134c:	464e      	mov	r6, r9
 800134e:	433e      	orrs	r6, r7
 8001350:	0037      	movs	r7, r6
 8001352:	4656      	mov	r6, sl
 8001354:	40b2      	lsls	r2, r6
 8001356:	1e56      	subs	r6, r2, #1
 8001358:	41b2      	sbcs	r2, r6
 800135a:	4317      	orrs	r7, r2
 800135c:	4642      	mov	r2, r8
 800135e:	40da      	lsrs	r2, r3
 8001360:	1889      	adds	r1, r1, r2
 8001362:	e6ae      	b.n	80010c2 <__aeabi_dadd+0x15a>
 8001364:	000007ff 	.word	0x000007ff
 8001368:	ff7fffff 	.word	0xff7fffff
 800136c:	800fffff 	.word	0x800fffff
 8001370:	2620      	movs	r6, #32
 8001372:	4647      	mov	r7, r8
 8001374:	1af6      	subs	r6, r6, r3
 8001376:	40b7      	lsls	r7, r6
 8001378:	46b9      	mov	r9, r7
 800137a:	0017      	movs	r7, r2
 800137c:	46b2      	mov	sl, r6
 800137e:	40df      	lsrs	r7, r3
 8001380:	464e      	mov	r6, r9
 8001382:	433e      	orrs	r6, r7
 8001384:	0037      	movs	r7, r6
 8001386:	4656      	mov	r6, sl
 8001388:	40b2      	lsls	r2, r6
 800138a:	1e56      	subs	r6, r2, #1
 800138c:	41b2      	sbcs	r2, r6
 800138e:	4317      	orrs	r7, r2
 8001390:	4642      	mov	r2, r8
 8001392:	40da      	lsrs	r2, r3
 8001394:	1a89      	subs	r1, r1, r2
 8001396:	e799      	b.n	80012cc <__aeabi_dadd+0x364>
 8001398:	4c7f      	ldr	r4, [pc, #508]	; (8001598 <__aeabi_dadd+0x630>)
 800139a:	42a6      	cmp	r6, r4
 800139c:	d05b      	beq.n	8001456 <__aeabi_dadd+0x4ee>
 800139e:	2480      	movs	r4, #128	; 0x80
 80013a0:	0424      	lsls	r4, r4, #16
 80013a2:	425b      	negs	r3, r3
 80013a4:	4321      	orrs	r1, r4
 80013a6:	e727      	b.n	80011f8 <__aeabi_dadd+0x290>
 80013a8:	2e00      	cmp	r6, #0
 80013aa:	d10c      	bne.n	80013c6 <__aeabi_dadd+0x45e>
 80013ac:	2b00      	cmp	r3, #0
 80013ae:	d100      	bne.n	80013b2 <__aeabi_dadd+0x44a>
 80013b0:	e0cb      	b.n	800154a <__aeabi_dadd+0x5e2>
 80013b2:	4664      	mov	r4, ip
 80013b4:	0039      	movs	r1, r7
 80013b6:	0010      	movs	r0, r2
 80013b8:	4d77      	ldr	r5, [pc, #476]	; (8001598 <__aeabi_dadd+0x630>)
 80013ba:	e6d7      	b.n	800116c <__aeabi_dadd+0x204>
 80013bc:	4f76      	ldr	r7, [pc, #472]	; (8001598 <__aeabi_dadd+0x630>)
 80013be:	42bb      	cmp	r3, r7
 80013c0:	d018      	beq.n	80013f4 <__aeabi_dadd+0x48c>
 80013c2:	0033      	movs	r3, r6
 80013c4:	e675      	b.n	80010b2 <__aeabi_dadd+0x14a>
 80013c6:	2b00      	cmp	r3, #0
 80013c8:	d014      	beq.n	80013f4 <__aeabi_dadd+0x48c>
 80013ca:	074b      	lsls	r3, r1, #29
 80013cc:	08c0      	lsrs	r0, r0, #3
 80013ce:	4318      	orrs	r0, r3
 80013d0:	2380      	movs	r3, #128	; 0x80
 80013d2:	08c9      	lsrs	r1, r1, #3
 80013d4:	031b      	lsls	r3, r3, #12
 80013d6:	4219      	tst	r1, r3
 80013d8:	d007      	beq.n	80013ea <__aeabi_dadd+0x482>
 80013da:	08fc      	lsrs	r4, r7, #3
 80013dc:	421c      	tst	r4, r3
 80013de:	d104      	bne.n	80013ea <__aeabi_dadd+0x482>
 80013e0:	0779      	lsls	r1, r7, #29
 80013e2:	08d0      	lsrs	r0, r2, #3
 80013e4:	4308      	orrs	r0, r1
 80013e6:	46e1      	mov	r9, ip
 80013e8:	0021      	movs	r1, r4
 80013ea:	464c      	mov	r4, r9
 80013ec:	0f42      	lsrs	r2, r0, #29
 80013ee:	00c9      	lsls	r1, r1, #3
 80013f0:	4311      	orrs	r1, r2
 80013f2:	00c0      	lsls	r0, r0, #3
 80013f4:	4d68      	ldr	r5, [pc, #416]	; (8001598 <__aeabi_dadd+0x630>)
 80013f6:	e6b9      	b.n	800116c <__aeabi_dadd+0x204>
 80013f8:	001d      	movs	r5, r3
 80013fa:	2200      	movs	r2, #0
 80013fc:	2300      	movs	r3, #0
 80013fe:	e6c0      	b.n	8001182 <__aeabi_dadd+0x21a>
 8001400:	2d00      	cmp	r5, #0
 8001402:	d15b      	bne.n	80014bc <__aeabi_dadd+0x554>
 8001404:	000d      	movs	r5, r1
 8001406:	4305      	orrs	r5, r0
 8001408:	d100      	bne.n	800140c <__aeabi_dadd+0x4a4>
 800140a:	e6e2      	b.n	80011d2 <__aeabi_dadd+0x26a>
 800140c:	1c5d      	adds	r5, r3, #1
 800140e:	d100      	bne.n	8001412 <__aeabi_dadd+0x4aa>
 8001410:	e0b0      	b.n	8001574 <__aeabi_dadd+0x60c>
 8001412:	4d61      	ldr	r5, [pc, #388]	; (8001598 <__aeabi_dadd+0x630>)
 8001414:	42ae      	cmp	r6, r5
 8001416:	d01f      	beq.n	8001458 <__aeabi_dadd+0x4f0>
 8001418:	43db      	mvns	r3, r3
 800141a:	2b38      	cmp	r3, #56	; 0x38
 800141c:	dc71      	bgt.n	8001502 <__aeabi_dadd+0x59a>
 800141e:	2b1f      	cmp	r3, #31
 8001420:	dd00      	ble.n	8001424 <__aeabi_dadd+0x4bc>
 8001422:	e096      	b.n	8001552 <__aeabi_dadd+0x5ea>
 8001424:	2520      	movs	r5, #32
 8001426:	000f      	movs	r7, r1
 8001428:	1aed      	subs	r5, r5, r3
 800142a:	40af      	lsls	r7, r5
 800142c:	46b9      	mov	r9, r7
 800142e:	0007      	movs	r7, r0
 8001430:	46aa      	mov	sl, r5
 8001432:	40df      	lsrs	r7, r3
 8001434:	464d      	mov	r5, r9
 8001436:	433d      	orrs	r5, r7
 8001438:	002f      	movs	r7, r5
 800143a:	4655      	mov	r5, sl
 800143c:	40a8      	lsls	r0, r5
 800143e:	40d9      	lsrs	r1, r3
 8001440:	1e45      	subs	r5, r0, #1
 8001442:	41a8      	sbcs	r0, r5
 8001444:	4488      	add	r8, r1
 8001446:	4307      	orrs	r7, r0
 8001448:	18bf      	adds	r7, r7, r2
 800144a:	4297      	cmp	r7, r2
 800144c:	4192      	sbcs	r2, r2
 800144e:	4251      	negs	r1, r2
 8001450:	4441      	add	r1, r8
 8001452:	0035      	movs	r5, r6
 8001454:	e63a      	b.n	80010cc <__aeabi_dadd+0x164>
 8001456:	4664      	mov	r4, ip
 8001458:	0035      	movs	r5, r6
 800145a:	4641      	mov	r1, r8
 800145c:	0010      	movs	r0, r2
 800145e:	e685      	b.n	800116c <__aeabi_dadd+0x204>
 8001460:	000b      	movs	r3, r1
 8001462:	4303      	orrs	r3, r0
 8001464:	2d00      	cmp	r5, #0
 8001466:	d000      	beq.n	800146a <__aeabi_dadd+0x502>
 8001468:	e663      	b.n	8001132 <__aeabi_dadd+0x1ca>
 800146a:	2b00      	cmp	r3, #0
 800146c:	d0f5      	beq.n	800145a <__aeabi_dadd+0x4f2>
 800146e:	4643      	mov	r3, r8
 8001470:	4313      	orrs	r3, r2
 8001472:	d100      	bne.n	8001476 <__aeabi_dadd+0x50e>
 8001474:	e67a      	b.n	800116c <__aeabi_dadd+0x204>
 8001476:	1887      	adds	r7, r0, r2
 8001478:	4287      	cmp	r7, r0
 800147a:	4180      	sbcs	r0, r0
 800147c:	2207      	movs	r2, #7
 800147e:	4441      	add	r1, r8
 8001480:	4240      	negs	r0, r0
 8001482:	1809      	adds	r1, r1, r0
 8001484:	403a      	ands	r2, r7
 8001486:	020b      	lsls	r3, r1, #8
 8001488:	d400      	bmi.n	800148c <__aeabi_dadd+0x524>
 800148a:	e6d5      	b.n	8001238 <__aeabi_dadd+0x2d0>
 800148c:	4b43      	ldr	r3, [pc, #268]	; (800159c <__aeabi_dadd+0x634>)
 800148e:	3501      	adds	r5, #1
 8001490:	4019      	ands	r1, r3
 8001492:	e5c9      	b.n	8001028 <__aeabi_dadd+0xc0>
 8001494:	0038      	movs	r0, r7
 8001496:	e669      	b.n	800116c <__aeabi_dadd+0x204>
 8001498:	001e      	movs	r6, r3
 800149a:	4647      	mov	r7, r8
 800149c:	3e20      	subs	r6, #32
 800149e:	40f7      	lsrs	r7, r6
 80014a0:	46bc      	mov	ip, r7
 80014a2:	2b20      	cmp	r3, #32
 80014a4:	d004      	beq.n	80014b0 <__aeabi_dadd+0x548>
 80014a6:	2640      	movs	r6, #64	; 0x40
 80014a8:	1af3      	subs	r3, r6, r3
 80014aa:	4646      	mov	r6, r8
 80014ac:	409e      	lsls	r6, r3
 80014ae:	4332      	orrs	r2, r6
 80014b0:	0017      	movs	r7, r2
 80014b2:	4663      	mov	r3, ip
 80014b4:	1e7a      	subs	r2, r7, #1
 80014b6:	4197      	sbcs	r7, r2
 80014b8:	431f      	orrs	r7, r3
 80014ba:	e602      	b.n	80010c2 <__aeabi_dadd+0x15a>
 80014bc:	4d36      	ldr	r5, [pc, #216]	; (8001598 <__aeabi_dadd+0x630>)
 80014be:	42ae      	cmp	r6, r5
 80014c0:	d0ca      	beq.n	8001458 <__aeabi_dadd+0x4f0>
 80014c2:	2580      	movs	r5, #128	; 0x80
 80014c4:	042d      	lsls	r5, r5, #16
 80014c6:	425b      	negs	r3, r3
 80014c8:	4329      	orrs	r1, r5
 80014ca:	e7a6      	b.n	800141a <__aeabi_dadd+0x4b2>
 80014cc:	4308      	orrs	r0, r1
 80014ce:	1e41      	subs	r1, r0, #1
 80014d0:	4188      	sbcs	r0, r1
 80014d2:	e6a6      	b.n	8001222 <__aeabi_dadd+0x2ba>
 80014d4:	2b00      	cmp	r3, #0
 80014d6:	d100      	bne.n	80014da <__aeabi_dadd+0x572>
 80014d8:	e648      	b.n	800116c <__aeabi_dadd+0x204>
 80014da:	1a87      	subs	r7, r0, r2
 80014dc:	4643      	mov	r3, r8
 80014de:	42b8      	cmp	r0, r7
 80014e0:	41b6      	sbcs	r6, r6
 80014e2:	1acb      	subs	r3, r1, r3
 80014e4:	4276      	negs	r6, r6
 80014e6:	1b9e      	subs	r6, r3, r6
 80014e8:	0233      	lsls	r3, r6, #8
 80014ea:	d54b      	bpl.n	8001584 <__aeabi_dadd+0x61c>
 80014ec:	1a17      	subs	r7, r2, r0
 80014ee:	4643      	mov	r3, r8
 80014f0:	42ba      	cmp	r2, r7
 80014f2:	4192      	sbcs	r2, r2
 80014f4:	1a59      	subs	r1, r3, r1
 80014f6:	4252      	negs	r2, r2
 80014f8:	1a89      	subs	r1, r1, r2
 80014fa:	2207      	movs	r2, #7
 80014fc:	4664      	mov	r4, ip
 80014fe:	403a      	ands	r2, r7
 8001500:	e592      	b.n	8001028 <__aeabi_dadd+0xc0>
 8001502:	4301      	orrs	r1, r0
 8001504:	000f      	movs	r7, r1
 8001506:	1e79      	subs	r1, r7, #1
 8001508:	418f      	sbcs	r7, r1
 800150a:	e79d      	b.n	8001448 <__aeabi_dadd+0x4e0>
 800150c:	001c      	movs	r4, r3
 800150e:	000f      	movs	r7, r1
 8001510:	3c20      	subs	r4, #32
 8001512:	40e7      	lsrs	r7, r4
 8001514:	2b20      	cmp	r3, #32
 8001516:	d003      	beq.n	8001520 <__aeabi_dadd+0x5b8>
 8001518:	2440      	movs	r4, #64	; 0x40
 800151a:	1ae3      	subs	r3, r4, r3
 800151c:	4099      	lsls	r1, r3
 800151e:	4308      	orrs	r0, r1
 8001520:	1e41      	subs	r1, r0, #1
 8001522:	4188      	sbcs	r0, r1
 8001524:	4338      	orrs	r0, r7
 8001526:	e67c      	b.n	8001222 <__aeabi_dadd+0x2ba>
 8001528:	2200      	movs	r2, #0
 800152a:	2400      	movs	r4, #0
 800152c:	e625      	b.n	800117a <__aeabi_dadd+0x212>
 800152e:	1a17      	subs	r7, r2, r0
 8001530:	4643      	mov	r3, r8
 8001532:	42ba      	cmp	r2, r7
 8001534:	4192      	sbcs	r2, r2
 8001536:	1a59      	subs	r1, r3, r1
 8001538:	4252      	negs	r2, r2
 800153a:	1a89      	subs	r1, r1, r2
 800153c:	4664      	mov	r4, ip
 800153e:	0035      	movs	r5, r6
 8001540:	e543      	b.n	8000fca <__aeabi_dadd+0x62>
 8001542:	4641      	mov	r1, r8
 8001544:	0010      	movs	r0, r2
 8001546:	4d14      	ldr	r5, [pc, #80]	; (8001598 <__aeabi_dadd+0x630>)
 8001548:	e610      	b.n	800116c <__aeabi_dadd+0x204>
 800154a:	2280      	movs	r2, #128	; 0x80
 800154c:	2400      	movs	r4, #0
 800154e:	0312      	lsls	r2, r2, #12
 8001550:	e680      	b.n	8001254 <__aeabi_dadd+0x2ec>
 8001552:	001d      	movs	r5, r3
 8001554:	000f      	movs	r7, r1
 8001556:	3d20      	subs	r5, #32
 8001558:	40ef      	lsrs	r7, r5
 800155a:	46bc      	mov	ip, r7
 800155c:	2b20      	cmp	r3, #32
 800155e:	d003      	beq.n	8001568 <__aeabi_dadd+0x600>
 8001560:	2540      	movs	r5, #64	; 0x40
 8001562:	1aeb      	subs	r3, r5, r3
 8001564:	4099      	lsls	r1, r3
 8001566:	4308      	orrs	r0, r1
 8001568:	0007      	movs	r7, r0
 800156a:	4663      	mov	r3, ip
 800156c:	1e78      	subs	r0, r7, #1
 800156e:	4187      	sbcs	r7, r0
 8001570:	431f      	orrs	r7, r3
 8001572:	e769      	b.n	8001448 <__aeabi_dadd+0x4e0>
 8001574:	1887      	adds	r7, r0, r2
 8001576:	4297      	cmp	r7, r2
 8001578:	419b      	sbcs	r3, r3
 800157a:	4441      	add	r1, r8
 800157c:	425b      	negs	r3, r3
 800157e:	18c9      	adds	r1, r1, r3
 8001580:	0035      	movs	r5, r6
 8001582:	e5a3      	b.n	80010cc <__aeabi_dadd+0x164>
 8001584:	003b      	movs	r3, r7
 8001586:	4333      	orrs	r3, r6
 8001588:	d0ce      	beq.n	8001528 <__aeabi_dadd+0x5c0>
 800158a:	2207      	movs	r2, #7
 800158c:	0031      	movs	r1, r6
 800158e:	403a      	ands	r2, r7
 8001590:	e652      	b.n	8001238 <__aeabi_dadd+0x2d0>
 8001592:	2300      	movs	r3, #0
 8001594:	001a      	movs	r2, r3
 8001596:	e5f4      	b.n	8001182 <__aeabi_dadd+0x21a>
 8001598:	000007ff 	.word	0x000007ff
 800159c:	ff7fffff 	.word	0xff7fffff

080015a0 <__aeabi_ddiv>:
 80015a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80015a2:	4657      	mov	r7, sl
 80015a4:	46de      	mov	lr, fp
 80015a6:	464e      	mov	r6, r9
 80015a8:	4645      	mov	r5, r8
 80015aa:	b5e0      	push	{r5, r6, r7, lr}
 80015ac:	4683      	mov	fp, r0
 80015ae:	0007      	movs	r7, r0
 80015b0:	030e      	lsls	r6, r1, #12
 80015b2:	0048      	lsls	r0, r1, #1
 80015b4:	b085      	sub	sp, #20
 80015b6:	4692      	mov	sl, r2
 80015b8:	001c      	movs	r4, r3
 80015ba:	0b36      	lsrs	r6, r6, #12
 80015bc:	0d40      	lsrs	r0, r0, #21
 80015be:	0fcd      	lsrs	r5, r1, #31
 80015c0:	2800      	cmp	r0, #0
 80015c2:	d100      	bne.n	80015c6 <__aeabi_ddiv+0x26>
 80015c4:	e09d      	b.n	8001702 <__aeabi_ddiv+0x162>
 80015c6:	4b95      	ldr	r3, [pc, #596]	; (800181c <__aeabi_ddiv+0x27c>)
 80015c8:	4298      	cmp	r0, r3
 80015ca:	d039      	beq.n	8001640 <__aeabi_ddiv+0xa0>
 80015cc:	2380      	movs	r3, #128	; 0x80
 80015ce:	00f6      	lsls	r6, r6, #3
 80015d0:	041b      	lsls	r3, r3, #16
 80015d2:	431e      	orrs	r6, r3
 80015d4:	4a92      	ldr	r2, [pc, #584]	; (8001820 <__aeabi_ddiv+0x280>)
 80015d6:	0f7b      	lsrs	r3, r7, #29
 80015d8:	4333      	orrs	r3, r6
 80015da:	4699      	mov	r9, r3
 80015dc:	4694      	mov	ip, r2
 80015de:	0003      	movs	r3, r0
 80015e0:	4463      	add	r3, ip
 80015e2:	9300      	str	r3, [sp, #0]
 80015e4:	2300      	movs	r3, #0
 80015e6:	2600      	movs	r6, #0
 80015e8:	00ff      	lsls	r7, r7, #3
 80015ea:	9302      	str	r3, [sp, #8]
 80015ec:	0323      	lsls	r3, r4, #12
 80015ee:	0b1b      	lsrs	r3, r3, #12
 80015f0:	4698      	mov	r8, r3
 80015f2:	0063      	lsls	r3, r4, #1
 80015f4:	0fe4      	lsrs	r4, r4, #31
 80015f6:	4652      	mov	r2, sl
 80015f8:	0d5b      	lsrs	r3, r3, #21
 80015fa:	9401      	str	r4, [sp, #4]
 80015fc:	d100      	bne.n	8001600 <__aeabi_ddiv+0x60>
 80015fe:	e0b3      	b.n	8001768 <__aeabi_ddiv+0x1c8>
 8001600:	4986      	ldr	r1, [pc, #536]	; (800181c <__aeabi_ddiv+0x27c>)
 8001602:	428b      	cmp	r3, r1
 8001604:	d100      	bne.n	8001608 <__aeabi_ddiv+0x68>
 8001606:	e09e      	b.n	8001746 <__aeabi_ddiv+0x1a6>
 8001608:	4642      	mov	r2, r8
 800160a:	00d1      	lsls	r1, r2, #3
 800160c:	2280      	movs	r2, #128	; 0x80
 800160e:	0412      	lsls	r2, r2, #16
 8001610:	430a      	orrs	r2, r1
 8001612:	4651      	mov	r1, sl
 8001614:	0f49      	lsrs	r1, r1, #29
 8001616:	4311      	orrs	r1, r2
 8001618:	468b      	mov	fp, r1
 800161a:	4981      	ldr	r1, [pc, #516]	; (8001820 <__aeabi_ddiv+0x280>)
 800161c:	4652      	mov	r2, sl
 800161e:	468c      	mov	ip, r1
 8001620:	9900      	ldr	r1, [sp, #0]
 8001622:	4463      	add	r3, ip
 8001624:	1acb      	subs	r3, r1, r3
 8001626:	2100      	movs	r1, #0
 8001628:	00d2      	lsls	r2, r2, #3
 800162a:	9300      	str	r3, [sp, #0]
 800162c:	002b      	movs	r3, r5
 800162e:	4063      	eors	r3, r4
 8001630:	469a      	mov	sl, r3
 8001632:	2e0f      	cmp	r6, #15
 8001634:	d900      	bls.n	8001638 <__aeabi_ddiv+0x98>
 8001636:	e105      	b.n	8001844 <__aeabi_ddiv+0x2a4>
 8001638:	4b7a      	ldr	r3, [pc, #488]	; (8001824 <__aeabi_ddiv+0x284>)
 800163a:	00b6      	lsls	r6, r6, #2
 800163c:	599b      	ldr	r3, [r3, r6]
 800163e:	469f      	mov	pc, r3
 8001640:	465b      	mov	r3, fp
 8001642:	4333      	orrs	r3, r6
 8001644:	4699      	mov	r9, r3
 8001646:	d000      	beq.n	800164a <__aeabi_ddiv+0xaa>
 8001648:	e0b8      	b.n	80017bc <__aeabi_ddiv+0x21c>
 800164a:	2302      	movs	r3, #2
 800164c:	2608      	movs	r6, #8
 800164e:	2700      	movs	r7, #0
 8001650:	9000      	str	r0, [sp, #0]
 8001652:	9302      	str	r3, [sp, #8]
 8001654:	e7ca      	b.n	80015ec <__aeabi_ddiv+0x4c>
 8001656:	46cb      	mov	fp, r9
 8001658:	003a      	movs	r2, r7
 800165a:	9902      	ldr	r1, [sp, #8]
 800165c:	9501      	str	r5, [sp, #4]
 800165e:	9b01      	ldr	r3, [sp, #4]
 8001660:	469a      	mov	sl, r3
 8001662:	2902      	cmp	r1, #2
 8001664:	d027      	beq.n	80016b6 <__aeabi_ddiv+0x116>
 8001666:	2903      	cmp	r1, #3
 8001668:	d100      	bne.n	800166c <__aeabi_ddiv+0xcc>
 800166a:	e280      	b.n	8001b6e <__aeabi_ddiv+0x5ce>
 800166c:	2901      	cmp	r1, #1
 800166e:	d044      	beq.n	80016fa <__aeabi_ddiv+0x15a>
 8001670:	496d      	ldr	r1, [pc, #436]	; (8001828 <__aeabi_ddiv+0x288>)
 8001672:	9b00      	ldr	r3, [sp, #0]
 8001674:	468c      	mov	ip, r1
 8001676:	4463      	add	r3, ip
 8001678:	001c      	movs	r4, r3
 800167a:	2c00      	cmp	r4, #0
 800167c:	dd38      	ble.n	80016f0 <__aeabi_ddiv+0x150>
 800167e:	0753      	lsls	r3, r2, #29
 8001680:	d000      	beq.n	8001684 <__aeabi_ddiv+0xe4>
 8001682:	e213      	b.n	8001aac <__aeabi_ddiv+0x50c>
 8001684:	08d2      	lsrs	r2, r2, #3
 8001686:	465b      	mov	r3, fp
 8001688:	01db      	lsls	r3, r3, #7
 800168a:	d509      	bpl.n	80016a0 <__aeabi_ddiv+0x100>
 800168c:	4659      	mov	r1, fp
 800168e:	4b67      	ldr	r3, [pc, #412]	; (800182c <__aeabi_ddiv+0x28c>)
 8001690:	4019      	ands	r1, r3
 8001692:	468b      	mov	fp, r1
 8001694:	2180      	movs	r1, #128	; 0x80
 8001696:	00c9      	lsls	r1, r1, #3
 8001698:	468c      	mov	ip, r1
 800169a:	9b00      	ldr	r3, [sp, #0]
 800169c:	4463      	add	r3, ip
 800169e:	001c      	movs	r4, r3
 80016a0:	4b63      	ldr	r3, [pc, #396]	; (8001830 <__aeabi_ddiv+0x290>)
 80016a2:	429c      	cmp	r4, r3
 80016a4:	dc07      	bgt.n	80016b6 <__aeabi_ddiv+0x116>
 80016a6:	465b      	mov	r3, fp
 80016a8:	0564      	lsls	r4, r4, #21
 80016aa:	075f      	lsls	r7, r3, #29
 80016ac:	025b      	lsls	r3, r3, #9
 80016ae:	4317      	orrs	r7, r2
 80016b0:	0b1b      	lsrs	r3, r3, #12
 80016b2:	0d62      	lsrs	r2, r4, #21
 80016b4:	e002      	b.n	80016bc <__aeabi_ddiv+0x11c>
 80016b6:	2300      	movs	r3, #0
 80016b8:	2700      	movs	r7, #0
 80016ba:	4a58      	ldr	r2, [pc, #352]	; (800181c <__aeabi_ddiv+0x27c>)
 80016bc:	2100      	movs	r1, #0
 80016be:	031b      	lsls	r3, r3, #12
 80016c0:	0b1c      	lsrs	r4, r3, #12
 80016c2:	0d0b      	lsrs	r3, r1, #20
 80016c4:	051b      	lsls	r3, r3, #20
 80016c6:	4323      	orrs	r3, r4
 80016c8:	0514      	lsls	r4, r2, #20
 80016ca:	4a5a      	ldr	r2, [pc, #360]	; (8001834 <__aeabi_ddiv+0x294>)
 80016cc:	0038      	movs	r0, r7
 80016ce:	4013      	ands	r3, r2
 80016d0:	431c      	orrs	r4, r3
 80016d2:	4653      	mov	r3, sl
 80016d4:	0064      	lsls	r4, r4, #1
 80016d6:	07db      	lsls	r3, r3, #31
 80016d8:	0864      	lsrs	r4, r4, #1
 80016da:	431c      	orrs	r4, r3
 80016dc:	0021      	movs	r1, r4
 80016de:	b005      	add	sp, #20
 80016e0:	bc3c      	pop	{r2, r3, r4, r5}
 80016e2:	4690      	mov	r8, r2
 80016e4:	4699      	mov	r9, r3
 80016e6:	46a2      	mov	sl, r4
 80016e8:	46ab      	mov	fp, r5
 80016ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80016ec:	2201      	movs	r2, #1
 80016ee:	4252      	negs	r2, r2
 80016f0:	2301      	movs	r3, #1
 80016f2:	1b1b      	subs	r3, r3, r4
 80016f4:	2b38      	cmp	r3, #56	; 0x38
 80016f6:	dc00      	bgt.n	80016fa <__aeabi_ddiv+0x15a>
 80016f8:	e1ad      	b.n	8001a56 <__aeabi_ddiv+0x4b6>
 80016fa:	2200      	movs	r2, #0
 80016fc:	2300      	movs	r3, #0
 80016fe:	2700      	movs	r7, #0
 8001700:	e7dc      	b.n	80016bc <__aeabi_ddiv+0x11c>
 8001702:	465b      	mov	r3, fp
 8001704:	4333      	orrs	r3, r6
 8001706:	4699      	mov	r9, r3
 8001708:	d05e      	beq.n	80017c8 <__aeabi_ddiv+0x228>
 800170a:	2e00      	cmp	r6, #0
 800170c:	d100      	bne.n	8001710 <__aeabi_ddiv+0x170>
 800170e:	e18a      	b.n	8001a26 <__aeabi_ddiv+0x486>
 8001710:	0030      	movs	r0, r6
 8001712:	f001 fa9d 	bl	8002c50 <__clzsi2>
 8001716:	0003      	movs	r3, r0
 8001718:	3b0b      	subs	r3, #11
 800171a:	2b1c      	cmp	r3, #28
 800171c:	dd00      	ble.n	8001720 <__aeabi_ddiv+0x180>
 800171e:	e17b      	b.n	8001a18 <__aeabi_ddiv+0x478>
 8001720:	221d      	movs	r2, #29
 8001722:	1ad3      	subs	r3, r2, r3
 8001724:	465a      	mov	r2, fp
 8001726:	0001      	movs	r1, r0
 8001728:	40da      	lsrs	r2, r3
 800172a:	3908      	subs	r1, #8
 800172c:	408e      	lsls	r6, r1
 800172e:	0013      	movs	r3, r2
 8001730:	465f      	mov	r7, fp
 8001732:	4333      	orrs	r3, r6
 8001734:	4699      	mov	r9, r3
 8001736:	408f      	lsls	r7, r1
 8001738:	4b3f      	ldr	r3, [pc, #252]	; (8001838 <__aeabi_ddiv+0x298>)
 800173a:	2600      	movs	r6, #0
 800173c:	1a1b      	subs	r3, r3, r0
 800173e:	9300      	str	r3, [sp, #0]
 8001740:	2300      	movs	r3, #0
 8001742:	9302      	str	r3, [sp, #8]
 8001744:	e752      	b.n	80015ec <__aeabi_ddiv+0x4c>
 8001746:	4641      	mov	r1, r8
 8001748:	4653      	mov	r3, sl
 800174a:	430b      	orrs	r3, r1
 800174c:	493b      	ldr	r1, [pc, #236]	; (800183c <__aeabi_ddiv+0x29c>)
 800174e:	469b      	mov	fp, r3
 8001750:	468c      	mov	ip, r1
 8001752:	9b00      	ldr	r3, [sp, #0]
 8001754:	4463      	add	r3, ip
 8001756:	9300      	str	r3, [sp, #0]
 8001758:	465b      	mov	r3, fp
 800175a:	2b00      	cmp	r3, #0
 800175c:	d13b      	bne.n	80017d6 <__aeabi_ddiv+0x236>
 800175e:	2302      	movs	r3, #2
 8001760:	2200      	movs	r2, #0
 8001762:	431e      	orrs	r6, r3
 8001764:	2102      	movs	r1, #2
 8001766:	e761      	b.n	800162c <__aeabi_ddiv+0x8c>
 8001768:	4643      	mov	r3, r8
 800176a:	4313      	orrs	r3, r2
 800176c:	469b      	mov	fp, r3
 800176e:	d037      	beq.n	80017e0 <__aeabi_ddiv+0x240>
 8001770:	4643      	mov	r3, r8
 8001772:	2b00      	cmp	r3, #0
 8001774:	d100      	bne.n	8001778 <__aeabi_ddiv+0x1d8>
 8001776:	e162      	b.n	8001a3e <__aeabi_ddiv+0x49e>
 8001778:	4640      	mov	r0, r8
 800177a:	f001 fa69 	bl	8002c50 <__clzsi2>
 800177e:	0003      	movs	r3, r0
 8001780:	3b0b      	subs	r3, #11
 8001782:	2b1c      	cmp	r3, #28
 8001784:	dd00      	ble.n	8001788 <__aeabi_ddiv+0x1e8>
 8001786:	e153      	b.n	8001a30 <__aeabi_ddiv+0x490>
 8001788:	0002      	movs	r2, r0
 800178a:	4641      	mov	r1, r8
 800178c:	3a08      	subs	r2, #8
 800178e:	4091      	lsls	r1, r2
 8001790:	4688      	mov	r8, r1
 8001792:	211d      	movs	r1, #29
 8001794:	1acb      	subs	r3, r1, r3
 8001796:	4651      	mov	r1, sl
 8001798:	40d9      	lsrs	r1, r3
 800179a:	000b      	movs	r3, r1
 800179c:	4641      	mov	r1, r8
 800179e:	430b      	orrs	r3, r1
 80017a0:	469b      	mov	fp, r3
 80017a2:	4653      	mov	r3, sl
 80017a4:	4093      	lsls	r3, r2
 80017a6:	001a      	movs	r2, r3
 80017a8:	9b00      	ldr	r3, [sp, #0]
 80017aa:	4925      	ldr	r1, [pc, #148]	; (8001840 <__aeabi_ddiv+0x2a0>)
 80017ac:	469c      	mov	ip, r3
 80017ae:	4460      	add	r0, ip
 80017b0:	0003      	movs	r3, r0
 80017b2:	468c      	mov	ip, r1
 80017b4:	4463      	add	r3, ip
 80017b6:	9300      	str	r3, [sp, #0]
 80017b8:	2100      	movs	r1, #0
 80017ba:	e737      	b.n	800162c <__aeabi_ddiv+0x8c>
 80017bc:	2303      	movs	r3, #3
 80017be:	46b1      	mov	r9, r6
 80017c0:	9000      	str	r0, [sp, #0]
 80017c2:	260c      	movs	r6, #12
 80017c4:	9302      	str	r3, [sp, #8]
 80017c6:	e711      	b.n	80015ec <__aeabi_ddiv+0x4c>
 80017c8:	2300      	movs	r3, #0
 80017ca:	9300      	str	r3, [sp, #0]
 80017cc:	3301      	adds	r3, #1
 80017ce:	2604      	movs	r6, #4
 80017d0:	2700      	movs	r7, #0
 80017d2:	9302      	str	r3, [sp, #8]
 80017d4:	e70a      	b.n	80015ec <__aeabi_ddiv+0x4c>
 80017d6:	2303      	movs	r3, #3
 80017d8:	46c3      	mov	fp, r8
 80017da:	431e      	orrs	r6, r3
 80017dc:	2103      	movs	r1, #3
 80017de:	e725      	b.n	800162c <__aeabi_ddiv+0x8c>
 80017e0:	3301      	adds	r3, #1
 80017e2:	431e      	orrs	r6, r3
 80017e4:	2200      	movs	r2, #0
 80017e6:	2101      	movs	r1, #1
 80017e8:	e720      	b.n	800162c <__aeabi_ddiv+0x8c>
 80017ea:	2300      	movs	r3, #0
 80017ec:	469a      	mov	sl, r3
 80017ee:	2380      	movs	r3, #128	; 0x80
 80017f0:	2700      	movs	r7, #0
 80017f2:	031b      	lsls	r3, r3, #12
 80017f4:	4a09      	ldr	r2, [pc, #36]	; (800181c <__aeabi_ddiv+0x27c>)
 80017f6:	e761      	b.n	80016bc <__aeabi_ddiv+0x11c>
 80017f8:	2380      	movs	r3, #128	; 0x80
 80017fa:	4649      	mov	r1, r9
 80017fc:	031b      	lsls	r3, r3, #12
 80017fe:	4219      	tst	r1, r3
 8001800:	d100      	bne.n	8001804 <__aeabi_ddiv+0x264>
 8001802:	e0e2      	b.n	80019ca <__aeabi_ddiv+0x42a>
 8001804:	4659      	mov	r1, fp
 8001806:	4219      	tst	r1, r3
 8001808:	d000      	beq.n	800180c <__aeabi_ddiv+0x26c>
 800180a:	e0de      	b.n	80019ca <__aeabi_ddiv+0x42a>
 800180c:	430b      	orrs	r3, r1
 800180e:	031b      	lsls	r3, r3, #12
 8001810:	0017      	movs	r7, r2
 8001812:	0b1b      	lsrs	r3, r3, #12
 8001814:	46a2      	mov	sl, r4
 8001816:	4a01      	ldr	r2, [pc, #4]	; (800181c <__aeabi_ddiv+0x27c>)
 8001818:	e750      	b.n	80016bc <__aeabi_ddiv+0x11c>
 800181a:	46c0      	nop			; (mov r8, r8)
 800181c:	000007ff 	.word	0x000007ff
 8001820:	fffffc01 	.word	0xfffffc01
 8001824:	08019038 	.word	0x08019038
 8001828:	000003ff 	.word	0x000003ff
 800182c:	feffffff 	.word	0xfeffffff
 8001830:	000007fe 	.word	0x000007fe
 8001834:	800fffff 	.word	0x800fffff
 8001838:	fffffc0d 	.word	0xfffffc0d
 800183c:	fffff801 	.word	0xfffff801
 8001840:	000003f3 	.word	0x000003f3
 8001844:	45d9      	cmp	r9, fp
 8001846:	d900      	bls.n	800184a <__aeabi_ddiv+0x2aa>
 8001848:	e0cb      	b.n	80019e2 <__aeabi_ddiv+0x442>
 800184a:	d100      	bne.n	800184e <__aeabi_ddiv+0x2ae>
 800184c:	e0c6      	b.n	80019dc <__aeabi_ddiv+0x43c>
 800184e:	003c      	movs	r4, r7
 8001850:	4648      	mov	r0, r9
 8001852:	2700      	movs	r7, #0
 8001854:	9b00      	ldr	r3, [sp, #0]
 8001856:	3b01      	subs	r3, #1
 8001858:	9300      	str	r3, [sp, #0]
 800185a:	465b      	mov	r3, fp
 800185c:	0e16      	lsrs	r6, r2, #24
 800185e:	021b      	lsls	r3, r3, #8
 8001860:	431e      	orrs	r6, r3
 8001862:	0213      	lsls	r3, r2, #8
 8001864:	4698      	mov	r8, r3
 8001866:	0433      	lsls	r3, r6, #16
 8001868:	0c1b      	lsrs	r3, r3, #16
 800186a:	4699      	mov	r9, r3
 800186c:	0c31      	lsrs	r1, r6, #16
 800186e:	9101      	str	r1, [sp, #4]
 8001870:	f7fe fd08 	bl	8000284 <__aeabi_uidivmod>
 8001874:	464a      	mov	r2, r9
 8001876:	4342      	muls	r2, r0
 8001878:	040b      	lsls	r3, r1, #16
 800187a:	0c21      	lsrs	r1, r4, #16
 800187c:	0005      	movs	r5, r0
 800187e:	4319      	orrs	r1, r3
 8001880:	428a      	cmp	r2, r1
 8001882:	d907      	bls.n	8001894 <__aeabi_ddiv+0x2f4>
 8001884:	1989      	adds	r1, r1, r6
 8001886:	3d01      	subs	r5, #1
 8001888:	428e      	cmp	r6, r1
 800188a:	d803      	bhi.n	8001894 <__aeabi_ddiv+0x2f4>
 800188c:	428a      	cmp	r2, r1
 800188e:	d901      	bls.n	8001894 <__aeabi_ddiv+0x2f4>
 8001890:	1e85      	subs	r5, r0, #2
 8001892:	1989      	adds	r1, r1, r6
 8001894:	1a88      	subs	r0, r1, r2
 8001896:	9901      	ldr	r1, [sp, #4]
 8001898:	f7fe fcf4 	bl	8000284 <__aeabi_uidivmod>
 800189c:	0409      	lsls	r1, r1, #16
 800189e:	468c      	mov	ip, r1
 80018a0:	464a      	mov	r2, r9
 80018a2:	0421      	lsls	r1, r4, #16
 80018a4:	4664      	mov	r4, ip
 80018a6:	4342      	muls	r2, r0
 80018a8:	0c09      	lsrs	r1, r1, #16
 80018aa:	0003      	movs	r3, r0
 80018ac:	4321      	orrs	r1, r4
 80018ae:	428a      	cmp	r2, r1
 80018b0:	d904      	bls.n	80018bc <__aeabi_ddiv+0x31c>
 80018b2:	1989      	adds	r1, r1, r6
 80018b4:	3b01      	subs	r3, #1
 80018b6:	428e      	cmp	r6, r1
 80018b8:	d800      	bhi.n	80018bc <__aeabi_ddiv+0x31c>
 80018ba:	e0f1      	b.n	8001aa0 <__aeabi_ddiv+0x500>
 80018bc:	042d      	lsls	r5, r5, #16
 80018be:	431d      	orrs	r5, r3
 80018c0:	46ab      	mov	fp, r5
 80018c2:	4643      	mov	r3, r8
 80018c4:	1a89      	subs	r1, r1, r2
 80018c6:	4642      	mov	r2, r8
 80018c8:	0c28      	lsrs	r0, r5, #16
 80018ca:	0412      	lsls	r2, r2, #16
 80018cc:	0c1d      	lsrs	r5, r3, #16
 80018ce:	465b      	mov	r3, fp
 80018d0:	0c14      	lsrs	r4, r2, #16
 80018d2:	0022      	movs	r2, r4
 80018d4:	041b      	lsls	r3, r3, #16
 80018d6:	0c1b      	lsrs	r3, r3, #16
 80018d8:	435a      	muls	r2, r3
 80018da:	9403      	str	r4, [sp, #12]
 80018dc:	436b      	muls	r3, r5
 80018de:	4344      	muls	r4, r0
 80018e0:	9502      	str	r5, [sp, #8]
 80018e2:	4368      	muls	r0, r5
 80018e4:	191b      	adds	r3, r3, r4
 80018e6:	0c15      	lsrs	r5, r2, #16
 80018e8:	18eb      	adds	r3, r5, r3
 80018ea:	429c      	cmp	r4, r3
 80018ec:	d903      	bls.n	80018f6 <__aeabi_ddiv+0x356>
 80018ee:	2480      	movs	r4, #128	; 0x80
 80018f0:	0264      	lsls	r4, r4, #9
 80018f2:	46a4      	mov	ip, r4
 80018f4:	4460      	add	r0, ip
 80018f6:	0c1c      	lsrs	r4, r3, #16
 80018f8:	0415      	lsls	r5, r2, #16
 80018fa:	041b      	lsls	r3, r3, #16
 80018fc:	0c2d      	lsrs	r5, r5, #16
 80018fe:	1820      	adds	r0, r4, r0
 8001900:	195d      	adds	r5, r3, r5
 8001902:	4281      	cmp	r1, r0
 8001904:	d377      	bcc.n	80019f6 <__aeabi_ddiv+0x456>
 8001906:	d073      	beq.n	80019f0 <__aeabi_ddiv+0x450>
 8001908:	1a0c      	subs	r4, r1, r0
 800190a:	4aa2      	ldr	r2, [pc, #648]	; (8001b94 <__aeabi_ddiv+0x5f4>)
 800190c:	1b7d      	subs	r5, r7, r5
 800190e:	42af      	cmp	r7, r5
 8001910:	41bf      	sbcs	r7, r7
 8001912:	4694      	mov	ip, r2
 8001914:	9b00      	ldr	r3, [sp, #0]
 8001916:	427f      	negs	r7, r7
 8001918:	4463      	add	r3, ip
 800191a:	1be0      	subs	r0, r4, r7
 800191c:	001c      	movs	r4, r3
 800191e:	4286      	cmp	r6, r0
 8001920:	d100      	bne.n	8001924 <__aeabi_ddiv+0x384>
 8001922:	e0db      	b.n	8001adc <__aeabi_ddiv+0x53c>
 8001924:	9901      	ldr	r1, [sp, #4]
 8001926:	f7fe fcad 	bl	8000284 <__aeabi_uidivmod>
 800192a:	464a      	mov	r2, r9
 800192c:	4342      	muls	r2, r0
 800192e:	040b      	lsls	r3, r1, #16
 8001930:	0c29      	lsrs	r1, r5, #16
 8001932:	0007      	movs	r7, r0
 8001934:	4319      	orrs	r1, r3
 8001936:	428a      	cmp	r2, r1
 8001938:	d907      	bls.n	800194a <__aeabi_ddiv+0x3aa>
 800193a:	1989      	adds	r1, r1, r6
 800193c:	3f01      	subs	r7, #1
 800193e:	428e      	cmp	r6, r1
 8001940:	d803      	bhi.n	800194a <__aeabi_ddiv+0x3aa>
 8001942:	428a      	cmp	r2, r1
 8001944:	d901      	bls.n	800194a <__aeabi_ddiv+0x3aa>
 8001946:	1e87      	subs	r7, r0, #2
 8001948:	1989      	adds	r1, r1, r6
 800194a:	1a88      	subs	r0, r1, r2
 800194c:	9901      	ldr	r1, [sp, #4]
 800194e:	f7fe fc99 	bl	8000284 <__aeabi_uidivmod>
 8001952:	0409      	lsls	r1, r1, #16
 8001954:	464a      	mov	r2, r9
 8001956:	4689      	mov	r9, r1
 8001958:	0429      	lsls	r1, r5, #16
 800195a:	464d      	mov	r5, r9
 800195c:	4342      	muls	r2, r0
 800195e:	0c09      	lsrs	r1, r1, #16
 8001960:	0003      	movs	r3, r0
 8001962:	4329      	orrs	r1, r5
 8001964:	428a      	cmp	r2, r1
 8001966:	d907      	bls.n	8001978 <__aeabi_ddiv+0x3d8>
 8001968:	1989      	adds	r1, r1, r6
 800196a:	3b01      	subs	r3, #1
 800196c:	428e      	cmp	r6, r1
 800196e:	d803      	bhi.n	8001978 <__aeabi_ddiv+0x3d8>
 8001970:	428a      	cmp	r2, r1
 8001972:	d901      	bls.n	8001978 <__aeabi_ddiv+0x3d8>
 8001974:	1e83      	subs	r3, r0, #2
 8001976:	1989      	adds	r1, r1, r6
 8001978:	043f      	lsls	r7, r7, #16
 800197a:	1a89      	subs	r1, r1, r2
 800197c:	003a      	movs	r2, r7
 800197e:	9f03      	ldr	r7, [sp, #12]
 8001980:	431a      	orrs	r2, r3
 8001982:	0038      	movs	r0, r7
 8001984:	0413      	lsls	r3, r2, #16
 8001986:	0c1b      	lsrs	r3, r3, #16
 8001988:	4358      	muls	r0, r3
 800198a:	4681      	mov	r9, r0
 800198c:	9802      	ldr	r0, [sp, #8]
 800198e:	0c15      	lsrs	r5, r2, #16
 8001990:	436f      	muls	r7, r5
 8001992:	4343      	muls	r3, r0
 8001994:	4345      	muls	r5, r0
 8001996:	4648      	mov	r0, r9
 8001998:	0c00      	lsrs	r0, r0, #16
 800199a:	4684      	mov	ip, r0
 800199c:	19db      	adds	r3, r3, r7
 800199e:	4463      	add	r3, ip
 80019a0:	429f      	cmp	r7, r3
 80019a2:	d903      	bls.n	80019ac <__aeabi_ddiv+0x40c>
 80019a4:	2080      	movs	r0, #128	; 0x80
 80019a6:	0240      	lsls	r0, r0, #9
 80019a8:	4684      	mov	ip, r0
 80019aa:	4465      	add	r5, ip
 80019ac:	4648      	mov	r0, r9
 80019ae:	0c1f      	lsrs	r7, r3, #16
 80019b0:	0400      	lsls	r0, r0, #16
 80019b2:	041b      	lsls	r3, r3, #16
 80019b4:	0c00      	lsrs	r0, r0, #16
 80019b6:	197d      	adds	r5, r7, r5
 80019b8:	1818      	adds	r0, r3, r0
 80019ba:	42a9      	cmp	r1, r5
 80019bc:	d200      	bcs.n	80019c0 <__aeabi_ddiv+0x420>
 80019be:	e084      	b.n	8001aca <__aeabi_ddiv+0x52a>
 80019c0:	d100      	bne.n	80019c4 <__aeabi_ddiv+0x424>
 80019c2:	e07f      	b.n	8001ac4 <__aeabi_ddiv+0x524>
 80019c4:	2301      	movs	r3, #1
 80019c6:	431a      	orrs	r2, r3
 80019c8:	e657      	b.n	800167a <__aeabi_ddiv+0xda>
 80019ca:	2380      	movs	r3, #128	; 0x80
 80019cc:	464a      	mov	r2, r9
 80019ce:	031b      	lsls	r3, r3, #12
 80019d0:	4313      	orrs	r3, r2
 80019d2:	031b      	lsls	r3, r3, #12
 80019d4:	0b1b      	lsrs	r3, r3, #12
 80019d6:	46aa      	mov	sl, r5
 80019d8:	4a6f      	ldr	r2, [pc, #444]	; (8001b98 <__aeabi_ddiv+0x5f8>)
 80019da:	e66f      	b.n	80016bc <__aeabi_ddiv+0x11c>
 80019dc:	42ba      	cmp	r2, r7
 80019de:	d900      	bls.n	80019e2 <__aeabi_ddiv+0x442>
 80019e0:	e735      	b.n	800184e <__aeabi_ddiv+0x2ae>
 80019e2:	464b      	mov	r3, r9
 80019e4:	07dc      	lsls	r4, r3, #31
 80019e6:	0858      	lsrs	r0, r3, #1
 80019e8:	087b      	lsrs	r3, r7, #1
 80019ea:	431c      	orrs	r4, r3
 80019ec:	07ff      	lsls	r7, r7, #31
 80019ee:	e734      	b.n	800185a <__aeabi_ddiv+0x2ba>
 80019f0:	2400      	movs	r4, #0
 80019f2:	42af      	cmp	r7, r5
 80019f4:	d289      	bcs.n	800190a <__aeabi_ddiv+0x36a>
 80019f6:	4447      	add	r7, r8
 80019f8:	4547      	cmp	r7, r8
 80019fa:	41a4      	sbcs	r4, r4
 80019fc:	465b      	mov	r3, fp
 80019fe:	4264      	negs	r4, r4
 8001a00:	19a4      	adds	r4, r4, r6
 8001a02:	1864      	adds	r4, r4, r1
 8001a04:	3b01      	subs	r3, #1
 8001a06:	42a6      	cmp	r6, r4
 8001a08:	d21e      	bcs.n	8001a48 <__aeabi_ddiv+0x4a8>
 8001a0a:	42a0      	cmp	r0, r4
 8001a0c:	d86d      	bhi.n	8001aea <__aeabi_ddiv+0x54a>
 8001a0e:	d100      	bne.n	8001a12 <__aeabi_ddiv+0x472>
 8001a10:	e0b6      	b.n	8001b80 <__aeabi_ddiv+0x5e0>
 8001a12:	1a24      	subs	r4, r4, r0
 8001a14:	469b      	mov	fp, r3
 8001a16:	e778      	b.n	800190a <__aeabi_ddiv+0x36a>
 8001a18:	0003      	movs	r3, r0
 8001a1a:	465a      	mov	r2, fp
 8001a1c:	3b28      	subs	r3, #40	; 0x28
 8001a1e:	409a      	lsls	r2, r3
 8001a20:	2700      	movs	r7, #0
 8001a22:	4691      	mov	r9, r2
 8001a24:	e688      	b.n	8001738 <__aeabi_ddiv+0x198>
 8001a26:	4658      	mov	r0, fp
 8001a28:	f001 f912 	bl	8002c50 <__clzsi2>
 8001a2c:	3020      	adds	r0, #32
 8001a2e:	e672      	b.n	8001716 <__aeabi_ddiv+0x176>
 8001a30:	0003      	movs	r3, r0
 8001a32:	4652      	mov	r2, sl
 8001a34:	3b28      	subs	r3, #40	; 0x28
 8001a36:	409a      	lsls	r2, r3
 8001a38:	4693      	mov	fp, r2
 8001a3a:	2200      	movs	r2, #0
 8001a3c:	e6b4      	b.n	80017a8 <__aeabi_ddiv+0x208>
 8001a3e:	4650      	mov	r0, sl
 8001a40:	f001 f906 	bl	8002c50 <__clzsi2>
 8001a44:	3020      	adds	r0, #32
 8001a46:	e69a      	b.n	800177e <__aeabi_ddiv+0x1de>
 8001a48:	42a6      	cmp	r6, r4
 8001a4a:	d1e2      	bne.n	8001a12 <__aeabi_ddiv+0x472>
 8001a4c:	45b8      	cmp	r8, r7
 8001a4e:	d9dc      	bls.n	8001a0a <__aeabi_ddiv+0x46a>
 8001a50:	1a34      	subs	r4, r6, r0
 8001a52:	469b      	mov	fp, r3
 8001a54:	e759      	b.n	800190a <__aeabi_ddiv+0x36a>
 8001a56:	2b1f      	cmp	r3, #31
 8001a58:	dc65      	bgt.n	8001b26 <__aeabi_ddiv+0x586>
 8001a5a:	4c50      	ldr	r4, [pc, #320]	; (8001b9c <__aeabi_ddiv+0x5fc>)
 8001a5c:	9900      	ldr	r1, [sp, #0]
 8001a5e:	46a4      	mov	ip, r4
 8001a60:	465c      	mov	r4, fp
 8001a62:	4461      	add	r1, ip
 8001a64:	0008      	movs	r0, r1
 8001a66:	408c      	lsls	r4, r1
 8001a68:	0011      	movs	r1, r2
 8001a6a:	4082      	lsls	r2, r0
 8001a6c:	40d9      	lsrs	r1, r3
 8001a6e:	1e50      	subs	r0, r2, #1
 8001a70:	4182      	sbcs	r2, r0
 8001a72:	430c      	orrs	r4, r1
 8001a74:	4314      	orrs	r4, r2
 8001a76:	465a      	mov	r2, fp
 8001a78:	40da      	lsrs	r2, r3
 8001a7a:	0013      	movs	r3, r2
 8001a7c:	0762      	lsls	r2, r4, #29
 8001a7e:	d009      	beq.n	8001a94 <__aeabi_ddiv+0x4f4>
 8001a80:	220f      	movs	r2, #15
 8001a82:	4022      	ands	r2, r4
 8001a84:	2a04      	cmp	r2, #4
 8001a86:	d005      	beq.n	8001a94 <__aeabi_ddiv+0x4f4>
 8001a88:	0022      	movs	r2, r4
 8001a8a:	1d14      	adds	r4, r2, #4
 8001a8c:	4294      	cmp	r4, r2
 8001a8e:	4189      	sbcs	r1, r1
 8001a90:	4249      	negs	r1, r1
 8001a92:	185b      	adds	r3, r3, r1
 8001a94:	021a      	lsls	r2, r3, #8
 8001a96:	d562      	bpl.n	8001b5e <__aeabi_ddiv+0x5be>
 8001a98:	2201      	movs	r2, #1
 8001a9a:	2300      	movs	r3, #0
 8001a9c:	2700      	movs	r7, #0
 8001a9e:	e60d      	b.n	80016bc <__aeabi_ddiv+0x11c>
 8001aa0:	428a      	cmp	r2, r1
 8001aa2:	d800      	bhi.n	8001aa6 <__aeabi_ddiv+0x506>
 8001aa4:	e70a      	b.n	80018bc <__aeabi_ddiv+0x31c>
 8001aa6:	1e83      	subs	r3, r0, #2
 8001aa8:	1989      	adds	r1, r1, r6
 8001aaa:	e707      	b.n	80018bc <__aeabi_ddiv+0x31c>
 8001aac:	230f      	movs	r3, #15
 8001aae:	4013      	ands	r3, r2
 8001ab0:	2b04      	cmp	r3, #4
 8001ab2:	d100      	bne.n	8001ab6 <__aeabi_ddiv+0x516>
 8001ab4:	e5e6      	b.n	8001684 <__aeabi_ddiv+0xe4>
 8001ab6:	1d17      	adds	r7, r2, #4
 8001ab8:	4297      	cmp	r7, r2
 8001aba:	4192      	sbcs	r2, r2
 8001abc:	4253      	negs	r3, r2
 8001abe:	449b      	add	fp, r3
 8001ac0:	08fa      	lsrs	r2, r7, #3
 8001ac2:	e5e0      	b.n	8001686 <__aeabi_ddiv+0xe6>
 8001ac4:	2800      	cmp	r0, #0
 8001ac6:	d100      	bne.n	8001aca <__aeabi_ddiv+0x52a>
 8001ac8:	e5d7      	b.n	800167a <__aeabi_ddiv+0xda>
 8001aca:	1871      	adds	r1, r6, r1
 8001acc:	1e53      	subs	r3, r2, #1
 8001ace:	42b1      	cmp	r1, r6
 8001ad0:	d327      	bcc.n	8001b22 <__aeabi_ddiv+0x582>
 8001ad2:	42a9      	cmp	r1, r5
 8001ad4:	d315      	bcc.n	8001b02 <__aeabi_ddiv+0x562>
 8001ad6:	d058      	beq.n	8001b8a <__aeabi_ddiv+0x5ea>
 8001ad8:	001a      	movs	r2, r3
 8001ada:	e773      	b.n	80019c4 <__aeabi_ddiv+0x424>
 8001adc:	2b00      	cmp	r3, #0
 8001ade:	dc00      	bgt.n	8001ae2 <__aeabi_ddiv+0x542>
 8001ae0:	e604      	b.n	80016ec <__aeabi_ddiv+0x14c>
 8001ae2:	2301      	movs	r3, #1
 8001ae4:	2200      	movs	r2, #0
 8001ae6:	449b      	add	fp, r3
 8001ae8:	e5cd      	b.n	8001686 <__aeabi_ddiv+0xe6>
 8001aea:	2302      	movs	r3, #2
 8001aec:	4447      	add	r7, r8
 8001aee:	4547      	cmp	r7, r8
 8001af0:	4189      	sbcs	r1, r1
 8001af2:	425b      	negs	r3, r3
 8001af4:	469c      	mov	ip, r3
 8001af6:	4249      	negs	r1, r1
 8001af8:	1989      	adds	r1, r1, r6
 8001afa:	190c      	adds	r4, r1, r4
 8001afc:	44e3      	add	fp, ip
 8001afe:	1a24      	subs	r4, r4, r0
 8001b00:	e703      	b.n	800190a <__aeabi_ddiv+0x36a>
 8001b02:	4643      	mov	r3, r8
 8001b04:	005f      	lsls	r7, r3, #1
 8001b06:	4547      	cmp	r7, r8
 8001b08:	419b      	sbcs	r3, r3
 8001b0a:	46b8      	mov	r8, r7
 8001b0c:	425b      	negs	r3, r3
 8001b0e:	199e      	adds	r6, r3, r6
 8001b10:	3a02      	subs	r2, #2
 8001b12:	1989      	adds	r1, r1, r6
 8001b14:	42a9      	cmp	r1, r5
 8001b16:	d000      	beq.n	8001b1a <__aeabi_ddiv+0x57a>
 8001b18:	e754      	b.n	80019c4 <__aeabi_ddiv+0x424>
 8001b1a:	4540      	cmp	r0, r8
 8001b1c:	d000      	beq.n	8001b20 <__aeabi_ddiv+0x580>
 8001b1e:	e751      	b.n	80019c4 <__aeabi_ddiv+0x424>
 8001b20:	e5ab      	b.n	800167a <__aeabi_ddiv+0xda>
 8001b22:	001a      	movs	r2, r3
 8001b24:	e7f6      	b.n	8001b14 <__aeabi_ddiv+0x574>
 8001b26:	211f      	movs	r1, #31
 8001b28:	465f      	mov	r7, fp
 8001b2a:	4249      	negs	r1, r1
 8001b2c:	1b0c      	subs	r4, r1, r4
 8001b2e:	40e7      	lsrs	r7, r4
 8001b30:	2b20      	cmp	r3, #32
 8001b32:	d007      	beq.n	8001b44 <__aeabi_ddiv+0x5a4>
 8001b34:	491a      	ldr	r1, [pc, #104]	; (8001ba0 <__aeabi_ddiv+0x600>)
 8001b36:	9b00      	ldr	r3, [sp, #0]
 8001b38:	468c      	mov	ip, r1
 8001b3a:	4463      	add	r3, ip
 8001b3c:	0018      	movs	r0, r3
 8001b3e:	465b      	mov	r3, fp
 8001b40:	4083      	lsls	r3, r0
 8001b42:	431a      	orrs	r2, r3
 8001b44:	1e50      	subs	r0, r2, #1
 8001b46:	4182      	sbcs	r2, r0
 8001b48:	433a      	orrs	r2, r7
 8001b4a:	2707      	movs	r7, #7
 8001b4c:	2300      	movs	r3, #0
 8001b4e:	4017      	ands	r7, r2
 8001b50:	d009      	beq.n	8001b66 <__aeabi_ddiv+0x5c6>
 8001b52:	210f      	movs	r1, #15
 8001b54:	2300      	movs	r3, #0
 8001b56:	4011      	ands	r1, r2
 8001b58:	0014      	movs	r4, r2
 8001b5a:	2904      	cmp	r1, #4
 8001b5c:	d195      	bne.n	8001a8a <__aeabi_ddiv+0x4ea>
 8001b5e:	0022      	movs	r2, r4
 8001b60:	075f      	lsls	r7, r3, #29
 8001b62:	025b      	lsls	r3, r3, #9
 8001b64:	0b1b      	lsrs	r3, r3, #12
 8001b66:	08d2      	lsrs	r2, r2, #3
 8001b68:	4317      	orrs	r7, r2
 8001b6a:	2200      	movs	r2, #0
 8001b6c:	e5a6      	b.n	80016bc <__aeabi_ddiv+0x11c>
 8001b6e:	2380      	movs	r3, #128	; 0x80
 8001b70:	4659      	mov	r1, fp
 8001b72:	031b      	lsls	r3, r3, #12
 8001b74:	430b      	orrs	r3, r1
 8001b76:	031b      	lsls	r3, r3, #12
 8001b78:	0017      	movs	r7, r2
 8001b7a:	0b1b      	lsrs	r3, r3, #12
 8001b7c:	4a06      	ldr	r2, [pc, #24]	; (8001b98 <__aeabi_ddiv+0x5f8>)
 8001b7e:	e59d      	b.n	80016bc <__aeabi_ddiv+0x11c>
 8001b80:	42bd      	cmp	r5, r7
 8001b82:	d8b2      	bhi.n	8001aea <__aeabi_ddiv+0x54a>
 8001b84:	469b      	mov	fp, r3
 8001b86:	2400      	movs	r4, #0
 8001b88:	e6bf      	b.n	800190a <__aeabi_ddiv+0x36a>
 8001b8a:	4580      	cmp	r8, r0
 8001b8c:	d3b9      	bcc.n	8001b02 <__aeabi_ddiv+0x562>
 8001b8e:	001a      	movs	r2, r3
 8001b90:	e7c3      	b.n	8001b1a <__aeabi_ddiv+0x57a>
 8001b92:	46c0      	nop			; (mov r8, r8)
 8001b94:	000003ff 	.word	0x000003ff
 8001b98:	000007ff 	.word	0x000007ff
 8001b9c:	0000041e 	.word	0x0000041e
 8001ba0:	0000043e 	.word	0x0000043e

08001ba4 <__eqdf2>:
 8001ba4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001ba6:	464f      	mov	r7, r9
 8001ba8:	4646      	mov	r6, r8
 8001baa:	46d6      	mov	lr, sl
 8001bac:	4684      	mov	ip, r0
 8001bae:	b5c0      	push	{r6, r7, lr}
 8001bb0:	4680      	mov	r8, r0
 8001bb2:	4e19      	ldr	r6, [pc, #100]	; (8001c18 <__eqdf2+0x74>)
 8001bb4:	0318      	lsls	r0, r3, #12
 8001bb6:	030f      	lsls	r7, r1, #12
 8001bb8:	004d      	lsls	r5, r1, #1
 8001bba:	0b00      	lsrs	r0, r0, #12
 8001bbc:	005c      	lsls	r4, r3, #1
 8001bbe:	4682      	mov	sl, r0
 8001bc0:	0b3f      	lsrs	r7, r7, #12
 8001bc2:	0d6d      	lsrs	r5, r5, #21
 8001bc4:	0fc9      	lsrs	r1, r1, #31
 8001bc6:	4691      	mov	r9, r2
 8001bc8:	0d64      	lsrs	r4, r4, #21
 8001bca:	0fdb      	lsrs	r3, r3, #31
 8001bcc:	2001      	movs	r0, #1
 8001bce:	42b5      	cmp	r5, r6
 8001bd0:	d00a      	beq.n	8001be8 <__eqdf2+0x44>
 8001bd2:	42b4      	cmp	r4, r6
 8001bd4:	d003      	beq.n	8001bde <__eqdf2+0x3a>
 8001bd6:	42a5      	cmp	r5, r4
 8001bd8:	d101      	bne.n	8001bde <__eqdf2+0x3a>
 8001bda:	4557      	cmp	r7, sl
 8001bdc:	d00c      	beq.n	8001bf8 <__eqdf2+0x54>
 8001bde:	bc1c      	pop	{r2, r3, r4}
 8001be0:	4690      	mov	r8, r2
 8001be2:	4699      	mov	r9, r3
 8001be4:	46a2      	mov	sl, r4
 8001be6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001be8:	4666      	mov	r6, ip
 8001bea:	433e      	orrs	r6, r7
 8001bec:	d1f7      	bne.n	8001bde <__eqdf2+0x3a>
 8001bee:	42ac      	cmp	r4, r5
 8001bf0:	d1f5      	bne.n	8001bde <__eqdf2+0x3a>
 8001bf2:	4654      	mov	r4, sl
 8001bf4:	4314      	orrs	r4, r2
 8001bf6:	d1f2      	bne.n	8001bde <__eqdf2+0x3a>
 8001bf8:	2001      	movs	r0, #1
 8001bfa:	45c8      	cmp	r8, r9
 8001bfc:	d1ef      	bne.n	8001bde <__eqdf2+0x3a>
 8001bfe:	4299      	cmp	r1, r3
 8001c00:	d007      	beq.n	8001c12 <__eqdf2+0x6e>
 8001c02:	2d00      	cmp	r5, #0
 8001c04:	d1eb      	bne.n	8001bde <__eqdf2+0x3a>
 8001c06:	4663      	mov	r3, ip
 8001c08:	431f      	orrs	r7, r3
 8001c0a:	0038      	movs	r0, r7
 8001c0c:	1e47      	subs	r7, r0, #1
 8001c0e:	41b8      	sbcs	r0, r7
 8001c10:	e7e5      	b.n	8001bde <__eqdf2+0x3a>
 8001c12:	2000      	movs	r0, #0
 8001c14:	e7e3      	b.n	8001bde <__eqdf2+0x3a>
 8001c16:	46c0      	nop			; (mov r8, r8)
 8001c18:	000007ff 	.word	0x000007ff

08001c1c <__gedf2>:
 8001c1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001c1e:	464f      	mov	r7, r9
 8001c20:	4646      	mov	r6, r8
 8001c22:	46d6      	mov	lr, sl
 8001c24:	004d      	lsls	r5, r1, #1
 8001c26:	b5c0      	push	{r6, r7, lr}
 8001c28:	030e      	lsls	r6, r1, #12
 8001c2a:	0fc9      	lsrs	r1, r1, #31
 8001c2c:	468a      	mov	sl, r1
 8001c2e:	492c      	ldr	r1, [pc, #176]	; (8001ce0 <__gedf2+0xc4>)
 8001c30:	031f      	lsls	r7, r3, #12
 8001c32:	005c      	lsls	r4, r3, #1
 8001c34:	4680      	mov	r8, r0
 8001c36:	0b36      	lsrs	r6, r6, #12
 8001c38:	0d6d      	lsrs	r5, r5, #21
 8001c3a:	4691      	mov	r9, r2
 8001c3c:	0b3f      	lsrs	r7, r7, #12
 8001c3e:	0d64      	lsrs	r4, r4, #21
 8001c40:	0fdb      	lsrs	r3, r3, #31
 8001c42:	428d      	cmp	r5, r1
 8001c44:	d01e      	beq.n	8001c84 <__gedf2+0x68>
 8001c46:	428c      	cmp	r4, r1
 8001c48:	d016      	beq.n	8001c78 <__gedf2+0x5c>
 8001c4a:	2d00      	cmp	r5, #0
 8001c4c:	d11e      	bne.n	8001c8c <__gedf2+0x70>
 8001c4e:	4330      	orrs	r0, r6
 8001c50:	4684      	mov	ip, r0
 8001c52:	2c00      	cmp	r4, #0
 8001c54:	d101      	bne.n	8001c5a <__gedf2+0x3e>
 8001c56:	433a      	orrs	r2, r7
 8001c58:	d023      	beq.n	8001ca2 <__gedf2+0x86>
 8001c5a:	4662      	mov	r2, ip
 8001c5c:	2a00      	cmp	r2, #0
 8001c5e:	d01a      	beq.n	8001c96 <__gedf2+0x7a>
 8001c60:	459a      	cmp	sl, r3
 8001c62:	d029      	beq.n	8001cb8 <__gedf2+0x9c>
 8001c64:	4651      	mov	r1, sl
 8001c66:	2002      	movs	r0, #2
 8001c68:	3901      	subs	r1, #1
 8001c6a:	4008      	ands	r0, r1
 8001c6c:	3801      	subs	r0, #1
 8001c6e:	bc1c      	pop	{r2, r3, r4}
 8001c70:	4690      	mov	r8, r2
 8001c72:	4699      	mov	r9, r3
 8001c74:	46a2      	mov	sl, r4
 8001c76:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001c78:	0039      	movs	r1, r7
 8001c7a:	4311      	orrs	r1, r2
 8001c7c:	d0e5      	beq.n	8001c4a <__gedf2+0x2e>
 8001c7e:	2002      	movs	r0, #2
 8001c80:	4240      	negs	r0, r0
 8001c82:	e7f4      	b.n	8001c6e <__gedf2+0x52>
 8001c84:	4330      	orrs	r0, r6
 8001c86:	d1fa      	bne.n	8001c7e <__gedf2+0x62>
 8001c88:	42ac      	cmp	r4, r5
 8001c8a:	d00f      	beq.n	8001cac <__gedf2+0x90>
 8001c8c:	2c00      	cmp	r4, #0
 8001c8e:	d10f      	bne.n	8001cb0 <__gedf2+0x94>
 8001c90:	433a      	orrs	r2, r7
 8001c92:	d0e7      	beq.n	8001c64 <__gedf2+0x48>
 8001c94:	e00c      	b.n	8001cb0 <__gedf2+0x94>
 8001c96:	2201      	movs	r2, #1
 8001c98:	3b01      	subs	r3, #1
 8001c9a:	4393      	bics	r3, r2
 8001c9c:	0018      	movs	r0, r3
 8001c9e:	3001      	adds	r0, #1
 8001ca0:	e7e5      	b.n	8001c6e <__gedf2+0x52>
 8001ca2:	4663      	mov	r3, ip
 8001ca4:	2000      	movs	r0, #0
 8001ca6:	2b00      	cmp	r3, #0
 8001ca8:	d0e1      	beq.n	8001c6e <__gedf2+0x52>
 8001caa:	e7db      	b.n	8001c64 <__gedf2+0x48>
 8001cac:	433a      	orrs	r2, r7
 8001cae:	d1e6      	bne.n	8001c7e <__gedf2+0x62>
 8001cb0:	459a      	cmp	sl, r3
 8001cb2:	d1d7      	bne.n	8001c64 <__gedf2+0x48>
 8001cb4:	42a5      	cmp	r5, r4
 8001cb6:	dcd5      	bgt.n	8001c64 <__gedf2+0x48>
 8001cb8:	42a5      	cmp	r5, r4
 8001cba:	db05      	blt.n	8001cc8 <__gedf2+0xac>
 8001cbc:	42be      	cmp	r6, r7
 8001cbe:	d8d1      	bhi.n	8001c64 <__gedf2+0x48>
 8001cc0:	d008      	beq.n	8001cd4 <__gedf2+0xb8>
 8001cc2:	2000      	movs	r0, #0
 8001cc4:	42be      	cmp	r6, r7
 8001cc6:	d2d2      	bcs.n	8001c6e <__gedf2+0x52>
 8001cc8:	4650      	mov	r0, sl
 8001cca:	2301      	movs	r3, #1
 8001ccc:	3801      	subs	r0, #1
 8001cce:	4398      	bics	r0, r3
 8001cd0:	3001      	adds	r0, #1
 8001cd2:	e7cc      	b.n	8001c6e <__gedf2+0x52>
 8001cd4:	45c8      	cmp	r8, r9
 8001cd6:	d8c5      	bhi.n	8001c64 <__gedf2+0x48>
 8001cd8:	2000      	movs	r0, #0
 8001cda:	45c8      	cmp	r8, r9
 8001cdc:	d3f4      	bcc.n	8001cc8 <__gedf2+0xac>
 8001cde:	e7c6      	b.n	8001c6e <__gedf2+0x52>
 8001ce0:	000007ff 	.word	0x000007ff

08001ce4 <__ledf2>:
 8001ce4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001ce6:	464f      	mov	r7, r9
 8001ce8:	4646      	mov	r6, r8
 8001cea:	46d6      	mov	lr, sl
 8001cec:	004d      	lsls	r5, r1, #1
 8001cee:	b5c0      	push	{r6, r7, lr}
 8001cf0:	030e      	lsls	r6, r1, #12
 8001cf2:	0fc9      	lsrs	r1, r1, #31
 8001cf4:	468a      	mov	sl, r1
 8001cf6:	492e      	ldr	r1, [pc, #184]	; (8001db0 <__ledf2+0xcc>)
 8001cf8:	031f      	lsls	r7, r3, #12
 8001cfa:	005c      	lsls	r4, r3, #1
 8001cfc:	4680      	mov	r8, r0
 8001cfe:	0b36      	lsrs	r6, r6, #12
 8001d00:	0d6d      	lsrs	r5, r5, #21
 8001d02:	4691      	mov	r9, r2
 8001d04:	0b3f      	lsrs	r7, r7, #12
 8001d06:	0d64      	lsrs	r4, r4, #21
 8001d08:	0fdb      	lsrs	r3, r3, #31
 8001d0a:	428d      	cmp	r5, r1
 8001d0c:	d018      	beq.n	8001d40 <__ledf2+0x5c>
 8001d0e:	428c      	cmp	r4, r1
 8001d10:	d011      	beq.n	8001d36 <__ledf2+0x52>
 8001d12:	2d00      	cmp	r5, #0
 8001d14:	d118      	bne.n	8001d48 <__ledf2+0x64>
 8001d16:	4330      	orrs	r0, r6
 8001d18:	4684      	mov	ip, r0
 8001d1a:	2c00      	cmp	r4, #0
 8001d1c:	d11e      	bne.n	8001d5c <__ledf2+0x78>
 8001d1e:	433a      	orrs	r2, r7
 8001d20:	d11c      	bne.n	8001d5c <__ledf2+0x78>
 8001d22:	4663      	mov	r3, ip
 8001d24:	2000      	movs	r0, #0
 8001d26:	2b00      	cmp	r3, #0
 8001d28:	d030      	beq.n	8001d8c <__ledf2+0xa8>
 8001d2a:	4651      	mov	r1, sl
 8001d2c:	2002      	movs	r0, #2
 8001d2e:	3901      	subs	r1, #1
 8001d30:	4008      	ands	r0, r1
 8001d32:	3801      	subs	r0, #1
 8001d34:	e02a      	b.n	8001d8c <__ledf2+0xa8>
 8001d36:	0039      	movs	r1, r7
 8001d38:	4311      	orrs	r1, r2
 8001d3a:	d0ea      	beq.n	8001d12 <__ledf2+0x2e>
 8001d3c:	2002      	movs	r0, #2
 8001d3e:	e025      	b.n	8001d8c <__ledf2+0xa8>
 8001d40:	4330      	orrs	r0, r6
 8001d42:	d1fb      	bne.n	8001d3c <__ledf2+0x58>
 8001d44:	42ac      	cmp	r4, r5
 8001d46:	d026      	beq.n	8001d96 <__ledf2+0xb2>
 8001d48:	2c00      	cmp	r4, #0
 8001d4a:	d126      	bne.n	8001d9a <__ledf2+0xb6>
 8001d4c:	433a      	orrs	r2, r7
 8001d4e:	d124      	bne.n	8001d9a <__ledf2+0xb6>
 8001d50:	4651      	mov	r1, sl
 8001d52:	2002      	movs	r0, #2
 8001d54:	3901      	subs	r1, #1
 8001d56:	4008      	ands	r0, r1
 8001d58:	3801      	subs	r0, #1
 8001d5a:	e017      	b.n	8001d8c <__ledf2+0xa8>
 8001d5c:	4662      	mov	r2, ip
 8001d5e:	2a00      	cmp	r2, #0
 8001d60:	d00f      	beq.n	8001d82 <__ledf2+0x9e>
 8001d62:	459a      	cmp	sl, r3
 8001d64:	d1e1      	bne.n	8001d2a <__ledf2+0x46>
 8001d66:	42a5      	cmp	r5, r4
 8001d68:	db05      	blt.n	8001d76 <__ledf2+0x92>
 8001d6a:	42be      	cmp	r6, r7
 8001d6c:	d8dd      	bhi.n	8001d2a <__ledf2+0x46>
 8001d6e:	d019      	beq.n	8001da4 <__ledf2+0xc0>
 8001d70:	2000      	movs	r0, #0
 8001d72:	42be      	cmp	r6, r7
 8001d74:	d20a      	bcs.n	8001d8c <__ledf2+0xa8>
 8001d76:	4650      	mov	r0, sl
 8001d78:	2301      	movs	r3, #1
 8001d7a:	3801      	subs	r0, #1
 8001d7c:	4398      	bics	r0, r3
 8001d7e:	3001      	adds	r0, #1
 8001d80:	e004      	b.n	8001d8c <__ledf2+0xa8>
 8001d82:	2201      	movs	r2, #1
 8001d84:	3b01      	subs	r3, #1
 8001d86:	4393      	bics	r3, r2
 8001d88:	0018      	movs	r0, r3
 8001d8a:	3001      	adds	r0, #1
 8001d8c:	bc1c      	pop	{r2, r3, r4}
 8001d8e:	4690      	mov	r8, r2
 8001d90:	4699      	mov	r9, r3
 8001d92:	46a2      	mov	sl, r4
 8001d94:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d96:	433a      	orrs	r2, r7
 8001d98:	d1d0      	bne.n	8001d3c <__ledf2+0x58>
 8001d9a:	459a      	cmp	sl, r3
 8001d9c:	d1c5      	bne.n	8001d2a <__ledf2+0x46>
 8001d9e:	42a5      	cmp	r5, r4
 8001da0:	dcc3      	bgt.n	8001d2a <__ledf2+0x46>
 8001da2:	e7e0      	b.n	8001d66 <__ledf2+0x82>
 8001da4:	45c8      	cmp	r8, r9
 8001da6:	d8c0      	bhi.n	8001d2a <__ledf2+0x46>
 8001da8:	2000      	movs	r0, #0
 8001daa:	45c8      	cmp	r8, r9
 8001dac:	d3e3      	bcc.n	8001d76 <__ledf2+0x92>
 8001dae:	e7ed      	b.n	8001d8c <__ledf2+0xa8>
 8001db0:	000007ff 	.word	0x000007ff

08001db4 <__aeabi_dmul>:
 8001db4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001db6:	4657      	mov	r7, sl
 8001db8:	46de      	mov	lr, fp
 8001dba:	464e      	mov	r6, r9
 8001dbc:	4645      	mov	r5, r8
 8001dbe:	b5e0      	push	{r5, r6, r7, lr}
 8001dc0:	4683      	mov	fp, r0
 8001dc2:	0006      	movs	r6, r0
 8001dc4:	030f      	lsls	r7, r1, #12
 8001dc6:	0048      	lsls	r0, r1, #1
 8001dc8:	b087      	sub	sp, #28
 8001dca:	4692      	mov	sl, r2
 8001dcc:	001d      	movs	r5, r3
 8001dce:	0b3f      	lsrs	r7, r7, #12
 8001dd0:	0d40      	lsrs	r0, r0, #21
 8001dd2:	0fcc      	lsrs	r4, r1, #31
 8001dd4:	2800      	cmp	r0, #0
 8001dd6:	d100      	bne.n	8001dda <__aeabi_dmul+0x26>
 8001dd8:	e06f      	b.n	8001eba <__aeabi_dmul+0x106>
 8001dda:	4bde      	ldr	r3, [pc, #888]	; (8002154 <__aeabi_dmul+0x3a0>)
 8001ddc:	4298      	cmp	r0, r3
 8001dde:	d038      	beq.n	8001e52 <__aeabi_dmul+0x9e>
 8001de0:	2380      	movs	r3, #128	; 0x80
 8001de2:	00ff      	lsls	r7, r7, #3
 8001de4:	041b      	lsls	r3, r3, #16
 8001de6:	431f      	orrs	r7, r3
 8001de8:	0f73      	lsrs	r3, r6, #29
 8001dea:	433b      	orrs	r3, r7
 8001dec:	9301      	str	r3, [sp, #4]
 8001dee:	4bda      	ldr	r3, [pc, #872]	; (8002158 <__aeabi_dmul+0x3a4>)
 8001df0:	2700      	movs	r7, #0
 8001df2:	4699      	mov	r9, r3
 8001df4:	2300      	movs	r3, #0
 8001df6:	469b      	mov	fp, r3
 8001df8:	00f6      	lsls	r6, r6, #3
 8001dfa:	4481      	add	r9, r0
 8001dfc:	032b      	lsls	r3, r5, #12
 8001dfe:	0069      	lsls	r1, r5, #1
 8001e00:	0b1b      	lsrs	r3, r3, #12
 8001e02:	4652      	mov	r2, sl
 8001e04:	4698      	mov	r8, r3
 8001e06:	0d49      	lsrs	r1, r1, #21
 8001e08:	0fed      	lsrs	r5, r5, #31
 8001e0a:	2900      	cmp	r1, #0
 8001e0c:	d100      	bne.n	8001e10 <__aeabi_dmul+0x5c>
 8001e0e:	e085      	b.n	8001f1c <__aeabi_dmul+0x168>
 8001e10:	4bd0      	ldr	r3, [pc, #832]	; (8002154 <__aeabi_dmul+0x3a0>)
 8001e12:	4299      	cmp	r1, r3
 8001e14:	d100      	bne.n	8001e18 <__aeabi_dmul+0x64>
 8001e16:	e073      	b.n	8001f00 <__aeabi_dmul+0x14c>
 8001e18:	4643      	mov	r3, r8
 8001e1a:	00da      	lsls	r2, r3, #3
 8001e1c:	2380      	movs	r3, #128	; 0x80
 8001e1e:	041b      	lsls	r3, r3, #16
 8001e20:	4313      	orrs	r3, r2
 8001e22:	4652      	mov	r2, sl
 8001e24:	48cc      	ldr	r0, [pc, #816]	; (8002158 <__aeabi_dmul+0x3a4>)
 8001e26:	0f52      	lsrs	r2, r2, #29
 8001e28:	4684      	mov	ip, r0
 8001e2a:	4313      	orrs	r3, r2
 8001e2c:	4652      	mov	r2, sl
 8001e2e:	2000      	movs	r0, #0
 8001e30:	4461      	add	r1, ip
 8001e32:	00d2      	lsls	r2, r2, #3
 8001e34:	4489      	add	r9, r1
 8001e36:	0021      	movs	r1, r4
 8001e38:	4069      	eors	r1, r5
 8001e3a:	9100      	str	r1, [sp, #0]
 8001e3c:	468c      	mov	ip, r1
 8001e3e:	2101      	movs	r1, #1
 8001e40:	4449      	add	r1, r9
 8001e42:	468a      	mov	sl, r1
 8001e44:	2f0f      	cmp	r7, #15
 8001e46:	d900      	bls.n	8001e4a <__aeabi_dmul+0x96>
 8001e48:	e090      	b.n	8001f6c <__aeabi_dmul+0x1b8>
 8001e4a:	49c4      	ldr	r1, [pc, #784]	; (800215c <__aeabi_dmul+0x3a8>)
 8001e4c:	00bf      	lsls	r7, r7, #2
 8001e4e:	59cf      	ldr	r7, [r1, r7]
 8001e50:	46bf      	mov	pc, r7
 8001e52:	465b      	mov	r3, fp
 8001e54:	433b      	orrs	r3, r7
 8001e56:	9301      	str	r3, [sp, #4]
 8001e58:	d000      	beq.n	8001e5c <__aeabi_dmul+0xa8>
 8001e5a:	e16a      	b.n	8002132 <__aeabi_dmul+0x37e>
 8001e5c:	2302      	movs	r3, #2
 8001e5e:	2708      	movs	r7, #8
 8001e60:	2600      	movs	r6, #0
 8001e62:	4681      	mov	r9, r0
 8001e64:	469b      	mov	fp, r3
 8001e66:	e7c9      	b.n	8001dfc <__aeabi_dmul+0x48>
 8001e68:	0032      	movs	r2, r6
 8001e6a:	4658      	mov	r0, fp
 8001e6c:	9b01      	ldr	r3, [sp, #4]
 8001e6e:	4661      	mov	r1, ip
 8001e70:	9100      	str	r1, [sp, #0]
 8001e72:	2802      	cmp	r0, #2
 8001e74:	d100      	bne.n	8001e78 <__aeabi_dmul+0xc4>
 8001e76:	e075      	b.n	8001f64 <__aeabi_dmul+0x1b0>
 8001e78:	2803      	cmp	r0, #3
 8001e7a:	d100      	bne.n	8001e7e <__aeabi_dmul+0xca>
 8001e7c:	e1fe      	b.n	800227c <__aeabi_dmul+0x4c8>
 8001e7e:	2801      	cmp	r0, #1
 8001e80:	d000      	beq.n	8001e84 <__aeabi_dmul+0xd0>
 8001e82:	e12c      	b.n	80020de <__aeabi_dmul+0x32a>
 8001e84:	2300      	movs	r3, #0
 8001e86:	2700      	movs	r7, #0
 8001e88:	2600      	movs	r6, #0
 8001e8a:	2500      	movs	r5, #0
 8001e8c:	033f      	lsls	r7, r7, #12
 8001e8e:	0d2a      	lsrs	r2, r5, #20
 8001e90:	0b3f      	lsrs	r7, r7, #12
 8001e92:	48b3      	ldr	r0, [pc, #716]	; (8002160 <__aeabi_dmul+0x3ac>)
 8001e94:	0512      	lsls	r2, r2, #20
 8001e96:	433a      	orrs	r2, r7
 8001e98:	4002      	ands	r2, r0
 8001e9a:	051b      	lsls	r3, r3, #20
 8001e9c:	4313      	orrs	r3, r2
 8001e9e:	9a00      	ldr	r2, [sp, #0]
 8001ea0:	005b      	lsls	r3, r3, #1
 8001ea2:	07d1      	lsls	r1, r2, #31
 8001ea4:	085b      	lsrs	r3, r3, #1
 8001ea6:	430b      	orrs	r3, r1
 8001ea8:	0030      	movs	r0, r6
 8001eaa:	0019      	movs	r1, r3
 8001eac:	b007      	add	sp, #28
 8001eae:	bc3c      	pop	{r2, r3, r4, r5}
 8001eb0:	4690      	mov	r8, r2
 8001eb2:	4699      	mov	r9, r3
 8001eb4:	46a2      	mov	sl, r4
 8001eb6:	46ab      	mov	fp, r5
 8001eb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001eba:	465b      	mov	r3, fp
 8001ebc:	433b      	orrs	r3, r7
 8001ebe:	9301      	str	r3, [sp, #4]
 8001ec0:	d100      	bne.n	8001ec4 <__aeabi_dmul+0x110>
 8001ec2:	e12f      	b.n	8002124 <__aeabi_dmul+0x370>
 8001ec4:	2f00      	cmp	r7, #0
 8001ec6:	d100      	bne.n	8001eca <__aeabi_dmul+0x116>
 8001ec8:	e1a5      	b.n	8002216 <__aeabi_dmul+0x462>
 8001eca:	0038      	movs	r0, r7
 8001ecc:	f000 fec0 	bl	8002c50 <__clzsi2>
 8001ed0:	0003      	movs	r3, r0
 8001ed2:	3b0b      	subs	r3, #11
 8001ed4:	2b1c      	cmp	r3, #28
 8001ed6:	dd00      	ble.n	8001eda <__aeabi_dmul+0x126>
 8001ed8:	e196      	b.n	8002208 <__aeabi_dmul+0x454>
 8001eda:	221d      	movs	r2, #29
 8001edc:	1ad3      	subs	r3, r2, r3
 8001ede:	465a      	mov	r2, fp
 8001ee0:	0001      	movs	r1, r0
 8001ee2:	40da      	lsrs	r2, r3
 8001ee4:	465e      	mov	r6, fp
 8001ee6:	3908      	subs	r1, #8
 8001ee8:	408f      	lsls	r7, r1
 8001eea:	0013      	movs	r3, r2
 8001eec:	408e      	lsls	r6, r1
 8001eee:	433b      	orrs	r3, r7
 8001ef0:	9301      	str	r3, [sp, #4]
 8001ef2:	4b9c      	ldr	r3, [pc, #624]	; (8002164 <__aeabi_dmul+0x3b0>)
 8001ef4:	2700      	movs	r7, #0
 8001ef6:	1a1b      	subs	r3, r3, r0
 8001ef8:	4699      	mov	r9, r3
 8001efa:	2300      	movs	r3, #0
 8001efc:	469b      	mov	fp, r3
 8001efe:	e77d      	b.n	8001dfc <__aeabi_dmul+0x48>
 8001f00:	4641      	mov	r1, r8
 8001f02:	4653      	mov	r3, sl
 8001f04:	430b      	orrs	r3, r1
 8001f06:	4993      	ldr	r1, [pc, #588]	; (8002154 <__aeabi_dmul+0x3a0>)
 8001f08:	468c      	mov	ip, r1
 8001f0a:	44e1      	add	r9, ip
 8001f0c:	2b00      	cmp	r3, #0
 8001f0e:	d000      	beq.n	8001f12 <__aeabi_dmul+0x15e>
 8001f10:	e11a      	b.n	8002148 <__aeabi_dmul+0x394>
 8001f12:	2202      	movs	r2, #2
 8001f14:	2002      	movs	r0, #2
 8001f16:	4317      	orrs	r7, r2
 8001f18:	2200      	movs	r2, #0
 8001f1a:	e78c      	b.n	8001e36 <__aeabi_dmul+0x82>
 8001f1c:	4313      	orrs	r3, r2
 8001f1e:	d100      	bne.n	8001f22 <__aeabi_dmul+0x16e>
 8001f20:	e10d      	b.n	800213e <__aeabi_dmul+0x38a>
 8001f22:	4643      	mov	r3, r8
 8001f24:	2b00      	cmp	r3, #0
 8001f26:	d100      	bne.n	8001f2a <__aeabi_dmul+0x176>
 8001f28:	e181      	b.n	800222e <__aeabi_dmul+0x47a>
 8001f2a:	4640      	mov	r0, r8
 8001f2c:	f000 fe90 	bl	8002c50 <__clzsi2>
 8001f30:	0002      	movs	r2, r0
 8001f32:	3a0b      	subs	r2, #11
 8001f34:	2a1c      	cmp	r2, #28
 8001f36:	dd00      	ble.n	8001f3a <__aeabi_dmul+0x186>
 8001f38:	e172      	b.n	8002220 <__aeabi_dmul+0x46c>
 8001f3a:	0001      	movs	r1, r0
 8001f3c:	4643      	mov	r3, r8
 8001f3e:	3908      	subs	r1, #8
 8001f40:	408b      	lsls	r3, r1
 8001f42:	4698      	mov	r8, r3
 8001f44:	231d      	movs	r3, #29
 8001f46:	1a9a      	subs	r2, r3, r2
 8001f48:	4653      	mov	r3, sl
 8001f4a:	40d3      	lsrs	r3, r2
 8001f4c:	001a      	movs	r2, r3
 8001f4e:	4643      	mov	r3, r8
 8001f50:	4313      	orrs	r3, r2
 8001f52:	4652      	mov	r2, sl
 8001f54:	408a      	lsls	r2, r1
 8001f56:	4649      	mov	r1, r9
 8001f58:	1a08      	subs	r0, r1, r0
 8001f5a:	4982      	ldr	r1, [pc, #520]	; (8002164 <__aeabi_dmul+0x3b0>)
 8001f5c:	4689      	mov	r9, r1
 8001f5e:	4481      	add	r9, r0
 8001f60:	2000      	movs	r0, #0
 8001f62:	e768      	b.n	8001e36 <__aeabi_dmul+0x82>
 8001f64:	4b7b      	ldr	r3, [pc, #492]	; (8002154 <__aeabi_dmul+0x3a0>)
 8001f66:	2700      	movs	r7, #0
 8001f68:	2600      	movs	r6, #0
 8001f6a:	e78e      	b.n	8001e8a <__aeabi_dmul+0xd6>
 8001f6c:	0c14      	lsrs	r4, r2, #16
 8001f6e:	0412      	lsls	r2, r2, #16
 8001f70:	0c12      	lsrs	r2, r2, #16
 8001f72:	0011      	movs	r1, r2
 8001f74:	0c37      	lsrs	r7, r6, #16
 8001f76:	0436      	lsls	r6, r6, #16
 8001f78:	0c35      	lsrs	r5, r6, #16
 8001f7a:	4379      	muls	r1, r7
 8001f7c:	0028      	movs	r0, r5
 8001f7e:	468c      	mov	ip, r1
 8001f80:	002e      	movs	r6, r5
 8001f82:	4360      	muls	r0, r4
 8001f84:	4460      	add	r0, ip
 8001f86:	4683      	mov	fp, r0
 8001f88:	4356      	muls	r6, r2
 8001f8a:	0021      	movs	r1, r4
 8001f8c:	0c30      	lsrs	r0, r6, #16
 8001f8e:	4680      	mov	r8, r0
 8001f90:	4658      	mov	r0, fp
 8001f92:	4379      	muls	r1, r7
 8001f94:	4440      	add	r0, r8
 8001f96:	9102      	str	r1, [sp, #8]
 8001f98:	4584      	cmp	ip, r0
 8001f9a:	d906      	bls.n	8001faa <__aeabi_dmul+0x1f6>
 8001f9c:	4688      	mov	r8, r1
 8001f9e:	2180      	movs	r1, #128	; 0x80
 8001fa0:	0249      	lsls	r1, r1, #9
 8001fa2:	468c      	mov	ip, r1
 8001fa4:	44e0      	add	r8, ip
 8001fa6:	4641      	mov	r1, r8
 8001fa8:	9102      	str	r1, [sp, #8]
 8001faa:	0436      	lsls	r6, r6, #16
 8001fac:	0c01      	lsrs	r1, r0, #16
 8001fae:	0c36      	lsrs	r6, r6, #16
 8001fb0:	0400      	lsls	r0, r0, #16
 8001fb2:	468b      	mov	fp, r1
 8001fb4:	1981      	adds	r1, r0, r6
 8001fb6:	0c1e      	lsrs	r6, r3, #16
 8001fb8:	041b      	lsls	r3, r3, #16
 8001fba:	0c1b      	lsrs	r3, r3, #16
 8001fbc:	9103      	str	r1, [sp, #12]
 8001fbe:	0019      	movs	r1, r3
 8001fc0:	4379      	muls	r1, r7
 8001fc2:	468c      	mov	ip, r1
 8001fc4:	0028      	movs	r0, r5
 8001fc6:	4375      	muls	r5, r6
 8001fc8:	4465      	add	r5, ip
 8001fca:	46a8      	mov	r8, r5
 8001fcc:	4358      	muls	r0, r3
 8001fce:	0c05      	lsrs	r5, r0, #16
 8001fd0:	4445      	add	r5, r8
 8001fd2:	4377      	muls	r7, r6
 8001fd4:	42a9      	cmp	r1, r5
 8001fd6:	d903      	bls.n	8001fe0 <__aeabi_dmul+0x22c>
 8001fd8:	2180      	movs	r1, #128	; 0x80
 8001fda:	0249      	lsls	r1, r1, #9
 8001fdc:	468c      	mov	ip, r1
 8001fde:	4467      	add	r7, ip
 8001fe0:	0c29      	lsrs	r1, r5, #16
 8001fe2:	468c      	mov	ip, r1
 8001fe4:	0039      	movs	r1, r7
 8001fe6:	0400      	lsls	r0, r0, #16
 8001fe8:	0c00      	lsrs	r0, r0, #16
 8001fea:	042d      	lsls	r5, r5, #16
 8001fec:	182d      	adds	r5, r5, r0
 8001fee:	4461      	add	r1, ip
 8001ff0:	44ab      	add	fp, r5
 8001ff2:	9105      	str	r1, [sp, #20]
 8001ff4:	4659      	mov	r1, fp
 8001ff6:	9104      	str	r1, [sp, #16]
 8001ff8:	9901      	ldr	r1, [sp, #4]
 8001ffa:	040f      	lsls	r7, r1, #16
 8001ffc:	0c3f      	lsrs	r7, r7, #16
 8001ffe:	0c08      	lsrs	r0, r1, #16
 8002000:	0039      	movs	r1, r7
 8002002:	4351      	muls	r1, r2
 8002004:	4342      	muls	r2, r0
 8002006:	4690      	mov	r8, r2
 8002008:	0002      	movs	r2, r0
 800200a:	468c      	mov	ip, r1
 800200c:	0c09      	lsrs	r1, r1, #16
 800200e:	468b      	mov	fp, r1
 8002010:	4362      	muls	r2, r4
 8002012:	437c      	muls	r4, r7
 8002014:	4444      	add	r4, r8
 8002016:	445c      	add	r4, fp
 8002018:	45a0      	cmp	r8, r4
 800201a:	d903      	bls.n	8002024 <__aeabi_dmul+0x270>
 800201c:	2180      	movs	r1, #128	; 0x80
 800201e:	0249      	lsls	r1, r1, #9
 8002020:	4688      	mov	r8, r1
 8002022:	4442      	add	r2, r8
 8002024:	0c21      	lsrs	r1, r4, #16
 8002026:	4688      	mov	r8, r1
 8002028:	4661      	mov	r1, ip
 800202a:	0409      	lsls	r1, r1, #16
 800202c:	0c09      	lsrs	r1, r1, #16
 800202e:	468c      	mov	ip, r1
 8002030:	0039      	movs	r1, r7
 8002032:	4359      	muls	r1, r3
 8002034:	4343      	muls	r3, r0
 8002036:	4370      	muls	r0, r6
 8002038:	437e      	muls	r6, r7
 800203a:	0c0f      	lsrs	r7, r1, #16
 800203c:	18f6      	adds	r6, r6, r3
 800203e:	0424      	lsls	r4, r4, #16
 8002040:	19be      	adds	r6, r7, r6
 8002042:	4464      	add	r4, ip
 8002044:	4442      	add	r2, r8
 8002046:	468c      	mov	ip, r1
 8002048:	42b3      	cmp	r3, r6
 800204a:	d903      	bls.n	8002054 <__aeabi_dmul+0x2a0>
 800204c:	2380      	movs	r3, #128	; 0x80
 800204e:	025b      	lsls	r3, r3, #9
 8002050:	4698      	mov	r8, r3
 8002052:	4440      	add	r0, r8
 8002054:	9b02      	ldr	r3, [sp, #8]
 8002056:	4661      	mov	r1, ip
 8002058:	4698      	mov	r8, r3
 800205a:	9b04      	ldr	r3, [sp, #16]
 800205c:	0437      	lsls	r7, r6, #16
 800205e:	4443      	add	r3, r8
 8002060:	469b      	mov	fp, r3
 8002062:	45ab      	cmp	fp, r5
 8002064:	41ad      	sbcs	r5, r5
 8002066:	426b      	negs	r3, r5
 8002068:	040d      	lsls	r5, r1, #16
 800206a:	9905      	ldr	r1, [sp, #20]
 800206c:	0c2d      	lsrs	r5, r5, #16
 800206e:	468c      	mov	ip, r1
 8002070:	197f      	adds	r7, r7, r5
 8002072:	4467      	add	r7, ip
 8002074:	18fd      	adds	r5, r7, r3
 8002076:	46a8      	mov	r8, r5
 8002078:	465d      	mov	r5, fp
 800207a:	192d      	adds	r5, r5, r4
 800207c:	42a5      	cmp	r5, r4
 800207e:	41a4      	sbcs	r4, r4
 8002080:	4693      	mov	fp, r2
 8002082:	4264      	negs	r4, r4
 8002084:	46a4      	mov	ip, r4
 8002086:	44c3      	add	fp, r8
 8002088:	44dc      	add	ip, fp
 800208a:	428f      	cmp	r7, r1
 800208c:	41bf      	sbcs	r7, r7
 800208e:	4598      	cmp	r8, r3
 8002090:	419b      	sbcs	r3, r3
 8002092:	4593      	cmp	fp, r2
 8002094:	4192      	sbcs	r2, r2
 8002096:	45a4      	cmp	ip, r4
 8002098:	41a4      	sbcs	r4, r4
 800209a:	425b      	negs	r3, r3
 800209c:	427f      	negs	r7, r7
 800209e:	431f      	orrs	r7, r3
 80020a0:	0c36      	lsrs	r6, r6, #16
 80020a2:	4252      	negs	r2, r2
 80020a4:	4264      	negs	r4, r4
 80020a6:	19bf      	adds	r7, r7, r6
 80020a8:	4322      	orrs	r2, r4
 80020aa:	18bf      	adds	r7, r7, r2
 80020ac:	4662      	mov	r2, ip
 80020ae:	1838      	adds	r0, r7, r0
 80020b0:	0243      	lsls	r3, r0, #9
 80020b2:	0dd2      	lsrs	r2, r2, #23
 80020b4:	9903      	ldr	r1, [sp, #12]
 80020b6:	4313      	orrs	r3, r2
 80020b8:	026a      	lsls	r2, r5, #9
 80020ba:	430a      	orrs	r2, r1
 80020bc:	1e50      	subs	r0, r2, #1
 80020be:	4182      	sbcs	r2, r0
 80020c0:	4661      	mov	r1, ip
 80020c2:	0ded      	lsrs	r5, r5, #23
 80020c4:	432a      	orrs	r2, r5
 80020c6:	024e      	lsls	r6, r1, #9
 80020c8:	4332      	orrs	r2, r6
 80020ca:	01d9      	lsls	r1, r3, #7
 80020cc:	d400      	bmi.n	80020d0 <__aeabi_dmul+0x31c>
 80020ce:	e0b3      	b.n	8002238 <__aeabi_dmul+0x484>
 80020d0:	2601      	movs	r6, #1
 80020d2:	0850      	lsrs	r0, r2, #1
 80020d4:	4032      	ands	r2, r6
 80020d6:	4302      	orrs	r2, r0
 80020d8:	07de      	lsls	r6, r3, #31
 80020da:	4332      	orrs	r2, r6
 80020dc:	085b      	lsrs	r3, r3, #1
 80020de:	4c22      	ldr	r4, [pc, #136]	; (8002168 <__aeabi_dmul+0x3b4>)
 80020e0:	4454      	add	r4, sl
 80020e2:	2c00      	cmp	r4, #0
 80020e4:	dd62      	ble.n	80021ac <__aeabi_dmul+0x3f8>
 80020e6:	0751      	lsls	r1, r2, #29
 80020e8:	d009      	beq.n	80020fe <__aeabi_dmul+0x34a>
 80020ea:	200f      	movs	r0, #15
 80020ec:	4010      	ands	r0, r2
 80020ee:	2804      	cmp	r0, #4
 80020f0:	d005      	beq.n	80020fe <__aeabi_dmul+0x34a>
 80020f2:	1d10      	adds	r0, r2, #4
 80020f4:	4290      	cmp	r0, r2
 80020f6:	4192      	sbcs	r2, r2
 80020f8:	4252      	negs	r2, r2
 80020fa:	189b      	adds	r3, r3, r2
 80020fc:	0002      	movs	r2, r0
 80020fe:	01d9      	lsls	r1, r3, #7
 8002100:	d504      	bpl.n	800210c <__aeabi_dmul+0x358>
 8002102:	2480      	movs	r4, #128	; 0x80
 8002104:	4819      	ldr	r0, [pc, #100]	; (800216c <__aeabi_dmul+0x3b8>)
 8002106:	00e4      	lsls	r4, r4, #3
 8002108:	4003      	ands	r3, r0
 800210a:	4454      	add	r4, sl
 800210c:	4818      	ldr	r0, [pc, #96]	; (8002170 <__aeabi_dmul+0x3bc>)
 800210e:	4284      	cmp	r4, r0
 8002110:	dd00      	ble.n	8002114 <__aeabi_dmul+0x360>
 8002112:	e727      	b.n	8001f64 <__aeabi_dmul+0x1b0>
 8002114:	075e      	lsls	r6, r3, #29
 8002116:	025b      	lsls	r3, r3, #9
 8002118:	08d2      	lsrs	r2, r2, #3
 800211a:	0b1f      	lsrs	r7, r3, #12
 800211c:	0563      	lsls	r3, r4, #21
 800211e:	4316      	orrs	r6, r2
 8002120:	0d5b      	lsrs	r3, r3, #21
 8002122:	e6b2      	b.n	8001e8a <__aeabi_dmul+0xd6>
 8002124:	2300      	movs	r3, #0
 8002126:	4699      	mov	r9, r3
 8002128:	3301      	adds	r3, #1
 800212a:	2704      	movs	r7, #4
 800212c:	2600      	movs	r6, #0
 800212e:	469b      	mov	fp, r3
 8002130:	e664      	b.n	8001dfc <__aeabi_dmul+0x48>
 8002132:	2303      	movs	r3, #3
 8002134:	9701      	str	r7, [sp, #4]
 8002136:	4681      	mov	r9, r0
 8002138:	270c      	movs	r7, #12
 800213a:	469b      	mov	fp, r3
 800213c:	e65e      	b.n	8001dfc <__aeabi_dmul+0x48>
 800213e:	2201      	movs	r2, #1
 8002140:	2001      	movs	r0, #1
 8002142:	4317      	orrs	r7, r2
 8002144:	2200      	movs	r2, #0
 8002146:	e676      	b.n	8001e36 <__aeabi_dmul+0x82>
 8002148:	2303      	movs	r3, #3
 800214a:	2003      	movs	r0, #3
 800214c:	431f      	orrs	r7, r3
 800214e:	4643      	mov	r3, r8
 8002150:	e671      	b.n	8001e36 <__aeabi_dmul+0x82>
 8002152:	46c0      	nop			; (mov r8, r8)
 8002154:	000007ff 	.word	0x000007ff
 8002158:	fffffc01 	.word	0xfffffc01
 800215c:	08019078 	.word	0x08019078
 8002160:	800fffff 	.word	0x800fffff
 8002164:	fffffc0d 	.word	0xfffffc0d
 8002168:	000003ff 	.word	0x000003ff
 800216c:	feffffff 	.word	0xfeffffff
 8002170:	000007fe 	.word	0x000007fe
 8002174:	2300      	movs	r3, #0
 8002176:	2780      	movs	r7, #128	; 0x80
 8002178:	9300      	str	r3, [sp, #0]
 800217a:	033f      	lsls	r7, r7, #12
 800217c:	2600      	movs	r6, #0
 800217e:	4b43      	ldr	r3, [pc, #268]	; (800228c <__aeabi_dmul+0x4d8>)
 8002180:	e683      	b.n	8001e8a <__aeabi_dmul+0xd6>
 8002182:	9b01      	ldr	r3, [sp, #4]
 8002184:	0032      	movs	r2, r6
 8002186:	46a4      	mov	ip, r4
 8002188:	4658      	mov	r0, fp
 800218a:	e670      	b.n	8001e6e <__aeabi_dmul+0xba>
 800218c:	46ac      	mov	ip, r5
 800218e:	e66e      	b.n	8001e6e <__aeabi_dmul+0xba>
 8002190:	2780      	movs	r7, #128	; 0x80
 8002192:	9901      	ldr	r1, [sp, #4]
 8002194:	033f      	lsls	r7, r7, #12
 8002196:	4239      	tst	r1, r7
 8002198:	d02d      	beq.n	80021f6 <__aeabi_dmul+0x442>
 800219a:	423b      	tst	r3, r7
 800219c:	d12b      	bne.n	80021f6 <__aeabi_dmul+0x442>
 800219e:	431f      	orrs	r7, r3
 80021a0:	033f      	lsls	r7, r7, #12
 80021a2:	0b3f      	lsrs	r7, r7, #12
 80021a4:	9500      	str	r5, [sp, #0]
 80021a6:	0016      	movs	r6, r2
 80021a8:	4b38      	ldr	r3, [pc, #224]	; (800228c <__aeabi_dmul+0x4d8>)
 80021aa:	e66e      	b.n	8001e8a <__aeabi_dmul+0xd6>
 80021ac:	2501      	movs	r5, #1
 80021ae:	1b2d      	subs	r5, r5, r4
 80021b0:	2d38      	cmp	r5, #56	; 0x38
 80021b2:	dd00      	ble.n	80021b6 <__aeabi_dmul+0x402>
 80021b4:	e666      	b.n	8001e84 <__aeabi_dmul+0xd0>
 80021b6:	2d1f      	cmp	r5, #31
 80021b8:	dc40      	bgt.n	800223c <__aeabi_dmul+0x488>
 80021ba:	4835      	ldr	r0, [pc, #212]	; (8002290 <__aeabi_dmul+0x4dc>)
 80021bc:	001c      	movs	r4, r3
 80021be:	4450      	add	r0, sl
 80021c0:	0016      	movs	r6, r2
 80021c2:	4082      	lsls	r2, r0
 80021c4:	4084      	lsls	r4, r0
 80021c6:	40ee      	lsrs	r6, r5
 80021c8:	1e50      	subs	r0, r2, #1
 80021ca:	4182      	sbcs	r2, r0
 80021cc:	4334      	orrs	r4, r6
 80021ce:	4314      	orrs	r4, r2
 80021d0:	40eb      	lsrs	r3, r5
 80021d2:	0762      	lsls	r2, r4, #29
 80021d4:	d009      	beq.n	80021ea <__aeabi_dmul+0x436>
 80021d6:	220f      	movs	r2, #15
 80021d8:	4022      	ands	r2, r4
 80021da:	2a04      	cmp	r2, #4
 80021dc:	d005      	beq.n	80021ea <__aeabi_dmul+0x436>
 80021de:	0022      	movs	r2, r4
 80021e0:	1d14      	adds	r4, r2, #4
 80021e2:	4294      	cmp	r4, r2
 80021e4:	4180      	sbcs	r0, r0
 80021e6:	4240      	negs	r0, r0
 80021e8:	181b      	adds	r3, r3, r0
 80021ea:	021a      	lsls	r2, r3, #8
 80021ec:	d53e      	bpl.n	800226c <__aeabi_dmul+0x4b8>
 80021ee:	2301      	movs	r3, #1
 80021f0:	2700      	movs	r7, #0
 80021f2:	2600      	movs	r6, #0
 80021f4:	e649      	b.n	8001e8a <__aeabi_dmul+0xd6>
 80021f6:	2780      	movs	r7, #128	; 0x80
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	033f      	lsls	r7, r7, #12
 80021fc:	431f      	orrs	r7, r3
 80021fe:	033f      	lsls	r7, r7, #12
 8002200:	0b3f      	lsrs	r7, r7, #12
 8002202:	9400      	str	r4, [sp, #0]
 8002204:	4b21      	ldr	r3, [pc, #132]	; (800228c <__aeabi_dmul+0x4d8>)
 8002206:	e640      	b.n	8001e8a <__aeabi_dmul+0xd6>
 8002208:	0003      	movs	r3, r0
 800220a:	465a      	mov	r2, fp
 800220c:	3b28      	subs	r3, #40	; 0x28
 800220e:	409a      	lsls	r2, r3
 8002210:	2600      	movs	r6, #0
 8002212:	9201      	str	r2, [sp, #4]
 8002214:	e66d      	b.n	8001ef2 <__aeabi_dmul+0x13e>
 8002216:	4658      	mov	r0, fp
 8002218:	f000 fd1a 	bl	8002c50 <__clzsi2>
 800221c:	3020      	adds	r0, #32
 800221e:	e657      	b.n	8001ed0 <__aeabi_dmul+0x11c>
 8002220:	0003      	movs	r3, r0
 8002222:	4652      	mov	r2, sl
 8002224:	3b28      	subs	r3, #40	; 0x28
 8002226:	409a      	lsls	r2, r3
 8002228:	0013      	movs	r3, r2
 800222a:	2200      	movs	r2, #0
 800222c:	e693      	b.n	8001f56 <__aeabi_dmul+0x1a2>
 800222e:	4650      	mov	r0, sl
 8002230:	f000 fd0e 	bl	8002c50 <__clzsi2>
 8002234:	3020      	adds	r0, #32
 8002236:	e67b      	b.n	8001f30 <__aeabi_dmul+0x17c>
 8002238:	46ca      	mov	sl, r9
 800223a:	e750      	b.n	80020de <__aeabi_dmul+0x32a>
 800223c:	201f      	movs	r0, #31
 800223e:	001e      	movs	r6, r3
 8002240:	4240      	negs	r0, r0
 8002242:	1b04      	subs	r4, r0, r4
 8002244:	40e6      	lsrs	r6, r4
 8002246:	2d20      	cmp	r5, #32
 8002248:	d003      	beq.n	8002252 <__aeabi_dmul+0x49e>
 800224a:	4c12      	ldr	r4, [pc, #72]	; (8002294 <__aeabi_dmul+0x4e0>)
 800224c:	4454      	add	r4, sl
 800224e:	40a3      	lsls	r3, r4
 8002250:	431a      	orrs	r2, r3
 8002252:	1e50      	subs	r0, r2, #1
 8002254:	4182      	sbcs	r2, r0
 8002256:	4332      	orrs	r2, r6
 8002258:	2607      	movs	r6, #7
 800225a:	2700      	movs	r7, #0
 800225c:	4016      	ands	r6, r2
 800225e:	d009      	beq.n	8002274 <__aeabi_dmul+0x4c0>
 8002260:	200f      	movs	r0, #15
 8002262:	2300      	movs	r3, #0
 8002264:	4010      	ands	r0, r2
 8002266:	0014      	movs	r4, r2
 8002268:	2804      	cmp	r0, #4
 800226a:	d1b9      	bne.n	80021e0 <__aeabi_dmul+0x42c>
 800226c:	0022      	movs	r2, r4
 800226e:	075e      	lsls	r6, r3, #29
 8002270:	025b      	lsls	r3, r3, #9
 8002272:	0b1f      	lsrs	r7, r3, #12
 8002274:	08d2      	lsrs	r2, r2, #3
 8002276:	4316      	orrs	r6, r2
 8002278:	2300      	movs	r3, #0
 800227a:	e606      	b.n	8001e8a <__aeabi_dmul+0xd6>
 800227c:	2780      	movs	r7, #128	; 0x80
 800227e:	033f      	lsls	r7, r7, #12
 8002280:	431f      	orrs	r7, r3
 8002282:	033f      	lsls	r7, r7, #12
 8002284:	0b3f      	lsrs	r7, r7, #12
 8002286:	0016      	movs	r6, r2
 8002288:	4b00      	ldr	r3, [pc, #0]	; (800228c <__aeabi_dmul+0x4d8>)
 800228a:	e5fe      	b.n	8001e8a <__aeabi_dmul+0xd6>
 800228c:	000007ff 	.word	0x000007ff
 8002290:	0000041e 	.word	0x0000041e
 8002294:	0000043e 	.word	0x0000043e

08002298 <__aeabi_dsub>:
 8002298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800229a:	4657      	mov	r7, sl
 800229c:	464e      	mov	r6, r9
 800229e:	4645      	mov	r5, r8
 80022a0:	46de      	mov	lr, fp
 80022a2:	000c      	movs	r4, r1
 80022a4:	0309      	lsls	r1, r1, #12
 80022a6:	b5e0      	push	{r5, r6, r7, lr}
 80022a8:	0a49      	lsrs	r1, r1, #9
 80022aa:	0f46      	lsrs	r6, r0, #29
 80022ac:	005f      	lsls	r7, r3, #1
 80022ae:	4331      	orrs	r1, r6
 80022b0:	031e      	lsls	r6, r3, #12
 80022b2:	0fdb      	lsrs	r3, r3, #31
 80022b4:	0a76      	lsrs	r6, r6, #9
 80022b6:	469b      	mov	fp, r3
 80022b8:	0f53      	lsrs	r3, r2, #29
 80022ba:	4333      	orrs	r3, r6
 80022bc:	4ec8      	ldr	r6, [pc, #800]	; (80025e0 <__aeabi_dsub+0x348>)
 80022be:	0065      	lsls	r5, r4, #1
 80022c0:	00c0      	lsls	r0, r0, #3
 80022c2:	0fe4      	lsrs	r4, r4, #31
 80022c4:	00d2      	lsls	r2, r2, #3
 80022c6:	0d6d      	lsrs	r5, r5, #21
 80022c8:	46a2      	mov	sl, r4
 80022ca:	4681      	mov	r9, r0
 80022cc:	0d7f      	lsrs	r7, r7, #21
 80022ce:	469c      	mov	ip, r3
 80022d0:	4690      	mov	r8, r2
 80022d2:	42b7      	cmp	r7, r6
 80022d4:	d100      	bne.n	80022d8 <__aeabi_dsub+0x40>
 80022d6:	e0b9      	b.n	800244c <__aeabi_dsub+0x1b4>
 80022d8:	465b      	mov	r3, fp
 80022da:	2601      	movs	r6, #1
 80022dc:	4073      	eors	r3, r6
 80022de:	469b      	mov	fp, r3
 80022e0:	1bee      	subs	r6, r5, r7
 80022e2:	45a3      	cmp	fp, r4
 80022e4:	d100      	bne.n	80022e8 <__aeabi_dsub+0x50>
 80022e6:	e083      	b.n	80023f0 <__aeabi_dsub+0x158>
 80022e8:	2e00      	cmp	r6, #0
 80022ea:	dd63      	ble.n	80023b4 <__aeabi_dsub+0x11c>
 80022ec:	2f00      	cmp	r7, #0
 80022ee:	d000      	beq.n	80022f2 <__aeabi_dsub+0x5a>
 80022f0:	e0b1      	b.n	8002456 <__aeabi_dsub+0x1be>
 80022f2:	4663      	mov	r3, ip
 80022f4:	4313      	orrs	r3, r2
 80022f6:	d100      	bne.n	80022fa <__aeabi_dsub+0x62>
 80022f8:	e123      	b.n	8002542 <__aeabi_dsub+0x2aa>
 80022fa:	1e73      	subs	r3, r6, #1
 80022fc:	2b00      	cmp	r3, #0
 80022fe:	d000      	beq.n	8002302 <__aeabi_dsub+0x6a>
 8002300:	e1ba      	b.n	8002678 <__aeabi_dsub+0x3e0>
 8002302:	1a86      	subs	r6, r0, r2
 8002304:	4663      	mov	r3, ip
 8002306:	42b0      	cmp	r0, r6
 8002308:	4180      	sbcs	r0, r0
 800230a:	2501      	movs	r5, #1
 800230c:	1ac9      	subs	r1, r1, r3
 800230e:	4240      	negs	r0, r0
 8002310:	1a09      	subs	r1, r1, r0
 8002312:	020b      	lsls	r3, r1, #8
 8002314:	d400      	bmi.n	8002318 <__aeabi_dsub+0x80>
 8002316:	e147      	b.n	80025a8 <__aeabi_dsub+0x310>
 8002318:	0249      	lsls	r1, r1, #9
 800231a:	0a4b      	lsrs	r3, r1, #9
 800231c:	4698      	mov	r8, r3
 800231e:	4643      	mov	r3, r8
 8002320:	2b00      	cmp	r3, #0
 8002322:	d100      	bne.n	8002326 <__aeabi_dsub+0x8e>
 8002324:	e189      	b.n	800263a <__aeabi_dsub+0x3a2>
 8002326:	4640      	mov	r0, r8
 8002328:	f000 fc92 	bl	8002c50 <__clzsi2>
 800232c:	0003      	movs	r3, r0
 800232e:	3b08      	subs	r3, #8
 8002330:	2b1f      	cmp	r3, #31
 8002332:	dd00      	ble.n	8002336 <__aeabi_dsub+0x9e>
 8002334:	e17c      	b.n	8002630 <__aeabi_dsub+0x398>
 8002336:	2220      	movs	r2, #32
 8002338:	0030      	movs	r0, r6
 800233a:	1ad2      	subs	r2, r2, r3
 800233c:	4641      	mov	r1, r8
 800233e:	40d0      	lsrs	r0, r2
 8002340:	4099      	lsls	r1, r3
 8002342:	0002      	movs	r2, r0
 8002344:	409e      	lsls	r6, r3
 8002346:	430a      	orrs	r2, r1
 8002348:	429d      	cmp	r5, r3
 800234a:	dd00      	ble.n	800234e <__aeabi_dsub+0xb6>
 800234c:	e16a      	b.n	8002624 <__aeabi_dsub+0x38c>
 800234e:	1b5d      	subs	r5, r3, r5
 8002350:	1c6b      	adds	r3, r5, #1
 8002352:	2b1f      	cmp	r3, #31
 8002354:	dd00      	ble.n	8002358 <__aeabi_dsub+0xc0>
 8002356:	e194      	b.n	8002682 <__aeabi_dsub+0x3ea>
 8002358:	2120      	movs	r1, #32
 800235a:	0010      	movs	r0, r2
 800235c:	0035      	movs	r5, r6
 800235e:	1ac9      	subs	r1, r1, r3
 8002360:	408e      	lsls	r6, r1
 8002362:	40da      	lsrs	r2, r3
 8002364:	4088      	lsls	r0, r1
 8002366:	40dd      	lsrs	r5, r3
 8002368:	1e71      	subs	r1, r6, #1
 800236a:	418e      	sbcs	r6, r1
 800236c:	0011      	movs	r1, r2
 800236e:	2207      	movs	r2, #7
 8002370:	4328      	orrs	r0, r5
 8002372:	2500      	movs	r5, #0
 8002374:	4306      	orrs	r6, r0
 8002376:	4032      	ands	r2, r6
 8002378:	2a00      	cmp	r2, #0
 800237a:	d009      	beq.n	8002390 <__aeabi_dsub+0xf8>
 800237c:	230f      	movs	r3, #15
 800237e:	4033      	ands	r3, r6
 8002380:	2b04      	cmp	r3, #4
 8002382:	d005      	beq.n	8002390 <__aeabi_dsub+0xf8>
 8002384:	1d33      	adds	r3, r6, #4
 8002386:	42b3      	cmp	r3, r6
 8002388:	41b6      	sbcs	r6, r6
 800238a:	4276      	negs	r6, r6
 800238c:	1989      	adds	r1, r1, r6
 800238e:	001e      	movs	r6, r3
 8002390:	020b      	lsls	r3, r1, #8
 8002392:	d400      	bmi.n	8002396 <__aeabi_dsub+0xfe>
 8002394:	e23d      	b.n	8002812 <__aeabi_dsub+0x57a>
 8002396:	1c6a      	adds	r2, r5, #1
 8002398:	4b91      	ldr	r3, [pc, #580]	; (80025e0 <__aeabi_dsub+0x348>)
 800239a:	0555      	lsls	r5, r2, #21
 800239c:	0d6d      	lsrs	r5, r5, #21
 800239e:	429a      	cmp	r2, r3
 80023a0:	d100      	bne.n	80023a4 <__aeabi_dsub+0x10c>
 80023a2:	e119      	b.n	80025d8 <__aeabi_dsub+0x340>
 80023a4:	4a8f      	ldr	r2, [pc, #572]	; (80025e4 <__aeabi_dsub+0x34c>)
 80023a6:	08f6      	lsrs	r6, r6, #3
 80023a8:	400a      	ands	r2, r1
 80023aa:	0757      	lsls	r7, r2, #29
 80023ac:	0252      	lsls	r2, r2, #9
 80023ae:	4337      	orrs	r7, r6
 80023b0:	0b12      	lsrs	r2, r2, #12
 80023b2:	e09b      	b.n	80024ec <__aeabi_dsub+0x254>
 80023b4:	2e00      	cmp	r6, #0
 80023b6:	d000      	beq.n	80023ba <__aeabi_dsub+0x122>
 80023b8:	e0c5      	b.n	8002546 <__aeabi_dsub+0x2ae>
 80023ba:	1c6e      	adds	r6, r5, #1
 80023bc:	0576      	lsls	r6, r6, #21
 80023be:	0d76      	lsrs	r6, r6, #21
 80023c0:	2e01      	cmp	r6, #1
 80023c2:	dc00      	bgt.n	80023c6 <__aeabi_dsub+0x12e>
 80023c4:	e148      	b.n	8002658 <__aeabi_dsub+0x3c0>
 80023c6:	4667      	mov	r7, ip
 80023c8:	1a86      	subs	r6, r0, r2
 80023ca:	1bcb      	subs	r3, r1, r7
 80023cc:	42b0      	cmp	r0, r6
 80023ce:	41bf      	sbcs	r7, r7
 80023d0:	427f      	negs	r7, r7
 80023d2:	46b8      	mov	r8, r7
 80023d4:	001f      	movs	r7, r3
 80023d6:	4643      	mov	r3, r8
 80023d8:	1aff      	subs	r7, r7, r3
 80023da:	003b      	movs	r3, r7
 80023dc:	46b8      	mov	r8, r7
 80023de:	021b      	lsls	r3, r3, #8
 80023e0:	d500      	bpl.n	80023e4 <__aeabi_dsub+0x14c>
 80023e2:	e15f      	b.n	80026a4 <__aeabi_dsub+0x40c>
 80023e4:	4337      	orrs	r7, r6
 80023e6:	d19a      	bne.n	800231e <__aeabi_dsub+0x86>
 80023e8:	2200      	movs	r2, #0
 80023ea:	2400      	movs	r4, #0
 80023ec:	2500      	movs	r5, #0
 80023ee:	e079      	b.n	80024e4 <__aeabi_dsub+0x24c>
 80023f0:	2e00      	cmp	r6, #0
 80023f2:	dc00      	bgt.n	80023f6 <__aeabi_dsub+0x15e>
 80023f4:	e0fa      	b.n	80025ec <__aeabi_dsub+0x354>
 80023f6:	2f00      	cmp	r7, #0
 80023f8:	d100      	bne.n	80023fc <__aeabi_dsub+0x164>
 80023fa:	e08d      	b.n	8002518 <__aeabi_dsub+0x280>
 80023fc:	4b78      	ldr	r3, [pc, #480]	; (80025e0 <__aeabi_dsub+0x348>)
 80023fe:	429d      	cmp	r5, r3
 8002400:	d067      	beq.n	80024d2 <__aeabi_dsub+0x23a>
 8002402:	2380      	movs	r3, #128	; 0x80
 8002404:	4667      	mov	r7, ip
 8002406:	041b      	lsls	r3, r3, #16
 8002408:	431f      	orrs	r7, r3
 800240a:	46bc      	mov	ip, r7
 800240c:	2e38      	cmp	r6, #56	; 0x38
 800240e:	dc00      	bgt.n	8002412 <__aeabi_dsub+0x17a>
 8002410:	e152      	b.n	80026b8 <__aeabi_dsub+0x420>
 8002412:	4663      	mov	r3, ip
 8002414:	4313      	orrs	r3, r2
 8002416:	1e5a      	subs	r2, r3, #1
 8002418:	4193      	sbcs	r3, r2
 800241a:	181e      	adds	r6, r3, r0
 800241c:	4286      	cmp	r6, r0
 800241e:	4180      	sbcs	r0, r0
 8002420:	4240      	negs	r0, r0
 8002422:	1809      	adds	r1, r1, r0
 8002424:	020b      	lsls	r3, r1, #8
 8002426:	d400      	bmi.n	800242a <__aeabi_dsub+0x192>
 8002428:	e0be      	b.n	80025a8 <__aeabi_dsub+0x310>
 800242a:	4b6d      	ldr	r3, [pc, #436]	; (80025e0 <__aeabi_dsub+0x348>)
 800242c:	3501      	adds	r5, #1
 800242e:	429d      	cmp	r5, r3
 8002430:	d100      	bne.n	8002434 <__aeabi_dsub+0x19c>
 8002432:	e0d2      	b.n	80025da <__aeabi_dsub+0x342>
 8002434:	4a6b      	ldr	r2, [pc, #428]	; (80025e4 <__aeabi_dsub+0x34c>)
 8002436:	0873      	lsrs	r3, r6, #1
 8002438:	400a      	ands	r2, r1
 800243a:	2101      	movs	r1, #1
 800243c:	400e      	ands	r6, r1
 800243e:	431e      	orrs	r6, r3
 8002440:	0851      	lsrs	r1, r2, #1
 8002442:	07d3      	lsls	r3, r2, #31
 8002444:	2207      	movs	r2, #7
 8002446:	431e      	orrs	r6, r3
 8002448:	4032      	ands	r2, r6
 800244a:	e795      	b.n	8002378 <__aeabi_dsub+0xe0>
 800244c:	001e      	movs	r6, r3
 800244e:	4316      	orrs	r6, r2
 8002450:	d000      	beq.n	8002454 <__aeabi_dsub+0x1bc>
 8002452:	e745      	b.n	80022e0 <__aeabi_dsub+0x48>
 8002454:	e740      	b.n	80022d8 <__aeabi_dsub+0x40>
 8002456:	4b62      	ldr	r3, [pc, #392]	; (80025e0 <__aeabi_dsub+0x348>)
 8002458:	429d      	cmp	r5, r3
 800245a:	d03a      	beq.n	80024d2 <__aeabi_dsub+0x23a>
 800245c:	2380      	movs	r3, #128	; 0x80
 800245e:	4667      	mov	r7, ip
 8002460:	041b      	lsls	r3, r3, #16
 8002462:	431f      	orrs	r7, r3
 8002464:	46bc      	mov	ip, r7
 8002466:	2e38      	cmp	r6, #56	; 0x38
 8002468:	dd00      	ble.n	800246c <__aeabi_dsub+0x1d4>
 800246a:	e0eb      	b.n	8002644 <__aeabi_dsub+0x3ac>
 800246c:	2e1f      	cmp	r6, #31
 800246e:	dc00      	bgt.n	8002472 <__aeabi_dsub+0x1da>
 8002470:	e13a      	b.n	80026e8 <__aeabi_dsub+0x450>
 8002472:	0033      	movs	r3, r6
 8002474:	4667      	mov	r7, ip
 8002476:	3b20      	subs	r3, #32
 8002478:	40df      	lsrs	r7, r3
 800247a:	003b      	movs	r3, r7
 800247c:	2e20      	cmp	r6, #32
 800247e:	d005      	beq.n	800248c <__aeabi_dsub+0x1f4>
 8002480:	2740      	movs	r7, #64	; 0x40
 8002482:	1bbf      	subs	r7, r7, r6
 8002484:	4666      	mov	r6, ip
 8002486:	40be      	lsls	r6, r7
 8002488:	4332      	orrs	r2, r6
 800248a:	4690      	mov	r8, r2
 800248c:	4646      	mov	r6, r8
 800248e:	1e72      	subs	r2, r6, #1
 8002490:	4196      	sbcs	r6, r2
 8002492:	4333      	orrs	r3, r6
 8002494:	e0da      	b.n	800264c <__aeabi_dsub+0x3b4>
 8002496:	2b00      	cmp	r3, #0
 8002498:	d100      	bne.n	800249c <__aeabi_dsub+0x204>
 800249a:	e214      	b.n	80028c6 <__aeabi_dsub+0x62e>
 800249c:	4663      	mov	r3, ip
 800249e:	4313      	orrs	r3, r2
 80024a0:	d100      	bne.n	80024a4 <__aeabi_dsub+0x20c>
 80024a2:	e168      	b.n	8002776 <__aeabi_dsub+0x4de>
 80024a4:	2380      	movs	r3, #128	; 0x80
 80024a6:	074e      	lsls	r6, r1, #29
 80024a8:	08c0      	lsrs	r0, r0, #3
 80024aa:	08c9      	lsrs	r1, r1, #3
 80024ac:	031b      	lsls	r3, r3, #12
 80024ae:	4306      	orrs	r6, r0
 80024b0:	4219      	tst	r1, r3
 80024b2:	d008      	beq.n	80024c6 <__aeabi_dsub+0x22e>
 80024b4:	4660      	mov	r0, ip
 80024b6:	08c0      	lsrs	r0, r0, #3
 80024b8:	4218      	tst	r0, r3
 80024ba:	d104      	bne.n	80024c6 <__aeabi_dsub+0x22e>
 80024bc:	4663      	mov	r3, ip
 80024be:	0001      	movs	r1, r0
 80024c0:	08d2      	lsrs	r2, r2, #3
 80024c2:	075e      	lsls	r6, r3, #29
 80024c4:	4316      	orrs	r6, r2
 80024c6:	00f3      	lsls	r3, r6, #3
 80024c8:	4699      	mov	r9, r3
 80024ca:	00c9      	lsls	r1, r1, #3
 80024cc:	0f72      	lsrs	r2, r6, #29
 80024ce:	4d44      	ldr	r5, [pc, #272]	; (80025e0 <__aeabi_dsub+0x348>)
 80024d0:	4311      	orrs	r1, r2
 80024d2:	464b      	mov	r3, r9
 80024d4:	08de      	lsrs	r6, r3, #3
 80024d6:	4b42      	ldr	r3, [pc, #264]	; (80025e0 <__aeabi_dsub+0x348>)
 80024d8:	074f      	lsls	r7, r1, #29
 80024da:	4337      	orrs	r7, r6
 80024dc:	08ca      	lsrs	r2, r1, #3
 80024de:	429d      	cmp	r5, r3
 80024e0:	d100      	bne.n	80024e4 <__aeabi_dsub+0x24c>
 80024e2:	e06e      	b.n	80025c2 <__aeabi_dsub+0x32a>
 80024e4:	0312      	lsls	r2, r2, #12
 80024e6:	056d      	lsls	r5, r5, #21
 80024e8:	0b12      	lsrs	r2, r2, #12
 80024ea:	0d6d      	lsrs	r5, r5, #21
 80024ec:	2100      	movs	r1, #0
 80024ee:	0312      	lsls	r2, r2, #12
 80024f0:	0b13      	lsrs	r3, r2, #12
 80024f2:	0d0a      	lsrs	r2, r1, #20
 80024f4:	0512      	lsls	r2, r2, #20
 80024f6:	431a      	orrs	r2, r3
 80024f8:	4b3b      	ldr	r3, [pc, #236]	; (80025e8 <__aeabi_dsub+0x350>)
 80024fa:	052d      	lsls	r5, r5, #20
 80024fc:	4013      	ands	r3, r2
 80024fe:	432b      	orrs	r3, r5
 8002500:	005b      	lsls	r3, r3, #1
 8002502:	07e4      	lsls	r4, r4, #31
 8002504:	085b      	lsrs	r3, r3, #1
 8002506:	4323      	orrs	r3, r4
 8002508:	0038      	movs	r0, r7
 800250a:	0019      	movs	r1, r3
 800250c:	bc3c      	pop	{r2, r3, r4, r5}
 800250e:	4690      	mov	r8, r2
 8002510:	4699      	mov	r9, r3
 8002512:	46a2      	mov	sl, r4
 8002514:	46ab      	mov	fp, r5
 8002516:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002518:	4663      	mov	r3, ip
 800251a:	4313      	orrs	r3, r2
 800251c:	d011      	beq.n	8002542 <__aeabi_dsub+0x2aa>
 800251e:	1e73      	subs	r3, r6, #1
 8002520:	2b00      	cmp	r3, #0
 8002522:	d000      	beq.n	8002526 <__aeabi_dsub+0x28e>
 8002524:	e107      	b.n	8002736 <__aeabi_dsub+0x49e>
 8002526:	1886      	adds	r6, r0, r2
 8002528:	4286      	cmp	r6, r0
 800252a:	4180      	sbcs	r0, r0
 800252c:	4461      	add	r1, ip
 800252e:	4240      	negs	r0, r0
 8002530:	1809      	adds	r1, r1, r0
 8002532:	2501      	movs	r5, #1
 8002534:	020b      	lsls	r3, r1, #8
 8002536:	d537      	bpl.n	80025a8 <__aeabi_dsub+0x310>
 8002538:	2502      	movs	r5, #2
 800253a:	e77b      	b.n	8002434 <__aeabi_dsub+0x19c>
 800253c:	003e      	movs	r6, r7
 800253e:	4661      	mov	r1, ip
 8002540:	4691      	mov	r9, r2
 8002542:	0035      	movs	r5, r6
 8002544:	e7c5      	b.n	80024d2 <__aeabi_dsub+0x23a>
 8002546:	465c      	mov	r4, fp
 8002548:	2d00      	cmp	r5, #0
 800254a:	d000      	beq.n	800254e <__aeabi_dsub+0x2b6>
 800254c:	e0e1      	b.n	8002712 <__aeabi_dsub+0x47a>
 800254e:	000b      	movs	r3, r1
 8002550:	4303      	orrs	r3, r0
 8002552:	d0f3      	beq.n	800253c <__aeabi_dsub+0x2a4>
 8002554:	1c73      	adds	r3, r6, #1
 8002556:	d100      	bne.n	800255a <__aeabi_dsub+0x2c2>
 8002558:	e1ac      	b.n	80028b4 <__aeabi_dsub+0x61c>
 800255a:	4b21      	ldr	r3, [pc, #132]	; (80025e0 <__aeabi_dsub+0x348>)
 800255c:	429f      	cmp	r7, r3
 800255e:	d100      	bne.n	8002562 <__aeabi_dsub+0x2ca>
 8002560:	e13a      	b.n	80027d8 <__aeabi_dsub+0x540>
 8002562:	43f3      	mvns	r3, r6
 8002564:	2b38      	cmp	r3, #56	; 0x38
 8002566:	dd00      	ble.n	800256a <__aeabi_dsub+0x2d2>
 8002568:	e16f      	b.n	800284a <__aeabi_dsub+0x5b2>
 800256a:	2b1f      	cmp	r3, #31
 800256c:	dd00      	ble.n	8002570 <__aeabi_dsub+0x2d8>
 800256e:	e18c      	b.n	800288a <__aeabi_dsub+0x5f2>
 8002570:	2520      	movs	r5, #32
 8002572:	000e      	movs	r6, r1
 8002574:	1aed      	subs	r5, r5, r3
 8002576:	40ae      	lsls	r6, r5
 8002578:	46b0      	mov	r8, r6
 800257a:	0006      	movs	r6, r0
 800257c:	46aa      	mov	sl, r5
 800257e:	40de      	lsrs	r6, r3
 8002580:	4645      	mov	r5, r8
 8002582:	4335      	orrs	r5, r6
 8002584:	002e      	movs	r6, r5
 8002586:	4655      	mov	r5, sl
 8002588:	40d9      	lsrs	r1, r3
 800258a:	40a8      	lsls	r0, r5
 800258c:	4663      	mov	r3, ip
 800258e:	1e45      	subs	r5, r0, #1
 8002590:	41a8      	sbcs	r0, r5
 8002592:	1a5b      	subs	r3, r3, r1
 8002594:	469c      	mov	ip, r3
 8002596:	4330      	orrs	r0, r6
 8002598:	1a16      	subs	r6, r2, r0
 800259a:	42b2      	cmp	r2, r6
 800259c:	4192      	sbcs	r2, r2
 800259e:	4663      	mov	r3, ip
 80025a0:	4252      	negs	r2, r2
 80025a2:	1a99      	subs	r1, r3, r2
 80025a4:	003d      	movs	r5, r7
 80025a6:	e6b4      	b.n	8002312 <__aeabi_dsub+0x7a>
 80025a8:	2207      	movs	r2, #7
 80025aa:	4032      	ands	r2, r6
 80025ac:	2a00      	cmp	r2, #0
 80025ae:	d000      	beq.n	80025b2 <__aeabi_dsub+0x31a>
 80025b0:	e6e4      	b.n	800237c <__aeabi_dsub+0xe4>
 80025b2:	4b0b      	ldr	r3, [pc, #44]	; (80025e0 <__aeabi_dsub+0x348>)
 80025b4:	08f6      	lsrs	r6, r6, #3
 80025b6:	074f      	lsls	r7, r1, #29
 80025b8:	4337      	orrs	r7, r6
 80025ba:	08ca      	lsrs	r2, r1, #3
 80025bc:	429d      	cmp	r5, r3
 80025be:	d000      	beq.n	80025c2 <__aeabi_dsub+0x32a>
 80025c0:	e790      	b.n	80024e4 <__aeabi_dsub+0x24c>
 80025c2:	003b      	movs	r3, r7
 80025c4:	4313      	orrs	r3, r2
 80025c6:	d100      	bne.n	80025ca <__aeabi_dsub+0x332>
 80025c8:	e1a6      	b.n	8002918 <__aeabi_dsub+0x680>
 80025ca:	2380      	movs	r3, #128	; 0x80
 80025cc:	031b      	lsls	r3, r3, #12
 80025ce:	431a      	orrs	r2, r3
 80025d0:	0312      	lsls	r2, r2, #12
 80025d2:	0b12      	lsrs	r2, r2, #12
 80025d4:	4d02      	ldr	r5, [pc, #8]	; (80025e0 <__aeabi_dsub+0x348>)
 80025d6:	e789      	b.n	80024ec <__aeabi_dsub+0x254>
 80025d8:	0015      	movs	r5, r2
 80025da:	2200      	movs	r2, #0
 80025dc:	2700      	movs	r7, #0
 80025de:	e785      	b.n	80024ec <__aeabi_dsub+0x254>
 80025e0:	000007ff 	.word	0x000007ff
 80025e4:	ff7fffff 	.word	0xff7fffff
 80025e8:	800fffff 	.word	0x800fffff
 80025ec:	2e00      	cmp	r6, #0
 80025ee:	d000      	beq.n	80025f2 <__aeabi_dsub+0x35a>
 80025f0:	e0c7      	b.n	8002782 <__aeabi_dsub+0x4ea>
 80025f2:	1c6b      	adds	r3, r5, #1
 80025f4:	055e      	lsls	r6, r3, #21
 80025f6:	0d76      	lsrs	r6, r6, #21
 80025f8:	2e01      	cmp	r6, #1
 80025fa:	dc00      	bgt.n	80025fe <__aeabi_dsub+0x366>
 80025fc:	e0f0      	b.n	80027e0 <__aeabi_dsub+0x548>
 80025fe:	4dc8      	ldr	r5, [pc, #800]	; (8002920 <__aeabi_dsub+0x688>)
 8002600:	42ab      	cmp	r3, r5
 8002602:	d100      	bne.n	8002606 <__aeabi_dsub+0x36e>
 8002604:	e0b9      	b.n	800277a <__aeabi_dsub+0x4e2>
 8002606:	1885      	adds	r5, r0, r2
 8002608:	000a      	movs	r2, r1
 800260a:	4285      	cmp	r5, r0
 800260c:	4189      	sbcs	r1, r1
 800260e:	4462      	add	r2, ip
 8002610:	4249      	negs	r1, r1
 8002612:	1851      	adds	r1, r2, r1
 8002614:	2207      	movs	r2, #7
 8002616:	07ce      	lsls	r6, r1, #31
 8002618:	086d      	lsrs	r5, r5, #1
 800261a:	432e      	orrs	r6, r5
 800261c:	0849      	lsrs	r1, r1, #1
 800261e:	4032      	ands	r2, r6
 8002620:	001d      	movs	r5, r3
 8002622:	e6a9      	b.n	8002378 <__aeabi_dsub+0xe0>
 8002624:	49bf      	ldr	r1, [pc, #764]	; (8002924 <__aeabi_dsub+0x68c>)
 8002626:	1aed      	subs	r5, r5, r3
 8002628:	4011      	ands	r1, r2
 800262a:	2207      	movs	r2, #7
 800262c:	4032      	ands	r2, r6
 800262e:	e6a3      	b.n	8002378 <__aeabi_dsub+0xe0>
 8002630:	0032      	movs	r2, r6
 8002632:	3828      	subs	r0, #40	; 0x28
 8002634:	4082      	lsls	r2, r0
 8002636:	2600      	movs	r6, #0
 8002638:	e686      	b.n	8002348 <__aeabi_dsub+0xb0>
 800263a:	0030      	movs	r0, r6
 800263c:	f000 fb08 	bl	8002c50 <__clzsi2>
 8002640:	3020      	adds	r0, #32
 8002642:	e673      	b.n	800232c <__aeabi_dsub+0x94>
 8002644:	4663      	mov	r3, ip
 8002646:	4313      	orrs	r3, r2
 8002648:	1e5a      	subs	r2, r3, #1
 800264a:	4193      	sbcs	r3, r2
 800264c:	1ac6      	subs	r6, r0, r3
 800264e:	42b0      	cmp	r0, r6
 8002650:	4180      	sbcs	r0, r0
 8002652:	4240      	negs	r0, r0
 8002654:	1a09      	subs	r1, r1, r0
 8002656:	e65c      	b.n	8002312 <__aeabi_dsub+0x7a>
 8002658:	000e      	movs	r6, r1
 800265a:	4667      	mov	r7, ip
 800265c:	4306      	orrs	r6, r0
 800265e:	4317      	orrs	r7, r2
 8002660:	2d00      	cmp	r5, #0
 8002662:	d15e      	bne.n	8002722 <__aeabi_dsub+0x48a>
 8002664:	2e00      	cmp	r6, #0
 8002666:	d000      	beq.n	800266a <__aeabi_dsub+0x3d2>
 8002668:	e0f3      	b.n	8002852 <__aeabi_dsub+0x5ba>
 800266a:	2f00      	cmp	r7, #0
 800266c:	d100      	bne.n	8002670 <__aeabi_dsub+0x3d8>
 800266e:	e11e      	b.n	80028ae <__aeabi_dsub+0x616>
 8002670:	465c      	mov	r4, fp
 8002672:	4661      	mov	r1, ip
 8002674:	4691      	mov	r9, r2
 8002676:	e72c      	b.n	80024d2 <__aeabi_dsub+0x23a>
 8002678:	4fa9      	ldr	r7, [pc, #676]	; (8002920 <__aeabi_dsub+0x688>)
 800267a:	42be      	cmp	r6, r7
 800267c:	d07b      	beq.n	8002776 <__aeabi_dsub+0x4de>
 800267e:	001e      	movs	r6, r3
 8002680:	e6f1      	b.n	8002466 <__aeabi_dsub+0x1ce>
 8002682:	0010      	movs	r0, r2
 8002684:	3d1f      	subs	r5, #31
 8002686:	40e8      	lsrs	r0, r5
 8002688:	2b20      	cmp	r3, #32
 800268a:	d003      	beq.n	8002694 <__aeabi_dsub+0x3fc>
 800268c:	2140      	movs	r1, #64	; 0x40
 800268e:	1acb      	subs	r3, r1, r3
 8002690:	409a      	lsls	r2, r3
 8002692:	4316      	orrs	r6, r2
 8002694:	1e73      	subs	r3, r6, #1
 8002696:	419e      	sbcs	r6, r3
 8002698:	2207      	movs	r2, #7
 800269a:	4306      	orrs	r6, r0
 800269c:	4032      	ands	r2, r6
 800269e:	2100      	movs	r1, #0
 80026a0:	2500      	movs	r5, #0
 80026a2:	e783      	b.n	80025ac <__aeabi_dsub+0x314>
 80026a4:	1a16      	subs	r6, r2, r0
 80026a6:	4663      	mov	r3, ip
 80026a8:	42b2      	cmp	r2, r6
 80026aa:	4180      	sbcs	r0, r0
 80026ac:	1a59      	subs	r1, r3, r1
 80026ae:	4240      	negs	r0, r0
 80026b0:	1a0b      	subs	r3, r1, r0
 80026b2:	4698      	mov	r8, r3
 80026b4:	465c      	mov	r4, fp
 80026b6:	e632      	b.n	800231e <__aeabi_dsub+0x86>
 80026b8:	2e1f      	cmp	r6, #31
 80026ba:	dd00      	ble.n	80026be <__aeabi_dsub+0x426>
 80026bc:	e0ab      	b.n	8002816 <__aeabi_dsub+0x57e>
 80026be:	2720      	movs	r7, #32
 80026c0:	1bbb      	subs	r3, r7, r6
 80026c2:	469a      	mov	sl, r3
 80026c4:	4663      	mov	r3, ip
 80026c6:	4657      	mov	r7, sl
 80026c8:	40bb      	lsls	r3, r7
 80026ca:	4699      	mov	r9, r3
 80026cc:	0013      	movs	r3, r2
 80026ce:	464f      	mov	r7, r9
 80026d0:	40f3      	lsrs	r3, r6
 80026d2:	431f      	orrs	r7, r3
 80026d4:	003b      	movs	r3, r7
 80026d6:	4657      	mov	r7, sl
 80026d8:	40ba      	lsls	r2, r7
 80026da:	1e57      	subs	r7, r2, #1
 80026dc:	41ba      	sbcs	r2, r7
 80026de:	4313      	orrs	r3, r2
 80026e0:	4662      	mov	r2, ip
 80026e2:	40f2      	lsrs	r2, r6
 80026e4:	1889      	adds	r1, r1, r2
 80026e6:	e698      	b.n	800241a <__aeabi_dsub+0x182>
 80026e8:	2720      	movs	r7, #32
 80026ea:	1bbb      	subs	r3, r7, r6
 80026ec:	469a      	mov	sl, r3
 80026ee:	4663      	mov	r3, ip
 80026f0:	4657      	mov	r7, sl
 80026f2:	40bb      	lsls	r3, r7
 80026f4:	4699      	mov	r9, r3
 80026f6:	0013      	movs	r3, r2
 80026f8:	464f      	mov	r7, r9
 80026fa:	40f3      	lsrs	r3, r6
 80026fc:	431f      	orrs	r7, r3
 80026fe:	003b      	movs	r3, r7
 8002700:	4657      	mov	r7, sl
 8002702:	40ba      	lsls	r2, r7
 8002704:	1e57      	subs	r7, r2, #1
 8002706:	41ba      	sbcs	r2, r7
 8002708:	4313      	orrs	r3, r2
 800270a:	4662      	mov	r2, ip
 800270c:	40f2      	lsrs	r2, r6
 800270e:	1a89      	subs	r1, r1, r2
 8002710:	e79c      	b.n	800264c <__aeabi_dsub+0x3b4>
 8002712:	4b83      	ldr	r3, [pc, #524]	; (8002920 <__aeabi_dsub+0x688>)
 8002714:	429f      	cmp	r7, r3
 8002716:	d05f      	beq.n	80027d8 <__aeabi_dsub+0x540>
 8002718:	2580      	movs	r5, #128	; 0x80
 800271a:	042d      	lsls	r5, r5, #16
 800271c:	4273      	negs	r3, r6
 800271e:	4329      	orrs	r1, r5
 8002720:	e720      	b.n	8002564 <__aeabi_dsub+0x2cc>
 8002722:	2e00      	cmp	r6, #0
 8002724:	d10c      	bne.n	8002740 <__aeabi_dsub+0x4a8>
 8002726:	2f00      	cmp	r7, #0
 8002728:	d100      	bne.n	800272c <__aeabi_dsub+0x494>
 800272a:	e0d0      	b.n	80028ce <__aeabi_dsub+0x636>
 800272c:	465c      	mov	r4, fp
 800272e:	4661      	mov	r1, ip
 8002730:	4691      	mov	r9, r2
 8002732:	4d7b      	ldr	r5, [pc, #492]	; (8002920 <__aeabi_dsub+0x688>)
 8002734:	e6cd      	b.n	80024d2 <__aeabi_dsub+0x23a>
 8002736:	4f7a      	ldr	r7, [pc, #488]	; (8002920 <__aeabi_dsub+0x688>)
 8002738:	42be      	cmp	r6, r7
 800273a:	d01c      	beq.n	8002776 <__aeabi_dsub+0x4de>
 800273c:	001e      	movs	r6, r3
 800273e:	e665      	b.n	800240c <__aeabi_dsub+0x174>
 8002740:	2f00      	cmp	r7, #0
 8002742:	d018      	beq.n	8002776 <__aeabi_dsub+0x4de>
 8002744:	08c0      	lsrs	r0, r0, #3
 8002746:	074e      	lsls	r6, r1, #29
 8002748:	4306      	orrs	r6, r0
 800274a:	2080      	movs	r0, #128	; 0x80
 800274c:	08c9      	lsrs	r1, r1, #3
 800274e:	0300      	lsls	r0, r0, #12
 8002750:	4201      	tst	r1, r0
 8002752:	d008      	beq.n	8002766 <__aeabi_dsub+0x4ce>
 8002754:	4663      	mov	r3, ip
 8002756:	08dc      	lsrs	r4, r3, #3
 8002758:	4204      	tst	r4, r0
 800275a:	d104      	bne.n	8002766 <__aeabi_dsub+0x4ce>
 800275c:	0021      	movs	r1, r4
 800275e:	46da      	mov	sl, fp
 8002760:	08d2      	lsrs	r2, r2, #3
 8002762:	075e      	lsls	r6, r3, #29
 8002764:	4316      	orrs	r6, r2
 8002766:	00f3      	lsls	r3, r6, #3
 8002768:	4699      	mov	r9, r3
 800276a:	2401      	movs	r4, #1
 800276c:	4653      	mov	r3, sl
 800276e:	00c9      	lsls	r1, r1, #3
 8002770:	0f72      	lsrs	r2, r6, #29
 8002772:	4311      	orrs	r1, r2
 8002774:	401c      	ands	r4, r3
 8002776:	4d6a      	ldr	r5, [pc, #424]	; (8002920 <__aeabi_dsub+0x688>)
 8002778:	e6ab      	b.n	80024d2 <__aeabi_dsub+0x23a>
 800277a:	001d      	movs	r5, r3
 800277c:	2200      	movs	r2, #0
 800277e:	2700      	movs	r7, #0
 8002780:	e6b4      	b.n	80024ec <__aeabi_dsub+0x254>
 8002782:	2d00      	cmp	r5, #0
 8002784:	d159      	bne.n	800283a <__aeabi_dsub+0x5a2>
 8002786:	000b      	movs	r3, r1
 8002788:	4303      	orrs	r3, r0
 800278a:	d100      	bne.n	800278e <__aeabi_dsub+0x4f6>
 800278c:	e6d6      	b.n	800253c <__aeabi_dsub+0x2a4>
 800278e:	1c73      	adds	r3, r6, #1
 8002790:	d100      	bne.n	8002794 <__aeabi_dsub+0x4fc>
 8002792:	e0b2      	b.n	80028fa <__aeabi_dsub+0x662>
 8002794:	4b62      	ldr	r3, [pc, #392]	; (8002920 <__aeabi_dsub+0x688>)
 8002796:	429f      	cmp	r7, r3
 8002798:	d01e      	beq.n	80027d8 <__aeabi_dsub+0x540>
 800279a:	43f3      	mvns	r3, r6
 800279c:	2b38      	cmp	r3, #56	; 0x38
 800279e:	dc6f      	bgt.n	8002880 <__aeabi_dsub+0x5e8>
 80027a0:	2b1f      	cmp	r3, #31
 80027a2:	dd00      	ble.n	80027a6 <__aeabi_dsub+0x50e>
 80027a4:	e097      	b.n	80028d6 <__aeabi_dsub+0x63e>
 80027a6:	2520      	movs	r5, #32
 80027a8:	000e      	movs	r6, r1
 80027aa:	1aed      	subs	r5, r5, r3
 80027ac:	40ae      	lsls	r6, r5
 80027ae:	46b0      	mov	r8, r6
 80027b0:	0006      	movs	r6, r0
 80027b2:	46aa      	mov	sl, r5
 80027b4:	40de      	lsrs	r6, r3
 80027b6:	4645      	mov	r5, r8
 80027b8:	4335      	orrs	r5, r6
 80027ba:	002e      	movs	r6, r5
 80027bc:	4655      	mov	r5, sl
 80027be:	40a8      	lsls	r0, r5
 80027c0:	40d9      	lsrs	r1, r3
 80027c2:	1e45      	subs	r5, r0, #1
 80027c4:	41a8      	sbcs	r0, r5
 80027c6:	448c      	add	ip, r1
 80027c8:	4306      	orrs	r6, r0
 80027ca:	18b6      	adds	r6, r6, r2
 80027cc:	4296      	cmp	r6, r2
 80027ce:	4192      	sbcs	r2, r2
 80027d0:	4251      	negs	r1, r2
 80027d2:	4461      	add	r1, ip
 80027d4:	003d      	movs	r5, r7
 80027d6:	e625      	b.n	8002424 <__aeabi_dsub+0x18c>
 80027d8:	003d      	movs	r5, r7
 80027da:	4661      	mov	r1, ip
 80027dc:	4691      	mov	r9, r2
 80027de:	e678      	b.n	80024d2 <__aeabi_dsub+0x23a>
 80027e0:	000b      	movs	r3, r1
 80027e2:	4303      	orrs	r3, r0
 80027e4:	2d00      	cmp	r5, #0
 80027e6:	d000      	beq.n	80027ea <__aeabi_dsub+0x552>
 80027e8:	e655      	b.n	8002496 <__aeabi_dsub+0x1fe>
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	d0f5      	beq.n	80027da <__aeabi_dsub+0x542>
 80027ee:	4663      	mov	r3, ip
 80027f0:	4313      	orrs	r3, r2
 80027f2:	d100      	bne.n	80027f6 <__aeabi_dsub+0x55e>
 80027f4:	e66d      	b.n	80024d2 <__aeabi_dsub+0x23a>
 80027f6:	1886      	adds	r6, r0, r2
 80027f8:	4286      	cmp	r6, r0
 80027fa:	4180      	sbcs	r0, r0
 80027fc:	4461      	add	r1, ip
 80027fe:	4240      	negs	r0, r0
 8002800:	1809      	adds	r1, r1, r0
 8002802:	2200      	movs	r2, #0
 8002804:	020b      	lsls	r3, r1, #8
 8002806:	d400      	bmi.n	800280a <__aeabi_dsub+0x572>
 8002808:	e6d0      	b.n	80025ac <__aeabi_dsub+0x314>
 800280a:	4b46      	ldr	r3, [pc, #280]	; (8002924 <__aeabi_dsub+0x68c>)
 800280c:	3501      	adds	r5, #1
 800280e:	4019      	ands	r1, r3
 8002810:	e5b2      	b.n	8002378 <__aeabi_dsub+0xe0>
 8002812:	46b1      	mov	r9, r6
 8002814:	e65d      	b.n	80024d2 <__aeabi_dsub+0x23a>
 8002816:	0033      	movs	r3, r6
 8002818:	4667      	mov	r7, ip
 800281a:	3b20      	subs	r3, #32
 800281c:	40df      	lsrs	r7, r3
 800281e:	003b      	movs	r3, r7
 8002820:	2e20      	cmp	r6, #32
 8002822:	d005      	beq.n	8002830 <__aeabi_dsub+0x598>
 8002824:	2740      	movs	r7, #64	; 0x40
 8002826:	1bbf      	subs	r7, r7, r6
 8002828:	4666      	mov	r6, ip
 800282a:	40be      	lsls	r6, r7
 800282c:	4332      	orrs	r2, r6
 800282e:	4690      	mov	r8, r2
 8002830:	4646      	mov	r6, r8
 8002832:	1e72      	subs	r2, r6, #1
 8002834:	4196      	sbcs	r6, r2
 8002836:	4333      	orrs	r3, r6
 8002838:	e5ef      	b.n	800241a <__aeabi_dsub+0x182>
 800283a:	4b39      	ldr	r3, [pc, #228]	; (8002920 <__aeabi_dsub+0x688>)
 800283c:	429f      	cmp	r7, r3
 800283e:	d0cb      	beq.n	80027d8 <__aeabi_dsub+0x540>
 8002840:	2580      	movs	r5, #128	; 0x80
 8002842:	042d      	lsls	r5, r5, #16
 8002844:	4273      	negs	r3, r6
 8002846:	4329      	orrs	r1, r5
 8002848:	e7a8      	b.n	800279c <__aeabi_dsub+0x504>
 800284a:	4308      	orrs	r0, r1
 800284c:	1e41      	subs	r1, r0, #1
 800284e:	4188      	sbcs	r0, r1
 8002850:	e6a2      	b.n	8002598 <__aeabi_dsub+0x300>
 8002852:	2f00      	cmp	r7, #0
 8002854:	d100      	bne.n	8002858 <__aeabi_dsub+0x5c0>
 8002856:	e63c      	b.n	80024d2 <__aeabi_dsub+0x23a>
 8002858:	4663      	mov	r3, ip
 800285a:	1a86      	subs	r6, r0, r2
 800285c:	1acf      	subs	r7, r1, r3
 800285e:	42b0      	cmp	r0, r6
 8002860:	419b      	sbcs	r3, r3
 8002862:	425b      	negs	r3, r3
 8002864:	1afb      	subs	r3, r7, r3
 8002866:	4698      	mov	r8, r3
 8002868:	021b      	lsls	r3, r3, #8
 800286a:	d54e      	bpl.n	800290a <__aeabi_dsub+0x672>
 800286c:	1a16      	subs	r6, r2, r0
 800286e:	4663      	mov	r3, ip
 8002870:	42b2      	cmp	r2, r6
 8002872:	4192      	sbcs	r2, r2
 8002874:	1a59      	subs	r1, r3, r1
 8002876:	4252      	negs	r2, r2
 8002878:	1a89      	subs	r1, r1, r2
 800287a:	465c      	mov	r4, fp
 800287c:	2200      	movs	r2, #0
 800287e:	e57b      	b.n	8002378 <__aeabi_dsub+0xe0>
 8002880:	4301      	orrs	r1, r0
 8002882:	000e      	movs	r6, r1
 8002884:	1e71      	subs	r1, r6, #1
 8002886:	418e      	sbcs	r6, r1
 8002888:	e79f      	b.n	80027ca <__aeabi_dsub+0x532>
 800288a:	001d      	movs	r5, r3
 800288c:	000e      	movs	r6, r1
 800288e:	3d20      	subs	r5, #32
 8002890:	40ee      	lsrs	r6, r5
 8002892:	46b0      	mov	r8, r6
 8002894:	2b20      	cmp	r3, #32
 8002896:	d004      	beq.n	80028a2 <__aeabi_dsub+0x60a>
 8002898:	2540      	movs	r5, #64	; 0x40
 800289a:	1aeb      	subs	r3, r5, r3
 800289c:	4099      	lsls	r1, r3
 800289e:	4308      	orrs	r0, r1
 80028a0:	4681      	mov	r9, r0
 80028a2:	4648      	mov	r0, r9
 80028a4:	4643      	mov	r3, r8
 80028a6:	1e41      	subs	r1, r0, #1
 80028a8:	4188      	sbcs	r0, r1
 80028aa:	4318      	orrs	r0, r3
 80028ac:	e674      	b.n	8002598 <__aeabi_dsub+0x300>
 80028ae:	2200      	movs	r2, #0
 80028b0:	2400      	movs	r4, #0
 80028b2:	e617      	b.n	80024e4 <__aeabi_dsub+0x24c>
 80028b4:	1a16      	subs	r6, r2, r0
 80028b6:	4663      	mov	r3, ip
 80028b8:	42b2      	cmp	r2, r6
 80028ba:	4192      	sbcs	r2, r2
 80028bc:	1a59      	subs	r1, r3, r1
 80028be:	4252      	negs	r2, r2
 80028c0:	1a89      	subs	r1, r1, r2
 80028c2:	003d      	movs	r5, r7
 80028c4:	e525      	b.n	8002312 <__aeabi_dsub+0x7a>
 80028c6:	4661      	mov	r1, ip
 80028c8:	4691      	mov	r9, r2
 80028ca:	4d15      	ldr	r5, [pc, #84]	; (8002920 <__aeabi_dsub+0x688>)
 80028cc:	e601      	b.n	80024d2 <__aeabi_dsub+0x23a>
 80028ce:	2280      	movs	r2, #128	; 0x80
 80028d0:	2400      	movs	r4, #0
 80028d2:	0312      	lsls	r2, r2, #12
 80028d4:	e679      	b.n	80025ca <__aeabi_dsub+0x332>
 80028d6:	001d      	movs	r5, r3
 80028d8:	000e      	movs	r6, r1
 80028da:	3d20      	subs	r5, #32
 80028dc:	40ee      	lsrs	r6, r5
 80028de:	46b0      	mov	r8, r6
 80028e0:	2b20      	cmp	r3, #32
 80028e2:	d004      	beq.n	80028ee <__aeabi_dsub+0x656>
 80028e4:	2540      	movs	r5, #64	; 0x40
 80028e6:	1aeb      	subs	r3, r5, r3
 80028e8:	4099      	lsls	r1, r3
 80028ea:	4308      	orrs	r0, r1
 80028ec:	4681      	mov	r9, r0
 80028ee:	464e      	mov	r6, r9
 80028f0:	4643      	mov	r3, r8
 80028f2:	1e71      	subs	r1, r6, #1
 80028f4:	418e      	sbcs	r6, r1
 80028f6:	431e      	orrs	r6, r3
 80028f8:	e767      	b.n	80027ca <__aeabi_dsub+0x532>
 80028fa:	1886      	adds	r6, r0, r2
 80028fc:	4296      	cmp	r6, r2
 80028fe:	419b      	sbcs	r3, r3
 8002900:	4461      	add	r1, ip
 8002902:	425b      	negs	r3, r3
 8002904:	18c9      	adds	r1, r1, r3
 8002906:	003d      	movs	r5, r7
 8002908:	e58c      	b.n	8002424 <__aeabi_dsub+0x18c>
 800290a:	4647      	mov	r7, r8
 800290c:	4337      	orrs	r7, r6
 800290e:	d0ce      	beq.n	80028ae <__aeabi_dsub+0x616>
 8002910:	2207      	movs	r2, #7
 8002912:	4641      	mov	r1, r8
 8002914:	4032      	ands	r2, r6
 8002916:	e649      	b.n	80025ac <__aeabi_dsub+0x314>
 8002918:	2700      	movs	r7, #0
 800291a:	003a      	movs	r2, r7
 800291c:	e5e6      	b.n	80024ec <__aeabi_dsub+0x254>
 800291e:	46c0      	nop			; (mov r8, r8)
 8002920:	000007ff 	.word	0x000007ff
 8002924:	ff7fffff 	.word	0xff7fffff

08002928 <__aeabi_dcmpun>:
 8002928:	b570      	push	{r4, r5, r6, lr}
 800292a:	4e0c      	ldr	r6, [pc, #48]	; (800295c <__aeabi_dcmpun+0x34>)
 800292c:	030d      	lsls	r5, r1, #12
 800292e:	031c      	lsls	r4, r3, #12
 8002930:	0049      	lsls	r1, r1, #1
 8002932:	005b      	lsls	r3, r3, #1
 8002934:	0b2d      	lsrs	r5, r5, #12
 8002936:	0d49      	lsrs	r1, r1, #21
 8002938:	0b24      	lsrs	r4, r4, #12
 800293a:	0d5b      	lsrs	r3, r3, #21
 800293c:	42b1      	cmp	r1, r6
 800293e:	d008      	beq.n	8002952 <__aeabi_dcmpun+0x2a>
 8002940:	4906      	ldr	r1, [pc, #24]	; (800295c <__aeabi_dcmpun+0x34>)
 8002942:	2000      	movs	r0, #0
 8002944:	428b      	cmp	r3, r1
 8002946:	d103      	bne.n	8002950 <__aeabi_dcmpun+0x28>
 8002948:	4314      	orrs	r4, r2
 800294a:	0020      	movs	r0, r4
 800294c:	1e44      	subs	r4, r0, #1
 800294e:	41a0      	sbcs	r0, r4
 8002950:	bd70      	pop	{r4, r5, r6, pc}
 8002952:	4305      	orrs	r5, r0
 8002954:	2001      	movs	r0, #1
 8002956:	2d00      	cmp	r5, #0
 8002958:	d1fa      	bne.n	8002950 <__aeabi_dcmpun+0x28>
 800295a:	e7f1      	b.n	8002940 <__aeabi_dcmpun+0x18>
 800295c:	000007ff 	.word	0x000007ff

08002960 <__aeabi_d2iz>:
 8002960:	b530      	push	{r4, r5, lr}
 8002962:	4d14      	ldr	r5, [pc, #80]	; (80029b4 <__aeabi_d2iz+0x54>)
 8002964:	030a      	lsls	r2, r1, #12
 8002966:	004b      	lsls	r3, r1, #1
 8002968:	0b12      	lsrs	r2, r2, #12
 800296a:	0d5b      	lsrs	r3, r3, #21
 800296c:	0fc9      	lsrs	r1, r1, #31
 800296e:	2400      	movs	r4, #0
 8002970:	42ab      	cmp	r3, r5
 8002972:	dd11      	ble.n	8002998 <__aeabi_d2iz+0x38>
 8002974:	4c10      	ldr	r4, [pc, #64]	; (80029b8 <__aeabi_d2iz+0x58>)
 8002976:	42a3      	cmp	r3, r4
 8002978:	dc10      	bgt.n	800299c <__aeabi_d2iz+0x3c>
 800297a:	2480      	movs	r4, #128	; 0x80
 800297c:	0364      	lsls	r4, r4, #13
 800297e:	4322      	orrs	r2, r4
 8002980:	4c0e      	ldr	r4, [pc, #56]	; (80029bc <__aeabi_d2iz+0x5c>)
 8002982:	1ae4      	subs	r4, r4, r3
 8002984:	2c1f      	cmp	r4, #31
 8002986:	dd0c      	ble.n	80029a2 <__aeabi_d2iz+0x42>
 8002988:	480d      	ldr	r0, [pc, #52]	; (80029c0 <__aeabi_d2iz+0x60>)
 800298a:	1ac3      	subs	r3, r0, r3
 800298c:	40da      	lsrs	r2, r3
 800298e:	0013      	movs	r3, r2
 8002990:	425c      	negs	r4, r3
 8002992:	2900      	cmp	r1, #0
 8002994:	d100      	bne.n	8002998 <__aeabi_d2iz+0x38>
 8002996:	001c      	movs	r4, r3
 8002998:	0020      	movs	r0, r4
 800299a:	bd30      	pop	{r4, r5, pc}
 800299c:	4b09      	ldr	r3, [pc, #36]	; (80029c4 <__aeabi_d2iz+0x64>)
 800299e:	18cc      	adds	r4, r1, r3
 80029a0:	e7fa      	b.n	8002998 <__aeabi_d2iz+0x38>
 80029a2:	4d09      	ldr	r5, [pc, #36]	; (80029c8 <__aeabi_d2iz+0x68>)
 80029a4:	40e0      	lsrs	r0, r4
 80029a6:	46ac      	mov	ip, r5
 80029a8:	4463      	add	r3, ip
 80029aa:	409a      	lsls	r2, r3
 80029ac:	0013      	movs	r3, r2
 80029ae:	4303      	orrs	r3, r0
 80029b0:	e7ee      	b.n	8002990 <__aeabi_d2iz+0x30>
 80029b2:	46c0      	nop			; (mov r8, r8)
 80029b4:	000003fe 	.word	0x000003fe
 80029b8:	0000041d 	.word	0x0000041d
 80029bc:	00000433 	.word	0x00000433
 80029c0:	00000413 	.word	0x00000413
 80029c4:	7fffffff 	.word	0x7fffffff
 80029c8:	fffffbed 	.word	0xfffffbed

080029cc <__aeabi_i2d>:
 80029cc:	b570      	push	{r4, r5, r6, lr}
 80029ce:	2800      	cmp	r0, #0
 80029d0:	d02d      	beq.n	8002a2e <__aeabi_i2d+0x62>
 80029d2:	17c3      	asrs	r3, r0, #31
 80029d4:	18c5      	adds	r5, r0, r3
 80029d6:	405d      	eors	r5, r3
 80029d8:	0fc4      	lsrs	r4, r0, #31
 80029da:	0028      	movs	r0, r5
 80029dc:	f000 f938 	bl	8002c50 <__clzsi2>
 80029e0:	4b15      	ldr	r3, [pc, #84]	; (8002a38 <__aeabi_i2d+0x6c>)
 80029e2:	1a1b      	subs	r3, r3, r0
 80029e4:	055b      	lsls	r3, r3, #21
 80029e6:	0d5b      	lsrs	r3, r3, #21
 80029e8:	280a      	cmp	r0, #10
 80029ea:	dd15      	ble.n	8002a18 <__aeabi_i2d+0x4c>
 80029ec:	380b      	subs	r0, #11
 80029ee:	4085      	lsls	r5, r0
 80029f0:	2200      	movs	r2, #0
 80029f2:	032d      	lsls	r5, r5, #12
 80029f4:	0b2d      	lsrs	r5, r5, #12
 80029f6:	2100      	movs	r1, #0
 80029f8:	0010      	movs	r0, r2
 80029fa:	032d      	lsls	r5, r5, #12
 80029fc:	0d0a      	lsrs	r2, r1, #20
 80029fe:	0b2d      	lsrs	r5, r5, #12
 8002a00:	0512      	lsls	r2, r2, #20
 8002a02:	432a      	orrs	r2, r5
 8002a04:	4d0d      	ldr	r5, [pc, #52]	; (8002a3c <__aeabi_i2d+0x70>)
 8002a06:	051b      	lsls	r3, r3, #20
 8002a08:	402a      	ands	r2, r5
 8002a0a:	4313      	orrs	r3, r2
 8002a0c:	005b      	lsls	r3, r3, #1
 8002a0e:	07e4      	lsls	r4, r4, #31
 8002a10:	085b      	lsrs	r3, r3, #1
 8002a12:	4323      	orrs	r3, r4
 8002a14:	0019      	movs	r1, r3
 8002a16:	bd70      	pop	{r4, r5, r6, pc}
 8002a18:	0002      	movs	r2, r0
 8002a1a:	0029      	movs	r1, r5
 8002a1c:	3215      	adds	r2, #21
 8002a1e:	4091      	lsls	r1, r2
 8002a20:	000a      	movs	r2, r1
 8002a22:	210b      	movs	r1, #11
 8002a24:	1a08      	subs	r0, r1, r0
 8002a26:	40c5      	lsrs	r5, r0
 8002a28:	032d      	lsls	r5, r5, #12
 8002a2a:	0b2d      	lsrs	r5, r5, #12
 8002a2c:	e7e3      	b.n	80029f6 <__aeabi_i2d+0x2a>
 8002a2e:	2400      	movs	r4, #0
 8002a30:	2300      	movs	r3, #0
 8002a32:	2500      	movs	r5, #0
 8002a34:	2200      	movs	r2, #0
 8002a36:	e7de      	b.n	80029f6 <__aeabi_i2d+0x2a>
 8002a38:	0000041e 	.word	0x0000041e
 8002a3c:	800fffff 	.word	0x800fffff

08002a40 <__aeabi_ui2d>:
 8002a40:	b510      	push	{r4, lr}
 8002a42:	1e04      	subs	r4, r0, #0
 8002a44:	d025      	beq.n	8002a92 <__aeabi_ui2d+0x52>
 8002a46:	f000 f903 	bl	8002c50 <__clzsi2>
 8002a4a:	4b14      	ldr	r3, [pc, #80]	; (8002a9c <__aeabi_ui2d+0x5c>)
 8002a4c:	1a1b      	subs	r3, r3, r0
 8002a4e:	055b      	lsls	r3, r3, #21
 8002a50:	0d5b      	lsrs	r3, r3, #21
 8002a52:	280a      	cmp	r0, #10
 8002a54:	dd12      	ble.n	8002a7c <__aeabi_ui2d+0x3c>
 8002a56:	380b      	subs	r0, #11
 8002a58:	4084      	lsls	r4, r0
 8002a5a:	2200      	movs	r2, #0
 8002a5c:	0324      	lsls	r4, r4, #12
 8002a5e:	0b24      	lsrs	r4, r4, #12
 8002a60:	2100      	movs	r1, #0
 8002a62:	0010      	movs	r0, r2
 8002a64:	0324      	lsls	r4, r4, #12
 8002a66:	0d0a      	lsrs	r2, r1, #20
 8002a68:	0b24      	lsrs	r4, r4, #12
 8002a6a:	0512      	lsls	r2, r2, #20
 8002a6c:	4322      	orrs	r2, r4
 8002a6e:	4c0c      	ldr	r4, [pc, #48]	; (8002aa0 <__aeabi_ui2d+0x60>)
 8002a70:	051b      	lsls	r3, r3, #20
 8002a72:	4022      	ands	r2, r4
 8002a74:	4313      	orrs	r3, r2
 8002a76:	005b      	lsls	r3, r3, #1
 8002a78:	0859      	lsrs	r1, r3, #1
 8002a7a:	bd10      	pop	{r4, pc}
 8002a7c:	0002      	movs	r2, r0
 8002a7e:	0021      	movs	r1, r4
 8002a80:	3215      	adds	r2, #21
 8002a82:	4091      	lsls	r1, r2
 8002a84:	000a      	movs	r2, r1
 8002a86:	210b      	movs	r1, #11
 8002a88:	1a08      	subs	r0, r1, r0
 8002a8a:	40c4      	lsrs	r4, r0
 8002a8c:	0324      	lsls	r4, r4, #12
 8002a8e:	0b24      	lsrs	r4, r4, #12
 8002a90:	e7e6      	b.n	8002a60 <__aeabi_ui2d+0x20>
 8002a92:	2300      	movs	r3, #0
 8002a94:	2400      	movs	r4, #0
 8002a96:	2200      	movs	r2, #0
 8002a98:	e7e2      	b.n	8002a60 <__aeabi_ui2d+0x20>
 8002a9a:	46c0      	nop			; (mov r8, r8)
 8002a9c:	0000041e 	.word	0x0000041e
 8002aa0:	800fffff 	.word	0x800fffff

08002aa4 <__aeabi_f2d>:
 8002aa4:	0041      	lsls	r1, r0, #1
 8002aa6:	0e09      	lsrs	r1, r1, #24
 8002aa8:	1c4b      	adds	r3, r1, #1
 8002aaa:	b570      	push	{r4, r5, r6, lr}
 8002aac:	b2db      	uxtb	r3, r3
 8002aae:	0246      	lsls	r6, r0, #9
 8002ab0:	0a75      	lsrs	r5, r6, #9
 8002ab2:	0fc4      	lsrs	r4, r0, #31
 8002ab4:	2b01      	cmp	r3, #1
 8002ab6:	dd14      	ble.n	8002ae2 <__aeabi_f2d+0x3e>
 8002ab8:	23e0      	movs	r3, #224	; 0xe0
 8002aba:	009b      	lsls	r3, r3, #2
 8002abc:	076d      	lsls	r5, r5, #29
 8002abe:	0b36      	lsrs	r6, r6, #12
 8002ac0:	18cb      	adds	r3, r1, r3
 8002ac2:	2100      	movs	r1, #0
 8002ac4:	0d0a      	lsrs	r2, r1, #20
 8002ac6:	0028      	movs	r0, r5
 8002ac8:	0512      	lsls	r2, r2, #20
 8002aca:	4d1c      	ldr	r5, [pc, #112]	; (8002b3c <__aeabi_f2d+0x98>)
 8002acc:	4332      	orrs	r2, r6
 8002ace:	055b      	lsls	r3, r3, #21
 8002ad0:	402a      	ands	r2, r5
 8002ad2:	085b      	lsrs	r3, r3, #1
 8002ad4:	4313      	orrs	r3, r2
 8002ad6:	005b      	lsls	r3, r3, #1
 8002ad8:	07e4      	lsls	r4, r4, #31
 8002ada:	085b      	lsrs	r3, r3, #1
 8002adc:	4323      	orrs	r3, r4
 8002ade:	0019      	movs	r1, r3
 8002ae0:	bd70      	pop	{r4, r5, r6, pc}
 8002ae2:	2900      	cmp	r1, #0
 8002ae4:	d114      	bne.n	8002b10 <__aeabi_f2d+0x6c>
 8002ae6:	2d00      	cmp	r5, #0
 8002ae8:	d01e      	beq.n	8002b28 <__aeabi_f2d+0x84>
 8002aea:	0028      	movs	r0, r5
 8002aec:	f000 f8b0 	bl	8002c50 <__clzsi2>
 8002af0:	280a      	cmp	r0, #10
 8002af2:	dc1c      	bgt.n	8002b2e <__aeabi_f2d+0x8a>
 8002af4:	230b      	movs	r3, #11
 8002af6:	002a      	movs	r2, r5
 8002af8:	1a1b      	subs	r3, r3, r0
 8002afa:	40da      	lsrs	r2, r3
 8002afc:	0003      	movs	r3, r0
 8002afe:	3315      	adds	r3, #21
 8002b00:	409d      	lsls	r5, r3
 8002b02:	4b0f      	ldr	r3, [pc, #60]	; (8002b40 <__aeabi_f2d+0x9c>)
 8002b04:	0312      	lsls	r2, r2, #12
 8002b06:	1a1b      	subs	r3, r3, r0
 8002b08:	055b      	lsls	r3, r3, #21
 8002b0a:	0b16      	lsrs	r6, r2, #12
 8002b0c:	0d5b      	lsrs	r3, r3, #21
 8002b0e:	e7d8      	b.n	8002ac2 <__aeabi_f2d+0x1e>
 8002b10:	2d00      	cmp	r5, #0
 8002b12:	d006      	beq.n	8002b22 <__aeabi_f2d+0x7e>
 8002b14:	0b32      	lsrs	r2, r6, #12
 8002b16:	2680      	movs	r6, #128	; 0x80
 8002b18:	0336      	lsls	r6, r6, #12
 8002b1a:	076d      	lsls	r5, r5, #29
 8002b1c:	4316      	orrs	r6, r2
 8002b1e:	4b09      	ldr	r3, [pc, #36]	; (8002b44 <__aeabi_f2d+0xa0>)
 8002b20:	e7cf      	b.n	8002ac2 <__aeabi_f2d+0x1e>
 8002b22:	4b08      	ldr	r3, [pc, #32]	; (8002b44 <__aeabi_f2d+0xa0>)
 8002b24:	2600      	movs	r6, #0
 8002b26:	e7cc      	b.n	8002ac2 <__aeabi_f2d+0x1e>
 8002b28:	2300      	movs	r3, #0
 8002b2a:	2600      	movs	r6, #0
 8002b2c:	e7c9      	b.n	8002ac2 <__aeabi_f2d+0x1e>
 8002b2e:	0003      	movs	r3, r0
 8002b30:	002a      	movs	r2, r5
 8002b32:	3b0b      	subs	r3, #11
 8002b34:	409a      	lsls	r2, r3
 8002b36:	2500      	movs	r5, #0
 8002b38:	e7e3      	b.n	8002b02 <__aeabi_f2d+0x5e>
 8002b3a:	46c0      	nop			; (mov r8, r8)
 8002b3c:	800fffff 	.word	0x800fffff
 8002b40:	00000389 	.word	0x00000389
 8002b44:	000007ff 	.word	0x000007ff

08002b48 <__aeabi_d2f>:
 8002b48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002b4a:	004c      	lsls	r4, r1, #1
 8002b4c:	0d64      	lsrs	r4, r4, #21
 8002b4e:	030b      	lsls	r3, r1, #12
 8002b50:	1c62      	adds	r2, r4, #1
 8002b52:	0a5b      	lsrs	r3, r3, #9
 8002b54:	0f46      	lsrs	r6, r0, #29
 8002b56:	0552      	lsls	r2, r2, #21
 8002b58:	0fc9      	lsrs	r1, r1, #31
 8002b5a:	431e      	orrs	r6, r3
 8002b5c:	00c5      	lsls	r5, r0, #3
 8002b5e:	0d52      	lsrs	r2, r2, #21
 8002b60:	2a01      	cmp	r2, #1
 8002b62:	dd29      	ble.n	8002bb8 <__aeabi_d2f+0x70>
 8002b64:	4b37      	ldr	r3, [pc, #220]	; (8002c44 <__aeabi_d2f+0xfc>)
 8002b66:	18e7      	adds	r7, r4, r3
 8002b68:	2ffe      	cmp	r7, #254	; 0xfe
 8002b6a:	dc1c      	bgt.n	8002ba6 <__aeabi_d2f+0x5e>
 8002b6c:	2f00      	cmp	r7, #0
 8002b6e:	dd3b      	ble.n	8002be8 <__aeabi_d2f+0xa0>
 8002b70:	0180      	lsls	r0, r0, #6
 8002b72:	1e43      	subs	r3, r0, #1
 8002b74:	4198      	sbcs	r0, r3
 8002b76:	2207      	movs	r2, #7
 8002b78:	00f3      	lsls	r3, r6, #3
 8002b7a:	0f6d      	lsrs	r5, r5, #29
 8002b7c:	4303      	orrs	r3, r0
 8002b7e:	432b      	orrs	r3, r5
 8002b80:	401a      	ands	r2, r3
 8002b82:	2a00      	cmp	r2, #0
 8002b84:	d004      	beq.n	8002b90 <__aeabi_d2f+0x48>
 8002b86:	220f      	movs	r2, #15
 8002b88:	401a      	ands	r2, r3
 8002b8a:	2a04      	cmp	r2, #4
 8002b8c:	d000      	beq.n	8002b90 <__aeabi_d2f+0x48>
 8002b8e:	3304      	adds	r3, #4
 8002b90:	2280      	movs	r2, #128	; 0x80
 8002b92:	04d2      	lsls	r2, r2, #19
 8002b94:	401a      	ands	r2, r3
 8002b96:	d024      	beq.n	8002be2 <__aeabi_d2f+0x9a>
 8002b98:	3701      	adds	r7, #1
 8002b9a:	b2fa      	uxtb	r2, r7
 8002b9c:	2fff      	cmp	r7, #255	; 0xff
 8002b9e:	d002      	beq.n	8002ba6 <__aeabi_d2f+0x5e>
 8002ba0:	019b      	lsls	r3, r3, #6
 8002ba2:	0a58      	lsrs	r0, r3, #9
 8002ba4:	e001      	b.n	8002baa <__aeabi_d2f+0x62>
 8002ba6:	22ff      	movs	r2, #255	; 0xff
 8002ba8:	2000      	movs	r0, #0
 8002baa:	0240      	lsls	r0, r0, #9
 8002bac:	05d2      	lsls	r2, r2, #23
 8002bae:	0a40      	lsrs	r0, r0, #9
 8002bb0:	07c9      	lsls	r1, r1, #31
 8002bb2:	4310      	orrs	r0, r2
 8002bb4:	4308      	orrs	r0, r1
 8002bb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002bb8:	4335      	orrs	r5, r6
 8002bba:	2c00      	cmp	r4, #0
 8002bbc:	d104      	bne.n	8002bc8 <__aeabi_d2f+0x80>
 8002bbe:	2d00      	cmp	r5, #0
 8002bc0:	d10a      	bne.n	8002bd8 <__aeabi_d2f+0x90>
 8002bc2:	2200      	movs	r2, #0
 8002bc4:	2000      	movs	r0, #0
 8002bc6:	e7f0      	b.n	8002baa <__aeabi_d2f+0x62>
 8002bc8:	2d00      	cmp	r5, #0
 8002bca:	d0ec      	beq.n	8002ba6 <__aeabi_d2f+0x5e>
 8002bcc:	2080      	movs	r0, #128	; 0x80
 8002bce:	03c0      	lsls	r0, r0, #15
 8002bd0:	4330      	orrs	r0, r6
 8002bd2:	22ff      	movs	r2, #255	; 0xff
 8002bd4:	e7e9      	b.n	8002baa <__aeabi_d2f+0x62>
 8002bd6:	2400      	movs	r4, #0
 8002bd8:	2300      	movs	r3, #0
 8002bda:	025b      	lsls	r3, r3, #9
 8002bdc:	0a58      	lsrs	r0, r3, #9
 8002bde:	b2e2      	uxtb	r2, r4
 8002be0:	e7e3      	b.n	8002baa <__aeabi_d2f+0x62>
 8002be2:	08db      	lsrs	r3, r3, #3
 8002be4:	003c      	movs	r4, r7
 8002be6:	e7f8      	b.n	8002bda <__aeabi_d2f+0x92>
 8002be8:	003b      	movs	r3, r7
 8002bea:	3317      	adds	r3, #23
 8002bec:	dbf3      	blt.n	8002bd6 <__aeabi_d2f+0x8e>
 8002bee:	2380      	movs	r3, #128	; 0x80
 8002bf0:	041b      	lsls	r3, r3, #16
 8002bf2:	4333      	orrs	r3, r6
 8002bf4:	261e      	movs	r6, #30
 8002bf6:	1bf6      	subs	r6, r6, r7
 8002bf8:	2e1f      	cmp	r6, #31
 8002bfa:	dd14      	ble.n	8002c26 <__aeabi_d2f+0xde>
 8002bfc:	2202      	movs	r2, #2
 8002bfe:	4252      	negs	r2, r2
 8002c00:	1bd7      	subs	r7, r2, r7
 8002c02:	001a      	movs	r2, r3
 8002c04:	40fa      	lsrs	r2, r7
 8002c06:	0017      	movs	r7, r2
 8002c08:	2e20      	cmp	r6, #32
 8002c0a:	d004      	beq.n	8002c16 <__aeabi_d2f+0xce>
 8002c0c:	4a0e      	ldr	r2, [pc, #56]	; (8002c48 <__aeabi_d2f+0x100>)
 8002c0e:	4694      	mov	ip, r2
 8002c10:	4464      	add	r4, ip
 8002c12:	40a3      	lsls	r3, r4
 8002c14:	431d      	orrs	r5, r3
 8002c16:	002b      	movs	r3, r5
 8002c18:	1e5d      	subs	r5, r3, #1
 8002c1a:	41ab      	sbcs	r3, r5
 8002c1c:	2207      	movs	r2, #7
 8002c1e:	433b      	orrs	r3, r7
 8002c20:	401a      	ands	r2, r3
 8002c22:	2700      	movs	r7, #0
 8002c24:	e7ad      	b.n	8002b82 <__aeabi_d2f+0x3a>
 8002c26:	4a09      	ldr	r2, [pc, #36]	; (8002c4c <__aeabi_d2f+0x104>)
 8002c28:	0028      	movs	r0, r5
 8002c2a:	18a2      	adds	r2, r4, r2
 8002c2c:	4095      	lsls	r5, r2
 8002c2e:	4093      	lsls	r3, r2
 8002c30:	1e6c      	subs	r4, r5, #1
 8002c32:	41a5      	sbcs	r5, r4
 8002c34:	40f0      	lsrs	r0, r6
 8002c36:	2207      	movs	r2, #7
 8002c38:	432b      	orrs	r3, r5
 8002c3a:	4303      	orrs	r3, r0
 8002c3c:	401a      	ands	r2, r3
 8002c3e:	2700      	movs	r7, #0
 8002c40:	e79f      	b.n	8002b82 <__aeabi_d2f+0x3a>
 8002c42:	46c0      	nop			; (mov r8, r8)
 8002c44:	fffffc80 	.word	0xfffffc80
 8002c48:	fffffca2 	.word	0xfffffca2
 8002c4c:	fffffc82 	.word	0xfffffc82

08002c50 <__clzsi2>:
 8002c50:	211c      	movs	r1, #28
 8002c52:	2301      	movs	r3, #1
 8002c54:	041b      	lsls	r3, r3, #16
 8002c56:	4298      	cmp	r0, r3
 8002c58:	d301      	bcc.n	8002c5e <__clzsi2+0xe>
 8002c5a:	0c00      	lsrs	r0, r0, #16
 8002c5c:	3910      	subs	r1, #16
 8002c5e:	0a1b      	lsrs	r3, r3, #8
 8002c60:	4298      	cmp	r0, r3
 8002c62:	d301      	bcc.n	8002c68 <__clzsi2+0x18>
 8002c64:	0a00      	lsrs	r0, r0, #8
 8002c66:	3908      	subs	r1, #8
 8002c68:	091b      	lsrs	r3, r3, #4
 8002c6a:	4298      	cmp	r0, r3
 8002c6c:	d301      	bcc.n	8002c72 <__clzsi2+0x22>
 8002c6e:	0900      	lsrs	r0, r0, #4
 8002c70:	3904      	subs	r1, #4
 8002c72:	a202      	add	r2, pc, #8	; (adr r2, 8002c7c <__clzsi2+0x2c>)
 8002c74:	5c10      	ldrb	r0, [r2, r0]
 8002c76:	1840      	adds	r0, r0, r1
 8002c78:	4770      	bx	lr
 8002c7a:	46c0      	nop			; (mov r8, r8)
 8002c7c:	02020304 	.word	0x02020304
 8002c80:	01010101 	.word	0x01010101
	...

08002c8c <__clzdi2>:
 8002c8c:	b510      	push	{r4, lr}
 8002c8e:	2900      	cmp	r1, #0
 8002c90:	d103      	bne.n	8002c9a <__clzdi2+0xe>
 8002c92:	f7ff ffdd 	bl	8002c50 <__clzsi2>
 8002c96:	3020      	adds	r0, #32
 8002c98:	e002      	b.n	8002ca0 <__clzdi2+0x14>
 8002c9a:	1c08      	adds	r0, r1, #0
 8002c9c:	f7ff ffd8 	bl	8002c50 <__clzsi2>
 8002ca0:	bd10      	pop	{r4, pc}
 8002ca2:	46c0      	nop			; (mov r8, r8)

08002ca4 <minArr>:
uint8_t minArr(uint8_t *arr, uint8_t *Q) {
	uint8_t smallest = 0xFF;
	uint8_t index = 0;

	/* Consider first element as smallest */
	if (!Q[0])						// Not visited yet
 8002ca4:	780b      	ldrb	r3, [r1, #0]
uint8_t minArr(uint8_t *arr, uint8_t *Q) {
 8002ca6:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t smallest = 0xFF;
 8002ca8:	22ff      	movs	r2, #255	; 0xff
uint8_t minArr(uint8_t *arr, uint8_t *Q) {
 8002caa:	0004      	movs	r4, r0
	if (!Q[0])						// Not visited yet
 8002cac:	2b00      	cmp	r3, #0
 8002cae:	d100      	bne.n	8002cb2 <minArr+0xe>
		smallest = arr[0];
 8002cb0:	7802      	ldrb	r2, [r0, #0]

	for (int i = 0; i < N; i++) {
 8002cb2:	4b08      	ldr	r3, [pc, #32]	; (8002cd4 <minArr+0x30>)
 8002cb4:	781e      	ldrb	r6, [r3, #0]
 8002cb6:	2300      	movs	r3, #0
 8002cb8:	0018      	movs	r0, r3
 8002cba:	429e      	cmp	r6, r3
 8002cbc:	dc00      	bgt.n	8002cc0 <minArr+0x1c>
			index = i;
		}
	}

	return index;
}
 8002cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if ((arr[i] < smallest) && !Q[i]) {
 8002cc0:	5ce5      	ldrb	r5, [r4, r3]
 8002cc2:	4295      	cmp	r5, r2
 8002cc4:	d204      	bcs.n	8002cd0 <minArr+0x2c>
 8002cc6:	5ccf      	ldrb	r7, [r1, r3]
 8002cc8:	2f00      	cmp	r7, #0
 8002cca:	d101      	bne.n	8002cd0 <minArr+0x2c>
			index = i;
 8002ccc:	002a      	movs	r2, r5
 8002cce:	b2d8      	uxtb	r0, r3
	for (int i = 0; i < N; i++) {
 8002cd0:	3301      	adds	r3, #1
 8002cd2:	e7f2      	b.n	8002cba <minArr+0x16>
 8002cd4:	2000001c 	.word	0x2000001c

08002cd8 <QnotEmpty>:

/*-----------------------------------------------------------*/

/* --- Used by FoundRoute: Check if Q is empty (all modules have been visited) 
 */
uint8_t QnotEmpty(uint8_t *Q) {
 8002cd8:	b510      	push	{r4, lr}
	char temp = 1;

	for (int i = 0; i < N; i++) {
 8002cda:	4b06      	ldr	r3, [pc, #24]	; (8002cf4 <QnotEmpty+0x1c>)
	char temp = 1;
 8002cdc:	2201      	movs	r2, #1
	for (int i = 0; i < N; i++) {
 8002cde:	781c      	ldrb	r4, [r3, #0]
 8002ce0:	0003      	movs	r3, r0
 8002ce2:	1a19      	subs	r1, r3, r0
 8002ce4:	428c      	cmp	r4, r1
 8002ce6:	dc01      	bgt.n	8002cec <QnotEmpty+0x14>
		temp &= Q[i];
	}

	return temp;
}
 8002ce8:	0010      	movs	r0, r2
 8002cea:	bd10      	pop	{r4, pc}
		temp &= Q[i];
 8002cec:	7819      	ldrb	r1, [r3, #0]
 8002cee:	3301      	adds	r3, #1
 8002cf0:	400a      	ands	r2, r1
 8002cf2:	e7f6      	b.n	8002ce2 <QnotEmpty+0xa>
 8002cf4:	2000001c 	.word	0x2000001c

08002cf8 <LoadROtopology>:

/*-----------------------------------------------------------*/

/* --- Load array topology stored in Flash RO --- 
 */
uint8_t LoadROtopology(void) {
 8002cf8:	b5f0      	push	{r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;
	uint16_t add = 2, temp = 0;

	/* Load number of modules */
	temp = (*(__IO uint16_t*) (RO_START_ADDRESS));
 8002cfa:	4b1e      	ldr	r3, [pc, #120]	; (8002d74 <LoadROtopology+0x7c>)

	if (temp == 0xFFFF)				// Memory has been erased
 8002cfc:	481e      	ldr	r0, [pc, #120]	; (8002d78 <LoadROtopology+0x80>)
	temp = (*(__IO uint16_t*) (RO_START_ADDRESS));
 8002cfe:	881b      	ldrh	r3, [r3, #0]
uint8_t LoadROtopology(void) {
 8002d00:	b085      	sub	sp, #20
	temp = (*(__IO uint16_t*) (RO_START_ADDRESS));
 8002d02:	b29b      	uxth	r3, r3
 8002d04:	4a1d      	ldr	r2, [pc, #116]	; (8002d7c <LoadROtopology+0x84>)
 8002d06:	491e      	ldr	r1, [pc, #120]	; (8002d80 <LoadROtopology+0x88>)
	if (temp == 0xFFFF)				// Memory has been erased
 8002d08:	4283      	cmp	r3, r0
 8002d0a:	d106      	bne.n	8002d1a <LoadROtopology+0x22>
			{
		N = 1;
 8002d0c:	2301      	movs	r3, #1
 8002d0e:	7013      	strb	r3, [r2, #0]
		myID = 0;
 8002d10:	2300      	movs	r3, #0
		return BOS_MEM_ERASED;
 8002d12:	20fa      	movs	r0, #250	; 0xfa
		myID = 0;
 8002d14:	700b      	strb	r3, [r1, #0]
			}
		}
	}

	return result;
}
 8002d16:	b005      	add	sp, #20
 8002d18:	bdf0      	pop	{r4, r5, r6, r7, pc}
		N = (uint8_t) (temp >> 8);
 8002d1a:	0a18      	lsrs	r0, r3, #8
		if (N == 0)
 8002d1c:	d00d      	beq.n	8002d3a <LoadROtopology+0x42>
			N = 1;
 8002d1e:	7010      	strb	r0, [r2, #0]
		myID = (uint8_t) temp;
 8002d20:	700b      	strb	r3, [r1, #0]
		for (uint8_t i = 1; i <= N; i++) {
 8002d22:	7813      	ldrb	r3, [r2, #0]
				array[i - 1][j] = (*(__IO uint16_t*) (RO_START_ADDRESS + add));
 8002d24:	260b      	movs	r6, #11
		for (uint8_t i = 1; i <= N; i++) {
 8002d26:	9301      	str	r3, [sp, #4]
	uint16_t add = 2, temp = 0;
 8002d28:	2202      	movs	r2, #2
		for (uint8_t i = 1; i <= N; i++) {
 8002d2a:	2301      	movs	r3, #1
			for (volatile uint8_t j = 0; j <= MaxNumOfPorts; j++) {
 8002d2c:	a902      	add	r1, sp, #8
 8002d2e:	3107      	adds	r1, #7
		for (uint8_t i = 1; i <= N; i++) {
 8002d30:	9801      	ldr	r0, [sp, #4]
 8002d32:	4283      	cmp	r3, r0
 8002d34:	d903      	bls.n	8002d3e <LoadROtopology+0x46>
 8002d36:	2000      	movs	r0, #0
 8002d38:	e7ed      	b.n	8002d16 <LoadROtopology+0x1e>
			N = 1;
 8002d3a:	2001      	movs	r0, #1
 8002d3c:	e7ef      	b.n	8002d1e <LoadROtopology+0x26>
			for (volatile uint8_t j = 0; j <= MaxNumOfPorts; j++) {
 8002d3e:	2000      	movs	r0, #0
				array[i - 1][j] = (*(__IO uint16_t*) (RO_START_ADDRESS + add));
 8002d40:	1e5c      	subs	r4, r3, #1
 8002d42:	4374      	muls	r4, r6
			for (volatile uint8_t j = 0; j <= MaxNumOfPorts; j++) {
 8002d44:	7008      	strb	r0, [r1, #0]
 8002d46:	7808      	ldrb	r0, [r1, #0]
 8002d48:	280a      	cmp	r0, #10
 8002d4a:	d902      	bls.n	8002d52 <LoadROtopology+0x5a>
		for (uint8_t i = 1; i <= N; i++) {
 8002d4c:	3301      	adds	r3, #1
 8002d4e:	b2db      	uxtb	r3, r3
 8002d50:	e7ee      	b.n	8002d30 <LoadROtopology+0x38>
				array[i - 1][j] = (*(__IO uint16_t*) (RO_START_ADDRESS + add));
 8002d52:	4808      	ldr	r0, [pc, #32]	; (8002d74 <LoadROtopology+0x7c>)
 8002d54:	1817      	adds	r7, r2, r0
 8002d56:	7808      	ldrb	r0, [r1, #0]
 8002d58:	883f      	ldrh	r7, [r7, #0]
 8002d5a:	1820      	adds	r0, r4, r0
 8002d5c:	46bc      	mov	ip, r7
 8002d5e:	4665      	mov	r5, ip
 8002d60:	4f08      	ldr	r7, [pc, #32]	; (8002d84 <LoadROtopology+0x8c>)
 8002d62:	0040      	lsls	r0, r0, #1
 8002d64:	523d      	strh	r5, [r7, r0]
			for (volatile uint8_t j = 0; j <= MaxNumOfPorts; j++) {
 8002d66:	7808      	ldrb	r0, [r1, #0]
				add += 2;
 8002d68:	3202      	adds	r2, #2
			for (volatile uint8_t j = 0; j <= MaxNumOfPorts; j++) {
 8002d6a:	3001      	adds	r0, #1
 8002d6c:	b2c0      	uxtb	r0, r0
				add += 2;
 8002d6e:	b292      	uxth	r2, r2
			for (volatile uint8_t j = 0; j <= MaxNumOfPorts; j++) {
 8002d70:	7008      	strb	r0, [r1, #0]
 8002d72:	e7e8      	b.n	8002d46 <LoadROtopology+0x4e>
 8002d74:	0801d800 	.word	0x0801d800
 8002d78:	0000ffff 	.word	0x0000ffff
 8002d7c:	2000001c 	.word	0x2000001c
 8002d80:	20001039 	.word	0x20001039
 8002d84:	20000aa0 	.word	0x20000aa0

08002d88 <SaveEEportsDir>:
/*-----------------------------------------------------------*/

/* --- Save array ports directions in EEPROM ---
 */
BOS_Status SaveEEportsDir(void) {
 8002d88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;

	for (uint8_t i = 1; i <= N; i++) {
 8002d8a:	2401      	movs	r4, #1
	BOS_Status result = BOS_OK;
 8002d8c:	2500      	movs	r5, #0
		if (arrayPortsDir[i - 1])
			EE_WriteVariable(_EE_PORT_DIR_BASE + i - 1, arrayPortsDir[i - 1]);

		if ((i + _EE_PORT_DIR_BASE) >= _EE_ALIAS_BASE)
			result = BOS_ERR_EEPROM;
 8002d8e:	270a      	movs	r7, #10
	for (uint8_t i = 1; i <= N; i++) {
 8002d90:	4b0a      	ldr	r3, [pc, #40]	; (8002dbc <SaveEEportsDir+0x34>)
 8002d92:	781b      	ldrb	r3, [r3, #0]
 8002d94:	42a3      	cmp	r3, r4
 8002d96:	d201      	bcs.n	8002d9c <SaveEEportsDir+0x14>
	}

	return result;
}
 8002d98:	0028      	movs	r0, r5
 8002d9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (arrayPortsDir[i - 1])
 8002d9c:	1e63      	subs	r3, r4, #1
 8002d9e:	4a08      	ldr	r2, [pc, #32]	; (8002dc0 <SaveEEportsDir+0x38>)
 8002da0:	005b      	lsls	r3, r3, #1
 8002da2:	5a99      	ldrh	r1, [r3, r2]
 8002da4:	1c66      	adds	r6, r4, #1
 8002da6:	2900      	cmp	r1, #0
 8002da8:	d002      	beq.n	8002db0 <SaveEEportsDir+0x28>
			EE_WriteVariable(_EE_PORT_DIR_BASE + i - 1, arrayPortsDir[i - 1]);
 8002daa:	b2b0      	uxth	r0, r6
 8002dac:	f003 fe26 	bl	80069fc <EE_WriteVariable>
		if ((i + _EE_PORT_DIR_BASE) >= _EE_ALIAS_BASE)
 8002db0:	2c19      	cmp	r4, #25
 8002db2:	d900      	bls.n	8002db6 <SaveEEportsDir+0x2e>
			result = BOS_ERR_EEPROM;
 8002db4:	003d      	movs	r5, r7
	for (uint8_t i = 1; i <= N; i++) {
 8002db6:	b2f4      	uxtb	r4, r6
 8002db8:	e7ea      	b.n	8002d90 <SaveEEportsDir+0x8>
 8002dba:	46c0      	nop			; (mov r8, r8)
 8002dbc:	2000001c 	.word	0x2000001c
 8002dc0:	20007a44 	.word	0x20007a44

08002dc4 <ClearEEportsDir>:

/*-----------------------------------------------------------*/

/* --- Clear array ports directions in EEPROM --- 
 */
BOS_Status ClearEEportsDir(void) {
 8002dc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;

	memset(arrayPortsDir, 0, sizeof(arrayPortsDir));
 8002dc6:	4e0e      	ldr	r6, [pc, #56]	; (8002e00 <ClearEEportsDir+0x3c>)
 8002dc8:	2232      	movs	r2, #50	; 0x32
 8002dca:	2100      	movs	r1, #0
 8002dcc:	0030      	movs	r0, r6
 8002dce:	f011 fc4a 	bl	8014666 <memset>

	for (uint8_t i = 1; i <= N; i++) {
 8002dd2:	2401      	movs	r4, #1
	BOS_Status result = BOS_OK;
 8002dd4:	2500      	movs	r5, #0
	for (uint8_t i = 1; i <= N; i++) {
 8002dd6:	4b0b      	ldr	r3, [pc, #44]	; (8002e04 <ClearEEportsDir+0x40>)
 8002dd8:	781b      	ldrb	r3, [r3, #0]
 8002dda:	42a3      	cmp	r3, r4
 8002ddc:	d201      	bcs.n	8002de2 <ClearEEportsDir+0x1e>
		if ((i + _EE_PORT_DIR_BASE) >= _EE_ALIAS_BASE)
			result = BOS_ERR_EEPROM;
	}

	return result;
}
 8002dde:	0028      	movs	r0, r5
 8002de0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (arrayPortsDir[i - 1])
 8002de2:	1e63      	subs	r3, r4, #1
 8002de4:	005b      	lsls	r3, r3, #1
 8002de6:	5af1      	ldrh	r1, [r6, r3]
 8002de8:	1c67      	adds	r7, r4, #1
 8002dea:	2900      	cmp	r1, #0
 8002dec:	d002      	beq.n	8002df4 <ClearEEportsDir+0x30>
			EE_WriteVariable(_EE_PORT_DIR_BASE + i - 1, arrayPortsDir[i - 1]);
 8002dee:	b2b8      	uxth	r0, r7
 8002df0:	f003 fe04 	bl	80069fc <EE_WriteVariable>
		if ((i + _EE_PORT_DIR_BASE) >= _EE_ALIAS_BASE)
 8002df4:	2c19      	cmp	r4, #25
 8002df6:	d900      	bls.n	8002dfa <ClearEEportsDir+0x36>
			result = BOS_ERR_EEPROM;
 8002df8:	250a      	movs	r5, #10
	for (uint8_t i = 1; i <= N; i++) {
 8002dfa:	b2fc      	uxtb	r4, r7
 8002dfc:	e7eb      	b.n	8002dd6 <ClearEEportsDir+0x12>
 8002dfe:	46c0      	nop			; (mov r8, r8)
 8002e00:	20007a44 	.word	0x20007a44
 8002e04:	2000001c 	.word	0x2000001c

08002e08 <LoadEEportsDir>:

/*-----------------------------------------------------------*/

/* --- Load array ports directions stored in EEPROM --- 
 */
BOS_Status LoadEEportsDir(void) {
 8002e08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;

	for (uint8_t i = 1; i <= N; i++) {
 8002e0a:	2401      	movs	r4, #1
	BOS_Status result = BOS_OK;
 8002e0c:	2500      	movs	r5, #0
		EE_ReadVariable(_EE_PORT_DIR_BASE + i - 1, &arrayPortsDir[i - 1]);

		if ((i + _EE_PORT_DIR_BASE) >= _EE_ALIAS_BASE)
			result = BOS_ERR_EEPROM;
 8002e0e:	270a      	movs	r7, #10
	for (uint8_t i = 1; i <= N; i++) {
 8002e10:	4b09      	ldr	r3, [pc, #36]	; (8002e38 <LoadEEportsDir+0x30>)
 8002e12:	781b      	ldrb	r3, [r3, #0]
 8002e14:	42a3      	cmp	r3, r4
 8002e16:	d201      	bcs.n	8002e1c <LoadEEportsDir+0x14>
	}

	return result;
}
 8002e18:	0028      	movs	r0, r5
 8002e1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		EE_ReadVariable(_EE_PORT_DIR_BASE + i - 1, &arrayPortsDir[i - 1]);
 8002e1c:	1e61      	subs	r1, r4, #1
 8002e1e:	4b07      	ldr	r3, [pc, #28]	; (8002e3c <LoadEEportsDir+0x34>)
 8002e20:	0049      	lsls	r1, r1, #1
 8002e22:	1c66      	adds	r6, r4, #1
 8002e24:	18c9      	adds	r1, r1, r3
 8002e26:	b2b0      	uxth	r0, r6
 8002e28:	f003 fdbe 	bl	80069a8 <EE_ReadVariable>
		if ((i + _EE_PORT_DIR_BASE) >= _EE_ALIAS_BASE)
 8002e2c:	2c19      	cmp	r4, #25
 8002e2e:	d900      	bls.n	8002e32 <LoadEEportsDir+0x2a>
			result = BOS_ERR_EEPROM;
 8002e30:	003d      	movs	r5, r7
	for (uint8_t i = 1; i <= N; i++) {
 8002e32:	b2f4      	uxtb	r4, r6
 8002e34:	e7ec      	b.n	8002e10 <LoadEEportsDir+0x8>
 8002e36:	46c0      	nop			; (mov r8, r8)
 8002e38:	2000001c 	.word	0x2000001c
 8002e3c:	20007a44 	.word	0x20007a44

08002e40 <SaveEEalias>:

/*-----------------------------------------------------------*/

/* --- Save module alias in EEPROM --- 
 */
BOS_Status SaveEEalias(void) {
 8002e40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;
	uint16_t add = 0, temp = 0;

	for (uint8_t i = 0; i <= N; i++)				// N+1 module aliases
 8002e42:	2500      	movs	r5, #0
	uint16_t add = 0, temp = 0;
 8002e44:	002f      	movs	r7, r5
	for (uint8_t i = 0; i <= N; i++)				// N+1 module aliases
 8002e46:	4b13      	ldr	r3, [pc, #76]	; (8002e94 <SaveEEalias+0x54>)
 8002e48:	781b      	ldrb	r3, [r3, #0]
 8002e4a:	42ab      	cmp	r3, r5
 8002e4c:	d201      	bcs.n	8002e52 <SaveEEalias+0x12>
			}
		}
	}

	return result;
}
 8002e4e:	2000      	movs	r0, #0
 8002e50:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (moduleAlias[i][0]) {
 8002e52:	260a      	movs	r6, #10
 8002e54:	436e      	muls	r6, r5
 8002e56:	4b10      	ldr	r3, [pc, #64]	; (8002e98 <SaveEEalias+0x58>)
 8002e58:	5cf2      	ldrb	r2, [r6, r3]
 8002e5a:	2a00      	cmp	r2, #0
 8002e5c:	d017      	beq.n	8002e8e <SaveEEalias+0x4e>
 8002e5e:	18f6      	adds	r6, r6, r3
 8002e60:	003b      	movs	r3, r7
 8002e62:	003c      	movs	r4, r7
 8002e64:	3321      	adds	r3, #33	; 0x21
 8002e66:	341c      	adds	r4, #28
 8002e68:	b29b      	uxth	r3, r3
 8002e6a:	b2a4      	uxth	r4, r4
 8002e6c:	9301      	str	r3, [sp, #4]
				temp = (uint16_t) (moduleAlias[i][j - 1] << 8)
 8002e6e:	7833      	ldrb	r3, [r6, #0]
						+ moduleAlias[i][j];
 8002e70:	7871      	ldrb	r1, [r6, #1]
				temp = (uint16_t) (moduleAlias[i][j - 1] << 8)
 8002e72:	021b      	lsls	r3, r3, #8
 8002e74:	18c9      	adds	r1, r1, r3
				EE_WriteVariable(_EE_ALIAS_BASE + add, temp);
 8002e76:	0020      	movs	r0, r4
 8002e78:	b289      	uxth	r1, r1
 8002e7a:	f003 fdbf 	bl	80069fc <EE_WriteVariable>
 8002e7e:	3401      	adds	r4, #1
			for (uint8_t j = 1; j <= MaxLengthOfAlias; j += 2) {
 8002e80:	9b01      	ldr	r3, [sp, #4]
 8002e82:	b2a4      	uxth	r4, r4
 8002e84:	3602      	adds	r6, #2
 8002e86:	429c      	cmp	r4, r3
 8002e88:	d1f1      	bne.n	8002e6e <SaveEEalias+0x2e>
 8002e8a:	3705      	adds	r7, #5
 8002e8c:	b2bf      	uxth	r7, r7
	for (uint8_t i = 0; i <= N; i++)				// N+1 module aliases
 8002e8e:	3501      	adds	r5, #1
 8002e90:	b2ed      	uxtb	r5, r5
 8002e92:	e7d8      	b.n	8002e46 <SaveEEalias+0x6>
 8002e94:	2000001c 	.word	0x2000001c
 8002e98:	20000f35 	.word	0x20000f35

08002e9c <LoadEEalias>:

/*-----------------------------------------------------------*/

/* --- Load module alias stored in EEPROM --- 
 */
BOS_Status LoadEEalias(void) {
 8002e9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002e9e:	b085      	sub	sp, #20
	BOS_Status result = BOS_OK;
	uint16_t add = 0, temp = 0;
 8002ea0:	ab02      	add	r3, sp, #8
 8002ea2:	2400      	movs	r4, #0
 8002ea4:	1d9f      	adds	r7, r3, #6

	for (uint8_t i = 0; i <= N; i++)				// N+1 module aliases
 8002ea6:	231c      	movs	r3, #28
	uint16_t add = 0, temp = 0;
 8002ea8:	803c      	strh	r4, [r7, #0]
 8002eaa:	9300      	str	r3, [sp, #0]
	for (uint8_t i = 0; i <= N; i++)				// N+1 module aliases
 8002eac:	4b14      	ldr	r3, [pc, #80]	; (8002f00 <LoadEEalias+0x64>)
 8002eae:	781b      	ldrb	r3, [r3, #0]
 8002eb0:	42a3      	cmp	r3, r4
 8002eb2:	d202      	bcs.n	8002eba <LoadEEalias+0x1e>
		}
		moduleAlias[i][MaxLengthOfAlias] = '\0';
	}

	return result;
}
 8002eb4:	2000      	movs	r0, #0
 8002eb6:	b005      	add	sp, #20
 8002eb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002eba:	230a      	movs	r3, #10
	for (uint8_t i = 0; i <= N; i++)				// N+1 module aliases
 8002ebc:	2500      	movs	r5, #0
 8002ebe:	4363      	muls	r3, r4
 8002ec0:	4a10      	ldr	r2, [pc, #64]	; (8002f04 <LoadEEalias+0x68>)
 8002ec2:	9e00      	ldr	r6, [sp, #0]
 8002ec4:	189b      	adds	r3, r3, r2
 8002ec6:	9301      	str	r3, [sp, #4]
			EE_ReadVariable(_EE_ALIAS_BASE + add, &temp);
 8002ec8:	0030      	movs	r0, r6
 8002eca:	0039      	movs	r1, r7
 8002ecc:	f003 fd6c 	bl	80069a8 <EE_ReadVariable>
			moduleAlias[i][j] = (uint8_t) temp;
 8002ed0:	9a01      	ldr	r2, [sp, #4]
 8002ed2:	883b      	ldrh	r3, [r7, #0]
 8002ed4:	1952      	adds	r2, r2, r5
 8002ed6:	7053      	strb	r3, [r2, #1]
			moduleAlias[i][j - 1] = (uint8_t) (temp >> 8);
 8002ed8:	9a01      	ldr	r2, [sp, #4]
 8002eda:	0a1b      	lsrs	r3, r3, #8
 8002edc:	5553      	strb	r3, [r2, r5]
 8002ede:	3601      	adds	r6, #1
 8002ee0:	3502      	adds	r5, #2
 8002ee2:	b2b6      	uxth	r6, r6
		for (uint8_t j = 1; j <= MaxLengthOfAlias; j += 2) {
 8002ee4:	2d0a      	cmp	r5, #10
 8002ee6:	d1ef      	bne.n	8002ec8 <LoadEEalias+0x2c>
		moduleAlias[i][MaxLengthOfAlias] = '\0';
 8002ee8:	4365      	muls	r5, r4
 8002eea:	4b06      	ldr	r3, [pc, #24]	; (8002f04 <LoadEEalias+0x68>)
	for (uint8_t i = 0; i <= N; i++)				// N+1 module aliases
 8002eec:	3401      	adds	r4, #1
		moduleAlias[i][MaxLengthOfAlias] = '\0';
 8002eee:	195d      	adds	r5, r3, r5
 8002ef0:	2300      	movs	r3, #0
 8002ef2:	726b      	strb	r3, [r5, #9]
 8002ef4:	9b00      	ldr	r3, [sp, #0]
	for (uint8_t i = 0; i <= N; i++)				// N+1 module aliases
 8002ef6:	b2e4      	uxtb	r4, r4
 8002ef8:	3305      	adds	r3, #5
 8002efa:	b29b      	uxth	r3, r3
 8002efc:	e7d5      	b.n	8002eaa <LoadEEalias+0xe>
 8002efe:	46c0      	nop			; (mov r8, r8)
 8002f00:	2000001c 	.word	0x2000001c
 8002f04:	20000f35 	.word	0x20000f35

08002f08 <LoadEEgroup>:

/*-----------------------------------------------------------*/

/* --- Load module groups stored in EEPROM --- 
 */
BOS_Status LoadEEgroup(void) {
 8002f08:	b5f0      	push	{r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;
	uint16_t add = 0, temp = 0;
 8002f0a:	2400      	movs	r4, #0
BOS_Status LoadEEgroup(void) {
 8002f0c:	b085      	sub	sp, #20
	uint16_t add = 0, temp = 0;
 8002f0e:	ab02      	add	r3, sp, #8
 8002f10:	1d9f      	adds	r7, r3, #6
 8002f12:	803c      	strh	r4, [r7, #0]
	uint8_t i = 0;

	/* Load group members */
	for (i = 0; i < N; i++)			// N modules
 8002f14:	4b17      	ldr	r3, [pc, #92]	; (8002f74 <LoadEEgroup+0x6c>)
 8002f16:	1c65      	adds	r5, r4, #1
 8002f18:	781b      	ldrb	r3, [r3, #0]
 8002f1a:	b2e1      	uxtb	r1, r4
 8002f1c:	b2ad      	uxth	r5, r5
 8002f1e:	428b      	cmp	r3, r1
 8002f20:	d81e      	bhi.n	8002f60 <LoadEEgroup+0x58>
 8002f22:	3499      	adds	r4, #153	; 0x99
 8002f24:	4d14      	ldr	r5, [pc, #80]	; (8002f78 <LoadEEgroup+0x70>)
 8002f26:	b2a4      	uxth	r4, r4
			{
		EE_ReadVariable(_EE_GROUP_MODULES_BASE + add, &groupModules[i]);
		add++;
 8002f28:	2600      	movs	r6, #0
 8002f2a:	9401      	str	r4, [sp, #4]

	/* Load group alias */
	for (i = 0; i < MaxNumOfGroups; i++)		// MaxNumOfGroups group aliases
			{
		for (uint8_t j = 1; j <= MaxLengthOfAlias; j += 2) {
			EE_ReadVariable(_EE_GROUP_ALIAS_BASE + add, &temp);
 8002f2c:	0039      	movs	r1, r7
 8002f2e:	9801      	ldr	r0, [sp, #4]
 8002f30:	f003 fd3a 	bl	80069a8 <EE_ReadVariable>
			groupAlias[i][j] = (uint8_t) temp;
 8002f34:	883b      	ldrh	r3, [r7, #0]
 8002f36:	19aa      	adds	r2, r5, r6
 8002f38:	7053      	strb	r3, [r2, #1]
			groupAlias[i][j - 1] = (uint8_t) (temp >> 8);
 8002f3a:	0a1b      	lsrs	r3, r3, #8
 8002f3c:	55ab      	strb	r3, [r5, r6]
 8002f3e:	9b01      	ldr	r3, [sp, #4]
 8002f40:	3602      	adds	r6, #2
 8002f42:	3301      	adds	r3, #1
 8002f44:	b29b      	uxth	r3, r3
 8002f46:	9301      	str	r3, [sp, #4]
		for (uint8_t j = 1; j <= MaxLengthOfAlias; j += 2) {
 8002f48:	2e0a      	cmp	r6, #10
 8002f4a:	d1ef      	bne.n	8002f2c <LoadEEgroup+0x24>
			add++;
		}
		groupAlias[i][MaxLengthOfAlias] = '\0';
 8002f4c:	2000      	movs	r0, #0
	for (i = 0; i < MaxNumOfGroups; i++)		// MaxNumOfGroups group aliases
 8002f4e:	4b0b      	ldr	r3, [pc, #44]	; (8002f7c <LoadEEgroup+0x74>)
		groupAlias[i][MaxLengthOfAlias] = '\0';
 8002f50:	7268      	strb	r0, [r5, #9]
 8002f52:	3405      	adds	r4, #5
 8002f54:	350a      	adds	r5, #10
 8002f56:	b2a4      	uxth	r4, r4
	for (i = 0; i < MaxNumOfGroups; i++)		// MaxNumOfGroups group aliases
 8002f58:	429d      	cmp	r5, r3
 8002f5a:	d1e5      	bne.n	8002f28 <LoadEEgroup+0x20>
	}

	return result;
}
 8002f5c:	b005      	add	sp, #20
 8002f5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		EE_ReadVariable(_EE_GROUP_MODULES_BASE + add, &groupModules[i]);
 8002f60:	4b07      	ldr	r3, [pc, #28]	; (8002f80 <LoadEEgroup+0x78>)
 8002f62:	34cb      	adds	r4, #203	; 0xcb
 8002f64:	0049      	lsls	r1, r1, #1
 8002f66:	b2a0      	uxth	r0, r4
 8002f68:	1859      	adds	r1, r3, r1
 8002f6a:	f003 fd1d 	bl	80069a8 <EE_ReadVariable>
		add++;
 8002f6e:	002c      	movs	r4, r5
 8002f70:	e7d0      	b.n	8002f14 <LoadEEgroup+0xc>
 8002f72:	46c0      	nop			; (mov r8, r8)
 8002f74:	2000001c 	.word	0x2000001c
 8002f78:	20000e2f 	.word	0x20000e2f
 8002f7c:	20000e93 	.word	0x20000e93
 8002f80:	20000e94 	.word	0x20000e94

08002f84 <LoadEEstreams>:

/*-----------------------------------------------------------*/

/* --- Load module DMA streams --- 
 */
BOS_Status LoadEEstreams(void) {
 8002f84:	b5f0      	push	{r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;
	uint16_t temp1 = 0, temp2 = 0, status1 = 0, status2 = 0;
 8002f86:	270e      	movs	r7, #14
 8002f88:	2500      	movs	r5, #0
BOS_Status LoadEEstreams(void) {
 8002f8a:	b087      	sub	sp, #28
	uint16_t temp1 = 0, temp2 = 0, status1 = 0, status2 = 0;
 8002f8c:	ac05      	add	r4, sp, #20
 8002f8e:	ab02      	add	r3, sp, #8
 8002f90:	18ff      	adds	r7, r7, r3
	uint8_t direction = 0;
	uint32_t count = 0, timeout = 0;
	static uint8_t src1, dst1, src2, dst2, src3, dst3;

	/* Direction */
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE, &temp1);
 8002f92:	0021      	movs	r1, r4
 8002f94:	20e4      	movs	r0, #228	; 0xe4
	uint16_t temp1 = 0, temp2 = 0, status1 = 0, status2 = 0;
 8002f96:	8025      	strh	r5, [r4, #0]
 8002f98:	803d      	strh	r5, [r7, #0]
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE, &temp1);
 8002f9a:	f003 fd05 	bl	80069a8 <EE_ReadVariable>
	uint8_t direction = 0;
 8002f9e:	9503      	str	r5, [sp, #12]
	if (!status1) {
 8002fa0:	42a8      	cmp	r0, r5
 8002fa2:	d101      	bne.n	8002fa8 <LoadEEstreams+0x24>
		direction = (uint8_t) temp1;
 8002fa4:	7823      	ldrb	r3, [r4, #0]
 8002fa6:	9303      	str	r3, [sp, #12]
	}

	/* Count */
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 1, &temp1);
 8002fa8:	0021      	movs	r1, r4
 8002faa:	20e5      	movs	r0, #229	; 0xe5
 8002fac:	f003 fcfc 	bl	80069a8 <EE_ReadVariable>
	status2 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 2, &temp2);
 8002fb0:	0039      	movs	r1, r7
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 1, &temp1);
 8002fb2:	0005      	movs	r5, r0
	status2 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 2, &temp2);
 8002fb4:	20e6      	movs	r0, #230	; 0xe6
 8002fb6:	f003 fcf7 	bl	80069a8 <EE_ReadVariable>
	if (!status1 && !status2) {
 8002fba:	4328      	orrs	r0, r5
	uint32_t count = 0, timeout = 0;
 8002fbc:	2500      	movs	r5, #0
	if (!status1 && !status2) {
 8002fbe:	b280      	uxth	r0, r0
 8002fc0:	42a8      	cmp	r0, r5
 8002fc2:	d103      	bne.n	8002fcc <LoadEEstreams+0x48>
		count = ((uint32_t) temp1 << 16) + temp2;
 8002fc4:	8825      	ldrh	r5, [r4, #0]
 8002fc6:	883b      	ldrh	r3, [r7, #0]
 8002fc8:	042d      	lsls	r5, r5, #16
 8002fca:	18ed      	adds	r5, r5, r3
	}

	/* Timeout */
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 3, &temp1);
 8002fcc:	0021      	movs	r1, r4
 8002fce:	20e7      	movs	r0, #231	; 0xe7
 8002fd0:	f003 fcea 	bl	80069a8 <EE_ReadVariable>
	status2 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 4, &temp2);
 8002fd4:	0039      	movs	r1, r7
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 3, &temp1);
 8002fd6:	0006      	movs	r6, r0
	status2 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 4, &temp2);
 8002fd8:	20e8      	movs	r0, #232	; 0xe8
 8002fda:	f003 fce5 	bl	80069a8 <EE_ReadVariable>
	if (!status1 && !status2) {
 8002fde:	4330      	orrs	r0, r6
	uint32_t count = 0, timeout = 0;
 8002fe0:	2600      	movs	r6, #0
	if (!status1 && !status2) {
 8002fe2:	b280      	uxth	r0, r0
 8002fe4:	42b0      	cmp	r0, r6
 8002fe6:	d103      	bne.n	8002ff0 <LoadEEstreams+0x6c>
		timeout = ((uint32_t) temp1 << 16) + temp2;
 8002fe8:	8826      	ldrh	r6, [r4, #0]
 8002fea:	883b      	ldrh	r3, [r7, #0]
 8002fec:	0436      	lsls	r6, r6, #16
 8002fee:	18f6      	adds	r6, r6, r3
	}

	/* src1 | dst1 */
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 5, &temp1);
 8002ff0:	0021      	movs	r1, r4
 8002ff2:	20e9      	movs	r0, #233	; 0xe9
 8002ff4:	f003 fcd8 	bl	80069a8 <EE_ReadVariable>
 8002ff8:	4f25      	ldr	r7, [pc, #148]	; (8003090 <LoadEEstreams+0x10c>)
	if (!status1) {
 8002ffa:	2800      	cmp	r0, #0
 8002ffc:	d104      	bne.n	8003008 <LoadEEstreams+0x84>
		src1 = (uint8_t) (temp1 >> 8);
 8002ffe:	8823      	ldrh	r3, [r4, #0]
 8003000:	0a1a      	lsrs	r2, r3, #8
 8003002:	703a      	strb	r2, [r7, #0]
		dst1 = (uint8_t) temp1;
 8003004:	4a23      	ldr	r2, [pc, #140]	; (8003094 <LoadEEstreams+0x110>)
 8003006:	7013      	strb	r3, [r2, #0]
	}

	/* src2 | dst2 */
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 6, &temp1);
 8003008:	0021      	movs	r1, r4
 800300a:	20ea      	movs	r0, #234	; 0xea
 800300c:	f003 fccc 	bl	80069a8 <EE_ReadVariable>
	if (!status1) {
 8003010:	2800      	cmp	r0, #0
 8003012:	d105      	bne.n	8003020 <LoadEEstreams+0x9c>
		src2 = (uint8_t) (temp1 >> 8);
 8003014:	8823      	ldrh	r3, [r4, #0]
 8003016:	4920      	ldr	r1, [pc, #128]	; (8003098 <LoadEEstreams+0x114>)
 8003018:	0a1a      	lsrs	r2, r3, #8
 800301a:	700a      	strb	r2, [r1, #0]
		dst2 = (uint8_t) temp1;
 800301c:	4a1f      	ldr	r2, [pc, #124]	; (800309c <LoadEEstreams+0x118>)
 800301e:	7013      	strb	r3, [r2, #0]
	}

	/* src3 | dst3 */
	status1 = EE_ReadVariable(_EE_DMA_STREAM_BASE + 7, &temp1);
 8003020:	0021      	movs	r1, r4
 8003022:	20eb      	movs	r0, #235	; 0xeb
 8003024:	f003 fcc0 	bl	80069a8 <EE_ReadVariable>
	if (!status1) {
 8003028:	2800      	cmp	r0, #0
 800302a:	d105      	bne.n	8003038 <LoadEEstreams+0xb4>
		src3 = (uint8_t) (temp1 >> 8);
 800302c:	8823      	ldrh	r3, [r4, #0]
 800302e:	491c      	ldr	r1, [pc, #112]	; (80030a0 <LoadEEstreams+0x11c>)
 8003030:	0a1a      	lsrs	r2, r3, #8
 8003032:	700a      	strb	r2, [r1, #0]
		dst3 = (uint8_t) temp1;
 8003034:	4a1b      	ldr	r2, [pc, #108]	; (80030a4 <LoadEEstreams+0x120>)
 8003036:	7013      	strb	r3, [r2, #0]
	}

	/* Activate the DMA streams */
	if (src1 && dst1)
 8003038:	783b      	ldrb	r3, [r7, #0]
 800303a:	2b00      	cmp	r3, #0
 800303c:	d009      	beq.n	8003052 <LoadEEstreams+0xce>
 800303e:	4a15      	ldr	r2, [pc, #84]	; (8003094 <LoadEEstreams+0x110>)
 8003040:	7812      	ldrb	r2, [r2, #0]
 8003042:	2a00      	cmp	r2, #0
 8003044:	d005      	beq.n	8003052 <LoadEEstreams+0xce>
		SetupDMAStreams(direction, count, timeout, src1, dst1);
 8003046:	9200      	str	r2, [sp, #0]
 8003048:	0029      	movs	r1, r5
 800304a:	0032      	movs	r2, r6
 800304c:	9803      	ldr	r0, [sp, #12]
 800304e:	f004 fcc5 	bl	80079dc <SetupDMAStreams>
	if (src2 && dst2)
 8003052:	4b11      	ldr	r3, [pc, #68]	; (8003098 <LoadEEstreams+0x114>)
 8003054:	781b      	ldrb	r3, [r3, #0]
 8003056:	2b00      	cmp	r3, #0
 8003058:	d009      	beq.n	800306e <LoadEEstreams+0xea>
 800305a:	4a10      	ldr	r2, [pc, #64]	; (800309c <LoadEEstreams+0x118>)
 800305c:	7812      	ldrb	r2, [r2, #0]
 800305e:	2a00      	cmp	r2, #0
 8003060:	d005      	beq.n	800306e <LoadEEstreams+0xea>
		SetupDMAStreams(direction, count, timeout, src2, dst2);
 8003062:	9200      	str	r2, [sp, #0]
 8003064:	0029      	movs	r1, r5
 8003066:	0032      	movs	r2, r6
 8003068:	9803      	ldr	r0, [sp, #12]
 800306a:	f004 fcb7 	bl	80079dc <SetupDMAStreams>
	if (src3 && dst3)
 800306e:	4b0c      	ldr	r3, [pc, #48]	; (80030a0 <LoadEEstreams+0x11c>)
 8003070:	781b      	ldrb	r3, [r3, #0]
 8003072:	2b00      	cmp	r3, #0
 8003074:	d009      	beq.n	800308a <LoadEEstreams+0x106>
 8003076:	4a0b      	ldr	r2, [pc, #44]	; (80030a4 <LoadEEstreams+0x120>)
 8003078:	7812      	ldrb	r2, [r2, #0]
 800307a:	2a00      	cmp	r2, #0
 800307c:	d005      	beq.n	800308a <LoadEEstreams+0x106>
		SetupDMAStreams(direction, count, timeout, src3, dst3);
 800307e:	9200      	str	r2, [sp, #0]
 8003080:	0029      	movs	r1, r5
 8003082:	0032      	movs	r2, r6
 8003084:	9803      	ldr	r0, [sp, #12]
 8003086:	f004 fca9 	bl	80079dc <SetupDMAStreams>

	return result;
}
 800308a:	2000      	movs	r0, #0
 800308c:	b007      	add	sp, #28
 800308e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003090:	200010fb 	.word	0x200010fb
 8003094:	20000e2c 	.word	0x20000e2c
 8003098:	200010fc 	.word	0x200010fc
 800309c:	20000e2d 	.word	0x20000e2d
 80030a0:	200010fd 	.word	0x200010fd
 80030a4:	20000e2e 	.word	0x20000e2e

080030a8 <SaveEEstreams>:

/* --- Save DMA streams to emulated EEPROM. --- 
 */
BOS_Status SaveEEstreams(uint8_t direction, uint32_t count, uint32_t timeout,
		uint8_t src1, uint8_t dst1, uint8_t src2, uint8_t dst2, uint8_t src3,
		uint8_t dst3) {
 80030a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80030aa:	000e      	movs	r6, r1
 80030ac:	0015      	movs	r5, r2
 80030ae:	001c      	movs	r4, r3
 80030b0:	b085      	sub	sp, #20
 80030b2:	ab0a      	add	r3, sp, #40	; 0x28
 80030b4:	781f      	ldrb	r7, [r3, #0]
 80030b6:	ab0b      	add	r3, sp, #44	; 0x2c
 80030b8:	781b      	ldrb	r3, [r3, #0]
	BOS_Status result = BOS_OK;

	EE_WriteVariable(_EE_DMA_STREAM_BASE, direction); /* Direction */
 80030ba:	b281      	uxth	r1, r0
		uint8_t dst3) {
 80030bc:	9300      	str	r3, [sp, #0]
 80030be:	ab0c      	add	r3, sp, #48	; 0x30
 80030c0:	781b      	ldrb	r3, [r3, #0]
	EE_WriteVariable(_EE_DMA_STREAM_BASE, direction); /* Direction */
 80030c2:	20e4      	movs	r0, #228	; 0xe4
		uint8_t dst3) {
 80030c4:	9301      	str	r3, [sp, #4]
 80030c6:	ab0d      	add	r3, sp, #52	; 0x34
 80030c8:	781b      	ldrb	r3, [r3, #0]
 80030ca:	9302      	str	r3, [sp, #8]
 80030cc:	ab0e      	add	r3, sp, #56	; 0x38
 80030ce:	781b      	ldrb	r3, [r3, #0]
 80030d0:	9303      	str	r3, [sp, #12]
	EE_WriteVariable(_EE_DMA_STREAM_BASE, direction); /* Direction */
 80030d2:	f003 fc93 	bl	80069fc <EE_WriteVariable>
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 1, ((uint16_t) (count >> 8))); /* Count high half-word */
 80030d6:	0a31      	lsrs	r1, r6, #8
 80030d8:	b289      	uxth	r1, r1
 80030da:	20e5      	movs	r0, #229	; 0xe5
 80030dc:	f003 fc8e 	bl	80069fc <EE_WriteVariable>
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 2, ((uint16_t) count)); /* Count low half-word */
 80030e0:	b2b1      	uxth	r1, r6
 80030e2:	20e6      	movs	r0, #230	; 0xe6
 80030e4:	f003 fc8a 	bl	80069fc <EE_WriteVariable>
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 3, ((uint16_t) (timeout >> 8))); /* Timeout high half-word */
 80030e8:	0a29      	lsrs	r1, r5, #8
 80030ea:	b289      	uxth	r1, r1
 80030ec:	20e7      	movs	r0, #231	; 0xe7
 80030ee:	f003 fc85 	bl	80069fc <EE_WriteVariable>
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 4, ((uint16_t) timeout)); /* Timeout low half-word */
 80030f2:	b2a9      	uxth	r1, r5
 80030f4:	20e8      	movs	r0, #232	; 0xe8
 80030f6:	f003 fc81 	bl	80069fc <EE_WriteVariable>
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 5,
			((uint16_t) (src1 << 8)) + (uint16_t) dst1); /* src1 | dst1 */
 80030fa:	0221      	lsls	r1, r4, #8
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 5,
 80030fc:	19c9      	adds	r1, r1, r7
 80030fe:	b289      	uxth	r1, r1
 8003100:	20e9      	movs	r0, #233	; 0xe9
 8003102:	f003 fc7b 	bl	80069fc <EE_WriteVariable>
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 6,
			((uint16_t) (src2 << 8)) + (uint16_t) dst2); /* src1 | dst1 */
 8003106:	9b00      	ldr	r3, [sp, #0]
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 6,
 8003108:	20ea      	movs	r0, #234	; 0xea
			((uint16_t) (src2 << 8)) + (uint16_t) dst2); /* src1 | dst1 */
 800310a:	0219      	lsls	r1, r3, #8
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 6,
 800310c:	9b01      	ldr	r3, [sp, #4]
 800310e:	18c9      	adds	r1, r1, r3
 8003110:	b289      	uxth	r1, r1
 8003112:	f003 fc73 	bl	80069fc <EE_WriteVariable>
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 7,
			((uint16_t) (src3 << 8)) + (uint16_t) dst3); /* src1 | dst1 */
 8003116:	9b02      	ldr	r3, [sp, #8]
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 7,
 8003118:	20eb      	movs	r0, #235	; 0xeb
			((uint16_t) (src3 << 8)) + (uint16_t) dst3); /* src1 | dst1 */
 800311a:	0219      	lsls	r1, r3, #8
	EE_WriteVariable(_EE_DMA_STREAM_BASE + 7,
 800311c:	9b03      	ldr	r3, [sp, #12]
 800311e:	18c9      	adds	r1, r1, r3
 8003120:	b289      	uxth	r1, r1
 8003122:	f003 fc6b 	bl	80069fc <EE_WriteVariable>

	return result;
}
 8003126:	2000      	movs	r0, #0
 8003128:	b005      	add	sp, #20
 800312a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800312c <LoadEEparams>:

/*-----------------------------------------------------------*/

/* --- Load module parameters from emulated EEPROM. If erased, loade defualts --- 
 */
BOS_Status LoadEEparams(void) {
 800312c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;
	uint16_t temp1, temp2, status1, status2;

	/* Read params base - BOS response and BOS trace */
	status1 = EE_ReadVariable(_EE_PARAMS_BASE, &temp1);
 800312e:	208a      	movs	r0, #138	; 0x8a
 8003130:	ad01      	add	r5, sp, #4
 8003132:	0029      	movs	r1, r5
 8003134:	0040      	lsls	r0, r0, #1
 8003136:	f003 fc37 	bl	80069a8 <EE_ReadVariable>
 800313a:	4c38      	ldr	r4, [pc, #224]	; (800321c <LoadEEparams+0xf0>)
	/* Found the variable (EEPROM is not cleared) */
	if (!status1) {
 800313c:	2800      	cmp	r0, #0
 800313e:	d14c      	bne.n	80031da <LoadEEparams+0xae>
		BOS.response = (uint8_t) temp1;
 8003140:	882b      	ldrh	r3, [r5, #0]
 8003142:	71a3      	strb	r3, [r4, #6]
		BOS.trace = (traceOptions_t) (temp1 >> 8);
 8003144:	0a1b      	lsrs	r3, r3, #8
		BOS.response = BOS_default.response;
		BOS.trace = BOS_default.trace;
	}

	/* Read Button debounce */
	status1 = EE_ReadVariable(_EE_PARAMS_DEBOUNCE, &temp1);
 8003146:	2016      	movs	r0, #22
 8003148:	0029      	movs	r1, r5
 800314a:	30ff      	adds	r0, #255	; 0xff
		BOS.trace = BOS_default.trace;
 800314c:	71e3      	strb	r3, [r4, #7]
	status1 = EE_ReadVariable(_EE_PARAMS_DEBOUNCE, &temp1);
 800314e:	f003 fc2b 	bl	80069a8 <EE_ReadVariable>
	if (!status1)
 8003152:	2800      	cmp	r0, #0
 8003154:	d146      	bne.n	80031e4 <LoadEEparams+0xb8>
		BOS.buttons.debounce = temp1;
 8003156:	882b      	ldrh	r3, [r5, #0]
	else
		BOS.buttons.debounce = BOS_default.buttons.debounce;

	/* Read Button single click time */
	status1 = EE_ReadVariable(_EE_PARAMS_SINGLE_CLICK, &temp1);
 8003158:	208b      	movs	r0, #139	; 0x8b
 800315a:	0029      	movs	r1, r5
 800315c:	0040      	lsls	r0, r0, #1
		BOS.buttons.debounce = BOS_default.buttons.debounce;
 800315e:	8023      	strh	r3, [r4, #0]
	status1 = EE_ReadVariable(_EE_PARAMS_SINGLE_CLICK, &temp1);
 8003160:	f003 fc22 	bl	80069a8 <EE_ReadVariable>
	if (!status1)
 8003164:	2800      	cmp	r0, #0
 8003166:	d140      	bne.n	80031ea <LoadEEparams+0xbe>
		BOS.buttons.singleClickTime = temp1;
 8003168:	882b      	ldrh	r3, [r5, #0]
	else
		BOS.buttons.singleClickTime = BOS_default.buttons.singleClickTime;

	/* Read Button double click time (min and max inter-click) */
	status1 = EE_ReadVariable(_EE_PARAMS_DBL_CLICK, &temp1);
 800316a:	2018      	movs	r0, #24
 800316c:	0029      	movs	r1, r5
 800316e:	30ff      	adds	r0, #255	; 0xff
		BOS.buttons.singleClickTime = BOS_default.buttons.singleClickTime;
 8003170:	8063      	strh	r3, [r4, #2]
	status1 = EE_ReadVariable(_EE_PARAMS_DBL_CLICK, &temp1);
 8003172:	f003 fc19 	bl	80069a8 <EE_ReadVariable>
	if (!status1) {
 8003176:	2800      	cmp	r0, #0
 8003178:	d13a      	bne.n	80031f0 <LoadEEparams+0xc4>
		BOS.buttons.minInterClickTime = (uint8_t) temp1;
 800317a:	882b      	ldrh	r3, [r5, #0]
 800317c:	7123      	strb	r3, [r4, #4]
		BOS.buttons.maxInterClickTime = (uint8_t) (temp1 >> 8);
 800317e:	0a1b      	lsrs	r3, r3, #8
		BOS.buttons.minInterClickTime = BOS_default.buttons.minInterClickTime;
		BOS.buttons.maxInterClickTime = BOS_default.buttons.maxInterClickTime;
	}

	/* Read CLI baudrate */
	status1 = EE_ReadVariable(_EE_CLI_BAUD, &temp1);
 8003180:	208c      	movs	r0, #140	; 0x8c
 8003182:	0029      	movs	r1, r5
 8003184:	0040      	lsls	r0, r0, #1
		BOS.buttons.maxInterClickTime = BOS_default.buttons.maxInterClickTime;
 8003186:	7163      	strb	r3, [r4, #5]
	status1 = EE_ReadVariable(_EE_CLI_BAUD, &temp1);
 8003188:	f003 fc0e 	bl	80069a8 <EE_ReadVariable>
	status2 = EE_ReadVariable(_EE_CLI_BAUD + 1, &temp2);
 800318c:	466b      	mov	r3, sp
	status1 = EE_ReadVariable(_EE_CLI_BAUD, &temp1);
 800318e:	0006      	movs	r6, r0
	status2 = EE_ReadVariable(_EE_CLI_BAUD + 1, &temp2);
 8003190:	201a      	movs	r0, #26
 8003192:	1d9f      	adds	r7, r3, #6
 8003194:	0039      	movs	r1, r7
 8003196:	30ff      	adds	r0, #255	; 0xff
 8003198:	f003 fc06 	bl	80069a8 <EE_ReadVariable>
	if (!status1 && !status2) {
 800319c:	4306      	orrs	r6, r0
 800319e:	b2b6      	uxth	r6, r6
 80031a0:	2e00      	cmp	r6, #0
 80031a2:	d12a      	bne.n	80031fa <LoadEEparams+0xce>
		BOS.clibaudrate = (uint32_t) temp1 | (((uint32_t) temp2) << 16);
 80031a4:	883b      	ldrh	r3, [r7, #0]
 80031a6:	882a      	ldrh	r2, [r5, #0]
 80031a8:	041b      	lsls	r3, r3, #16
 80031aa:	4313      	orrs	r3, r2
		BOS.clibaudrate = CLI_BAUDRATE_1;
	else
		BOS.clibaudrate = BOS_default.clibaudrate;

	/* Read RTC hourformat and daylightsaving */
	status1 = EE_ReadVariable(_EE_PARAMS_RTC, &temp1);
 80031ac:	208d      	movs	r0, #141	; 0x8d
 80031ae:	0029      	movs	r1, r5
 80031b0:	0040      	lsls	r0, r0, #1
		BOS.clibaudrate = BOS_default.clibaudrate;
 80031b2:	60a3      	str	r3, [r4, #8]
	status1 = EE_ReadVariable(_EE_PARAMS_RTC, &temp1);
 80031b4:	f003 fbf8 	bl	80069a8 <EE_ReadVariable>
	if (!status1) {
 80031b8:	2800      	cmp	r0, #0
 80031ba:	d128      	bne.n	800320e <LoadEEparams+0xe2>
		BOS.daylightsaving = (int8_t) temp1;
 80031bc:	882b      	ldrh	r3, [r5, #0]
 80031be:	7323      	strb	r3, [r4, #12]
		BOS.hourformat = (uint8_t) (temp1 >> 8);
 80031c0:	0a1b      	lsrs	r3, r3, #8
 80031c2:	7363      	strb	r3, [r4, #13]
		BOS.hourformat = 24;
		BOS.daylightsaving = DAYLIGHT_NONE;
	}

	/* Read disableCLI */
	status1 = EE_ReadVariable(_EE_PARAMS_DISABLE_CLI, &temp1);
 80031c4:	201c      	movs	r0, #28
 80031c6:	0029      	movs	r1, r5
 80031c8:	30ff      	adds	r0, #255	; 0xff
 80031ca:	f003 fbed 	bl	80069a8 <EE_ReadVariable>
	/* Found the variable (EEPROM is not cleared) */
	if (!status1) {
 80031ce:	2800      	cmp	r0, #0
 80031d0:	d121      	bne.n	8003216 <LoadEEparams+0xea>
		BOS.disableCLI = (uint8_t) temp1;
 80031d2:	882b      	ldrh	r3, [r5, #0]
	} else {
		BOS.disableCLI = BOS_default.disableCLI;
	}

	return result;
}
 80031d4:	2000      	movs	r0, #0
		BOS.disableCLI = BOS_default.disableCLI;
 80031d6:	76e3      	strb	r3, [r4, #27]
}
 80031d8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		BOS.response = BOS_default.response;
 80031da:	4b11      	ldr	r3, [pc, #68]	; (8003220 <LoadEEparams+0xf4>)
 80031dc:	799a      	ldrb	r2, [r3, #6]
 80031de:	71a2      	strb	r2, [r4, #6]
		BOS.trace = BOS_default.trace;
 80031e0:	79db      	ldrb	r3, [r3, #7]
 80031e2:	e7b0      	b.n	8003146 <LoadEEparams+0x1a>
		BOS.buttons.debounce = BOS_default.buttons.debounce;
 80031e4:	4b0e      	ldr	r3, [pc, #56]	; (8003220 <LoadEEparams+0xf4>)
 80031e6:	881b      	ldrh	r3, [r3, #0]
 80031e8:	e7b6      	b.n	8003158 <LoadEEparams+0x2c>
		BOS.buttons.singleClickTime = BOS_default.buttons.singleClickTime;
 80031ea:	4b0d      	ldr	r3, [pc, #52]	; (8003220 <LoadEEparams+0xf4>)
 80031ec:	885b      	ldrh	r3, [r3, #2]
 80031ee:	e7bc      	b.n	800316a <LoadEEparams+0x3e>
		BOS.buttons.minInterClickTime = BOS_default.buttons.minInterClickTime;
 80031f0:	4b0b      	ldr	r3, [pc, #44]	; (8003220 <LoadEEparams+0xf4>)
 80031f2:	791a      	ldrb	r2, [r3, #4]
 80031f4:	7122      	strb	r2, [r4, #4]
		BOS.buttons.maxInterClickTime = BOS_default.buttons.maxInterClickTime;
 80031f6:	795b      	ldrb	r3, [r3, #5]
 80031f8:	e7c2      	b.n	8003180 <LoadEEparams+0x54>
	} else if (CLI_LOW_Baudrate_Flag)
 80031fa:	4b0a      	ldr	r3, [pc, #40]	; (8003224 <LoadEEparams+0xf8>)
 80031fc:	781b      	ldrb	r3, [r3, #0]
 80031fe:	2b00      	cmp	r3, #0
 8003200:	d002      	beq.n	8003208 <LoadEEparams+0xdc>
		BOS.clibaudrate = CLI_BAUDRATE_1;
 8003202:	23e1      	movs	r3, #225	; 0xe1
 8003204:	025b      	lsls	r3, r3, #9
 8003206:	e7d1      	b.n	80031ac <LoadEEparams+0x80>
		BOS.clibaudrate = BOS_default.clibaudrate;
 8003208:	4b05      	ldr	r3, [pc, #20]	; (8003220 <LoadEEparams+0xf4>)
 800320a:	689b      	ldr	r3, [r3, #8]
 800320c:	e7ce      	b.n	80031ac <LoadEEparams+0x80>
		BOS.daylightsaving = DAYLIGHT_NONE;
 800320e:	23c0      	movs	r3, #192	; 0xc0
 8003210:	015b      	lsls	r3, r3, #5
 8003212:	81a3      	strh	r3, [r4, #12]
 8003214:	e7d6      	b.n	80031c4 <LoadEEparams+0x98>
		BOS.disableCLI = BOS_default.disableCLI;
 8003216:	4b02      	ldr	r3, [pc, #8]	; (8003220 <LoadEEparams+0xf4>)
 8003218:	7edb      	ldrb	r3, [r3, #27]
 800321a:	e7db      	b.n	80031d4 <LoadEEparams+0xa8>
 800321c:	20006f70 	.word	0x20006f70
 8003220:	20000000 	.word	0x20000000
 8003224:	20000a9e 	.word	0x20000a9e

08003228 <SaveEEparams>:
 */
BOS_Status SaveEEparams(void) {
	BOS_Status result = BOS_OK;

	/* Save params base - BOS response & BOS trace */
	EE_WriteVariable(_EE_PARAMS_BASE,
 8003228:	208a      	movs	r0, #138	; 0x8a
BOS_Status SaveEEparams(void) {
 800322a:	b510      	push	{r4, lr}
			((uint16_t) BOS.trace << 5) | (uint16_t) BOS.response);
 800322c:	4c1a      	ldr	r4, [pc, #104]	; (8003298 <SaveEEparams+0x70>)
	EE_WriteVariable(_EE_PARAMS_BASE,
 800322e:	0040      	lsls	r0, r0, #1
			((uint16_t) BOS.trace << 5) | (uint16_t) BOS.response);
 8003230:	79e3      	ldrb	r3, [r4, #7]
 8003232:	79a1      	ldrb	r1, [r4, #6]
 8003234:	015b      	lsls	r3, r3, #5
	EE_WriteVariable(_EE_PARAMS_BASE,
 8003236:	4319      	orrs	r1, r3
 8003238:	f003 fbe0 	bl	80069fc <EE_WriteVariable>

	/* Save Button debounce */
	EE_WriteVariable(_EE_PARAMS_DEBOUNCE, BOS.buttons.debounce);
 800323c:	2016      	movs	r0, #22
 800323e:	8821      	ldrh	r1, [r4, #0]
 8003240:	30ff      	adds	r0, #255	; 0xff
 8003242:	f003 fbdb 	bl	80069fc <EE_WriteVariable>

	/* Save Button single click time */
	EE_WriteVariable(_EE_PARAMS_SINGLE_CLICK, BOS.buttons.singleClickTime);
 8003246:	208b      	movs	r0, #139	; 0x8b
 8003248:	8861      	ldrh	r1, [r4, #2]
 800324a:	0040      	lsls	r0, r0, #1
 800324c:	f003 fbd6 	bl	80069fc <EE_WriteVariable>

	/* Save Button double click time (min and max inter-click) */
	EE_WriteVariable(_EE_PARAMS_DBL_CLICK,
 8003250:	2018      	movs	r0, #24
			((uint16_t) BOS.buttons.maxInterClickTime << 8)
 8003252:	7963      	ldrb	r3, [r4, #5]
					| (uint16_t) BOS.daylightsaving);
 8003254:	7b21      	ldrb	r1, [r4, #12]
			((uint16_t) BOS.buttons.maxInterClickTime << 8)
 8003256:	021b      	lsls	r3, r3, #8
	EE_WriteVariable(_EE_PARAMS_DBL_CLICK,
 8003258:	4319      	orrs	r1, r3
 800325a:	30ff      	adds	r0, #255	; 0xff
 800325c:	f003 fbce 	bl	80069fc <EE_WriteVariable>

	/* Save CLI baudrate */
	EE_WriteVariable(_EE_CLI_BAUD, (uint16_t) BOS.clibaudrate);
 8003260:	208c      	movs	r0, #140	; 0x8c
 8003262:	68a3      	ldr	r3, [r4, #8]
 8003264:	0040      	lsls	r0, r0, #1
 8003266:	b299      	uxth	r1, r3
 8003268:	f003 fbc8 	bl	80069fc <EE_WriteVariable>
	EE_WriteVariable(_EE_CLI_BAUD + 1, (uint16_t) (BOS.clibaudrate >> 16));
 800326c:	201a      	movs	r0, #26
 800326e:	68a3      	ldr	r3, [r4, #8]
 8003270:	30ff      	adds	r0, #255	; 0xff
 8003272:	0c19      	lsrs	r1, r3, #16
 8003274:	f003 fbc2 	bl	80069fc <EE_WriteVariable>

	/* Save RTC hourformat and daylightsaving */
	EE_WriteVariable(_EE_PARAMS_RTC,
 8003278:	208d      	movs	r0, #141	; 0x8d
			((uint16_t) BOS.hourformat << 8)
 800327a:	7b63      	ldrb	r3, [r4, #13]
					| (uint16_t) BOS.buttons.minInterClickTime);
 800327c:	7921      	ldrb	r1, [r4, #4]
			((uint16_t) BOS.hourformat << 8)
 800327e:	021b      	lsls	r3, r3, #8
	EE_WriteVariable(_EE_PARAMS_RTC,
 8003280:	4319      	orrs	r1, r3
 8003282:	0040      	lsls	r0, r0, #1
 8003284:	f003 fbba 	bl	80069fc <EE_WriteVariable>

	/* Save disableCLI */
	EE_WriteVariable(_EE_PARAMS_DISABLE_CLI, (uint16_t) BOS.disableCLI);
 8003288:	201c      	movs	r0, #28
 800328a:	7ee1      	ldrb	r1, [r4, #27]
 800328c:	30ff      	adds	r0, #255	; 0xff
 800328e:	f003 fbb5 	bl	80069fc <EE_WriteVariable>

	return result;
}
 8003292:	2000      	movs	r0, #0
 8003294:	bd10      	pop	{r4, pc}
 8003296:	46c0      	nop			; (mov r8, r8)
 8003298:	20006f70 	.word	0x20006f70

0800329c <LoadEEbuttons>:

/* --- Load button definitions and events from EEPROM --- 
 */
BOS_Status LoadEEbuttons(void) {
	BOS_Status result = BOS_OK;
	uint16_t temp16 = 0, status1 = 0;
 800329c:	231e      	movs	r3, #30
BOS_Status LoadEEbuttons(void) {
 800329e:	b5f0      	push	{r4, r5, r6, r7, lr}
 80032a0:	b08b      	sub	sp, #44	; 0x2c
	uint16_t temp16 = 0, status1 = 0;
 80032a2:	aa02      	add	r2, sp, #8
 80032a4:	189b      	adds	r3, r3, r2
 80032a6:	2200      	movs	r2, #0
 80032a8:	2701      	movs	r7, #1
 80032aa:	801a      	strh	r2, [r3, #0]
 80032ac:	b2bd      	uxth	r5, r7
	uint8_t temp8 = 0;

	for (uint8_t i = 0; i <= NumOfPorts; i++) {
		status1 = EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i), &temp16);
 80032ae:	0028      	movs	r0, r5
 80032b0:	261e      	movs	r6, #30
 80032b2:	ab02      	add	r3, sp, #8
 80032b4:	303a      	adds	r0, #58	; 0x3a
 80032b6:	18f6      	adds	r6, r6, r3
 80032b8:	0080      	lsls	r0, r0, #2
 80032ba:	b280      	uxth	r0, r0
 80032bc:	0031      	movs	r1, r6
 80032be:	f003 fb73 	bl	80069a8 <EE_ReadVariable>
 80032c2:	b2fb      	uxtb	r3, r7
 80032c4:	9006      	str	r0, [sp, #24]
 80032c6:	9307      	str	r3, [sp, #28]

		if (!status1)									// This variable exists
 80032c8:	2800      	cmp	r0, #0
 80032ca:	d145      	bne.n	8003358 <LoadEEbuttons+0xbc>
		{
			temp8 = (uint8_t) (temp16 >> 8);
 80032cc:	8832      	ldrh	r2, [r6, #0]
 80032ce:	0a13      	lsrs	r3, r2, #8
			if (((temp8 >> 4) == i + 1) && ((temp8 & 0x0F) != NONE))// This is same port and button type is not none
 80032d0:	0919      	lsrs	r1, r3, #4
 80032d2:	42b9      	cmp	r1, r7
 80032d4:	d140      	bne.n	8003358 <LoadEEbuttons+0xbc>
 80032d6:	210f      	movs	r1, #15
 80032d8:	400b      	ands	r3, r1
 80032da:	d03d      	beq.n	8003358 <LoadEEbuttons+0xbc>
 80032dc:	00ad      	lsls	r5, r5, #2
 80032de:	b2ad      	uxth	r5, r5
					{
				button[i + 1].type = temp8 & 0x0F;
				button[i + 1].events = (uint8_t) temp16;
				EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i) + 1, &temp16);
 80032e0:	0028      	movs	r0, r5
				button[i + 1].type = temp8 & 0x0F;
 80032e2:	3906      	subs	r1, #6
 80032e4:	4379      	muls	r1, r7
 80032e6:	4c1f      	ldr	r4, [pc, #124]	; (8003364 <LoadEEbuttons+0xc8>)
				EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i) + 1, &temp16);
 80032e8:	30e9      	adds	r0, #233	; 0xe9
				button[i + 1].type = temp8 & 0x0F;
 80032ea:	1864      	adds	r4, r4, r1
 80032ec:	7063      	strb	r3, [r4, #1]
				button[i + 1].events = (uint8_t) temp16;
 80032ee:	7222      	strb	r2, [r4, #8]
				EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i) + 1, &temp16);
 80032f0:	0031      	movs	r1, r6
 80032f2:	b280      	uxth	r0, r0
 80032f4:	f003 fb58 	bl	80069a8 <EE_ReadVariable>
				button[i + 1].pressedX1Sec = (uint8_t) (temp16 >> 8);
				button[i + 1].releasedY1Sec = (uint8_t) temp16;
				EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i) + 2, &temp16);
 80032f8:	0028      	movs	r0, r5
				button[i + 1].pressedX1Sec = (uint8_t) (temp16 >> 8);
 80032fa:	8833      	ldrh	r3, [r6, #0]
				EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i) + 2, &temp16);
 80032fc:	30ea      	adds	r0, #234	; 0xea
				button[i + 1].pressedX1Sec = (uint8_t) (temp16 >> 8);
 80032fe:	0a1a      	lsrs	r2, r3, #8
 8003300:	70a2      	strb	r2, [r4, #2]
				button[i + 1].releasedY1Sec = (uint8_t) temp16;
 8003302:	7163      	strb	r3, [r4, #5]
				EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i) + 2, &temp16);
 8003304:	0031      	movs	r1, r6
 8003306:	b280      	uxth	r0, r0
 8003308:	f003 fb4e 	bl	80069a8 <EE_ReadVariable>
				button[i + 1].pressedX2Sec = (uint8_t) (temp16 >> 8);
 800330c:	8833      	ldrh	r3, [r6, #0]
				button[i + 1].releasedY2Sec = (uint8_t) temp16;
				EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i) + 3, &temp16);
 800330e:	35eb      	adds	r5, #235	; 0xeb
				button[i + 1].pressedX2Sec = (uint8_t) (temp16 >> 8);
 8003310:	0a1a      	lsrs	r2, r3, #8
 8003312:	70e2      	strb	r2, [r4, #3]
				button[i + 1].releasedY2Sec = (uint8_t) temp16;
 8003314:	71a3      	strb	r3, [r4, #6]
				EE_ReadVariable(_EE_BUTTON_BASE + 4 * (i) + 3, &temp16);
 8003316:	0031      	movs	r1, r6
 8003318:	b2a8      	uxth	r0, r5
 800331a:	f003 fb45 	bl	80069a8 <EE_ReadVariable>
				button[i + 1].pressedX3Sec = (uint8_t) (temp16 >> 8);
 800331e:	8833      	ldrh	r3, [r6, #0]
				button[i + 1].releasedY3Sec = (uint8_t) temp16;
				/* Setup the button and its events */
				AddPortButton(button[i + 1].type, i + 1);
 8003320:	b2f9      	uxtb	r1, r7
				button[i + 1].pressedX3Sec = (uint8_t) (temp16 >> 8);
 8003322:	0a1a      	lsrs	r2, r3, #8
 8003324:	7122      	strb	r2, [r4, #4]
				button[i + 1].releasedY3Sec = (uint8_t) temp16;
 8003326:	71e3      	strb	r3, [r4, #7]
				AddPortButton(button[i + 1].type, i + 1);
 8003328:	7860      	ldrb	r0, [r4, #1]
 800332a:	f004 f8d3 	bl	80074d4 <AddPortButton>
				SetButtonEvents(i + 1,
 800332e:	2101      	movs	r1, #1
						(button[i + 1].events & BUTTON_EVENT_CLICKED),
 8003330:	7a20      	ldrb	r0, [r4, #8]
				SetButtonEvents(i + 1,
 8003332:	78a3      	ldrb	r3, [r4, #2]
						((button[i + 1].events & BUTTON_EVENT_DBL_CLICKED) >> 1),
 8003334:	1042      	asrs	r2, r0, #1
				SetButtonEvents(i + 1,
 8003336:	400a      	ands	r2, r1
 8003338:	4001      	ands	r1, r0
 800333a:	9806      	ldr	r0, [sp, #24]
 800333c:	9005      	str	r0, [sp, #20]
 800333e:	79e0      	ldrb	r0, [r4, #7]
 8003340:	9004      	str	r0, [sp, #16]
 8003342:	79a0      	ldrb	r0, [r4, #6]
 8003344:	9003      	str	r0, [sp, #12]
 8003346:	7960      	ldrb	r0, [r4, #5]
 8003348:	9002      	str	r0, [sp, #8]
 800334a:	7920      	ldrb	r0, [r4, #4]
 800334c:	9001      	str	r0, [sp, #4]
 800334e:	78e0      	ldrb	r0, [r4, #3]
 8003350:	9000      	str	r0, [sp, #0]
 8003352:	b2f8      	uxtb	r0, r7
 8003354:	f004 f9c8 	bl	80076e8 <SetButtonEvents>
 8003358:	3701      	adds	r7, #1
	for (uint8_t i = 0; i <= NumOfPorts; i++) {
 800335a:	2f07      	cmp	r7, #7
 800335c:	d1a6      	bne.n	80032ac <LoadEEbuttons+0x10>
			}
		}
	}

	return result;
}
 800335e:	2000      	movs	r0, #0
 8003360:	b00b      	add	sp, #44	; 0x2c
 8003362:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003364:	20001458 	.word	0x20001458

08003368 <LoadEEvars>:
void LoadEEvars(void) {
 8003368:	b510      	push	{r4, lr}
	LoadROtopology();
 800336a:	f7ff fcc5 	bl	8002cf8 <LoadROtopology>
	LoadEEportsDir();
 800336e:	f7ff fd4b 	bl	8002e08 <LoadEEportsDir>
	LoadEEalias();
 8003372:	f7ff fd93 	bl	8002e9c <LoadEEalias>
	LoadEEgroup();
 8003376:	f7ff fdc7 	bl	8002f08 <LoadEEgroup>
	LoadEEstreams();
 800337a:	f7ff fe03 	bl	8002f84 <LoadEEstreams>
	LoadEEparams();
 800337e:	f7ff fed5 	bl	800312c <LoadEEparams>
	LoadEEbuttons();
 8003382:	f7ff ff8b 	bl	800329c <LoadEEbuttons>
}
 8003386:	bd10      	pop	{r4, pc}

08003388 <IsLowerCLIbaud>:
	uint16_t P1_TX_Pin, P1_RX_Pin, P2_TX_Pin, P2_RX_Pin;

	/* -- Setup GPIOs -- */

	/* Get GPIOs */
	GetPortGPIOs(P1, &P1_TX_Port, &P1_TX_Pin, &P1_RX_Port, &P1_RX_Pin);
 8003388:	230e      	movs	r3, #14
uint8_t IsLowerCLIbaud(void) {
 800338a:	b5f0      	push	{r4, r5, r6, r7, lr}
	GetPortGPIOs(P2, &P2_TX_Port, &P2_TX_Pin, &P2_RX_Port, &P2_RX_Pin);
 800338c:	2512      	movs	r5, #18

	/* P1 TXD */
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800338e:	2400      	movs	r4, #0
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8003390:	2701      	movs	r7, #1
uint8_t IsLowerCLIbaud(void) {
 8003392:	b08f      	sub	sp, #60	; 0x3c
	GetPortGPIOs(P1, &P1_TX_Port, &P1_TX_Pin, &P1_RX_Port, &P1_RX_Pin);
 8003394:	ae03      	add	r6, sp, #12
 8003396:	446b      	add	r3, sp
	GetPortGPIOs(P2, &P2_TX_Port, &P2_TX_Pin, &P2_RX_Port, &P2_RX_Pin);
 8003398:	446d      	add	r5, sp
	GetPortGPIOs(P1, &P1_TX_Port, &P1_TX_Pin, &P1_RX_Port, &P1_RX_Pin);
 800339a:	9300      	str	r3, [sp, #0]
 800339c:	0032      	movs	r2, r6
 800339e:	ab06      	add	r3, sp, #24
 80033a0:	a905      	add	r1, sp, #20
 80033a2:	2001      	movs	r0, #1
 80033a4:	f008 fe46 	bl	800c034 <GetPortGPIOs>
	GetPortGPIOs(P2, &P2_TX_Port, &P2_TX_Pin, &P2_RX_Port, &P2_RX_Pin);
 80033a8:	aa04      	add	r2, sp, #16
 80033aa:	ab08      	add	r3, sp, #32
 80033ac:	a907      	add	r1, sp, #28
 80033ae:	9500      	str	r5, [sp, #0]
 80033b0:	2002      	movs	r0, #2
 80033b2:	f008 fe3f 	bl	800c034 <GetPortGPIOs>
	GPIO_InitStruct.Pin = P1_TX_Pin;
 80033b6:	8833      	ldrh	r3, [r6, #0]
	HAL_GPIO_Init((GPIO_TypeDef*) P1_TX_Port, &GPIO_InitStruct);
 80033b8:	a909      	add	r1, sp, #36	; 0x24
 80033ba:	9805      	ldr	r0, [sp, #20]
	GPIO_InitStruct.Pin = P1_TX_Pin;
 80033bc:	9309      	str	r3, [sp, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80033be:	970a      	str	r7, [sp, #40]	; 0x28
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 80033c0:	940b      	str	r4, [sp, #44]	; 0x2c
	HAL_GPIO_Init((GPIO_TypeDef*) P1_TX_Port, &GPIO_InitStruct);
 80033c2:	f00e feeb 	bl	801219c <HAL_GPIO_Init>

	/* P2 RXD */
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80033c6:	2302      	movs	r3, #2
 80033c8:	930b      	str	r3, [sp, #44]	; 0x2c
	GPIO_InitStruct.Pin = P2_RX_Pin;
 80033ca:	882b      	ldrh	r3, [r5, #0]
	HAL_GPIO_Init((GPIO_TypeDef*) P2_RX_Port, &GPIO_InitStruct);
 80033cc:	a909      	add	r1, sp, #36	; 0x24
 80033ce:	9808      	ldr	r0, [sp, #32]
	GPIO_InitStruct.Pin = P2_RX_Pin;
 80033d0:	9309      	str	r3, [sp, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80033d2:	940a      	str	r4, [sp, #40]	; 0x28
	HAL_GPIO_Init((GPIO_TypeDef*) P2_RX_Port, &GPIO_InitStruct);
 80033d4:	f00e fee2 	bl	801219c <HAL_GPIO_Init>

	/* Check for lower CLI baudrate conditions */
	HAL_GPIO_WritePin((GPIO_TypeDef*) P1_TX_Port, P1_TX_Pin, GPIO_PIN_RESET);
 80033d8:	8831      	ldrh	r1, [r6, #0]
 80033da:	0022      	movs	r2, r4
 80033dc:	9805      	ldr	r0, [sp, #20]
 80033de:	f00e ff9f 	bl	8012320 <HAL_GPIO_WritePin>
	Delay_ms_no_rtos(5);
 80033e2:	2005      	movs	r0, #5
 80033e4:	f009 fea2 	bl	800d12c <StartMilliDelay>
	if (HAL_GPIO_ReadPin((GPIO_TypeDef*) P2_RX_Port, P2_RX_Pin) == RESET) {
 80033e8:	8829      	ldrh	r1, [r5, #0]
 80033ea:	9808      	ldr	r0, [sp, #32]
 80033ec:	f00e ff92 	bl	8012314 <HAL_GPIO_ReadPin>
 80033f0:	42a0      	cmp	r0, r4
 80033f2:	d10f      	bne.n	8003414 <IsLowerCLIbaud+0x8c>
		HAL_GPIO_WritePin((GPIO_TypeDef*) P1_TX_Port, P1_TX_Pin, GPIO_PIN_SET);
 80033f4:	8831      	ldrh	r1, [r6, #0]
 80033f6:	003a      	movs	r2, r7
 80033f8:	9805      	ldr	r0, [sp, #20]
 80033fa:	f00e ff91 	bl	8012320 <HAL_GPIO_WritePin>
		Delay_ms_no_rtos(5);
 80033fe:	2005      	movs	r0, #5
 8003400:	f009 fe94 	bl	800d12c <StartMilliDelay>
		if (HAL_GPIO_ReadPin((GPIO_TypeDef*) P2_RX_Port, P2_RX_Pin) == SET) {
 8003404:	8829      	ldrh	r1, [r5, #0]
 8003406:	9808      	ldr	r0, [sp, #32]
 8003408:	f00e ff84 	bl	8012314 <HAL_GPIO_ReadPin>
 800340c:	3801      	subs	r0, #1
 800340e:	4244      	negs	r4, r0
 8003410:	4144      	adcs	r4, r0
			return 1;
 8003412:	b2e4      	uxtb	r4, r4
		}
	}

	return 0;
}
 8003414:	0020      	movs	r0, r4
 8003416:	b00f      	add	sp, #60	; 0x3c
 8003418:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800341c <EE_FormatForFactoryReset>:

/*-----------------------------------------------------------*/

/* --- Format emulated EEPROM for a factory reset
 */
void EE_FormatForFactoryReset(void) {
 800341c:	b570      	push	{r4, r5, r6, lr}
	/* Check if EEPROM was just formated? */
	/* Flag address (STM32F09x) - Last 4 words of SRAM */
	if (*((unsigned long*) 0x20007FF0) == 0xBEEFDEAD) {
 800341e:	4c05      	ldr	r4, [pc, #20]	; (8003434 <EE_FormatForFactoryReset+0x18>)
 8003420:	4d05      	ldr	r5, [pc, #20]	; (8003438 <EE_FormatForFactoryReset+0x1c>)
 8003422:	6823      	ldr	r3, [r4, #0]
 8003424:	42ab      	cmp	r3, r5
 8003426:	d004      	beq.n	8003432 <EE_FormatForFactoryReset+0x16>
		// Do nothing
	} else {
		if (EE_Format() == HAL_OK) {
 8003428:	f003 fb78 	bl	8006b1c <EE_Format>
 800342c:	2800      	cmp	r0, #0
 800342e:	d100      	bne.n	8003432 <EE_FormatForFactoryReset+0x16>
			/* Set flag for formated EEPROM */
			*((unsigned long*) 0x20007FF0) = 0xBEEFDEAD;
 8003430:	6025      	str	r5, [r4, #0]
		}
	}

}
 8003432:	bd70      	pop	{r4, r5, r6, pc}
 8003434:	20007ff0 	.word	0x20007ff0
 8003438:	beefdead 	.word	0xbeefdead

0800343c <SetupPortForRemoteBootloaderUpdate>:
/* --- Setup a port for remote ST factory bootloader update:
 - Set baudrate to 57600
 - Enable even parity
 - Set datasize to 9 bits
 */
void SetupPortForRemoteBootloaderUpdate(uint8_t port) {
 800343c:	b510      	push	{r4, lr}
	UART_HandleTypeDef *huart = GetUart(port);
 800343e:	f009 ffdf 	bl	800d400 <GetUart>

	huart->Init.BaudRate = 57600;
 8003442:	23e1      	movs	r3, #225	; 0xe1
 8003444:	021b      	lsls	r3, r3, #8
 8003446:	6043      	str	r3, [r0, #4]
	huart->Init.Parity = UART_PARITY_EVEN;
 8003448:	2380      	movs	r3, #128	; 0x80
 800344a:	00db      	lsls	r3, r3, #3
 800344c:	6103      	str	r3, [r0, #16]
	huart->Init.WordLength = UART_WORDLENGTH_9B;
 800344e:	2380      	movs	r3, #128	; 0x80
	UART_HandleTypeDef *huart = GetUart(port);
 8003450:	0004      	movs	r4, r0
	huart->Init.WordLength = UART_WORDLENGTH_9B;
 8003452:	015b      	lsls	r3, r3, #5
 8003454:	6083      	str	r3, [r0, #8]
	HAL_UART_Init(huart);
 8003456:	f010 fd19 	bl	8013e8c <HAL_UART_Init>

	/* The CLI port RXNE interrupt might be disabled so enable here again to be sure */
	__HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
 800345a:	2320      	movs	r3, #32
 800345c:	6822      	ldr	r2, [r4, #0]
 800345e:	6811      	ldr	r1, [r2, #0]
 8003460:	430b      	orrs	r3, r1
 8003462:	6013      	str	r3, [r2, #0]
}
 8003464:	bd10      	pop	{r4, pc}
	...

08003468 <IsModuleParameter>:

/*-----------------------------------------------------------*/

/* --- Check if this string is a local module parameter or event. Returns parameter index+1
 */
uint8_t IsModuleParameter(char *name) {
 8003468:	b510      	push	{r4, lr}
	for (uint8_t i = 0; i < NUM_MODULE_PARAMS; i++) {
		if (!strcmp(name, (const char*) (modParam[i].paramName)))
 800346a:	4b04      	ldr	r3, [pc, #16]	; (800347c <IsModuleParameter+0x14>)
 800346c:	6899      	ldr	r1, [r3, #8]
 800346e:	f7fc fe49 	bl	8000104 <strcmp>
 8003472:	4243      	negs	r3, r0
 8003474:	4158      	adcs	r0, r3
 8003476:	b2c0      	uxtb	r0, r0
			return i + 1;
	}
	return 0;
}
 8003478:	bd10      	pop	{r4, pc}
 800347a:	46c0      	nop			; (mov r8, r8)
 800347c:	2000008c 	.word	0x2000008c

08003480 <IsMathOperator>:

/*-----------------------------------------------------------*/

/* --- Check if this string is a math operator and return its enum
 */
uint8_t IsMathOperator(char *string) {
 8003480:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (uint8_t i = 0; i < NUM_MATH_OPERATORS; i++) {
		if (!strcmp(string, "="))
 8003482:	491c      	ldr	r1, [pc, #112]	; (80034f4 <IsMathOperator+0x74>)
uint8_t IsMathOperator(char *string) {
 8003484:	0005      	movs	r5, r0
		if (!strcmp(string, "="))
 8003486:	f7fc fe3d 	bl	8000104 <strcmp>
 800348a:	2406      	movs	r4, #6
 800348c:	0006      	movs	r6, r0
			return MATH_GREATER;
		else if (!strcmp(string, "<"))
			return MATH_SMALLER;
		else if (!strcmp(string, ">="))
			return MATH_GREATER_EQUAL;
		else if (!strcmp(string, "<="))
 800348e:	4f1a      	ldr	r7, [pc, #104]	; (80034f8 <IsMathOperator+0x78>)
		if (!strcmp(string, "="))
 8003490:	2e00      	cmp	r6, #0
 8003492:	d023      	beq.n	80034dc <IsMathOperator+0x5c>
		else if (!strcmp(string, ">"))
 8003494:	4919      	ldr	r1, [pc, #100]	; (80034fc <IsMathOperator+0x7c>)
 8003496:	0028      	movs	r0, r5
 8003498:	f7fc fe34 	bl	8000104 <strcmp>
 800349c:	2800      	cmp	r0, #0
 800349e:	d01f      	beq.n	80034e0 <IsMathOperator+0x60>
		else if (!strcmp(string, "<"))
 80034a0:	4917      	ldr	r1, [pc, #92]	; (8003500 <IsMathOperator+0x80>)
 80034a2:	0028      	movs	r0, r5
 80034a4:	f7fc fe2e 	bl	8000104 <strcmp>
 80034a8:	2800      	cmp	r0, #0
 80034aa:	d01b      	beq.n	80034e4 <IsMathOperator+0x64>
		else if (!strcmp(string, ">="))
 80034ac:	4915      	ldr	r1, [pc, #84]	; (8003504 <IsMathOperator+0x84>)
 80034ae:	0028      	movs	r0, r5
 80034b0:	f7fc fe28 	bl	8000104 <strcmp>
 80034b4:	2800      	cmp	r0, #0
 80034b6:	d017      	beq.n	80034e8 <IsMathOperator+0x68>
		else if (!strcmp(string, "<="))
 80034b8:	0039      	movs	r1, r7
 80034ba:	0028      	movs	r0, r5
 80034bc:	f7fc fe22 	bl	8000104 <strcmp>
 80034c0:	2800      	cmp	r0, #0
 80034c2:	d013      	beq.n	80034ec <IsMathOperator+0x6c>
			return MATH_SMALLER_EQUAL;
		else if (!strcmp(string, "!="))
 80034c4:	4910      	ldr	r1, [pc, #64]	; (8003508 <IsMathOperator+0x88>)
 80034c6:	0028      	movs	r0, r5
 80034c8:	f7fc fe1c 	bl	8000104 <strcmp>
 80034cc:	2800      	cmp	r0, #0
 80034ce:	d00f      	beq.n	80034f0 <IsMathOperator+0x70>
 80034d0:	3c01      	subs	r4, #1
 80034d2:	b2e4      	uxtb	r4, r4
	for (uint8_t i = 0; i < NUM_MATH_OPERATORS; i++) {
 80034d4:	2c00      	cmp	r4, #0
 80034d6:	d1db      	bne.n	8003490 <IsMathOperator+0x10>
			return MATH_NOT_EQUAL;
	}
	return 0;
 80034d8:	0020      	movs	r0, r4
}
 80034da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return MATH_EQUAL;
 80034dc:	2001      	movs	r0, #1
 80034de:	e7fc      	b.n	80034da <IsMathOperator+0x5a>
			return MATH_GREATER;
 80034e0:	2002      	movs	r0, #2
 80034e2:	e7fa      	b.n	80034da <IsMathOperator+0x5a>
			return MATH_SMALLER;
 80034e4:	2003      	movs	r0, #3
 80034e6:	e7f8      	b.n	80034da <IsMathOperator+0x5a>
			return MATH_GREATER_EQUAL;
 80034e8:	2004      	movs	r0, #4
 80034ea:	e7f6      	b.n	80034da <IsMathOperator+0x5a>
			return MATH_SMALLER_EQUAL;
 80034ec:	2005      	movs	r0, #5
 80034ee:	e7f4      	b.n	80034da <IsMathOperator+0x5a>
			return MATH_NOT_EQUAL;
 80034f0:	2006      	movs	r0, #6
 80034f2:	e7f2      	b.n	80034da <IsMathOperator+0x5a>
 80034f4:	080192eb 	.word	0x080192eb
 80034f8:	080192e7 	.word	0x080192e7
 80034fc:	08019786 	.word	0x08019786
 8003500:	080192e2 	.word	0x080192e2
 8003504:	080192e4 	.word	0x080192e4
 8003508:	080192ea 	.word	0x080192ea

0800350c <ExploreNeighbors>:
/*-----------------------------------------------------------*/
#ifndef __N
/* --- Explore adjacent neighbors 
*/
BOS_Status ExploreNeighbors(uint8_t ignore)
{
 800350c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800350e:	0005      	movs	r5, r0
	BOS_Status result = BOS_OK; 

	/* Send Hi messages to adjacent neighbors */
	for (uint8_t port=1 ; port<=NumOfPorts ; port++)  
 8003510:	2401      	movs	r4, #1
			/* This module info */
			messageParams[0] = (uint8_t) (myPN >> 8);
			messageParams[1] = (uint8_t) myPN;
			messageParams[2] = port;
			/* Port, Source = 0 (myID), Destination = 0 (adjacent neighbor), message code, number of parameters */
			SendMessageFromPort(port, 0, 0, CODE_HI, 3);
 8003512:	2603      	movs	r6, #3
		if (port != ignore) 
 8003514:	42a5      	cmp	r5, r4
 8003516:	d010      	beq.n	800353a <ExploreNeighbors+0x2e>
			messageParams[0] = (uint8_t) (myPN >> 8);
 8003518:	4b0b      	ldr	r3, [pc, #44]	; (8003548 <ExploreNeighbors+0x3c>)
			SendMessageFromPort(port, 0, 0, CODE_HI, 3);
 800351a:	0020      	movs	r0, r4
			messageParams[0] = (uint8_t) (myPN >> 8);
 800351c:	881a      	ldrh	r2, [r3, #0]
 800351e:	4b0b      	ldr	r3, [pc, #44]	; (800354c <ExploreNeighbors+0x40>)
 8003520:	0a11      	lsrs	r1, r2, #8
			messageParams[1] = (uint8_t) myPN;
 8003522:	705a      	strb	r2, [r3, #1]
			SendMessageFromPort(port, 0, 0, CODE_HI, 3);
 8003524:	2200      	movs	r2, #0
			messageParams[0] = (uint8_t) (myPN >> 8);
 8003526:	7019      	strb	r1, [r3, #0]
			messageParams[2] = port;
 8003528:	709c      	strb	r4, [r3, #2]
			SendMessageFromPort(port, 0, 0, CODE_HI, 3);
 800352a:	0011      	movs	r1, r2
 800352c:	9600      	str	r6, [sp, #0]
 800352e:	230a      	movs	r3, #10
 8003530:	f004 fb32 	bl	8007b98 <SendMessageFromPort>
			/* Minimum delay between two consequetive SendMessage commands (with response) */
			osDelay(10);
 8003534:	200a      	movs	r0, #10
 8003536:	f00c f914 	bl	800f762 <osDelay>
	for (uint8_t port=1 ; port<=NumOfPorts ; port++)  
 800353a:	3401      	adds	r4, #1
 800353c:	b2e4      	uxtb	r4, r4
 800353e:	2c06      	cmp	r4, #6
 8003540:	d1e8      	bne.n	8003514 <ExploreNeighbors+0x8>
		}
	}
	
	return result;
}
 8003542:	2000      	movs	r0, #0
 8003544:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8003546:	46c0      	nop			; (mov r8, r8)
 8003548:	20000050 	.word	0x20000050
 800354c:	20000f07 	.word	0x20000f07

08003550 <FindBroadcastRoutes>:
/*-----------------------------------------------------------*/

/* --- Find array broadcast routes starting from a given module 
 (Takes about 50 usec)
 */
BOS_Status FindBroadcastRoutes(uint8_t src) {
 8003550:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003552:	b087      	sub	sp, #28
	BOS_Status result = BOS_OK;
	uint8_t p = 0, m = 0, level = 0, untaged = 0;
	uint8_t modules[N];			// Todo: Optimize to make bit-wise
 8003554:	466a      	mov	r2, sp
 8003556:	4b3c      	ldr	r3, [pc, #240]	; (8003648 <FindBroadcastRoutes+0xf8>)
BOS_Status FindBroadcastRoutes(uint8_t src) {
 8003558:	af00      	add	r7, sp, #0
	uint8_t modules[N];			// Todo: Optimize to make bit-wise
 800355a:	781b      	ldrb	r3, [r3, #0]

	/* 1. Initialize modules list and broadcast routes */

	for (m = 0; m < N; m++) {
		modules[m] = 0;
		bcastRoutes[m] = 0;
 800355c:	4c3b      	ldr	r4, [pc, #236]	; (800364c <FindBroadcastRoutes+0xfc>)
	uint8_t modules[N];			// Todo: Optimize to make bit-wise
 800355e:	613b      	str	r3, [r7, #16]
 8003560:	3307      	adds	r3, #7
 8003562:	08db      	lsrs	r3, r3, #3
 8003564:	00db      	lsls	r3, r3, #3
 8003566:	1ad3      	subs	r3, r2, r3
 8003568:	469d      	mov	sp, r3
 800356a:	617b      	str	r3, [r7, #20]
	for (m = 0; m < N; m++) {
 800356c:	2300      	movs	r3, #0
		modules[m] = 0;
 800356e:	001a      	movs	r2, r3
	for (m = 0; m < N; m++) {
 8003570:	693d      	ldr	r5, [r7, #16]
 8003572:	b2d9      	uxtb	r1, r3
 8003574:	428d      	cmp	r5, r1
 8003576:	d830      	bhi.n	80035da <FindBroadcastRoutes+0x8a>
	}
	modules[src - 1] = ++level;					// Tag the source
 8003578:	2301      	movs	r3, #1
 800357a:	697a      	ldr	r2, [r7, #20]
 800357c:	3801      	subs	r0, #1
 800357e:	5413      	strb	r3, [r2, r0]
 8003580:	2216      	movs	r2, #22

	++level;												// Move one level

	for (p = 1; p <= NumOfPorts; p++) {
		if (array[src - 1][p]) {
			bcastRoutes[src - 1] |= (0x01 << (p - 1));
 8003582:	001d      	movs	r5, r3
 8003584:	4342      	muls	r2, r0
 8003586:	4098      	lsls	r0, r3
 8003588:	4931      	ldr	r1, [pc, #196]	; (8003650 <FindBroadcastRoutes+0x100>)
 800358a:	4c30      	ldr	r4, [pc, #192]	; (800364c <FindBroadcastRoutes+0xfc>)
 800358c:	1852      	adds	r2, r2, r1
 800358e:	60fa      	str	r2, [r7, #12]
		if (array[src - 1][p]) {
 8003590:	68f9      	ldr	r1, [r7, #12]
 8003592:	005a      	lsls	r2, r3, #1
 8003594:	5a8a      	ldrh	r2, [r1, r2]
 8003596:	2a00      	cmp	r2, #0
 8003598:	d00c      	beq.n	80035b4 <FindBroadcastRoutes+0x64>
			bcastRoutes[src - 1] |= (0x01 << (p - 1));
 800359a:	002e      	movs	r6, r5
 800359c:	1e59      	subs	r1, r3, #1
 800359e:	408e      	lsls	r6, r1
 80035a0:	0031      	movs	r1, r6
 80035a2:	5b06      	ldrh	r6, [r0, r4]
			modules[(array[src - 1][p] >> 3) - 1] = level;// Tag this module as already broadcasted-to
 80035a4:	08d2      	lsrs	r2, r2, #3
			bcastRoutes[src - 1] |= (0x01 << (p - 1));
 80035a6:	4331      	orrs	r1, r6
 80035a8:	5301      	strh	r1, [r0, r4]
			modules[(array[src - 1][p] >> 3) - 1] = level;// Tag this module as already broadcasted-to
 80035aa:	6979      	ldr	r1, [r7, #20]
 80035ac:	188a      	adds	r2, r1, r2
 80035ae:	2102      	movs	r1, #2
 80035b0:	3a01      	subs	r2, #1
 80035b2:	7011      	strb	r1, [r2, #0]
 80035b4:	3301      	adds	r3, #1
	for (p = 1; p <= NumOfPorts; p++) {
 80035b6:	2b06      	cmp	r3, #6
 80035b8:	d1ea      	bne.n	8003590 <FindBroadcastRoutes+0x40>
	++level;												// Move one level
 80035ba:	2102      	movs	r1, #2

	do {
		untaged = 0;								// Reset the untaged counter
		++level;											// Move one level

		for (m = 0; m < N; m++)					// Scan all modules in the list
 80035bc:	2300      	movs	r3, #0
		untaged = 0;								// Reset the untaged counter
 80035be:	0018      	movs	r0, r3
		++level;											// Move one level
 80035c0:	3101      	adds	r1, #1
 80035c2:	b2c9      	uxtb	r1, r1
				{
			if (modules[m] == (level - 1))// This module is already broadcasted-to from the previous level
 80035c4:	1e4a      	subs	r2, r1, #1
 80035c6:	603a      	str	r2, [r7, #0]
		for (m = 0; m < N; m++)					// Scan all modules in the list
 80035c8:	693c      	ldr	r4, [r7, #16]
 80035ca:	b2da      	uxtb	r2, r3
 80035cc:	4294      	cmp	r4, r2
 80035ce:	d80a      	bhi.n	80035e6 <FindBroadcastRoutes+0x96>
						++untaged;
					}
				}
			}
		}
	} while (untaged);
 80035d0:	2800      	cmp	r0, #0
 80035d2:	d1f3      	bne.n	80035bc <FindBroadcastRoutes+0x6c>

	return result;
}
 80035d4:	46bd      	mov	sp, r7
 80035d6:	b007      	add	sp, #28
 80035d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		modules[m] = 0;
 80035da:	6979      	ldr	r1, [r7, #20]
 80035dc:	54ca      	strb	r2, [r1, r3]
		bcastRoutes[m] = 0;
 80035de:	0059      	lsls	r1, r3, #1
 80035e0:	530a      	strh	r2, [r1, r4]
 80035e2:	3301      	adds	r3, #1
 80035e4:	e7c4      	b.n	8003570 <FindBroadcastRoutes+0x20>
			if (modules[m] == (level - 1))// This module is already broadcasted-to from the previous level
 80035e6:	697a      	ldr	r2, [r7, #20]
 80035e8:	683c      	ldr	r4, [r7, #0]
 80035ea:	5cd2      	ldrb	r2, [r2, r3]
 80035ec:	42a2      	cmp	r2, r4
 80035ee:	d128      	bne.n	8003642 <FindBroadcastRoutes+0xf2>
 80035f0:	2416      	movs	r4, #22
 80035f2:	435c      	muls	r4, r3
 80035f4:	4a16      	ldr	r2, [pc, #88]	; (8003650 <FindBroadcastRoutes+0x100>)
 80035f6:	18a2      	adds	r2, r4, r2
 80035f8:	607a      	str	r2, [r7, #4]
 80035fa:	005a      	lsls	r2, r3, #1
 80035fc:	60ba      	str	r2, [r7, #8]
						bcastRoutes[m] |= (0x01 << (p - 1));
 80035fe:	4a13      	ldr	r2, [pc, #76]	; (800364c <FindBroadcastRoutes+0xfc>)
			if (modules[m] == (level - 1))// This module is already broadcasted-to from the previous level
 8003600:	2401      	movs	r4, #1
						bcastRoutes[m] |= (0x01 << (p - 1));
 8003602:	4694      	mov	ip, r2
					if (array[m][p] && (modules[(array[m][p] >> 3) - 1] == 0)) // Found an untaged module
 8003604:	687d      	ldr	r5, [r7, #4]
 8003606:	0062      	lsls	r2, r4, #1
 8003608:	5aaa      	ldrh	r2, [r5, r2]
 800360a:	2a00      	cmp	r2, #0
 800360c:	d016      	beq.n	800363c <FindBroadcastRoutes+0xec>
 800360e:	08d2      	lsrs	r2, r2, #3
 8003610:	3a01      	subs	r2, #1
 8003612:	60fa      	str	r2, [r7, #12]
 8003614:	68fd      	ldr	r5, [r7, #12]
 8003616:	697a      	ldr	r2, [r7, #20]
 8003618:	5d55      	ldrb	r5, [r2, r5]
 800361a:	2d00      	cmp	r5, #0
 800361c:	d10e      	bne.n	800363c <FindBroadcastRoutes+0xec>
						bcastRoutes[m] |= (0x01 << (p - 1));
 800361e:	2601      	movs	r6, #1
 8003620:	1e65      	subs	r5, r4, #1
 8003622:	40ae      	lsls	r6, r5
 8003624:	0032      	movs	r2, r6
 8003626:	4666      	mov	r6, ip
 8003628:	68bd      	ldr	r5, [r7, #8]
						++untaged;
 800362a:	3001      	adds	r0, #1
						bcastRoutes[m] |= (0x01 << (p - 1));
 800362c:	5bad      	ldrh	r5, [r5, r6]
						++untaged;
 800362e:	b2c0      	uxtb	r0, r0
						bcastRoutes[m] |= (0x01 << (p - 1));
 8003630:	4315      	orrs	r5, r2
 8003632:	68ba      	ldr	r2, [r7, #8]
 8003634:	5395      	strh	r5, [r2, r6]
						modules[(array[m][p] >> 3) - 1] = level;// Tag this module as already broadcasted-to
 8003636:	697a      	ldr	r2, [r7, #20]
 8003638:	68fd      	ldr	r5, [r7, #12]
 800363a:	5551      	strb	r1, [r2, r5]
 800363c:	3401      	adds	r4, #1
				for (p = 1; p <= NumOfPorts; p++)// Check all neighbors if they're not already broadcasted-to
 800363e:	2c06      	cmp	r4, #6
 8003640:	d1e0      	bne.n	8003604 <FindBroadcastRoutes+0xb4>
 8003642:	3301      	adds	r3, #1
 8003644:	e7c0      	b.n	80035c8 <FindBroadcastRoutes+0x78>
 8003646:	46c0      	nop			; (mov r8, r8)
 8003648:	2000001c 	.word	0x2000001c
 800364c:	20000cc8 	.word	0x20000cc8
 8003650:	20000aa0 	.word	0x20000aa0

08003654 <FindRoute>:

 6- Otherwise, select the unvisited node that is marked with the smallest tentative distance,
 set it as the new "current node", and go back to step 3.

 */
uint8_t FindRoute(uint8_t sourceID, uint8_t desID) {
 8003654:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003656:	b093      	sub	sp, #76	; 0x4c
 8003658:	0004      	movs	r4, r0
 800365a:	000d      	movs	r5, r1
#ifdef ___N
	uint8_t Q[__N] = {0};		// All nodes initially in Q (unvisited nodes)
#else
	uint8_t Q[50] = { 0 };		// All nodes initially in Q (unvisited nodes)
 800365c:	2232      	movs	r2, #50	; 0x32
 800365e:	2100      	movs	r1, #0
 8003660:	a805      	add	r0, sp, #20
 8003662:	f011 f800 	bl	8014666 <memset>
	uint8_t alt = 0;
	uint8_t u = 0;
	uint8_t v = 0;
	uint8_t j = 0;

	memset(route, 0, sizeof(route));
 8003666:	2219      	movs	r2, #25
 8003668:	2100      	movs	r1, #0
 800366a:	4847      	ldr	r0, [pc, #284]	; (8003788 <FindRoute+0x134>)
 800366c:	f010 fffb 	bl	8014666 <memset>
	routeDist[sourceID - 1] = 0;               // Distance from source to source
 8003670:	2300      	movs	r3, #0
	routePrev[sourceID - 1] = 0; // Previous node in optimal path initialization undefined

	/* Check adjacent neighbors first! */
	for (int col = 1; col <= 6; col++) {
 8003672:	2001      	movs	r0, #1
	routeDist[sourceID - 1] = 0;               // Distance from source to source
 8003674:	4945      	ldr	r1, [pc, #276]	; (800378c <FindRoute+0x138>)
 8003676:	1e62      	subs	r2, r4, #1
 8003678:	548b      	strb	r3, [r1, r2]
	routePrev[sourceID - 1] = 0; // Previous node in optimal path initialization undefined
 800367a:	4945      	ldr	r1, [pc, #276]	; (8003790 <FindRoute+0x13c>)
 800367c:	548b      	strb	r3, [r1, r2]
 800367e:	3316      	adds	r3, #22
 8003680:	4353      	muls	r3, r2
 8003682:	4a44      	ldr	r2, [pc, #272]	; (8003794 <FindRoute+0x140>)
 8003684:	189b      	adds	r3, r3, r2
 8003686:	9301      	str	r3, [sp, #4]
		if (array[sourceID - 1][col]
				&& ((array[sourceID - 1][col] >> 3) == desID)) {
 8003688:	b2aa      	uxth	r2, r5
		if (array[sourceID - 1][col]
 800368a:	9901      	ldr	r1, [sp, #4]
 800368c:	0043      	lsls	r3, r0, #1
 800368e:	5acb      	ldrh	r3, [r1, r3]
 8003690:	2b00      	cmp	r3, #0
 8003692:	d00c      	beq.n	80036ae <FindRoute+0x5a>
				&& ((array[sourceID - 1][col] >> 3) == desID)) {
 8003694:	08db      	lsrs	r3, r3, #3
 8003696:	4293      	cmp	r3, r2
 8003698:	d109      	bne.n	80036ae <FindRoute+0x5a>
			routeDist[desID - 1] = 1;
 800369a:	2201      	movs	r2, #1
 800369c:	4b3b      	ldr	r3, [pc, #236]	; (800378c <FindRoute+0x138>)
			route[0] = desID;
			return col;
 800369e:	b2c0      	uxtb	r0, r0
			routeDist[desID - 1] = 1;
 80036a0:	195b      	adds	r3, r3, r5
 80036a2:	3b01      	subs	r3, #1
 80036a4:	701a      	strb	r2, [r3, #0]
			route[0] = desID;
 80036a6:	4b38      	ldr	r3, [pc, #224]	; (8003788 <FindRoute+0x134>)
 80036a8:	701d      	strb	r5, [r3, #0]
			return col;
		}
	}

	return 0;
}
 80036aa:	b013      	add	sp, #76	; 0x4c
 80036ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (int col = 1; col <= 6; col++) {
 80036ae:	3001      	adds	r0, #1
 80036b0:	2807      	cmp	r0, #7
 80036b2:	d1ea      	bne.n	800368a <FindRoute+0x36>
			routePrev[i - 1] = 0;   // Previous node in optimal path from source
 80036b4:	2200      	movs	r2, #0
	for (int i = 1; i <= N; i++) {
 80036b6:	4b38      	ldr	r3, [pc, #224]	; (8003798 <FindRoute+0x144>)
			routeDist[i - 1] = 0xFF; // Unknown distance function from source to i
 80036b8:	26ff      	movs	r6, #255	; 0xff
	for (int i = 1; i <= N; i++) {
 80036ba:	7819      	ldrb	r1, [r3, #0]
			routePrev[i - 1] = 0;   // Previous node in optimal path from source
 80036bc:	4694      	mov	ip, r2
	for (int i = 1; i <= N; i++) {
 80036be:	2301      	movs	r3, #1
			routePrev[i - 1] = 0;   // Previous node in optimal path from source
 80036c0:	4f33      	ldr	r7, [pc, #204]	; (8003790 <FindRoute+0x13c>)
	for (int i = 1; i <= N; i++) {
 80036c2:	4299      	cmp	r1, r3
 80036c4:	da2a      	bge.n	800371c <FindRoute+0xc8>
	uint8_t u = 0;
 80036c6:	2400      	movs	r4, #0
					alt = routeDist[u - 1] + 1;					// Add one hop
 80036c8:	4e30      	ldr	r6, [pc, #192]	; (800378c <FindRoute+0x138>)
	while (!QnotEmpty(Q)) {
 80036ca:	af05      	add	r7, sp, #20
 80036cc:	0038      	movs	r0, r7
 80036ce:	f7ff fb03 	bl	8002cd8 <QnotEmpty>
 80036d2:	2800      	cmp	r0, #0
 80036d4:	d107      	bne.n	80036e6 <FindRoute+0x92>
		u = minArr(routeDist, Q) + 1;				// Source node in first case
 80036d6:	0039      	movs	r1, r7
 80036d8:	482c      	ldr	r0, [pc, #176]	; (800378c <FindRoute+0x138>)
 80036da:	f7ff fae3 	bl	8002ca4 <minArr>
 80036de:	3001      	adds	r0, #1
 80036e0:	b2c4      	uxtb	r4, r0
		if (u == desID) {
 80036e2:	42ac      	cmp	r4, r5
 80036e4:	d124      	bne.n	8003730 <FindRoute+0xdc>
	uint8_t u = 0;
 80036e6:	2200      	movs	r2, #0
	while (routePrev[u - 1])   // Construct the shortest path with a stack route
 80036e8:	4929      	ldr	r1, [pc, #164]	; (8003790 <FindRoute+0x13c>)
		route[j++] = u;          			// Push the vertex onto the stack
 80036ea:	4e27      	ldr	r6, [pc, #156]	; (8003788 <FindRoute+0x134>)
	while (routePrev[u - 1])   // Construct the shortest path with a stack route
 80036ec:	190b      	adds	r3, r1, r4
 80036ee:	3b01      	subs	r3, #1
 80036f0:	7818      	ldrb	r0, [r3, #0]
 80036f2:	2800      	cmp	r0, #0
 80036f4:	d13f      	bne.n	8003776 <FindRoute+0x122>
	for (int col = 1; col <= 6; col++) {
 80036f6:	2301      	movs	r3, #1
						== route[routeDist[desID - 1] - 1])) {
 80036f8:	4a24      	ldr	r2, [pc, #144]	; (800378c <FindRoute+0x138>)
 80036fa:	1955      	adds	r5, r2, r5
 80036fc:	3d01      	subs	r5, #1
		if (array[sourceID - 1][col]
 80036fe:	9901      	ldr	r1, [sp, #4]
 8003700:	005a      	lsls	r2, r3, #1
 8003702:	5a89      	ldrh	r1, [r1, r2]
 8003704:	2900      	cmp	r1, #0
 8003706:	d03b      	beq.n	8003780 <FindRoute+0x12c>
						== route[routeDist[desID - 1] - 1])) {
 8003708:	782a      	ldrb	r2, [r5, #0]
 800370a:	4c1f      	ldr	r4, [pc, #124]	; (8003788 <FindRoute+0x134>)
				&& ((array[sourceID - 1][col] >> 3)
 800370c:	08c9      	lsrs	r1, r1, #3
						== route[routeDist[desID - 1] - 1])) {
 800370e:	18a2      	adds	r2, r4, r2
 8003710:	3a01      	subs	r2, #1
				&& ((array[sourceID - 1][col] >> 3)
 8003712:	7812      	ldrb	r2, [r2, #0]
 8003714:	428a      	cmp	r2, r1
 8003716:	d133      	bne.n	8003780 <FindRoute+0x12c>
			return col;
 8003718:	b2d8      	uxtb	r0, r3
 800371a:	e7c6      	b.n	80036aa <FindRoute+0x56>
		if (i != sourceID) // Where i has not yet been removed from Q (unvisited nodes)
 800371c:	429c      	cmp	r4, r3
 800371e:	d005      	beq.n	800372c <FindRoute+0xd8>
			routeDist[i - 1] = 0xFF; // Unknown distance function from source to i
 8003720:	481a      	ldr	r0, [pc, #104]	; (800378c <FindRoute+0x138>)
 8003722:	1e5a      	subs	r2, r3, #1
 8003724:	5486      	strb	r6, [r0, r2]
			routePrev[i - 1] = 0;   // Previous node in optimal path from source
 8003726:	4660      	mov	r0, ip
 8003728:	18ba      	adds	r2, r7, r2
 800372a:	7010      	strb	r0, [r2, #0]
	for (int i = 1; i <= N; i++) {
 800372c:	3301      	adds	r3, #1
 800372e:	e7c8      	b.n	80036c2 <FindRoute+0x6e>
 8003730:	2216      	movs	r2, #22
			Q[u - 1] = 1;									// Remove u from Q
 8003732:	2301      	movs	r3, #1
 8003734:	2101      	movs	r1, #1
 8003736:	1e60      	subs	r0, r4, #1
 8003738:	4342      	muls	r2, r0
 800373a:	543b      	strb	r3, [r7, r0]
 800373c:	4b15      	ldr	r3, [pc, #84]	; (8003794 <FindRoute+0x140>)
				if (!Q[v - 1])								// v is still in Q
 800373e:	9703      	str	r7, [sp, #12]
 8003740:	18d3      	adds	r3, r2, r3
 8003742:	9302      	str	r3, [sp, #8]
			if (array[u - 1][n])		// There's a neighbor v at this port n
 8003744:	9a02      	ldr	r2, [sp, #8]
 8003746:	004b      	lsls	r3, r1, #1
 8003748:	5ad3      	ldrh	r3, [r2, r3]
 800374a:	2b00      	cmp	r3, #0
 800374c:	d00f      	beq.n	800376e <FindRoute+0x11a>
				v = (array[u - 1][n] >> 3);
 800374e:	08db      	lsrs	r3, r3, #3
				if (!Q[v - 1])								// v is still in Q
 8003750:	b2db      	uxtb	r3, r3
 8003752:	9a03      	ldr	r2, [sp, #12]
 8003754:	3b01      	subs	r3, #1
 8003756:	5cd2      	ldrb	r2, [r2, r3]
 8003758:	2a00      	cmp	r2, #0
 800375a:	d108      	bne.n	800376e <FindRoute+0x11a>
					alt = routeDist[u - 1] + 1;					// Add one hop
 800375c:	5c32      	ldrb	r2, [r6, r0]
					if (alt < routeDist[v - 1]) // A shorter path to v has been found
 800375e:	5cf7      	ldrb	r7, [r6, r3]
					alt = routeDist[u - 1] + 1;					// Add one hop
 8003760:	3201      	adds	r2, #1
 8003762:	b2d2      	uxtb	r2, r2
					if (alt < routeDist[v - 1]) // A shorter path to v has been found
 8003764:	4297      	cmp	r7, r2
 8003766:	d902      	bls.n	800376e <FindRoute+0x11a>
						routeDist[v - 1] = alt;
 8003768:	54f2      	strb	r2, [r6, r3]
						routePrev[v - 1] = u;
 800376a:	4a09      	ldr	r2, [pc, #36]	; (8003790 <FindRoute+0x13c>)
 800376c:	54d4      	strb	r4, [r2, r3]
 800376e:	3101      	adds	r1, #1
		for (uint8_t n = 1; n <= 6; n++)      		// Check all module ports
 8003770:	2907      	cmp	r1, #7
 8003772:	d1e7      	bne.n	8003744 <FindRoute+0xf0>
 8003774:	e7a9      	b.n	80036ca <FindRoute+0x76>
		route[j++] = u;          			// Push the vertex onto the stack
 8003776:	1c53      	adds	r3, r2, #1
 8003778:	54b4      	strb	r4, [r6, r2]
 800377a:	b2da      	uxtb	r2, r3
 800377c:	0004      	movs	r4, r0
 800377e:	e7b5      	b.n	80036ec <FindRoute+0x98>
	for (int col = 1; col <= 6; col++) {
 8003780:	3301      	adds	r3, #1
 8003782:	2b07      	cmp	r3, #7
 8003784:	d1bb      	bne.n	80036fe <FindRoute+0xaa>
 8003786:	e790      	b.n	80036aa <FindRoute+0x56>
 8003788:	20007028 	.word	0x20007028
 800378c:	200010c9 	.word	0x200010c9
 8003790:	200010e2 	.word	0x200010e2
 8003794:	20000aa0 	.word	0x20000aa0
 8003798:	2000001c 	.word	0x2000001c

0800379c <remoteBootloaderUpdate>:
		uint8_t outport) {
 800379c:	b5f0      	push	{r4, r5, r6, r7, lr}
	myOutport = FindRoute(myID, dst);
 800379e:	4e31      	ldr	r6, [pc, #196]	; (8003864 <remoteBootloaderUpdate+0xc8>)
		uint8_t outport) {
 80037a0:	b089      	sub	sp, #36	; 0x24
 80037a2:	0005      	movs	r5, r0
	myOutport = FindRoute(myID, dst);
 80037a4:	7830      	ldrb	r0, [r6, #0]
		uint8_t outport) {
 80037a6:	000c      	movs	r4, r1
 80037a8:	9207      	str	r2, [sp, #28]
 80037aa:	001f      	movs	r7, r3
	myOutport = FindRoute(myID, dst);
 80037ac:	f7ff ff52 	bl	8003654 <FindRoute>
 80037b0:	7831      	ldrb	r1, [r6, #0]
 80037b2:	9005      	str	r0, [sp, #20]
	if (outport && dst == myID) { /* This is a 'via port' update and I'm the last module */
 80037b4:	2f00      	cmp	r7, #0
 80037b6:	d005      	beq.n	80037c4 <remoteBootloaderUpdate+0x28>
	uint8_t myOutport = 0, lastModule = 0;
 80037b8:	2300      	movs	r3, #0
	if (outport && dst == myID) { /* This is a 'via port' update and I'm the last module */
 80037ba:	42a1      	cmp	r1, r4
 80037bc:	d10d      	bne.n	80037da <remoteBootloaderUpdate+0x3e>
 80037be:	9406      	str	r4, [sp, #24]
 80037c0:	9705      	str	r7, [sp, #20]
 80037c2:	e00b      	b.n	80037dc <remoteBootloaderUpdate+0x40>
		if (NumberOfHops(dst)== 1)
 80037c4:	4b28      	ldr	r3, [pc, #160]	; (8003868 <remoteBootloaderUpdate+0xcc>)
 80037c6:	9106      	str	r1, [sp, #24]
 80037c8:	191b      	adds	r3, r3, r4
 80037ca:	3b01      	subs	r3, #1
 80037cc:	781a      	ldrb	r2, [r3, #0]
 80037ce:	2a01      	cmp	r2, #1
 80037d0:	d004      	beq.n	80037dc <remoteBootloaderUpdate+0x40>
		lastModule = route[NumberOfHops(dst)-1]; /* previous module = route[Number of hops - 1] */
 80037d2:	4b26      	ldr	r3, [pc, #152]	; (800386c <remoteBootloaderUpdate+0xd0>)
 80037d4:	189b      	adds	r3, r3, r2
 80037d6:	3b01      	subs	r3, #1
 80037d8:	781b      	ldrb	r3, [r3, #0]
 80037da:	9306      	str	r3, [sp, #24]
	if (src == myID) {
 80037dc:	7833      	ldrb	r3, [r6, #0]
 80037de:	42ab      	cmp	r3, r5
 80037e0:	d11a      	bne.n	8003818 <remoteBootloaderUpdate+0x7c>
		pcOutputString = FreeRTOS_CLIGetOutputBuffer();
 80037e2:	f00c f8b7 	bl	800f954 <FreeRTOS_CLIGetOutputBuffer>
 80037e6:	0005      	movs	r5, r0
		if (outport == 0)		// This is a remote module update
 80037e8:	2f00      	cmp	r7, #0
 80037ea:	d134      	bne.n	8003856 <remoteBootloaderUpdate+0xba>
			sprintf((char*) pcOutputString, pcRemoteBootloaderUpdateMessage,
 80037ec:	4b20      	ldr	r3, [pc, #128]	; (8003870 <remoteBootloaderUpdate+0xd4>)
 80037ee:	0022      	movs	r2, r4
 80037f0:	6819      	ldr	r1, [r3, #0]
 80037f2:	f011 f933 	bl	8014a5c <sprintf>
		strcat((char*) pcOutputString, pcRemoteBootloaderUpdateWarningMessage);
 80037f6:	4b1f      	ldr	r3, [pc, #124]	; (8003874 <remoteBootloaderUpdate+0xd8>)
 80037f8:	0028      	movs	r0, r5
 80037fa:	6819      	ldr	r1, [r3, #0]
 80037fc:	f011 f94e 	bl	8014a9c <strcat>
				strlen((char*) pcOutputString), cmd50ms);
 8003800:	0028      	movs	r0, r5
 8003802:	f7fc fc89 	bl	8000118 <strlen>
		writePxITMutex(inport, (char*) pcOutputString,
 8003806:	2332      	movs	r3, #50	; 0x32
 8003808:	b282      	uxth	r2, r0
 800380a:	0029      	movs	r1, r5
 800380c:	9807      	ldr	r0, [sp, #28]
 800380e:	f009 fe29 	bl	800d464 <writePxITMutex>
		Delay_ms(100);
 8003812:	2064      	movs	r0, #100	; 0x64
 8003814:	f00d fe7a 	bl	801150c <HAL_Delay>
	SetupPortForRemoteBootloaderUpdate(inport);
 8003818:	9807      	ldr	r0, [sp, #28]
 800381a:	f7ff fe0f 	bl	800343c <SetupPortForRemoteBootloaderUpdate>
	SetupPortForRemoteBootloaderUpdate(myOutport);
 800381e:	9805      	ldr	r0, [sp, #20]
 8003820:	f7ff fe0c 	bl	800343c <SetupPortForRemoteBootloaderUpdate>
	if (lastModule == myID) {
 8003824:	7833      	ldrb	r3, [r6, #0]
 8003826:	9a06      	ldr	r2, [sp, #24]
 8003828:	4293      	cmp	r3, r2
 800382a:	d105      	bne.n	8003838 <remoteBootloaderUpdate+0x9c>
		SwapUartPins(GetUart(myOutport), REVERSED);
 800382c:	9805      	ldr	r0, [sp, #20]
 800382e:	f009 fde7 	bl	800d400 <GetUart>
 8003832:	2101      	movs	r1, #1
 8003834:	f009 fe5a 	bl	800d4ec <SwapUartPins>
	StartScastDMAStream(inport, myID, myOutport, myID, BIDIRECTIONAL,
 8003838:	2300      	movs	r3, #0
 800383a:	7831      	ldrb	r1, [r6, #0]
 800383c:	9303      	str	r3, [sp, #12]
 800383e:	3b01      	subs	r3, #1
 8003840:	9302      	str	r3, [sp, #8]
 8003842:	9301      	str	r3, [sp, #4]
 8003844:	3303      	adds	r3, #3
 8003846:	9300      	str	r3, [sp, #0]
 8003848:	9a05      	ldr	r2, [sp, #20]
 800384a:	000b      	movs	r3, r1
 800384c:	9807      	ldr	r0, [sp, #28]
 800384e:	f004 fb8f 	bl	8007f70 <StartScastDMAStream>
}
 8003852:	b009      	add	sp, #36	; 0x24
 8003854:	bdf0      	pop	{r4, r5, r6, r7, pc}
			sprintf((char*) pcOutputString,
 8003856:	4908      	ldr	r1, [pc, #32]	; (8003878 <remoteBootloaderUpdate+0xdc>)
 8003858:	003b      	movs	r3, r7
 800385a:	0022      	movs	r2, r4
 800385c:	6809      	ldr	r1, [r1, #0]
 800385e:	f011 f8fd 	bl	8014a5c <sprintf>
 8003862:	e7c8      	b.n	80037f6 <remoteBootloaderUpdate+0x5a>
 8003864:	20001039 	.word	0x20001039
 8003868:	200010c9 	.word	0x200010c9
 800386c:	20007028 	.word	0x20007028
 8003870:	20000078 	.word	0x20000078
 8003874:	20000080 	.word	0x20000080
 8003878:	2000007c 	.word	0x2000007c

0800387c <DisplayTopology>:

/*-----------------------------------------------------------*/

/* --- Display array topology in human-readable format through module port --- 
 */
void DisplayTopology(uint8_t port) {
 800387c:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Print table header */
	sprintf(pcUserMessage, "\n\r(Module:Port)\t\t");
 800387e:	4d4f      	ldr	r5, [pc, #316]	; (80039bc <DisplayTopology+0x140>)
void DisplayTopology(uint8_t port) {
 8003880:	b085      	sub	sp, #20
	sprintf(pcUserMessage, "\n\r(Module:Port)\t\t");
 8003882:	494f      	ldr	r1, [pc, #316]	; (80039c0 <DisplayTopology+0x144>)
void DisplayTopology(uint8_t port) {
 8003884:	0004      	movs	r4, r0
	sprintf(pcUserMessage, "\n\r(Module:Port)\t\t");
 8003886:	0028      	movs	r0, r5
 8003888:	f011 f924 	bl	8014ad4 <strcpy>
	writePxMutex(port, pcUserMessage, strlen(pcUserMessage), cmd50ms,
 800388c:	2601      	movs	r6, #1
 800388e:	0028      	movs	r0, r5
 8003890:	f7fc fc42 	bl	8000118 <strlen>
 8003894:	4276      	negs	r6, r6
 8003896:	b282      	uxth	r2, r0
 8003898:	9600      	str	r6, [sp, #0]
 800389a:	2332      	movs	r3, #50	; 0x32
 800389c:	0029      	movs	r1, r5
 800389e:	0020      	movs	r0, r4
 80038a0:	f009 fdba 	bl	800d418 <writePxMutex>
 80038a4:	2701      	movs	r7, #1
			HAL_MAX_DELAY);
	for (uint8_t i = 1; i <= NumOfPorts; i++) {
		sprintf(pcUserMessage, "P%d\t", i);
 80038a6:	003a      	movs	r2, r7
 80038a8:	4946      	ldr	r1, [pc, #280]	; (80039c4 <DisplayTopology+0x148>)
 80038aa:	0028      	movs	r0, r5
 80038ac:	f011 f8d6 	bl	8014a5c <sprintf>
		writePxMutex(port, pcUserMessage, strlen(pcUserMessage), cmd50ms,
 80038b0:	0028      	movs	r0, r5
 80038b2:	f7fc fc31 	bl	8000118 <strlen>
 80038b6:	3701      	adds	r7, #1
 80038b8:	b282      	uxth	r2, r0
 80038ba:	9600      	str	r6, [sp, #0]
 80038bc:	2332      	movs	r3, #50	; 0x32
 80038be:	0029      	movs	r1, r5
 80038c0:	0020      	movs	r0, r4
 80038c2:	f009 fda9 	bl	800d418 <writePxMutex>
	for (uint8_t i = 1; i <= NumOfPorts; i++) {
 80038c6:	2f06      	cmp	r7, #6
 80038c8:	d1ed      	bne.n	80038a6 <DisplayTopology+0x2a>
				HAL_MAX_DELAY);
	}
	writePxMutex(port, "\n\n\r", 3, cmd50ms, HAL_MAX_DELAY);
 80038ca:	9600      	str	r6, [sp, #0]
 80038cc:	2332      	movs	r3, #50	; 0x32
 80038ce:	2203      	movs	r2, #3
 80038d0:	493d      	ldr	r1, [pc, #244]	; (80039c8 <DisplayTopology+0x14c>)
 80038d2:	0020      	movs	r0, r4
 80038d4:	f009 fda0 	bl	800d418 <writePxMutex>

	/* Print each row */
	for (uint8_t row = 0; row < N; row++) {
 80038d8:	2700      	movs	r7, #0
 80038da:	4b3c      	ldr	r3, [pc, #240]	; (80039cc <DisplayTopology+0x150>)
 80038dc:	781b      	ldrb	r3, [r3, #0]
 80038de:	42bb      	cmp	r3, r7
 80038e0:	d80a      	bhi.n	80038f8 <DisplayTopology+0x7c>
					HAL_MAX_DELAY);
		}
		writePxMutex(port, "\n\r", 2, cmd50ms, HAL_MAX_DELAY);
	}

	writePxMutex(port, "\n", 1, cmd50ms, HAL_MAX_DELAY);
 80038e2:	2301      	movs	r3, #1
 80038e4:	425b      	negs	r3, r3
 80038e6:	9300      	str	r3, [sp, #0]
 80038e8:	2201      	movs	r2, #1
 80038ea:	3333      	adds	r3, #51	; 0x33
 80038ec:	4938      	ldr	r1, [pc, #224]	; (80039d0 <DisplayTopology+0x154>)
 80038ee:	0020      	movs	r0, r4
 80038f0:	f009 fd92 	bl	800d418 <writePxMutex>
}
 80038f4:	b005      	add	sp, #20
 80038f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		sprintf(pcUserMessage, "Module %d:\t", row + 1);
 80038f8:	4d30      	ldr	r5, [pc, #192]	; (80039bc <DisplayTopology+0x140>)
 80038fa:	1c7a      	adds	r2, r7, #1
 80038fc:	4935      	ldr	r1, [pc, #212]	; (80039d4 <DisplayTopology+0x158>)
 80038fe:	0028      	movs	r0, r5
 8003900:	f011 f8ac 	bl	8014a5c <sprintf>
		writePxMutex(port, pcUserMessage, strlen(pcUserMessage), cmd50ms,
 8003904:	0028      	movs	r0, r5
 8003906:	f7fc fc07 	bl	8000118 <strlen>
 800390a:	2301      	movs	r3, #1
 800390c:	425b      	negs	r3, r3
 800390e:	b282      	uxth	r2, r0
 8003910:	0029      	movs	r1, r5
 8003912:	9300      	str	r3, [sp, #0]
 8003914:	0020      	movs	r0, r4
 8003916:	3333      	adds	r3, #51	; 0x33
 8003918:	f009 fd7e 	bl	800d418 <writePxMutex>
		strncpy(pcUserMessage, modulePNstring[(array[row][0])], 5);
 800391c:	2216      	movs	r2, #22
 800391e:	2106      	movs	r1, #6
 8003920:	437a      	muls	r2, r7
 8003922:	4e2d      	ldr	r6, [pc, #180]	; (80039d8 <DisplayTopology+0x15c>)
 8003924:	9203      	str	r2, [sp, #12]
 8003926:	5b93      	ldrh	r3, [r2, r6]
 8003928:	0028      	movs	r0, r5
 800392a:	4359      	muls	r1, r3
 800392c:	4b2b      	ldr	r3, [pc, #172]	; (80039dc <DisplayTopology+0x160>)
 800392e:	2205      	movs	r2, #5
 8003930:	18c9      	adds	r1, r1, r3
 8003932:	f011 f8e8 	bl	8014b06 <strncpy>
		writePxMutex(port, pcUserMessage, 5, cmd50ms, HAL_MAX_DELAY);
 8003936:	2301      	movs	r3, #1
 8003938:	425b      	negs	r3, r3
 800393a:	0029      	movs	r1, r5
 800393c:	9300      	str	r3, [sp, #0]
 800393e:	2205      	movs	r2, #5
 8003940:	3333      	adds	r3, #51	; 0x33
 8003942:	0020      	movs	r0, r4
 8003944:	f009 fd68 	bl	800d418 <writePxMutex>
		writePxMutex(port, "\t", 1, cmd50ms, HAL_MAX_DELAY);
 8003948:	2301      	movs	r3, #1
 800394a:	2501      	movs	r5, #1
 800394c:	425b      	negs	r3, r3
 800394e:	9300      	str	r3, [sp, #0]
 8003950:	2201      	movs	r2, #1
 8003952:	3333      	adds	r3, #51	; 0x33
 8003954:	4922      	ldr	r1, [pc, #136]	; (80039e0 <DisplayTopology+0x164>)
 8003956:	0020      	movs	r0, r4
 8003958:	f009 fd5e 	bl	800d418 <writePxMutex>
 800395c:	9b03      	ldr	r3, [sp, #12]
 800395e:	199b      	adds	r3, r3, r6
 8003960:	9303      	str	r3, [sp, #12]
			if (!array[row][col])
 8003962:	9a03      	ldr	r2, [sp, #12]
 8003964:	006b      	lsls	r3, r5, #1
 8003966:	5ad2      	ldrh	r2, [r2, r3]
 8003968:	4e14      	ldr	r6, [pc, #80]	; (80039bc <DisplayTopology+0x140>)
 800396a:	2a00      	cmp	r2, #0
 800396c:	d11e      	bne.n	80039ac <DisplayTopology+0x130>
				sprintf(pcUserMessage, "%d\t", 0);
 800396e:	491d      	ldr	r1, [pc, #116]	; (80039e4 <DisplayTopology+0x168>)
 8003970:	0030      	movs	r0, r6
 8003972:	f011 f873 	bl	8014a5c <sprintf>
			writePxMutex(port, pcUserMessage, strlen(pcUserMessage), cmd50ms,
 8003976:	0030      	movs	r0, r6
 8003978:	f7fc fbce 	bl	8000118 <strlen>
 800397c:	2301      	movs	r3, #1
 800397e:	425b      	negs	r3, r3
 8003980:	b282      	uxth	r2, r0
 8003982:	9300      	str	r3, [sp, #0]
 8003984:	0031      	movs	r1, r6
 8003986:	3333      	adds	r3, #51	; 0x33
 8003988:	0020      	movs	r0, r4
 800398a:	3501      	adds	r5, #1
 800398c:	f009 fd44 	bl	800d418 <writePxMutex>
		for (uint8_t col = 1; col <= NumOfPorts; col++) {
 8003990:	2d06      	cmp	r5, #6
 8003992:	d1e6      	bne.n	8003962 <DisplayTopology+0xe6>
		writePxMutex(port, "\n\r", 2, cmd50ms, HAL_MAX_DELAY);
 8003994:	2301      	movs	r3, #1
 8003996:	425b      	negs	r3, r3
 8003998:	9300      	str	r3, [sp, #0]
 800399a:	2202      	movs	r2, #2
 800399c:	3333      	adds	r3, #51	; 0x33
 800399e:	4912      	ldr	r1, [pc, #72]	; (80039e8 <DisplayTopology+0x16c>)
 80039a0:	0020      	movs	r0, r4
	for (uint8_t row = 0; row < N; row++) {
 80039a2:	3701      	adds	r7, #1
		writePxMutex(port, "\n\r", 2, cmd50ms, HAL_MAX_DELAY);
 80039a4:	f009 fd38 	bl	800d418 <writePxMutex>
	for (uint8_t row = 0; row < N; row++) {
 80039a8:	b2ff      	uxtb	r7, r7
 80039aa:	e796      	b.n	80038da <DisplayTopology+0x5e>
				sprintf(pcUserMessage, "%d:%d\t", (array[row][col] >> 3),
 80039ac:	2307      	movs	r3, #7
 80039ae:	490f      	ldr	r1, [pc, #60]	; (80039ec <DisplayTopology+0x170>)
 80039b0:	4013      	ands	r3, r2
 80039b2:	0030      	movs	r0, r6
 80039b4:	08d2      	lsrs	r2, r2, #3
 80039b6:	f011 f851 	bl	8014a5c <sprintf>
 80039ba:	e7dc      	b.n	8003976 <DisplayTopology+0xfa>
 80039bc:	20001062 	.word	0x20001062
 80039c0:	080192b4 	.word	0x080192b4
 80039c4:	080192c6 	.word	0x080192c6
 80039c8:	08019a5e 	.word	0x08019a5e
 80039cc:	2000001c 	.word	0x2000001c
 80039d0:	0801aae9 	.word	0x0801aae9
 80039d4:	080192cb 	.word	0x080192cb
 80039d8:	20000aa0 	.word	0x20000aa0
 80039dc:	0801930e 	.word	0x0801930e
 80039e0:	080192c4 	.word	0x080192c4
 80039e4:	080192da 	.word	0x080192da
 80039e8:	08019a5f 	.word	0x08019a5f
 80039ec:	080192d7 	.word	0x080192d7

080039f0 <DisplayPortsDir>:

/*-----------------------------------------------------------*/

/* --- Display ports directions in human-readable format through module port --- 
 */
void DisplayPortsDir(uint8_t port) {
 80039f0:	b5f0      	push	{r4, r5, r6, r7, lr}
	sprintf(pcUserMessage, "\n\rThese ports are reversed:");
 80039f2:	4c27      	ldr	r4, [pc, #156]	; (8003a90 <DisplayPortsDir+0xa0>)
void DisplayPortsDir(uint8_t port) {
 80039f4:	b085      	sub	sp, #20
	sprintf(pcUserMessage, "\n\rThese ports are reversed:");
 80039f6:	4927      	ldr	r1, [pc, #156]	; (8003a94 <DisplayPortsDir+0xa4>)
void DisplayPortsDir(uint8_t port) {
 80039f8:	0006      	movs	r6, r0
	sprintf(pcUserMessage, "\n\rThese ports are reversed:");
 80039fa:	0020      	movs	r0, r4
 80039fc:	f011 f86a 	bl	8014ad4 <strcpy>
	writePxMutex(port, pcUserMessage, strlen(pcUserMessage), cmd50ms,
 8003a00:	2701      	movs	r7, #1
 8003a02:	0020      	movs	r0, r4
 8003a04:	f7fc fb88 	bl	8000118 <strlen>
			HAL_MAX_DELAY);

	for (uint8_t i = 1; i <= N; i++) {
 8003a08:	2501      	movs	r5, #1
	writePxMutex(port, pcUserMessage, strlen(pcUserMessage), cmd50ms,
 8003a0a:	427f      	negs	r7, r7
 8003a0c:	b282      	uxth	r2, r0
 8003a0e:	9700      	str	r7, [sp, #0]
 8003a10:	2332      	movs	r3, #50	; 0x32
 8003a12:	0021      	movs	r1, r4
 8003a14:	0030      	movs	r0, r6
 8003a16:	f009 fcff 	bl	800d418 <writePxMutex>
		for (uint8_t p = 1; p <= MaxNumOfPorts; p++) {
			if ((arrayPortsDir[i - 1] & (0x8000 >> (p - 1)))) /* Port is reversed */
			{
				sprintf(pcUserMessage, "\n\rModule %d : P%d", i, p);
				writePxMutex(port, pcUserMessage, strlen(pcUserMessage),
 8003a1a:	9703      	str	r7, [sp, #12]
	for (uint8_t i = 1; i <= N; i++) {
 8003a1c:	4b1e      	ldr	r3, [pc, #120]	; (8003a98 <DisplayPortsDir+0xa8>)
 8003a1e:	781b      	ldrb	r3, [r3, #0]
 8003a20:	42ab      	cmp	r3, r5
 8003a22:	d211      	bcs.n	8003a48 <DisplayPortsDir+0x58>
						cmd50ms, HAL_MAX_DELAY);
			}
		}
	}

	sprintf(pcUserMessage, "\n\n\rAll other ports are normal\n\r");
 8003a24:	491d      	ldr	r1, [pc, #116]	; (8003a9c <DisplayPortsDir+0xac>)
 8003a26:	0020      	movs	r0, r4
 8003a28:	f011 f854 	bl	8014ad4 <strcpy>
	writePxMutex(port, pcUserMessage, strlen(pcUserMessage), cmd50ms,
 8003a2c:	0020      	movs	r0, r4
 8003a2e:	f7fc fb73 	bl	8000118 <strlen>
 8003a32:	2301      	movs	r3, #1
 8003a34:	425b      	negs	r3, r3
 8003a36:	b282      	uxth	r2, r0
 8003a38:	9300      	str	r3, [sp, #0]
 8003a3a:	0021      	movs	r1, r4
 8003a3c:	3333      	adds	r3, #51	; 0x33
 8003a3e:	0030      	movs	r0, r6
 8003a40:	f009 fcea 	bl	800d418 <writePxMutex>
			HAL_MAX_DELAY);
}
 8003a44:	b005      	add	sp, #20
 8003a46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003a48:	2300      	movs	r3, #0
			if ((arrayPortsDir[i - 1] & (0x8000 >> (p - 1)))) /* Port is reversed */
 8003a4a:	1e6a      	subs	r2, r5, #1
 8003a4c:	0052      	lsls	r2, r2, #1
 8003a4e:	9202      	str	r2, [sp, #8]
 8003a50:	9902      	ldr	r1, [sp, #8]
 8003a52:	4a13      	ldr	r2, [pc, #76]	; (8003aa0 <DisplayPortsDir+0xb0>)
 8003a54:	1c5f      	adds	r7, r3, #1
 8003a56:	5a8a      	ldrh	r2, [r1, r2]
 8003a58:	2180      	movs	r1, #128	; 0x80
 8003a5a:	0209      	lsls	r1, r1, #8
 8003a5c:	4119      	asrs	r1, r3
 8003a5e:	4211      	tst	r1, r2
 8003a60:	d010      	beq.n	8003a84 <DisplayPortsDir+0x94>
				sprintf(pcUserMessage, "\n\rModule %d : P%d", i, p);
 8003a62:	003b      	movs	r3, r7
 8003a64:	002a      	movs	r2, r5
 8003a66:	490f      	ldr	r1, [pc, #60]	; (8003aa4 <DisplayPortsDir+0xb4>)
 8003a68:	0020      	movs	r0, r4
 8003a6a:	f010 fff7 	bl	8014a5c <sprintf>
				writePxMutex(port, pcUserMessage, strlen(pcUserMessage),
 8003a6e:	0020      	movs	r0, r4
 8003a70:	f7fc fb52 	bl	8000118 <strlen>
 8003a74:	9b03      	ldr	r3, [sp, #12]
 8003a76:	b282      	uxth	r2, r0
 8003a78:	9300      	str	r3, [sp, #0]
 8003a7a:	0021      	movs	r1, r4
 8003a7c:	2332      	movs	r3, #50	; 0x32
 8003a7e:	0030      	movs	r0, r6
 8003a80:	f009 fcca 	bl	800d418 <writePxMutex>
 8003a84:	003b      	movs	r3, r7
		for (uint8_t p = 1; p <= MaxNumOfPorts; p++) {
 8003a86:	2f0a      	cmp	r7, #10
 8003a88:	d1e2      	bne.n	8003a50 <DisplayPortsDir+0x60>
	for (uint8_t i = 1; i <= N; i++) {
 8003a8a:	3501      	adds	r5, #1
 8003a8c:	b2ed      	uxtb	r5, r5
 8003a8e:	e7c5      	b.n	8003a1c <DisplayPortsDir+0x2c>
 8003a90:	20001062 	.word	0x20001062
 8003a94:	08019266 	.word	0x08019266
 8003a98:	2000001c 	.word	0x2000001c
 8003a9c:	08019294 	.word	0x08019294
 8003aa0:	20007a44 	.word	0x20007a44
 8003aa4:	08019282 	.word	0x08019282

08003aa8 <DisplayModuleStatus>:

/*-----------------------------------------------------------*/

/* --- Display a description of current module status (Firmware, Ports, P2P DMAs) --- 
 */
void DisplayModuleStatus(uint8_t port) {
 8003aa8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003aaa:	b085      	sub	sp, #20
 8003aac:	9003      	str	r0, [sp, #12]
	int8_t *pcOutputString;
	uint16_t temp = 0;

	/* Obtain the address of the output buffer. */
	pcOutputString = FreeRTOS_CLIGetOutputBuffer();
 8003aae:	f00b ff51 	bl	800f954 <FreeRTOS_CLIGetOutputBuffer>
 8003ab2:	0004      	movs	r4, r0

	strcpy((char*) pcOutputString, "");
 8003ab4:	496d      	ldr	r1, [pc, #436]	; (8003c6c <DisplayModuleStatus+0x1c4>)
 8003ab6:	f011 f80d 	bl	8014ad4 <strcpy>

	sprintf(pcUserMessage, "\n\r*** Module %d Status ***\n", myID);
 8003aba:	4d6d      	ldr	r5, [pc, #436]	; (8003c70 <DisplayModuleStatus+0x1c8>)
 8003abc:	4b6d      	ldr	r3, [pc, #436]	; (8003c74 <DisplayModuleStatus+0x1cc>)
 8003abe:	496e      	ldr	r1, [pc, #440]	; (8003c78 <DisplayModuleStatus+0x1d0>)
 8003ac0:	781a      	ldrb	r2, [r3, #0]
 8003ac2:	0028      	movs	r0, r5
 8003ac4:	f010 ffca 	bl	8014a5c <sprintf>
	strcat((char*) pcOutputString, pcUserMessage);
 8003ac8:	0029      	movs	r1, r5
 8003aca:	0020      	movs	r0, r4
 8003acc:	f010 ffe6 	bl	8014a9c <strcat>
	sprintf(pcUserMessage, "\n\rConnected via port: P%d\n\r", PcPort);
 8003ad0:	4b6a      	ldr	r3, [pc, #424]	; (8003c7c <DisplayModuleStatus+0x1d4>)
 8003ad2:	496b      	ldr	r1, [pc, #428]	; (8003c80 <DisplayModuleStatus+0x1d8>)
 8003ad4:	781a      	ldrb	r2, [r3, #0]
 8003ad6:	0028      	movs	r0, r5
 8003ad8:	f010 ffc0 	bl	8014a5c <sprintf>
	strcat((char*) pcOutputString, pcUserMessage);
 8003adc:	0029      	movs	r1, r5
 8003ade:	0020      	movs	r0, r4
 8003ae0:	f010 ffdc 	bl	8014a9c <strcat>

	/* Firmware */
	sprintf(pcUserMessage, "\n\rFirmware version: %d.%d.%d", _firmMajor,
 8003ae4:	2304      	movs	r3, #4
 8003ae6:	2200      	movs	r2, #0
 8003ae8:	9300      	str	r3, [sp, #0]
 8003aea:	4966      	ldr	r1, [pc, #408]	; (8003c84 <DisplayModuleStatus+0x1dc>)
 8003aec:	3b02      	subs	r3, #2
 8003aee:	0028      	movs	r0, r5
 8003af0:	f010 ffb4 	bl	8014a5c <sprintf>
			_firmMinor, _firmPatch);
	strcat((char*) pcOutputString, pcUserMessage);
 8003af4:	0029      	movs	r1, r5
 8003af6:	0020      	movs	r0, r4
 8003af8:	f010 ffd0 	bl	8014a9c <strcat>
	sprintf(pcUserMessage, "\n\rFirmware date:    %s", _firmDate);
 8003afc:	4a62      	ldr	r2, [pc, #392]	; (8003c88 <DisplayModuleStatus+0x1e0>)
 8003afe:	4963      	ldr	r1, [pc, #396]	; (8003c8c <DisplayModuleStatus+0x1e4>)
 8003b00:	0028      	movs	r0, r5
 8003b02:	f010 ffab 	bl	8014a5c <sprintf>
	strcat((char*) pcOutputString, pcUserMessage);
 8003b06:	0029      	movs	r1, r5
 8003b08:	0020      	movs	r0, r4
 8003b0a:	f010 ffc7 	bl	8014a9c <strcat>
	sprintf(pcUserMessage, "\n\rFirmware time:    %s\n\r", _firmTime);
 8003b0e:	4a60      	ldr	r2, [pc, #384]	; (8003c90 <DisplayModuleStatus+0x1e8>)
 8003b10:	4960      	ldr	r1, [pc, #384]	; (8003c94 <DisplayModuleStatus+0x1ec>)
 8003b12:	0028      	movs	r0, r5
 8003b14:	f010 ffa2 	bl	8014a5c <sprintf>
	strcat((char*) pcOutputString, pcUserMessage);
 8003b18:	0029      	movs	r1, r5
 8003b1a:	0020      	movs	r0, r4
 8003b1c:	f010 ffbe 	bl	8014a9c <strcat>

	/* Ports */
	sprintf(pcUserMessage, "\n\rPorts Status:\n\n\r");
 8003b20:	495d      	ldr	r1, [pc, #372]	; (8003c98 <DisplayModuleStatus+0x1f0>)
 8003b22:	0028      	movs	r0, r5
 8003b24:	f010 ffd6 	bl	8014ad4 <strcpy>
	strcat((char*) pcOutputString, pcUserMessage);
 8003b28:	0029      	movs	r1, r5
 8003b2a:	0020      	movs	r0, r4
 8003b2c:	f010 ffb6 	bl	8014a9c <strcat>
 8003b30:	2601      	movs	r6, #1
	for (uint8_t i = 1; i <= NumOfPorts; i++) {
		sprintf(pcUserMessage, "P%d: ", i);
 8003b32:	0032      	movs	r2, r6
 8003b34:	4959      	ldr	r1, [pc, #356]	; (8003c9c <DisplayModuleStatus+0x1f4>)
 8003b36:	0028      	movs	r0, r5
 8003b38:	f010 ff90 	bl	8014a5c <sprintf>
		strcat((char*) pcOutputString, pcUserMessage);
 8003b3c:	0029      	movs	r1, r5
 8003b3e:	0020      	movs	r0, r4
 8003b40:	f010 ffac 	bl	8014a9c <strcat>
		switch (portStatus[i]) {
 8003b44:	4b56      	ldr	r3, [pc, #344]	; (8003ca0 <DisplayModuleStatus+0x1f8>)
 8003b46:	5cf0      	ldrb	r0, [r6, r3]
 8003b48:	2804      	cmp	r0, #4
 8003b4a:	d808      	bhi.n	8003b5e <DisplayModuleStatus+0xb6>
 8003b4c:	f7fc faf6 	bl	800013c <__gnu_thumb1_case_uqi>
 8003b50:	76747203 	.word	0x76747203
 8003b54:	78          	.byte	0x78
 8003b55:	00          	.byte	0x00
		case FREE:
			sprintf(pcUserMessage, "Free\n\r");
 8003b56:	4953      	ldr	r1, [pc, #332]	; (8003ca4 <DisplayModuleStatus+0x1fc>)
			break;
		case CLI:
			sprintf(pcUserMessage, "Receiving user commands\n\r");
			break;
		case PORTBUTTON:
			sprintf(pcUserMessage, "Connected to a button/switch\n\r");
 8003b58:	0028      	movs	r0, r5
 8003b5a:	f010 ffbb 	bl	8014ad4 <strcpy>
			break;
		default:
			break;
		}
		strcat((char*) pcOutputString, pcUserMessage);
 8003b5e:	0029      	movs	r1, r5
 8003b60:	0020      	movs	r0, r4
 8003b62:	3601      	adds	r6, #1
 8003b64:	f010 ff9a 	bl	8014a9c <strcat>
	for (uint8_t i = 1; i <= NumOfPorts; i++) {
 8003b68:	2e06      	cmp	r6, #6
 8003b6a:	d1e2      	bne.n	8003b32 <DisplayModuleStatus+0x8a>
	}

	/* P2P DMAs */
	sprintf(pcUserMessage, "\n\rDMA Streams Status:\n\r");
 8003b6c:	494e      	ldr	r1, [pc, #312]	; (8003ca8 <DisplayModuleStatus+0x200>)
 8003b6e:	0028      	movs	r0, r5
 8003b70:	f010 ffb0 	bl	8014ad4 <strcpy>
	strcat((char*) pcOutputString, pcUserMessage);
 8003b74:	0029      	movs	r1, r5
 8003b76:	0020      	movs	r0, r4
 8003b78:	f010 ff90 	bl	8014a9c <strcat>
 8003b7c:	2501      	movs	r5, #1
 8003b7e:	2338      	movs	r3, #56	; 0x38
 8003b80:	436b      	muls	r3, r5
 8003b82:	4a4a      	ldr	r2, [pc, #296]	; (8003cac <DisplayModuleStatus+0x204>)
 8003b84:	189b      	adds	r3, r3, r2
	for (char i = 1; i <= 6; i++) {
		if (streamDMA[i - 1].Instance == 0) {
 8003b86:	001a      	movs	r2, r3
 8003b88:	3a38      	subs	r2, #56	; 0x38
 8003b8a:	6812      	ldr	r2, [r2, #0]
 8003b8c:	2a00      	cmp	r2, #0
 8003b8e:	d159      	bne.n	8003c44 <DisplayModuleStatus+0x19c>
			sprintf(pcUserMessage, "\n\rStreaming DMA %d is free", i);
 8003b90:	4e37      	ldr	r6, [pc, #220]	; (8003c70 <DisplayModuleStatus+0x1c8>)
 8003b92:	002a      	movs	r2, r5
 8003b94:	4946      	ldr	r1, [pc, #280]	; (8003cb0 <DisplayModuleStatus+0x208>)
 8003b96:	0030      	movs	r0, r6
 8003b98:	f010 ff60 	bl	8014a5c <sprintf>
		} else {
			sprintf(pcUserMessage,
					"\n\rStreaming DMA %d is streaming from P%d to P%d", i,
					GetPort(streamDMA[i - 1].Parent),
					GetPort(dmaStreamDst[i - 1]));
			strcat((char*) pcOutputString, pcUserMessage);
 8003b9c:	0031      	movs	r1, r6
 8003b9e:	0020      	movs	r0, r4
 8003ba0:	3501      	adds	r5, #1
 8003ba2:	f010 ff7b 	bl	8014a9c <strcat>
	for (char i = 1; i <= 6; i++) {
 8003ba6:	2d07      	cmp	r5, #7
 8003ba8:	d1e9      	bne.n	8003b7e <DisplayModuleStatus+0xd6>
		}
	}
	strcat((char*) pcOutputString, "\n\r");
 8003baa:	4942      	ldr	r1, [pc, #264]	; (8003cb4 <DisplayModuleStatus+0x20c>)
 8003bac:	0020      	movs	r0, r4
 8003bae:	f010 ff75 	bl	8014a9c <strcat>

	/* Ports direction */
	strcat((char*) pcOutputString, "\n\rThese ports are reversed: ");
 8003bb2:	4941      	ldr	r1, [pc, #260]	; (8003cb8 <DisplayModuleStatus+0x210>)
 8003bb4:	0020      	movs	r0, r4
 8003bb6:	f010 ff71 	bl	8014a9c <strcat>
	temp = strlen((char*) pcOutputString);
 8003bba:	0020      	movs	r0, r4
 8003bbc:	f7fc faac 	bl	8000118 <strlen>
 8003bc0:	2200      	movs	r2, #0
 8003bc2:	0005      	movs	r5, r0
	for (uint8_t p = 1; p <= NumOfPorts; p++) {
		if ((arrayPortsDir[myID - 1] & (0x8000 >> (p - 1)))) /* Port is reversed */
 8003bc4:	4b2b      	ldr	r3, [pc, #172]	; (8003c74 <DisplayModuleStatus+0x1cc>)
 8003bc6:	493d      	ldr	r1, [pc, #244]	; (8003cbc <DisplayModuleStatus+0x214>)
 8003bc8:	781b      	ldrb	r3, [r3, #0]
 8003bca:	1c56      	adds	r6, r2, #1
 8003bcc:	3b01      	subs	r3, #1
 8003bce:	005b      	lsls	r3, r3, #1
 8003bd0:	5a5b      	ldrh	r3, [r3, r1]
 8003bd2:	2180      	movs	r1, #128	; 0x80
 8003bd4:	0209      	lsls	r1, r1, #8
 8003bd6:	4111      	asrs	r1, r2
 8003bd8:	4219      	tst	r1, r3
 8003bda:	d009      	beq.n	8003bf0 <DisplayModuleStatus+0x148>
		{
			sprintf(pcUserMessage, "P%d ", p);
 8003bdc:	4f24      	ldr	r7, [pc, #144]	; (8003c70 <DisplayModuleStatus+0x1c8>)
 8003bde:	4938      	ldr	r1, [pc, #224]	; (8003cc0 <DisplayModuleStatus+0x218>)
 8003be0:	0032      	movs	r2, r6
 8003be2:	0038      	movs	r0, r7
 8003be4:	f010 ff3a 	bl	8014a5c <sprintf>
			strcat((char*) pcOutputString, pcUserMessage);
 8003be8:	0039      	movs	r1, r7
 8003bea:	0020      	movs	r0, r4
 8003bec:	f010 ff56 	bl	8014a9c <strcat>
 8003bf0:	0032      	movs	r2, r6
	for (uint8_t p = 1; p <= NumOfPorts; p++) {
 8003bf2:	2e05      	cmp	r6, #5
 8003bf4:	d1e6      	bne.n	8003bc4 <DisplayModuleStatus+0x11c>
		}
	}
	if (temp == strlen((char*) pcOutputString)) { /* All ports are normal */
 8003bf6:	0020      	movs	r0, r4
 8003bf8:	f7fc fa8e 	bl	8000118 <strlen>
 8003bfc:	b2ad      	uxth	r5, r5
 8003bfe:	42a8      	cmp	r0, r5
 8003c00:	d103      	bne.n	8003c0a <DisplayModuleStatus+0x162>
		strcat((char*) pcOutputString, "None");
 8003c02:	4930      	ldr	r1, [pc, #192]	; (8003cc4 <DisplayModuleStatus+0x21c>)
 8003c04:	0020      	movs	r0, r4
 8003c06:	f010 ff49 	bl	8014a9c <strcat>
	}
	strcat((char*) pcOutputString, "\n\r");
 8003c0a:	492a      	ldr	r1, [pc, #168]	; (8003cb4 <DisplayModuleStatus+0x20c>)
 8003c0c:	0020      	movs	r0, r4
 8003c0e:	f010 ff45 	bl	8014a9c <strcat>

	/* Display output */
	if (port)
 8003c12:	9b03      	ldr	r3, [sp, #12]
 8003c14:	2b00      	cmp	r3, #0
 8003c16:	d00b      	beq.n	8003c30 <DisplayModuleStatus+0x188>
		writePxMutex(port, (char*) pcOutputString,
				strlen((char*) pcOutputString), cmd50ms, HAL_MAX_DELAY);
 8003c18:	0020      	movs	r0, r4
 8003c1a:	f7fc fa7d 	bl	8000118 <strlen>
		writePxMutex(port, (char*) pcOutputString,
 8003c1e:	2301      	movs	r3, #1
 8003c20:	425b      	negs	r3, r3
 8003c22:	b282      	uxth	r2, r0
 8003c24:	9300      	str	r3, [sp, #0]
 8003c26:	0021      	movs	r1, r4
 8003c28:	3333      	adds	r3, #51	; 0x33
 8003c2a:	9803      	ldr	r0, [sp, #12]
 8003c2c:	f009 fbf4 	bl	800d418 <writePxMutex>

}
 8003c30:	b005      	add	sp, #20
 8003c32:	bdf0      	pop	{r4, r5, r6, r7, pc}
			sprintf(pcUserMessage, "Receiving messages\n\r");
 8003c34:	4924      	ldr	r1, [pc, #144]	; (8003cc8 <DisplayModuleStatus+0x220>)
 8003c36:	e78f      	b.n	8003b58 <DisplayModuleStatus+0xb0>
			sprintf(pcUserMessage, "Streaming\n\r");
 8003c38:	4924      	ldr	r1, [pc, #144]	; (8003ccc <DisplayModuleStatus+0x224>)
 8003c3a:	e78d      	b.n	8003b58 <DisplayModuleStatus+0xb0>
			sprintf(pcUserMessage, "Receiving user commands\n\r");
 8003c3c:	4924      	ldr	r1, [pc, #144]	; (8003cd0 <DisplayModuleStatus+0x228>)
 8003c3e:	e78b      	b.n	8003b58 <DisplayModuleStatus+0xb0>
			sprintf(pcUserMessage, "Connected to a button/switch\n\r");
 8003c40:	4924      	ldr	r1, [pc, #144]	; (8003cd4 <DisplayModuleStatus+0x22c>)
 8003c42:	e789      	b.n	8003b58 <DisplayModuleStatus+0xb0>
					GetPort(streamDMA[i - 1].Parent),
 8003c44:	3b14      	subs	r3, #20
 8003c46:	6818      	ldr	r0, [r3, #0]
 8003c48:	f005 ff06 	bl	8009a58 <GetPort>
					GetPort(dmaStreamDst[i - 1]));
 8003c4c:	4a22      	ldr	r2, [pc, #136]	; (8003cd8 <DisplayModuleStatus+0x230>)
 8003c4e:	00ab      	lsls	r3, r5, #2
 8003c50:	3b04      	subs	r3, #4
					GetPort(streamDMA[i - 1].Parent),
 8003c52:	0007      	movs	r7, r0
					GetPort(dmaStreamDst[i - 1]));
 8003c54:	58d0      	ldr	r0, [r2, r3]
 8003c56:	f005 feff 	bl	8009a58 <GetPort>
			sprintf(pcUserMessage,
 8003c5a:	4e05      	ldr	r6, [pc, #20]	; (8003c70 <DisplayModuleStatus+0x1c8>)
 8003c5c:	9000      	str	r0, [sp, #0]
 8003c5e:	003b      	movs	r3, r7
 8003c60:	002a      	movs	r2, r5
 8003c62:	491e      	ldr	r1, [pc, #120]	; (8003cdc <DisplayModuleStatus+0x234>)
 8003c64:	0030      	movs	r0, r6
 8003c66:	f010 fef9 	bl	8014a5c <sprintf>
 8003c6a:	e797      	b.n	8003b9c <DisplayModuleStatus+0xf4>
 8003c6c:	080192c5 	.word	0x080192c5
 8003c70:	20001062 	.word	0x20001062
 8003c74:	20001039 	.word	0x20001039
 8003c78:	080190c8 	.word	0x080190c8
 8003c7c:	20000a9f 	.word	0x20000a9f
 8003c80:	080190e4 	.word	0x080190e4
 8003c84:	08019100 	.word	0x08019100
 8003c88:	0801911d 	.word	0x0801911d
 8003c8c:	08019129 	.word	0x08019129
 8003c90:	08019140 	.word	0x08019140
 8003c94:	08019149 	.word	0x08019149
 8003c98:	08019162 	.word	0x08019162
 8003c9c:	08019175 	.word	0x08019175
 8003ca0:	200010b2 	.word	0x200010b2
 8003ca4:	0801917b 	.word	0x0801917b
 8003ca8:	080191dc 	.word	0x080191dc
 8003cac:	20001b38 	.word	0x20001b38
 8003cb0:	080191f4 	.word	0x080191f4
 8003cb4:	08019a5f 	.word	0x08019a5f
 8003cb8:	0801923f 	.word	0x0801923f
 8003cbc:	20007a44 	.word	0x20007a44
 8003cc0:	0801925c 	.word	0x0801925c
 8003cc4:	08019261 	.word	0x08019261
 8003cc8:	08019182 	.word	0x08019182
 8003ccc:	08019197 	.word	0x08019197
 8003cd0:	080191a3 	.word	0x080191a3
 8003cd4:	080191bd 	.word	0x080191bd
 8003cd8:	20001404 	.word	0x20001404
 8003cdc:	0801920f 	.word	0x0801920f

08003ce0 <GetID>:

/*-----------------------------------------------------------*/

/* --- Extract module ID from it's alias, ID string or keyword --- 
 */
int16_t GetID(char *string) {
 8003ce0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t id = 0, i = 0;

	if (!strcmp(string, "me")) /* Check keywords */
 8003ce2:	4928      	ldr	r1, [pc, #160]	; (8003d84 <GetID+0xa4>)
int16_t GetID(char *string) {
 8003ce4:	0005      	movs	r5, r0
	if (!strcmp(string, "me")) /* Check keywords */
 8003ce6:	f7fc fa0d 	bl	8000104 <strcmp>
 8003cea:	2800      	cmp	r0, #0
 8003cec:	d103      	bne.n	8003cf6 <GetID+0x16>
		return myID;
 8003cee:	4b26      	ldr	r3, [pc, #152]	; (8003d88 <GetID+0xa8>)
 8003cf0:	781c      	ldrb	r4, [r3, #0]
		}

		return BOS_ERR_WrongName;
	}

}
 8003cf2:	0020      	movs	r0, r4
 8003cf4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	else if (!strcmp(string, "all"))
 8003cf6:	4925      	ldr	r1, [pc, #148]	; (8003d8c <GetID+0xac>)
 8003cf8:	0028      	movs	r0, r5
 8003cfa:	f7fc fa03 	bl	8000104 <strcmp>
		return BOS_BROADCAST;
 8003cfe:	24ff      	movs	r4, #255	; 0xff
	else if (!strcmp(string, "all"))
 8003d00:	2800      	cmp	r0, #0
 8003d02:	d0f6      	beq.n	8003cf2 <GetID+0x12>
	else if (string[0] == '#') /* Check IDs */
 8003d04:	782f      	ldrb	r7, [r5, #0]
 8003d06:	2f23      	cmp	r7, #35	; 0x23
 8003d08:	d016      	beq.n	8003d38 <GetID+0x58>
		for (i = 0; i < N; i++) {
 8003d0a:	2600      	movs	r6, #0
 8003d0c:	4b20      	ldr	r3, [pc, #128]	; (8003d90 <GetID+0xb0>)
 8003d0e:	781b      	ldrb	r3, [r3, #0]
 8003d10:	9301      	str	r3, [sp, #4]
 8003d12:	9b01      	ldr	r3, [sp, #4]
 8003d14:	b2f4      	uxtb	r4, r6
 8003d16:	42a3      	cmp	r3, r4
 8003d18:	d820      	bhi.n	8003d5c <GetID+0x7c>
 8003d1a:	2400      	movs	r4, #0
			if (!strcmp(string, groupAlias[i]))
 8003d1c:	260a      	movs	r6, #10
 8003d1e:	4f1d      	ldr	r7, [pc, #116]	; (8003d94 <GetID+0xb4>)
 8003d20:	0031      	movs	r1, r6
 8003d22:	4361      	muls	r1, r4
 8003d24:	0028      	movs	r0, r5
 8003d26:	1879      	adds	r1, r7, r1
 8003d28:	f7fc f9ec 	bl	8000104 <strcmp>
 8003d2c:	2800      	cmp	r0, #0
 8003d2e:	d124      	bne.n	8003d7a <GetID+0x9a>
				return (BOS_MULTICAST | (i << 8));
 8003d30:	0220      	lsls	r0, r4, #8
 8003d32:	24fe      	movs	r4, #254	; 0xfe
 8003d34:	4304      	orrs	r4, r0
 8003d36:	e01c      	b.n	8003d72 <GetID+0x92>
		id = atol(string + 1);
 8003d38:	1c68      	adds	r0, r5, #1
 8003d3a:	f010 fa11 	bl	8014160 <atol>
 8003d3e:	b2c0      	uxtb	r0, r0
		if (id > 0 && id <= N)
 8003d40:	2800      	cmp	r0, #0
 8003d42:	d005      	beq.n	8003d50 <GetID+0x70>
 8003d44:	4b12      	ldr	r3, [pc, #72]	; (8003d90 <GetID+0xb0>)
 8003d46:	781b      	ldrb	r3, [r3, #0]
 8003d48:	4283      	cmp	r3, r0
 8003d4a:	d301      	bcc.n	8003d50 <GetID+0x70>
			return myID;
 8003d4c:	b204      	sxth	r4, r0
 8003d4e:	e7d0      	b.n	8003cf2 <GetID+0x12>
		else if (id == myID)
 8003d50:	4b0d      	ldr	r3, [pc, #52]	; (8003d88 <GetID+0xa8>)
			return BOS_ERR_WrongID;
 8003d52:	2466      	movs	r4, #102	; 0x66
		else if (id == myID)
 8003d54:	781b      	ldrb	r3, [r3, #0]
 8003d56:	4283      	cmp	r3, r0
 8003d58:	d0f8      	beq.n	8003d4c <GetID+0x6c>
 8003d5a:	e7ca      	b.n	8003cf2 <GetID+0x12>
			if (!strcmp(string, moduleAlias[i]) && (*string != 0))
 8003d5c:	210a      	movs	r1, #10
 8003d5e:	4371      	muls	r1, r6
 8003d60:	4b0d      	ldr	r3, [pc, #52]	; (8003d98 <GetID+0xb8>)
 8003d62:	0028      	movs	r0, r5
 8003d64:	18c9      	adds	r1, r1, r3
 8003d66:	f7fc f9cd 	bl	8000104 <strcmp>
 8003d6a:	2800      	cmp	r0, #0
 8003d6c:	d103      	bne.n	8003d76 <GetID+0x96>
 8003d6e:	2f00      	cmp	r7, #0
 8003d70:	d001      	beq.n	8003d76 <GetID+0x96>
				return (BOS_MULTICAST | (i << 8));
 8003d72:	b224      	sxth	r4, r4
 8003d74:	e7bd      	b.n	8003cf2 <GetID+0x12>
 8003d76:	3601      	adds	r6, #1
 8003d78:	e7cb      	b.n	8003d12 <GetID+0x32>
 8003d7a:	3401      	adds	r4, #1
		for (i = 0; i < MaxNumOfGroups; i++) {
 8003d7c:	2c0a      	cmp	r4, #10
 8003d7e:	d1cf      	bne.n	8003d20 <GetID+0x40>
		return BOS_ERR_WrongName;
 8003d80:	345a      	adds	r4, #90	; 0x5a
 8003d82:	e7b6      	b.n	8003cf2 <GetID+0x12>
 8003d84:	0801add5 	.word	0x0801add5
 8003d88:	20001039 	.word	0x20001039
 8003d8c:	080192de 	.word	0x080192de
 8003d90:	2000001c 	.word	0x2000001c
 8003d94:	20000e2f 	.word	0x20000e2f
 8003d98:	20000f35 	.word	0x20000f35

08003d9c <NameModule>:

/*-----------------------------------------------------------*/

/* --- Name a module with an alias --- 
 */
BOS_Status NameModule(uint8_t module, char *alias) {
 8003d9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003d9e:	000c      	movs	r4, r1
	static const CLI_Definition_List_Item_t *pxCommand = NULL;
	const int8_t *pcRegisteredCommandString;
	size_t xCommandStringLength;

	/* 1. Check module alias with keywords */
	for (i = 0; i < NumOfKeywords; i++) {
 8003da0:	2500      	movs	r5, #0
		if (!strcmp(alias, BOSkeywords[i]))
 8003da2:	4e29      	ldr	r6, [pc, #164]	; (8003e48 <NameModule+0xac>)
BOS_Status NameModule(uint8_t module, char *alias) {
 8003da4:	9001      	str	r0, [sp, #4]
		if (!strcmp(alias, BOSkeywords[i]))
 8003da6:	00a9      	lsls	r1, r5, #2
 8003da8:	1871      	adds	r1, r6, r1
 8003daa:	0020      	movs	r0, r4
 8003dac:	f7fc f9aa 	bl	8000104 <strcmp>
 8003db0:	2800      	cmp	r0, #0
 8003db2:	d042      	beq.n	8003e3a <NameModule+0x9e>
	for (i = 0; i < NumOfKeywords; i++) {
 8003db4:	3501      	adds	r5, #1
 8003db6:	2d04      	cmp	r5, #4
 8003db8:	d1f5      	bne.n	8003da6 <NameModule+0xa>
			return BOS_ERR_Keyword;
	}

	/* 2. Check module alias with other module aliases */
	for (i = 1; i < N; i++) {
		if (!strcmp(alias, moduleAlias[i]))
 8003dba:	270a      	movs	r7, #10
	for (i = 1; i < N; i++) {
 8003dbc:	4b23      	ldr	r3, [pc, #140]	; (8003e4c <NameModule+0xb0>)
		if (!strcmp(alias, moduleAlias[i]))
 8003dbe:	4e24      	ldr	r6, [pc, #144]	; (8003e50 <NameModule+0xb4>)
	for (i = 1; i < N; i++) {
 8003dc0:	781b      	ldrb	r3, [r3, #0]
 8003dc2:	3d03      	subs	r5, #3
 8003dc4:	9300      	str	r3, [sp, #0]
 8003dc6:	9b00      	ldr	r3, [sp, #0]
 8003dc8:	42ab      	cmp	r3, r5
 8003dca:	dc1e      	bgt.n	8003e0a <NameModule+0x6e>
			return BOS_ERR_ExistingAlias;
	}

	/* 3. Check module alias with group aliases */
	for (i = 0; i < MaxNumOfGroups; i++) {
 8003dcc:	2500      	movs	r5, #0
		if (!strcmp(alias, groupAlias[i]))
 8003dce:	270a      	movs	r7, #10
 8003dd0:	4e20      	ldr	r6, [pc, #128]	; (8003e54 <NameModule+0xb8>)
 8003dd2:	0039      	movs	r1, r7
 8003dd4:	4369      	muls	r1, r5
 8003dd6:	0020      	movs	r0, r4
 8003dd8:	1871      	adds	r1, r6, r1
 8003dda:	f7fc f993 	bl	8000104 <strcmp>
 8003dde:	2800      	cmp	r0, #0
 8003de0:	d02d      	beq.n	8003e3e <NameModule+0xa2>
	for (i = 0; i < MaxNumOfGroups; i++) {
 8003de2:	3501      	adds	r5, #1
 8003de4:	2d0a      	cmp	r5, #10
 8003de6:	d1f4      	bne.n	8003dd2 <NameModule+0x36>
			return BOS_ERR_ExistingAlias;
	}

	/* 4. Check alias with BOS and module commands */
	for (pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand =
 8003de8:	4e1b      	ldr	r6, [pc, #108]	; (8003e58 <NameModule+0xbc>)
 8003dea:	4b1c      	ldr	r3, [pc, #112]	; (8003e5c <NameModule+0xc0>)
 8003dec:	6033      	str	r3, [r6, #0]
 8003dee:	6835      	ldr	r5, [r6, #0]
 8003df0:	2d00      	cmp	r5, #0
 8003df2:	d114      	bne.n	8003e1e <NameModule+0x82>
			return BOS_ERR_ExistingCmd;
		}
	}

	/* 5. Module alias is unique */
	strcpy(moduleAlias[module], alias);
 8003df4:	200a      	movs	r0, #10
 8003df6:	9b01      	ldr	r3, [sp, #4]
 8003df8:	0021      	movs	r1, r4
 8003dfa:	4358      	muls	r0, r3
 8003dfc:	4b14      	ldr	r3, [pc, #80]	; (8003e50 <NameModule+0xb4>)
 8003dfe:	18c0      	adds	r0, r0, r3
 8003e00:	f010 fe68 	bl	8014ad4 <strcpy>

	/* 6. Share new module alias with other modules */

	/* 7. Save new alias to emulated EEPROM */
	result = SaveEEalias();
 8003e04:	f7ff f81c 	bl	8002e40 <SaveEEalias>

	return result;
}
 8003e08:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (!strcmp(alias, moduleAlias[i]))
 8003e0a:	0039      	movs	r1, r7
 8003e0c:	4369      	muls	r1, r5
 8003e0e:	0020      	movs	r0, r4
 8003e10:	1989      	adds	r1, r1, r6
 8003e12:	f7fc f977 	bl	8000104 <strcmp>
 8003e16:	2800      	cmp	r0, #0
 8003e18:	d011      	beq.n	8003e3e <NameModule+0xa2>
	for (i = 1; i < N; i++) {
 8003e1a:	3501      	adds	r5, #1
 8003e1c:	e7d3      	b.n	8003dc6 <NameModule+0x2a>
		pcRegisteredCommandString =
 8003e1e:	682b      	ldr	r3, [r5, #0]
 8003e20:	681f      	ldr	r7, [r3, #0]
		xCommandStringLength = strlen((const char*) pcRegisteredCommandString);
 8003e22:	0038      	movs	r0, r7
 8003e24:	f7fc f978 	bl	8000118 <strlen>
		if (!strncmp(alias, (const char*) pcRegisteredCommandString,
 8003e28:	0039      	movs	r1, r7
		xCommandStringLength = strlen((const char*) pcRegisteredCommandString);
 8003e2a:	0002      	movs	r2, r0
		if (!strncmp(alias, (const char*) pcRegisteredCommandString,
 8003e2c:	0020      	movs	r0, r4
 8003e2e:	f010 fe59 	bl	8014ae4 <strncmp>
 8003e32:	2800      	cmp	r0, #0
 8003e34:	d005      	beq.n	8003e42 <NameModule+0xa6>
	for (pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand =
 8003e36:	686b      	ldr	r3, [r5, #4]
 8003e38:	e7d8      	b.n	8003dec <NameModule+0x50>
			return BOS_ERR_Keyword;
 8003e3a:	2006      	movs	r0, #6
 8003e3c:	e7e4      	b.n	8003e08 <NameModule+0x6c>
			return BOS_ERR_ExistingAlias;
 8003e3e:	2007      	movs	r0, #7
 8003e40:	e7e2      	b.n	8003e08 <NameModule+0x6c>
			return BOS_ERR_ExistingCmd;
 8003e42:	2008      	movs	r0, #8
 8003e44:	e7e0      	b.n	8003e08 <NameModule+0x6c>
 8003e46:	46c0      	nop			; (mov r8, r8)
 8003e48:	080190b8 	.word	0x080190b8
 8003e4c:	2000001c 	.word	0x2000001c
 8003e50:	20000f35 	.word	0x20000f35
 8003e54:	20000e2f 	.word	0x20000e2f
 8003e58:	200010b8 	.word	0x200010b8
 8003e5c:	200000c0 	.word	0x200000c0

08003e60 <AddModuleToGroup>:

/*-----------------------------------------------------------*/

/* --- Add a module to this group --- 
 */
BOS_Status AddModuleToGroup(uint8_t module, char *group) {
 8003e60:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003e62:	000d      	movs	r5, r1
	const int8_t *pcRegisteredCommandString;
	size_t xCommandStringLength;

	/* Check alias with other group aliases */

	for (i = 0; i < MaxNumOfGroups; i++) {
 8003e64:	2400      	movs	r4, #0
		/* This group already exists */
		if (!strcmp(group, groupAlias[i])) {
 8003e66:	260a      	movs	r6, #10
BOS_Status AddModuleToGroup(uint8_t module, char *group) {
 8003e68:	9000      	str	r0, [sp, #0]
		if (!strcmp(group, groupAlias[i])) {
 8003e6a:	0031      	movs	r1, r6
 8003e6c:	4361      	muls	r1, r4
 8003e6e:	4b34      	ldr	r3, [pc, #208]	; (8003f40 <AddModuleToGroup+0xe0>)
 8003e70:	0028      	movs	r0, r5
 8003e72:	1859      	adds	r1, r3, r1
 8003e74:	f7fc f946 	bl	8000104 <strcmp>
 8003e78:	2800      	cmp	r0, #0
 8003e7a:	d109      	bne.n	8003e90 <AddModuleToGroup+0x30>
			/* 1. Add this module to the group */
			groupModules[module - 1] |= (0x0001 << i);
 8003e7c:	2101      	movs	r1, #1
 8003e7e:	40a1      	lsls	r1, r4
 8003e80:	9b00      	ldr	r3, [sp, #0]
 8003e82:	4d30      	ldr	r5, [pc, #192]	; (8003f44 <AddModuleToGroup+0xe4>)
 8003e84:	3b01      	subs	r3, #1
 8003e86:	005b      	lsls	r3, r3, #1
 8003e88:	5b5a      	ldrh	r2, [r3, r5]
 8003e8a:	430a      	orrs	r2, r1
 8003e8c:	535a      	strh	r2, [r3, r5]
	/* 6. Share new group with other modules */

	/* 7. Save new group to emulated EEPROM - Should call this manually */
	//result = SaveEEgroup();			
	return result;
}
 8003e8e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	for (i = 0; i < MaxNumOfGroups; i++) {
 8003e90:	3401      	adds	r4, #1
 8003e92:	2c0a      	cmp	r4, #10
 8003e94:	d1e9      	bne.n	8003e6a <AddModuleToGroup+0xa>
	for (j = 0; j < NumOfKeywords; j++) {
 8003e96:	2400      	movs	r4, #0
		if (!strcmp(group, BOSkeywords[j]))
 8003e98:	4e2b      	ldr	r6, [pc, #172]	; (8003f48 <AddModuleToGroup+0xe8>)
 8003e9a:	00a1      	lsls	r1, r4, #2
 8003e9c:	1871      	adds	r1, r6, r1
 8003e9e:	0028      	movs	r0, r5
 8003ea0:	f7fc f930 	bl	8000104 <strcmp>
 8003ea4:	2800      	cmp	r0, #0
 8003ea6:	d044      	beq.n	8003f32 <AddModuleToGroup+0xd2>
	for (j = 0; j < NumOfKeywords; j++) {
 8003ea8:	3401      	adds	r4, #1
 8003eaa:	2c04      	cmp	r4, #4
 8003eac:	d1f5      	bne.n	8003e9a <AddModuleToGroup+0x3a>
		if (!strcmp(group, moduleAlias[j]))
 8003eae:	270a      	movs	r7, #10
	for (j = 1; j < N; j++) {
 8003eb0:	4b26      	ldr	r3, [pc, #152]	; (8003f4c <AddModuleToGroup+0xec>)
		if (!strcmp(group, moduleAlias[j]))
 8003eb2:	4e27      	ldr	r6, [pc, #156]	; (8003f50 <AddModuleToGroup+0xf0>)
	for (j = 1; j < N; j++) {
 8003eb4:	781b      	ldrb	r3, [r3, #0]
 8003eb6:	3c03      	subs	r4, #3
 8003eb8:	9301      	str	r3, [sp, #4]
 8003eba:	9b01      	ldr	r3, [sp, #4]
 8003ebc:	42a3      	cmp	r3, r4
 8003ebe:	dc1c      	bgt.n	8003efa <AddModuleToGroup+0x9a>
	for (pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand =
 8003ec0:	4e24      	ldr	r6, [pc, #144]	; (8003f54 <AddModuleToGroup+0xf4>)
 8003ec2:	4b25      	ldr	r3, [pc, #148]	; (8003f58 <AddModuleToGroup+0xf8>)
 8003ec4:	6033      	str	r3, [r6, #0]
 8003ec6:	6834      	ldr	r4, [r6, #0]
 8003ec8:	2c00      	cmp	r4, #0
 8003eca:	d120      	bne.n	8003f0e <AddModuleToGroup+0xae>
 8003ecc:	230a      	movs	r3, #10
 8003ece:	0018      	movs	r0, r3
 8003ed0:	4360      	muls	r0, r4
		if (!groupAlias[i][0]) {
 8003ed2:	4a1b      	ldr	r2, [pc, #108]	; (8003f40 <AddModuleToGroup+0xe0>)
 8003ed4:	5c12      	ldrb	r2, [r2, r0]
 8003ed6:	2a00      	cmp	r2, #0
 8003ed8:	d127      	bne.n	8003f2a <AddModuleToGroup+0xca>
			strcpy(groupAlias[i], group);
 8003eda:	4b19      	ldr	r3, [pc, #100]	; (8003f40 <AddModuleToGroup+0xe0>)
 8003edc:	0029      	movs	r1, r5
 8003ede:	1818      	adds	r0, r3, r0
 8003ee0:	f010 fdf8 	bl	8014ad4 <strcpy>
	groupModules[module - 1] |= (0x0001 << i);
 8003ee4:	2101      	movs	r1, #1
 8003ee6:	40a1      	lsls	r1, r4
 8003ee8:	9b00      	ldr	r3, [sp, #0]
 8003eea:	4816      	ldr	r0, [pc, #88]	; (8003f44 <AddModuleToGroup+0xe4>)
 8003eec:	3b01      	subs	r3, #1
 8003eee:	005b      	lsls	r3, r3, #1
 8003ef0:	5a1a      	ldrh	r2, [r3, r0]
 8003ef2:	430a      	orrs	r2, r1
 8003ef4:	521a      	strh	r2, [r3, r0]
	return result;
 8003ef6:	2000      	movs	r0, #0
 8003ef8:	e7c9      	b.n	8003e8e <AddModuleToGroup+0x2e>
		if (!strcmp(group, moduleAlias[j]))
 8003efa:	0039      	movs	r1, r7
 8003efc:	4361      	muls	r1, r4
 8003efe:	0028      	movs	r0, r5
 8003f00:	1989      	adds	r1, r1, r6
 8003f02:	f7fc f8ff 	bl	8000104 <strcmp>
 8003f06:	2800      	cmp	r0, #0
 8003f08:	d015      	beq.n	8003f36 <AddModuleToGroup+0xd6>
	for (j = 1; j < N; j++) {
 8003f0a:	3401      	adds	r4, #1
 8003f0c:	e7d5      	b.n	8003eba <AddModuleToGroup+0x5a>
		pcRegisteredCommandString =
 8003f0e:	6823      	ldr	r3, [r4, #0]
 8003f10:	681f      	ldr	r7, [r3, #0]
		xCommandStringLength = strlen((const char*) pcRegisteredCommandString);
 8003f12:	0038      	movs	r0, r7
 8003f14:	f7fc f900 	bl	8000118 <strlen>
		if (!strncmp(group, (const char*) pcRegisteredCommandString,
 8003f18:	0039      	movs	r1, r7
		xCommandStringLength = strlen((const char*) pcRegisteredCommandString);
 8003f1a:	0002      	movs	r2, r0
		if (!strncmp(group, (const char*) pcRegisteredCommandString,
 8003f1c:	0028      	movs	r0, r5
 8003f1e:	f010 fde1 	bl	8014ae4 <strncmp>
 8003f22:	2800      	cmp	r0, #0
 8003f24:	d009      	beq.n	8003f3a <AddModuleToGroup+0xda>
	for (pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand =
 8003f26:	6863      	ldr	r3, [r4, #4]
 8003f28:	e7cc      	b.n	8003ec4 <AddModuleToGroup+0x64>
	for (i = 0; i < MaxNumOfGroups; i++) {
 8003f2a:	3401      	adds	r4, #1
 8003f2c:	2c0a      	cmp	r4, #10
 8003f2e:	d1ce      	bne.n	8003ece <AddModuleToGroup+0x6e>
 8003f30:	e7d8      	b.n	8003ee4 <AddModuleToGroup+0x84>
			return BOS_ERR_Keyword;
 8003f32:	2006      	movs	r0, #6
 8003f34:	e7ab      	b.n	8003e8e <AddModuleToGroup+0x2e>
			return BOS_ERR_ExistingAlias;
 8003f36:	2007      	movs	r0, #7
 8003f38:	e7a9      	b.n	8003e8e <AddModuleToGroup+0x2e>
			return BOS_ERR_ExistingCmd;
 8003f3a:	2008      	movs	r0, #8
 8003f3c:	e7a7      	b.n	8003e8e <AddModuleToGroup+0x2e>
 8003f3e:	46c0      	nop			; (mov r8, r8)
 8003f40:	20000e2f 	.word	0x20000e2f
 8003f44:	20000e94 	.word	0x20000e94
 8003f48:	080190b8 	.word	0x080190b8
 8003f4c:	2000001c 	.word	0x2000001c
 8003f50:	20000f35 	.word	0x20000f35
 8003f54:	200010bc 	.word	0x200010bc
 8003f58:	200000c0 	.word	0x200000c0

08003f5c <ReadPortsDir>:

/*-----------------------------------------------------------*/

/* --- Read Ports directions when a pre-defined topology file is used --- 
 */
BOS_Status ReadPortsDir(void) {
 8003f5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;

	/* Ask all other modules for their ports directions */
	for (uint8_t i = 1; i <= N; i++) {
 8003f5e:	2401      	movs	r4, #1
	BOS_Status result = BOS_OK;
 8003f60:	2600      	movs	r6, #0
	for (uint8_t i = 1; i <= N; i++) {
 8003f62:	4b19      	ldr	r3, [pc, #100]	; (8003fc8 <ReadPortsDir+0x6c>)
 8003f64:	781b      	ldrb	r3, [r3, #0]
 8003f66:	42a3      	cmp	r3, r4
 8003f68:	d201      	bcs.n	8003f6e <ReadPortsDir+0x12>
			}
		}
	}

	return result;
}
 8003f6a:	0030      	movs	r0, r6
 8003f6c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (i != myID) {
 8003f6e:	4f17      	ldr	r7, [pc, #92]	; (8003fcc <ReadPortsDir+0x70>)
 8003f70:	783b      	ldrb	r3, [r7, #0]
 8003f72:	42a3      	cmp	r3, r4
 8003f74:	d00f      	beq.n	8003f96 <ReadPortsDir+0x3a>
			SendMessageToModule(i, CODE_READ_PORT_DIR, 0);
 8003f76:	2200      	movs	r2, #0
 8003f78:	2113      	movs	r1, #19
 8003f7a:	0020      	movs	r0, r4
 8003f7c:	f003 ffd6 	bl	8007f2c <SendMessageToModule>
			Delay_ms_no_rtos(50);
 8003f80:	2032      	movs	r0, #50	; 0x32
 8003f82:	f009 f8d3 	bl	800d12c <StartMilliDelay>
			if (responseStatus != BOS_OK) {
 8003f86:	4b12      	ldr	r3, [pc, #72]	; (8003fd0 <ReadPortsDir+0x74>)
 8003f88:	781b      	ldrb	r3, [r3, #0]
 8003f8a:	2b00      	cmp	r3, #0
 8003f8c:	d000      	beq.n	8003f90 <ReadPortsDir+0x34>
				result = BOS_ERR_NoResponse;
 8003f8e:	2602      	movs	r6, #2
	for (uint8_t i = 1; i <= N; i++) {
 8003f90:	3401      	adds	r4, #1
 8003f92:	b2e4      	uxtb	r4, r4
 8003f94:	e7e5      	b.n	8003f62 <ReadPortsDir+0x6>
 8003f96:	2500      	movs	r5, #0
				if (GetUart(p)->AdvancedInit.Swap == UART_ADVFEATURE_SWAP_ENABLE) {
 8003f98:	1c6b      	adds	r3, r5, #1
 8003f9a:	9301      	str	r3, [sp, #4]
 8003f9c:	466b      	mov	r3, sp
 8003f9e:	7918      	ldrb	r0, [r3, #4]
 8003fa0:	f009 fa2e 	bl	800d400 <GetUart>
 8003fa4:	2280      	movs	r2, #128	; 0x80
 8003fa6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003fa8:	0212      	lsls	r2, r2, #8
 8003faa:	4293      	cmp	r3, r2
 8003fac:	d108      	bne.n	8003fc0 <ReadPortsDir+0x64>
					arrayPortsDir[myID - 1] |= (0x8000 >> (p - 1)); /* Set bit to 1 */
 8003fae:	0010      	movs	r0, r2
 8003fb0:	4128      	asrs	r0, r5
 8003fb2:	783b      	ldrb	r3, [r7, #0]
 8003fb4:	4907      	ldr	r1, [pc, #28]	; (8003fd4 <ReadPortsDir+0x78>)
 8003fb6:	3b01      	subs	r3, #1
 8003fb8:	005b      	lsls	r3, r3, #1
 8003fba:	5a5a      	ldrh	r2, [r3, r1]
 8003fbc:	4302      	orrs	r2, r0
 8003fbe:	525a      	strh	r2, [r3, r1]
 8003fc0:	9d01      	ldr	r5, [sp, #4]
			for (uint8_t p = 1; p <= NumOfPorts; p++) {
 8003fc2:	2d05      	cmp	r5, #5
 8003fc4:	d1e8      	bne.n	8003f98 <ReadPortsDir+0x3c>
 8003fc6:	e7e3      	b.n	8003f90 <ReadPortsDir+0x34>
 8003fc8:	2000001c 	.word	0x2000001c
 8003fcc:	20001039 	.word	0x20001039
 8003fd0:	200010c8 	.word	0x200010c8
 8003fd4:	20007a44 	.word	0x20007a44

08003fd8 <UpdateMyPortsDir>:
/*-----------------------------------------------------------*/
#ifndef __N
/* --- Update module port directions based on what is stored in eeprom --- 
*/
BOS_Status UpdateMyPortsDir(void)
{
 8003fd8:	b570      	push	{r4, r5, r6, lr}
	BOS_Status result = BOS_OK;
	
	/* Check port direction */
	for (uint8_t p=1 ; p<=NumOfPorts ; p++) 
	{
		if ( !(arrayPortsDir[myID-1] & (0x8000>>(p-1))) ) {
 8003fda:	2580      	movs	r5, #128	; 0x80
{
 8003fdc:	2200      	movs	r2, #0
		if ( !(arrayPortsDir[myID-1] & (0x8000>>(p-1))) ) {
 8003fde:	022d      	lsls	r5, r5, #8
 8003fe0:	002e      	movs	r6, r5
 8003fe2:	4116      	asrs	r6, r2
 8003fe4:	4b0b      	ldr	r3, [pc, #44]	; (8004014 <UpdateMyPortsDir+0x3c>)
 8003fe6:	490c      	ldr	r1, [pc, #48]	; (8004018 <UpdateMyPortsDir+0x40>)
 8003fe8:	781b      	ldrb	r3, [r3, #0]
 8003fea:	1c54      	adds	r4, r2, #1
 8003fec:	3b01      	subs	r3, #1
 8003fee:	005b      	lsls	r3, r3, #1
 8003ff0:	5a5b      	ldrh	r3, [r3, r1]
 8003ff2:	b2e0      	uxtb	r0, r4
 8003ff4:	401e      	ands	r6, r3
 8003ff6:	d109      	bne.n	800400c <UpdateMyPortsDir+0x34>
			/* Port is normal */
			SwapUartPins(GetUart(p), NORMAL);
 8003ff8:	f009 fa02 	bl	800d400 <GetUart>
 8003ffc:	0031      	movs	r1, r6
		} else {
			/* Port is reversed */
			SwapUartPins(GetUart(p), REVERSED);					
 8003ffe:	f009 fa75 	bl	800d4ec <SwapUartPins>
 8004002:	0022      	movs	r2, r4
	for (uint8_t p=1 ; p<=NumOfPorts ; p++) 
 8004004:	2c05      	cmp	r4, #5
 8004006:	d1eb      	bne.n	8003fe0 <UpdateMyPortsDir+0x8>
		}	
	}		
	
	return result;
}
 8004008:	2000      	movs	r0, #0
 800400a:	bd70      	pop	{r4, r5, r6, pc}
			SwapUartPins(GetUart(p), REVERSED);					
 800400c:	f009 f9f8 	bl	800d400 <GetUart>
 8004010:	2101      	movs	r1, #1
 8004012:	e7f4      	b.n	8003ffe <UpdateMyPortsDir+0x26>
 8004014:	20001039 	.word	0x20001039
 8004018:	20007a44 	.word	0x20007a44

0800401c <BOS_Init>:
void BOS_Init(void) {
 800401c:	b570      	push	{r4, r5, r6, lr}
	RTC_Init();
 800401e:	f008 fa29 	bl	800c474 <RTC_Init>
	GetTimeDate();
 8004022:	f008 fab5 	bl	800c590 <GetTimeDate>
	EE_Init();
 8004026:	f002 fdc9 	bl	8006bbc <EE_Init>
	GPIO_Init();
 800402a:	f007 ffcd 	bl	800bfc8 <GPIO_Init>
	DMA_Init();
 800402e:	f007 f94d 	bl	800b2cc <DMA_Init>
	TIM_USEC_Init();
 8004032:	f009 f807 	bl	800d044 <TIM_USEC_Init>
	CRC_Init();
 8004036:	f007 ff77 	bl	800bf28 <CRC_Init>
	TIM_MSEC_Init();
 800403a:	f009 f835 	bl	800d0a8 <TIM_MSEC_Init>
	if (IsFactoryReset()) {
 800403e:	f008 f849 	bl	800c0d4 <IsFactoryReset>
 8004042:	2800      	cmp	r0, #0
 8004044:	d00a      	beq.n	800405c <BOS_Init+0x40>
		EE_FormatForFactoryReset();
 8004046:	f7ff f9e9 	bl	800341c <EE_FormatForFactoryReset>
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800404a:	f3bf 8f4f 	dsb	sy
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800404e:	4b37      	ldr	r3, [pc, #220]	; (800412c <BOS_Init+0x110>)
 8004050:	4a37      	ldr	r2, [pc, #220]	; (8004130 <BOS_Init+0x114>)
 8004052:	60da      	str	r2, [r3, #12]
 8004054:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8004058:	46c0      	nop			; (mov r8, r8)
 800405a:	e7fd      	b.n	8004058 <BOS_Init+0x3c>
	if (IsLowerCLIbaud()) {
 800405c:	f7ff f994 	bl	8003388 <IsLowerCLIbaud>
 8004060:	2800      	cmp	r0, #0
 8004062:	d033      	beq.n	80040cc <BOS_Init+0xb0>
		CLI_LOW_Baudrate_Flag = 1;
 8004064:	2401      	movs	r4, #1
 8004066:	4b33      	ldr	r3, [pc, #204]	; (8004134 <BOS_Init+0x118>)
		Delay_ms_no_rtos(50);// Give other modules time to finish factory reset and baudrate check
 8004068:	2032      	movs	r0, #50	; 0x32
		CLI_LOW_Baudrate_Flag = 1;
 800406a:	701c      	strb	r4, [r3, #0]
		Delay_ms_no_rtos(50);// Give other modules time to finish factory reset and baudrate check
 800406c:	f009 f85e 	bl	800d12c <StartMilliDelay>
		Module_Init();
 8004070:	f005 fc42 	bl	80098f8 <Module_Init>
		BOS.clibaudrate = CLI_BAUDRATE_1;
 8004074:	23e1      	movs	r3, #225	; 0xe1
 8004076:	4d30      	ldr	r5, [pc, #192]	; (8004138 <BOS_Init+0x11c>)
 8004078:	025b      	lsls	r3, r3, #9
 800407a:	60ab      	str	r3, [r5, #8]
			UpdateBaudrate(port, BOS.clibaudrate);
 800407c:	0020      	movs	r0, r4
		for (uint8_t port = 1; port <= NumOfPorts; port++) {
 800407e:	3401      	adds	r4, #1
			UpdateBaudrate(port, BOS.clibaudrate);
 8004080:	68a9      	ldr	r1, [r5, #8]
		for (uint8_t port = 1; port <= NumOfPorts; port++) {
 8004082:	b2e4      	uxtb	r4, r4
			UpdateBaudrate(port, BOS.clibaudrate);
 8004084:	f009 fa28 	bl	800d4d8 <UpdateBaudrate>
		for (uint8_t port = 1; port <= NumOfPorts; port++) {
 8004088:	2c06      	cmp	r4, #6
 800408a:	d1f7      	bne.n	800407c <BOS_Init+0x60>
	LoadEEvars();
 800408c:	f7ff f96c 	bl	8003368 <LoadEEvars>
	UpdateMyPortsDir();
 8004090:	f7ff ffa2 	bl	8003fd8 <UpdateMyPortsDir>
	SetupMessagingRxDMAs();
 8004094:	f007 fc86 	bl	800b9a4 <SetupMessagingRxDMAs>
		IND_ON();
 8004098:	2180      	movs	r1, #128	; 0x80
	if (myID == 0) /* Native module */
 800409a:	4b28      	ldr	r3, [pc, #160]	; (800413c <BOS_Init+0x120>)
		IND_ON();
 800409c:	2201      	movs	r2, #1
	if (myID == 0) /* Native module */
 800409e:	781c      	ldrb	r4, [r3, #0]
		IND_ON();
 80040a0:	01c9      	lsls	r1, r1, #7
 80040a2:	4827      	ldr	r0, [pc, #156]	; (8004140 <BOS_Init+0x124>)
	if (myID == 0) /* Native module */
 80040a4:	2c00      	cmp	r4, #0
 80040a6:	d117      	bne.n	80040d8 <BOS_Init+0xbc>
		IND_ON();
 80040a8:	f00e f93a 	bl	8012320 <HAL_GPIO_WritePin>
		Delay_ms_no_rtos(500);IND_OFF();
 80040ac:	20fa      	movs	r0, #250	; 0xfa
 80040ae:	0040      	lsls	r0, r0, #1
		Delay_ms_no_rtos(100);IND_OFF();
 80040b0:	f009 f83c 	bl	800d12c <StartMilliDelay>
 80040b4:	2180      	movs	r1, #128	; 0x80
 80040b6:	2200      	movs	r2, #0
 80040b8:	01c9      	lsls	r1, r1, #7
 80040ba:	4821      	ldr	r0, [pc, #132]	; (8004140 <BOS_Init+0x124>)
 80040bc:	f00e f930 	bl	8012320 <HAL_GPIO_WritePin>
	ResetUartORE();
 80040c0:	f002 fbf6 	bl	80068b0 <ResetUartORE>
	BOS_initialized = 1;
 80040c4:	2201      	movs	r2, #1
 80040c6:	4b1f      	ldr	r3, [pc, #124]	; (8004144 <BOS_Init+0x128>)
 80040c8:	701a      	strb	r2, [r3, #0]
}
 80040ca:	bd70      	pop	{r4, r5, r6, pc}
		Delay_ms_no_rtos(50);// Give other modules time to finish factory reset and baudrate check
 80040cc:	2032      	movs	r0, #50	; 0x32
 80040ce:	f009 f82d 	bl	800d12c <StartMilliDelay>
		Module_Init();
 80040d2:	f005 fc11 	bl	80098f8 <Module_Init>
 80040d6:	e7d9      	b.n	800408c <BOS_Init+0x70>
		IND_ON();
 80040d8:	f00e f922 	bl	8012320 <HAL_GPIO_WritePin>
		Delay_ms_no_rtos(500);
 80040dc:	20fa      	movs	r0, #250	; 0xfa
 80040de:	0040      	lsls	r0, r0, #1
 80040e0:	f009 f824 	bl	800d12c <StartMilliDelay>
		IND_OFF();
 80040e4:	2180      	movs	r1, #128	; 0x80
 80040e6:	2200      	movs	r2, #0
 80040e8:	01c9      	lsls	r1, r1, #7
 80040ea:	4815      	ldr	r0, [pc, #84]	; (8004140 <BOS_Init+0x124>)
 80040ec:	f00e f918 	bl	8012320 <HAL_GPIO_WritePin>
		Delay_ms_no_rtos(100);
 80040f0:	2064      	movs	r0, #100	; 0x64
 80040f2:	f009 f81b 	bl	800d12c <StartMilliDelay>
		IND_ON();
 80040f6:	2180      	movs	r1, #128	; 0x80
 80040f8:	2201      	movs	r2, #1
 80040fa:	01c9      	lsls	r1, r1, #7
 80040fc:	4810      	ldr	r0, [pc, #64]	; (8004140 <BOS_Init+0x124>)
 80040fe:	f00e f90f 	bl	8012320 <HAL_GPIO_WritePin>
		Delay_ms_no_rtos(100);
 8004102:	2064      	movs	r0, #100	; 0x64
 8004104:	f009 f812 	bl	800d12c <StartMilliDelay>
		IND_OFF();
 8004108:	2180      	movs	r1, #128	; 0x80
 800410a:	2200      	movs	r2, #0
 800410c:	01c9      	lsls	r1, r1, #7
 800410e:	480c      	ldr	r0, [pc, #48]	; (8004140 <BOS_Init+0x124>)
 8004110:	f00e f906 	bl	8012320 <HAL_GPIO_WritePin>
		Delay_ms_no_rtos(100);
 8004114:	2064      	movs	r0, #100	; 0x64
 8004116:	f009 f809 	bl	800d12c <StartMilliDelay>
		IND_ON();
 800411a:	2180      	movs	r1, #128	; 0x80
 800411c:	4808      	ldr	r0, [pc, #32]	; (8004140 <BOS_Init+0x124>)
 800411e:	2201      	movs	r2, #1
 8004120:	01c9      	lsls	r1, r1, #7
 8004122:	f00e f8fd 	bl	8012320 <HAL_GPIO_WritePin>
		Delay_ms_no_rtos(100);IND_OFF();
 8004126:	2064      	movs	r0, #100	; 0x64
 8004128:	e7c2      	b.n	80040b0 <BOS_Init+0x94>
 800412a:	46c0      	nop			; (mov r8, r8)
 800412c:	e000ed00 	.word	0xe000ed00
 8004130:	05fa0004 	.word	0x05fa0004
 8004134:	20000a9e 	.word	0x20000a9e
 8004138:	20006f70 	.word	0x20006f70
 800413c:	20001039 	.word	0x20001039
 8004140:	48000400 	.word	0x48000400
 8004144:	20000a9d 	.word	0x20000a9d

08004148 <GetDateString>:

/*-----------------------------------------------------------*/

/* --- Make a data string with format weekday / month / date / year 
 */
char* GetDateString(void) {
 8004148:	b513      	push	{r0, r1, r4, lr}
	static const char formatDateStr[] = "%s %02d/%02d/%04d";
	char *buffer = malloc(30 * sizeof(int8_t));
 800414a:	201e      	movs	r0, #30
 800414c:	f010 f844 	bl	80141d8 <malloc>
 8004150:	0004      	movs	r4, r0
	memset(buffer, 0x00, 30 * sizeof(int8_t));
 8004152:	221e      	movs	r2, #30
 8004154:	2100      	movs	r1, #0
 8004156:	f010 fa86 	bl	8014666 <memset>
	sprintf(buffer, formatDateStr, weekdayString[BOS.date.weekday - 1],
			BOS.date.month, BOS.date.day, BOS.date.year);
 800415a:	4908      	ldr	r1, [pc, #32]	; (800417c <GetDateString+0x34>)
	sprintf(buffer, formatDateStr, weekdayString[BOS.date.weekday - 1],
 800415c:	8b08      	ldrh	r0, [r1, #24]
 800415e:	7d8b      	ldrb	r3, [r1, #22]
 8004160:	7d0a      	ldrb	r2, [r1, #20]
 8004162:	9001      	str	r0, [sp, #4]
 8004164:	7d49      	ldrb	r1, [r1, #21]
 8004166:	3a01      	subs	r2, #1
 8004168:	9100      	str	r1, [sp, #0]
 800416a:	4905      	ldr	r1, [pc, #20]	; (8004180 <GetDateString+0x38>)
 800416c:	0092      	lsls	r2, r2, #2
 800416e:	5852      	ldr	r2, [r2, r1]
 8004170:	0020      	movs	r0, r4
 8004172:	4904      	ldr	r1, [pc, #16]	; (8004184 <GetDateString+0x3c>)
 8004174:	f010 fc72 	bl	8014a5c <sprintf>
	return buffer;
}
 8004178:	0020      	movs	r0, r4
 800417a:	bd16      	pop	{r1, r2, r4, pc}
 800417c:	20006f70 	.word	0x20006f70
 8004180:	080195b4 	.word	0x080195b4
 8004184:	080192ed 	.word	0x080192ed

08004188 <GetTimeString>:

/*-----------------------------------------------------------*/

/* --- Make a time string with format hour / minute / second
 */
char* GetTimeString(void) {
 8004188:	b513      	push	{r0, r1, r4, lr}
	static const char formatTimeStr[] = "%02d:%02d:%02d";
	char *buffer = malloc(10 * sizeof(int8_t));
 800418a:	200a      	movs	r0, #10
 800418c:	f010 f824 	bl	80141d8 <malloc>
 8004190:	0004      	movs	r4, r0
	memset(buffer, 0x00, 10 * sizeof(int8_t));
 8004192:	220a      	movs	r2, #10
 8004194:	2100      	movs	r1, #0
 8004196:	f010 fa66 	bl	8014666 <memset>
	sprintf(buffer, formatTimeStr, BOS.time.hours, BOS.time.minutes,
 800419a:	4905      	ldr	r1, [pc, #20]	; (80041b0 <GetTimeString+0x28>)
 800419c:	0020      	movs	r0, r4
 800419e:	7c4b      	ldrb	r3, [r1, #17]
 80041a0:	7c8a      	ldrb	r2, [r1, #18]
 80041a2:	7c09      	ldrb	r1, [r1, #16]
 80041a4:	9100      	str	r1, [sp, #0]
 80041a6:	4903      	ldr	r1, [pc, #12]	; (80041b4 <GetTimeString+0x2c>)
 80041a8:	f010 fc58 	bl	8014a5c <sprintf>
			BOS.time.seconds);
	return buffer;
}
 80041ac:	0020      	movs	r0, r4
 80041ae:	bd16      	pop	{r1, r2, r4, pc}
 80041b0:	20006f70 	.word	0x20006f70
 80041b4:	080192ff 	.word	0x080192ff

080041b8 <Bridge>:

/*-----------------------------------------------------------*/

/* --- Bridge two array/communication ports together
 */
BOS_Status Bridge(uint8_t port1, uint8_t port2) {
 80041b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	// Link the ports together with an infinite DMA stream
	return StartScastDMAStream(port1, myID, port2, myID, BIDIRECTIONAL,
 80041ba:	4b07      	ldr	r3, [pc, #28]	; (80041d8 <Bridge+0x20>)
BOS_Status Bridge(uint8_t port1, uint8_t port2) {
 80041bc:	000a      	movs	r2, r1
	return StartScastDMAStream(port1, myID, port2, myID, BIDIRECTIONAL,
 80041be:	7819      	ldrb	r1, [r3, #0]
 80041c0:	2301      	movs	r3, #1
 80041c2:	9303      	str	r3, [sp, #12]
 80041c4:	3b02      	subs	r3, #2
 80041c6:	9302      	str	r3, [sp, #8]
 80041c8:	9301      	str	r3, [sp, #4]
 80041ca:	3303      	adds	r3, #3
 80041cc:	9300      	str	r3, [sp, #0]
 80041ce:	000b      	movs	r3, r1
 80041d0:	f003 fece 	bl	8007f70 <StartScastDMAStream>
			0xFFFFFFFF, 0xFFFFFFFF, true);
}
 80041d4:	b005      	add	sp, #20
 80041d6:	bd00      	pop	{pc}
 80041d8:	20001039 	.word	0x20001039

080041dc <Unbridge>:

/*-----------------------------------------------------------*/

/* --- Un-bridge two array/communication ports
 */
BOS_Status Unbridge(uint8_t port1, uint8_t port2) {
 80041dc:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Remove the stream from EEPROM
	SaveEEstreams(0, 0, 0, 0, 0, 0, 0, 0, 0);
 80041de:	2400      	movs	r4, #0
BOS_Status Unbridge(uint8_t port1, uint8_t port2) {
 80041e0:	b087      	sub	sp, #28
 80041e2:	0007      	movs	r7, r0
 80041e4:	000d      	movs	r5, r1
	SaveEEstreams(0, 0, 0, 0, 0, 0, 0, 0, 0);
 80041e6:	0023      	movs	r3, r4
 80041e8:	0022      	movs	r2, r4
 80041ea:	0021      	movs	r1, r4
 80041ec:	9404      	str	r4, [sp, #16]
 80041ee:	9403      	str	r4, [sp, #12]
 80041f0:	9402      	str	r4, [sp, #8]
 80041f2:	9401      	str	r4, [sp, #4]
 80041f4:	9400      	str	r4, [sp, #0]
 80041f6:	0020      	movs	r0, r4
 80041f8:	f7fe ff56 	bl	80030a8 <SaveEEstreams>

	// Stop the DMA streams and enable messaging back on these ports
	if (streamDMA[port1 - 1].Instance != 0
 80041fc:	2338      	movs	r3, #56	; 0x38
 80041fe:	1e79      	subs	r1, r7, #1
 8004200:	4359      	muls	r1, r3
 8004202:	4a0d      	ldr	r2, [pc, #52]	; (8004238 <Unbridge+0x5c>)
 8004204:	1e68      	subs	r0, r5, #1
 8004206:	588e      	ldr	r6, [r1, r2]
 8004208:	4343      	muls	r3, r0
 800420a:	42a6      	cmp	r6, r4
 800420c:	d00b      	beq.n	8004226 <Unbridge+0x4a>
			&& streamDMA[port2 - 1].Instance != 0) {
 800420e:	58d6      	ldr	r6, [r2, r3]
		SwitchStreamDMAToMsg(port1);
 8004210:	0038      	movs	r0, r7
			&& streamDMA[port2 - 1].Instance != 0) {
 8004212:	42a6      	cmp	r6, r4
 8004214:	d00c      	beq.n	8004230 <Unbridge+0x54>
		SwitchStreamDMAToMsg(port1);
 8004216:	f002 facd 	bl	80067b4 <SwitchStreamDMAToMsg>
		SwitchStreamDMAToMsg(port2);
 800421a:	0028      	movs	r0, r5
 800421c:	f002 faca 	bl	80067b4 <SwitchStreamDMAToMsg>
		return BOS_OK;
 8004220:	0020      	movs	r0, r4
		SwitchStreamDMAToMsg(port2);
		return BOS_OK;
	} else {
		return BOS_ERR_WrongValue;
	}
}
 8004222:	b007      	add	sp, #28
 8004224:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (streamDMA[port2 - 1].Instance != 0) {
 8004226:	58d3      	ldr	r3, [r2, r3]
		return BOS_ERR_WrongValue;
 8004228:	2068      	movs	r0, #104	; 0x68
	} else if (streamDMA[port2 - 1].Instance != 0) {
 800422a:	2b00      	cmp	r3, #0
 800422c:	d0f9      	beq.n	8004222 <Unbridge+0x46>
		SwitchStreamDMAToMsg(port2);
 800422e:	0028      	movs	r0, r5
 8004230:	f002 fac0 	bl	80067b4 <SwitchStreamDMAToMsg>
		return BOS_OK;
 8004234:	0030      	movs	r0, r6
 8004236:	e7f4      	b.n	8004222 <Unbridge+0x46>
 8004238:	20001b38 	.word	0x20001b38

0800423c <AddSnippet.part.0>:
		case SNIPPET_CONDITION :
			return ParseSnippetCondition(string);
		
		case SNIPPET_COMMANDS :
			// Did we allocate a buffer already?
			if (snippets[numOfRecordedSnippets-1].cmd != NULL) 
 800423c:	2314      	movs	r3, #20
BOS_Status AddSnippet(uint8_t code, char *string)
 800423e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
			if (snippets[numOfRecordedSnippets-1].cmd != NULL) 
 8004240:	4d22      	ldr	r5, [pc, #136]	; (80042cc <AddSnippet.part.0+0x90>)
 8004242:	4a23      	ldr	r2, [pc, #140]	; (80042d0 <AddSnippet.part.0+0x94>)
 8004244:	782c      	ldrb	r4, [r5, #0]
BOS_Status AddSnippet(uint8_t code, char *string)
 8004246:	0006      	movs	r6, r0
			if (snippets[numOfRecordedSnippets-1].cmd != NULL) 
 8004248:	3c01      	subs	r4, #1
 800424a:	435c      	muls	r4, r3
 800424c:	1914      	adds	r4, r2, r4
 800424e:	f7fb ff63 	bl	8000118 <strlen>
 8004252:	68e7      	ldr	r7, [r4, #12]
 8004254:	9001      	str	r0, [sp, #4]
 8004256:	2f00      	cmp	r7, #0
 8004258:	d02f      	beq.n	80042ba <AddSnippet.part.0+0x7e>
			{
				// re-allocate with new size
				int currentLenght = strlen(snippets[numOfRecordedSnippets-1].cmd);
 800425a:	0038      	movs	r0, r7
 800425c:	f7fb ff5c 	bl	8000118 <strlen>
				// Add two more bytes for the ENTER key (0x13) and end of string (0x00)
				snippets[numOfRecordedSnippets-1].cmd = (char *) realloc(snippets[numOfRecordedSnippets-1].cmd, currentLenght+strlen(string)+2);
 8004260:	9901      	ldr	r1, [sp, #4]
				int currentLenght = strlen(snippets[numOfRecordedSnippets-1].cmd);
 8004262:	9000      	str	r0, [sp, #0]
				snippets[numOfRecordedSnippets-1].cmd = (char *) realloc(snippets[numOfRecordedSnippets-1].cmd, currentLenght+strlen(string)+2);
 8004264:	3102      	adds	r1, #2
 8004266:	1809      	adds	r1, r1, r0
 8004268:	0038      	movs	r0, r7
 800426a:	f010 fa2f 	bl	80146cc <realloc>
 800426e:	60e0      	str	r0, [r4, #12]
				// Copy the command
				strcpy(snippets[numOfRecordedSnippets-1].cmd + currentLenght + 1, string);
 8004270:	2414      	movs	r4, #20
 8004272:	782b      	ldrb	r3, [r5, #0]
 8004274:	4a16      	ldr	r2, [pc, #88]	; (80042d0 <AddSnippet.part.0+0x94>)
 8004276:	3b01      	subs	r3, #1
 8004278:	4363      	muls	r3, r4
 800427a:	18d3      	adds	r3, r2, r3
 800427c:	9a00      	ldr	r2, [sp, #0]
 800427e:	68d8      	ldr	r0, [r3, #12]
 8004280:	3201      	adds	r2, #1
 8004282:	1880      	adds	r0, r0, r2
 8004284:	0031      	movs	r1, r6
 8004286:	f010 fc25 	bl	8014ad4 <strcpy>
				*(snippets[numOfRecordedSnippets-1].cmd + currentLenght) = 0x13;		// ENTER key between commands
 800428a:	782b      	ldrb	r3, [r5, #0]
 800428c:	4a10      	ldr	r2, [pc, #64]	; (80042d0 <AddSnippet.part.0+0x94>)
 800428e:	3b01      	subs	r3, #1
 8004290:	4363      	muls	r3, r4
 8004292:	18d3      	adds	r3, r2, r3
 8004294:	2213      	movs	r2, #19
 8004296:	68db      	ldr	r3, [r3, #12]
 8004298:	9900      	ldr	r1, [sp, #0]
 800429a:	545a      	strb	r2, [r3, r1]
				snippets[numOfRecordedSnippets-1].cmd = (char *) malloc(strlen(string)+1);
				// Copy the command
				strcpy(snippets[numOfRecordedSnippets-1].cmd, string);
			}
			// Return error if allocation fails
			if (snippets[numOfRecordedSnippets-1].cmd == NULL) {
 800429c:	2214      	movs	r2, #20
		
		default:
			break;
	}	
	
	return BOS_OK;
 800429e:	2100      	movs	r1, #0
			if (snippets[numOfRecordedSnippets-1].cmd == NULL) {
 80042a0:	7828      	ldrb	r0, [r5, #0]
 80042a2:	4b0b      	ldr	r3, [pc, #44]	; (80042d0 <AddSnippet.part.0+0x94>)
 80042a4:	3801      	subs	r0, #1
 80042a6:	4350      	muls	r0, r2
 80042a8:	1818      	adds	r0, r3, r0
 80042aa:	68c3      	ldr	r3, [r0, #12]
 80042ac:	428b      	cmp	r3, r1
 80042ae:	d102      	bne.n	80042b6 <AddSnippet.part.0+0x7a>
				memset(&snippets[numOfRecordedSnippets-1], 0, sizeof(snippet_t) );
 80042b0:	f010 f9d9 	bl	8014666 <memset>
				return BOS_ERR_SNIP_MEM_FULL;
 80042b4:	210e      	movs	r1, #14
}
 80042b6:	0008      	movs	r0, r1
 80042b8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				snippets[numOfRecordedSnippets-1].cmd = (char *) malloc(strlen(string)+1);
 80042ba:	9801      	ldr	r0, [sp, #4]
 80042bc:	3001      	adds	r0, #1
 80042be:	f00f ff8b 	bl	80141d8 <malloc>
				strcpy(snippets[numOfRecordedSnippets-1].cmd, string);
 80042c2:	0031      	movs	r1, r6
				snippets[numOfRecordedSnippets-1].cmd = (char *) malloc(strlen(string)+1);
 80042c4:	60e0      	str	r0, [r4, #12]
				strcpy(snippets[numOfRecordedSnippets-1].cmd, string);
 80042c6:	f010 fc05 	bl	8014ad4 <strcpy>
 80042ca:	e7e7      	b.n	800429c <AddSnippet.part.0+0x60>
 80042cc:	200011c7 	.word	0x200011c7
 80042d0:	20006f8c 	.word	0x20006f8c

080042d4 <StringToLowerCase>:
{
 80042d4:	b570      	push	{r4, r5, r6, lr}
 80042d6:	0005      	movs	r5, r0
		string[i] = tolower(string[i]);
 80042d8:	2603      	movs	r6, #3
	for(int i = 0; string[i]; i++){
 80042da:	782c      	ldrb	r4, [r5, #0]
 80042dc:	2c00      	cmp	r4, #0
 80042de:	d100      	bne.n	80042e2 <StringToLowerCase+0xe>
}
 80042e0:	bd70      	pop	{r4, r5, r6, pc}
		string[i] = tolower(string[i]);
 80042e2:	f00f ff6b 	bl	80141bc <__locale_ctype_ptr>
 80042e6:	1900      	adds	r0, r0, r4
 80042e8:	7842      	ldrb	r2, [r0, #1]
 80042ea:	4032      	ands	r2, r6
 80042ec:	2a01      	cmp	r2, #1
 80042ee:	d100      	bne.n	80042f2 <StringToLowerCase+0x1e>
 80042f0:	3420      	adds	r4, #32
 80042f2:	702c      	strb	r4, [r5, #0]
 80042f4:	3501      	adds	r5, #1
 80042f6:	e7f0      	b.n	80042da <StringToLowerCase+0x6>

080042f8 <ParseSnippetCondition>:
/*-----------------------------------------------------------*/

/* Parse Snippet conditions into the internal buffer
*/
BOS_Status ParseSnippetCondition(char *string)
{
 80042f8:	b5f0      	push	{r4, r5, r6, r7, lr}
	static int8_t cInputString[ cmdMAX_INPUT_SIZE ];
	BOS_Status status = BOS_OK;
	uint8_t port = 0;
	
	// A. Verify first there's still memory left to store Snippets	
	if (numOfRecordedSnippets == MAX_SNIPPETS)
 80042fa:	4bcd      	ldr	r3, [pc, #820]	; (8004630 <ParseSnippetCondition+0x338>)
{
 80042fc:	b08d      	sub	sp, #52	; 0x34
	if (numOfRecordedSnippets == MAX_SNIPPETS)
 80042fe:	781b      	ldrb	r3, [r3, #0]
{
 8004300:	9006      	str	r0, [sp, #24]
	if (numOfRecordedSnippets == MAX_SNIPPETS)
 8004302:	9308      	str	r3, [sp, #32]
	{	
		return BOS_ERR_SNIP_MEM_FULL;
 8004304:	240e      	movs	r4, #14
	if (numOfRecordedSnippets == MAX_SNIPPETS)
 8004306:	2b05      	cmp	r3, #5
 8004308:	d100      	bne.n	800430c <ParseSnippetCondition+0x14>
 800430a:	e13b      	b.n	8004584 <ParseSnippetCondition+0x28c>
	}
	// Initialize the next empty location
	else
	{
		snippets[numOfRecordedSnippets].cond.conditionType = 0;
 800430c:	2014      	movs	r0, #20
 800430e:	2400      	movs	r4, #0
 8004310:	4358      	muls	r0, r3
 8004312:	4fc8      	ldr	r7, [pc, #800]	; (8004634 <ParseSnippetCondition+0x33c>)
		snippets[numOfRecordedSnippets].cond.mathOperator = 0;			
		memset(snippets[numOfRecordedSnippets].cond.buffer1, 0, 4);			
 8004314:	2204      	movs	r2, #4
		snippets[numOfRecordedSnippets].cond.conditionType = 0;
 8004316:	19c3      	adds	r3, r0, r7
		memset(snippets[numOfRecordedSnippets].cond.buffer1, 0, 4);			
 8004318:	3002      	adds	r0, #2
		snippets[numOfRecordedSnippets].cond.conditionType = 0;
 800431a:	801c      	strh	r4, [r3, #0]
		memset(snippets[numOfRecordedSnippets].cond.buffer1, 0, 4);			
 800431c:	19c0      	adds	r0, r0, r7
 800431e:	0021      	movs	r1, r4
		snippets[numOfRecordedSnippets].cond.conditionType = 0;
 8004320:	9307      	str	r3, [sp, #28]
		memset(snippets[numOfRecordedSnippets].cond.buffer1, 0, 4);			
 8004322:	f010 f9a0 	bl	8014666 <memset>
	}
	
	// B. Parse Snippets based on their condition type 
	
	// #1: Button event: condition starts with "bx." 
	if(string[0] == 'b' && string[2] == '.')
 8004326:	9b06      	ldr	r3, [sp, #24]
 8004328:	781b      	ldrb	r3, [r3, #0]
 800432a:	2b62      	cmp	r3, #98	; 0x62
 800432c:	d000      	beq.n	8004330 <ParseSnippetCondition+0x38>
 800432e:	e111      	b.n	8004554 <ParseSnippetCondition+0x25c>
 8004330:	9b06      	ldr	r3, [sp, #24]
 8004332:	789b      	ldrb	r3, [r3, #2]
 8004334:	2b2e      	cmp	r3, #46	; 0x2e
 8004336:	d000      	beq.n	800433a <ParseSnippetCondition+0x42>
 8004338:	e10c      	b.n	8004554 <ParseSnippetCondition+0x25c>
	{
		if(string[1] >= '0' && string[1] <= (NumOfPorts+'0'))		// Valid port number
 800433a:	9b06      	ldr	r3, [sp, #24]
 800433c:	785e      	ldrb	r6, [r3, #1]
 800433e:	3e30      	subs	r6, #48	; 0x30
 8004340:	b2f6      	uxtb	r6, r6
 8004342:	2e05      	cmp	r6, #5
 8004344:	d900      	bls.n	8004348 <ParseSnippetCondition+0x50>
 8004346:	e11d      	b.n	8004584 <ParseSnippetCondition+0x28c>
		{
			port = string[1]-'0';
			snippets[numOfRecordedSnippets].cond.conditionType = SNIP_COND_BUTTON_EVENT;
 8004348:	2501      	movs	r5, #1
 800434a:	9b07      	ldr	r3, [sp, #28]
			snippets[numOfRecordedSnippets].cond.mathOperator = 0;			// No math operations
			snippets[numOfRecordedSnippets].cond.buffer1[0] = port;		// Store button port number	
			
			/* Store button event and event parameter if needed */
			if (!strncmp((char *)&string[3], "clicked", 7))
 800434c:	2207      	movs	r2, #7
			snippets[numOfRecordedSnippets].cond.conditionType = SNIP_COND_BUTTON_EVENT;
 800434e:	801d      	strh	r5, [r3, #0]
			snippets[numOfRecordedSnippets].cond.buffer1[0] = port;		// Store button port number	
 8004350:	709e      	strb	r6, [r3, #2]
			if (!strncmp((char *)&string[3], "clicked", 7))
 8004352:	9b06      	ldr	r3, [sp, #24]
 8004354:	49b8      	ldr	r1, [pc, #736]	; (8004638 <ParseSnippetCondition+0x340>)
 8004356:	3303      	adds	r3, #3
 8004358:	0018      	movs	r0, r3
 800435a:	9309      	str	r3, [sp, #36]	; 0x24
 800435c:	f010 fbc2 	bl	8014ae4 <strncmp>
 8004360:	42a0      	cmp	r0, r4
 8004362:	d11c      	bne.n	800439e <ParseSnippetCondition+0xa6>
			{
				snippets[numOfRecordedSnippets].cond.buffer1[1] = CLICKED;	
 8004364:	2305      	movs	r3, #5
 8004366:	9a07      	ldr	r2, [sp, #28]
 8004368:	70d3      	strb	r3, [r2, #3]
				if ((button[port].events & BUTTON_EVENT_CLICKED) != BUTTON_EVENT_CLICKED)		// Enable the event
 800436a:	2209      	movs	r2, #9
 800436c:	4372      	muls	r2, r6
 800436e:	4bb3      	ldr	r3, [pc, #716]	; (800463c <ParseSnippetCondition+0x344>)
 8004370:	189b      	adds	r3, r3, r2
 8004372:	7a1b      	ldrb	r3, [r3, #8]
 8004374:	422b      	tst	r3, r5
 8004376:	d005      	beq.n	8004384 <ParseSnippetCondition+0x8c>
					SetButtonEvents(port, 1, 0, 0, 0, 0, 0, 0, 0, BUTTON_EVENT_MODE_OR);
				status = BOS_OK;
 8004378:	2400      	movs	r4, #0
				} else {
					status = BOS_ERR_BUTTON_RELEASE_EVENT_FULL;
				}									
			}				
			
			++numOfRecordedSnippets;		// Record a successful Snippet			
 800437a:	4aad      	ldr	r2, [pc, #692]	; (8004630 <ParseSnippetCondition+0x338>)
 800437c:	7813      	ldrb	r3, [r2, #0]
 800437e:	3301      	adds	r3, #1
			{
			// #2: Module event	
				snippets[numOfRecordedSnippets].cond.conditionType = SNIP_COND_MODULE_EVENT;			
				snippets[numOfRecordedSnippets].cond.buffer1[1] = modPar1;		// Leaving first buffer byte for remote module ID
				
				++numOfRecordedSnippets;		// Record a successful Snippet	
 8004380:	7013      	strb	r3, [r2, #0]
				return BOS_OK;
 8004382:	e0ff      	b.n	8004584 <ParseSnippetCondition+0x28c>
					SetButtonEvents(port, 1, 0, 0, 0, 0, 0, 0, 0, BUTTON_EVENT_MODE_OR);
 8004384:	0023      	movs	r3, r4
 8004386:	0022      	movs	r2, r4
 8004388:	0029      	movs	r1, r5
 800438a:	9505      	str	r5, [sp, #20]
 800438c:	9404      	str	r4, [sp, #16]
 800438e:	9403      	str	r4, [sp, #12]
 8004390:	9402      	str	r4, [sp, #8]
 8004392:	9401      	str	r4, [sp, #4]
 8004394:	9400      	str	r4, [sp, #0]
					SetButtonEvents(port, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, 0, 0, 0, 0, BUTTON_EVENT_MODE_OR);
 8004396:	0030      	movs	r0, r6
 8004398:	f003 f9a6 	bl	80076e8 <SetButtonEvents>
 800439c:	e7ed      	b.n	800437a <ParseSnippetCondition+0x82>
			else if (!strncmp((char *)&string[3], "double clicked", 14))
 800439e:	220e      	movs	r2, #14
 80043a0:	49a7      	ldr	r1, [pc, #668]	; (8004640 <ParseSnippetCondition+0x348>)
 80043a2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80043a4:	f010 fb9e 	bl	8014ae4 <strncmp>
 80043a8:	2800      	cmp	r0, #0
 80043aa:	d113      	bne.n	80043d4 <ParseSnippetCondition+0xdc>
				snippets[numOfRecordedSnippets].cond.buffer1[1] = DBL_CLICKED;			
 80043ac:	2306      	movs	r3, #6
 80043ae:	9a07      	ldr	r2, [sp, #28]
 80043b0:	70d3      	strb	r3, [r2, #3]
				if ((button[port].events & BUTTON_EVENT_DBL_CLICKED) != BUTTON_EVENT_DBL_CLICKED)
 80043b2:	2209      	movs	r2, #9
 80043b4:	4372      	muls	r2, r6
 80043b6:	4ba1      	ldr	r3, [pc, #644]	; (800463c <ParseSnippetCondition+0x344>)
 80043b8:	189b      	adds	r3, r3, r2
 80043ba:	7a1b      	ldrb	r3, [r3, #8]
 80043bc:	079b      	lsls	r3, r3, #30
 80043be:	d4db      	bmi.n	8004378 <ParseSnippetCondition+0x80>
					SetButtonEvents(port, 0, 1, 0, 0, 0, 0, 0, 0, BUTTON_EVENT_MODE_OR);
 80043c0:	0023      	movs	r3, r4
 80043c2:	002a      	movs	r2, r5
 80043c4:	9505      	str	r5, [sp, #20]
 80043c6:	9404      	str	r4, [sp, #16]
 80043c8:	9403      	str	r4, [sp, #12]
 80043ca:	9402      	str	r4, [sp, #8]
 80043cc:	9401      	str	r4, [sp, #4]
 80043ce:	9400      	str	r4, [sp, #0]
					SetButtonEvents(port, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, 0, 0, 0, 0, BUTTON_EVENT_MODE_OR);
 80043d0:	0021      	movs	r1, r4
 80043d2:	e7e0      	b.n	8004396 <ParseSnippetCondition+0x9e>
			else if (!strncmp((char *)&string[3], "pressed for ", 12))
 80043d4:	220c      	movs	r2, #12
 80043d6:	499b      	ldr	r1, [pc, #620]	; (8004644 <ParseSnippetCondition+0x34c>)
 80043d8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80043da:	f010 fb83 	bl	8014ae4 <strncmp>
 80043de:	2800      	cmp	r0, #0
 80043e0:	d152      	bne.n	8004488 <ParseSnippetCondition+0x190>
				if (!button[port].pressedX1Sec) {	
 80043e2:	2209      	movs	r2, #9
 80043e4:	0011      	movs	r1, r2
 80043e6:	4371      	muls	r1, r6
 80043e8:	4b94      	ldr	r3, [pc, #592]	; (800463c <ParseSnippetCondition+0x344>)
 80043ea:	185b      	adds	r3, r3, r1
 80043ec:	7899      	ldrb	r1, [r3, #2]
 80043ee:	2900      	cmp	r1, #0
 80043f0:	d114      	bne.n	800441c <ParseSnippetCondition+0x124>
					snippets[numOfRecordedSnippets].cond.buffer1[1] = PRESSED_FOR_X1_SEC;	
 80043f2:	9b07      	ldr	r3, [sp, #28]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[15]);
 80043f4:	9806      	ldr	r0, [sp, #24]
					snippets[numOfRecordedSnippets].cond.buffer1[1] = PRESSED_FOR_X1_SEC;	
 80043f6:	70da      	strb	r2, [r3, #3]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[15]);
 80043f8:	300f      	adds	r0, #15
 80043fa:	f00f feab 	bl	8014154 <atoi>
 80043fe:	4a8c      	ldr	r2, [pc, #560]	; (8004630 <ParseSnippetCondition+0x338>)
 8004400:	b2c3      	uxtb	r3, r0
 8004402:	7810      	ldrb	r0, [r2, #0]
 8004404:	2214      	movs	r2, #20
 8004406:	4350      	muls	r0, r2
 8004408:	1838      	adds	r0, r7, r0
 800440a:	7103      	strb	r3, [r0, #4]
					SetButtonEvents(port, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, 0, 0, 0, 0, BUTTON_EVENT_MODE_OR);
 800440c:	9505      	str	r5, [sp, #20]
 800440e:	9404      	str	r4, [sp, #16]
 8004410:	9403      	str	r4, [sp, #12]
 8004412:	9402      	str	r4, [sp, #8]
 8004414:	9401      	str	r4, [sp, #4]
 8004416:	9400      	str	r4, [sp, #0]
 8004418:	0022      	movs	r2, r4
 800441a:	e7d9      	b.n	80043d0 <ParseSnippetCondition+0xd8>
				} else if (!button[port].pressedX2Sec) {	
 800441c:	78da      	ldrb	r2, [r3, #3]
 800441e:	2a00      	cmp	r2, #0
 8004420:	d115      	bne.n	800444e <ParseSnippetCondition+0x156>
					snippets[numOfRecordedSnippets].cond.buffer1[1] = PRESSED_FOR_X2_SEC;	
 8004422:	230a      	movs	r3, #10
 8004424:	9a07      	ldr	r2, [sp, #28]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[15]);
 8004426:	9806      	ldr	r0, [sp, #24]
					snippets[numOfRecordedSnippets].cond.buffer1[1] = PRESSED_FOR_X2_SEC;	
 8004428:	70d3      	strb	r3, [r2, #3]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[15]);
 800442a:	300f      	adds	r0, #15
 800442c:	f00f fe92 	bl	8014154 <atoi>
 8004430:	4a7f      	ldr	r2, [pc, #508]	; (8004630 <ParseSnippetCondition+0x338>)
 8004432:	b2c3      	uxtb	r3, r0
 8004434:	7810      	ldrb	r0, [r2, #0]
 8004436:	2214      	movs	r2, #20
 8004438:	4350      	muls	r0, r2
 800443a:	1838      	adds	r0, r7, r0
 800443c:	7103      	strb	r3, [r0, #4]
					SetButtonEvents(port, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, 0, 0, 0, BUTTON_EVENT_MODE_OR);
 800443e:	9505      	str	r5, [sp, #20]
 8004440:	9404      	str	r4, [sp, #16]
 8004442:	9403      	str	r4, [sp, #12]
 8004444:	9402      	str	r4, [sp, #8]
 8004446:	9401      	str	r4, [sp, #4]
 8004448:	9300      	str	r3, [sp, #0]
					SetButtonEvents(port, 0, 0, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, BUTTON_EVENT_MODE_OR);
 800444a:	0023      	movs	r3, r4
 800444c:	e7e4      	b.n	8004418 <ParseSnippetCondition+0x120>
				} else if (!button[port].pressedX3Sec) {	
 800444e:	791b      	ldrb	r3, [r3, #4]
					status = BOS_ERR_BUTTON_PRESS_EVENT_FULL;
 8004450:	240c      	movs	r4, #12
				} else if (!button[port].pressedX3Sec) {	
 8004452:	2b00      	cmp	r3, #0
 8004454:	d191      	bne.n	800437a <ParseSnippetCondition+0x82>
					snippets[numOfRecordedSnippets].cond.buffer1[1] = PRESSED_FOR_X3_SEC;	
 8004456:	2514      	movs	r5, #20
 8004458:	220b      	movs	r2, #11
 800445a:	9b08      	ldr	r3, [sp, #32]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[15]);
 800445c:	9806      	ldr	r0, [sp, #24]
					snippets[numOfRecordedSnippets].cond.buffer1[1] = PRESSED_FOR_X3_SEC;	
 800445e:	436b      	muls	r3, r5
 8004460:	18fb      	adds	r3, r7, r3
 8004462:	70da      	strb	r2, [r3, #3]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[15]);
 8004464:	300f      	adds	r0, #15
 8004466:	f00f fe75 	bl	8014154 <atoi>
 800446a:	4b71      	ldr	r3, [pc, #452]	; (8004630 <ParseSnippetCondition+0x338>)
					SetButtonEvents(port, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, 0, 0, BUTTON_EVENT_MODE_OR);
 800446c:	2400      	movs	r4, #0
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[15]);
 800446e:	781b      	ldrb	r3, [r3, #0]
 8004470:	b2c0      	uxtb	r0, r0
 8004472:	435d      	muls	r5, r3
					SetButtonEvents(port, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, 0, 0, BUTTON_EVENT_MODE_OR);
 8004474:	2301      	movs	r3, #1
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[15]);
 8004476:	197d      	adds	r5, r7, r5
 8004478:	7128      	strb	r0, [r5, #4]
					SetButtonEvents(port, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, 0, 0, BUTTON_EVENT_MODE_OR);
 800447a:	9305      	str	r3, [sp, #20]
 800447c:	9404      	str	r4, [sp, #16]
 800447e:	9403      	str	r4, [sp, #12]
 8004480:	9402      	str	r4, [sp, #8]
 8004482:	9001      	str	r0, [sp, #4]
					SetButtonEvents(port, 0, 0, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, BUTTON_EVENT_MODE_OR);
 8004484:	9400      	str	r4, [sp, #0]
 8004486:	e7e0      	b.n	800444a <ParseSnippetCondition+0x152>
			else if (!strncmp((char *)&string[3], "released for ", 13))
 8004488:	220d      	movs	r2, #13
 800448a:	496f      	ldr	r1, [pc, #444]	; (8004648 <ParseSnippetCondition+0x350>)
 800448c:	9809      	ldr	r0, [sp, #36]	; 0x24
 800448e:	f010 fb29 	bl	8014ae4 <strncmp>
 8004492:	2800      	cmp	r0, #0
 8004494:	d000      	beq.n	8004498 <ParseSnippetCondition+0x1a0>
 8004496:	e76f      	b.n	8004378 <ParseSnippetCondition+0x80>
				if (!button[port].releasedY1Sec) {	
 8004498:	2309      	movs	r3, #9
 800449a:	0019      	movs	r1, r3
 800449c:	4371      	muls	r1, r6
 800449e:	4a67      	ldr	r2, [pc, #412]	; (800463c <ParseSnippetCondition+0x344>)
 80044a0:	1851      	adds	r1, r2, r1
 80044a2:	7948      	ldrb	r0, [r1, #5]
 80044a4:	2800      	cmp	r0, #0
 80044a6:	d113      	bne.n	80044d0 <ParseSnippetCondition+0x1d8>
					snippets[numOfRecordedSnippets].cond.buffer1[1] = RELEASED_FOR_Y1_SEC;	
 80044a8:	9a07      	ldr	r2, [sp, #28]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[16]);
 80044aa:	9806      	ldr	r0, [sp, #24]
					snippets[numOfRecordedSnippets].cond.buffer1[1] = RELEASED_FOR_Y1_SEC;	
 80044ac:	3303      	adds	r3, #3
 80044ae:	70d3      	strb	r3, [r2, #3]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[16]);
 80044b0:	3010      	adds	r0, #16
 80044b2:	f00f fe4f 	bl	8014154 <atoi>
 80044b6:	4a5e      	ldr	r2, [pc, #376]	; (8004630 <ParseSnippetCondition+0x338>)
 80044b8:	b2c3      	uxtb	r3, r0
 80044ba:	7810      	ldrb	r0, [r2, #0]
 80044bc:	2214      	movs	r2, #20
 80044be:	4350      	muls	r0, r2
 80044c0:	1838      	adds	r0, r7, r0
 80044c2:	7103      	strb	r3, [r0, #4]
					SetButtonEvents(port, 0, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, 0, BUTTON_EVENT_MODE_OR);
 80044c4:	9505      	str	r5, [sp, #20]
 80044c6:	9404      	str	r4, [sp, #16]
 80044c8:	9403      	str	r4, [sp, #12]
 80044ca:	9302      	str	r3, [sp, #8]
					SetButtonEvents(port, 0, 0, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, BUTTON_EVENT_MODE_OR);
 80044cc:	9401      	str	r4, [sp, #4]
 80044ce:	e7d9      	b.n	8004484 <ParseSnippetCondition+0x18c>
				} else if (!button[port].releasedY2Sec) {	
 80044d0:	7989      	ldrb	r1, [r1, #6]
 80044d2:	2900      	cmp	r1, #0
 80044d4:	d117      	bne.n	8004506 <ParseSnippetCondition+0x20e>
					snippets[numOfRecordedSnippets].cond.buffer1[1] = RELEASED_FOR_Y2_SEC;	
 80044d6:	2514      	movs	r5, #20
 80044d8:	220d      	movs	r2, #13
 80044da:	9b08      	ldr	r3, [sp, #32]
 80044dc:	4c55      	ldr	r4, [pc, #340]	; (8004634 <ParseSnippetCondition+0x33c>)
 80044de:	436b      	muls	r3, r5
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[16]);
 80044e0:	9806      	ldr	r0, [sp, #24]
					snippets[numOfRecordedSnippets].cond.buffer1[1] = RELEASED_FOR_Y2_SEC;	
 80044e2:	18e3      	adds	r3, r4, r3
 80044e4:	70da      	strb	r2, [r3, #3]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[16]);
 80044e6:	3010      	adds	r0, #16
 80044e8:	f00f fe34 	bl	8014154 <atoi>
 80044ec:	4b50      	ldr	r3, [pc, #320]	; (8004630 <ParseSnippetCondition+0x338>)
 80044ee:	b2c0      	uxtb	r0, r0
 80044f0:	781b      	ldrb	r3, [r3, #0]
 80044f2:	435d      	muls	r5, r3
 80044f4:	1964      	adds	r4, r4, r5
 80044f6:	7120      	strb	r0, [r4, #4]
					SetButtonEvents(port, 0, 0, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], 0, BUTTON_EVENT_MODE_OR);
 80044f8:	2301      	movs	r3, #1
 80044fa:	2400      	movs	r4, #0
 80044fc:	9305      	str	r3, [sp, #20]
 80044fe:	9404      	str	r4, [sp, #16]
 8004500:	9003      	str	r0, [sp, #12]
 8004502:	9402      	str	r4, [sp, #8]
 8004504:	e7e2      	b.n	80044cc <ParseSnippetCondition+0x1d4>
				} else if (!button[port].releasedY3Sec) {	
 8004506:	4373      	muls	r3, r6
 8004508:	18d3      	adds	r3, r2, r3
 800450a:	79dd      	ldrb	r5, [r3, #7]
					status = BOS_ERR_BUTTON_RELEASE_EVENT_FULL;
 800450c:	240d      	movs	r4, #13
				} else if (!button[port].releasedY3Sec) {	
 800450e:	2d00      	cmp	r5, #0
 8004510:	d000      	beq.n	8004514 <ParseSnippetCondition+0x21c>
 8004512:	e732      	b.n	800437a <ParseSnippetCondition+0x82>
					snippets[numOfRecordedSnippets].cond.buffer1[1] = RELEASED_FOR_Y3_SEC;	
 8004514:	2714      	movs	r7, #20
 8004516:	220e      	movs	r2, #14
 8004518:	9b08      	ldr	r3, [sp, #32]
 800451a:	4c46      	ldr	r4, [pc, #280]	; (8004634 <ParseSnippetCondition+0x33c>)
 800451c:	437b      	muls	r3, r7
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[16]);
 800451e:	9806      	ldr	r0, [sp, #24]
					snippets[numOfRecordedSnippets].cond.buffer1[1] = RELEASED_FOR_Y3_SEC;	
 8004520:	18e3      	adds	r3, r4, r3
 8004522:	70da      	strb	r2, [r3, #3]
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[16]);
 8004524:	3010      	adds	r0, #16
 8004526:	f00f fe15 	bl	8014154 <atoi>
 800452a:	4b41      	ldr	r3, [pc, #260]	; (8004630 <ParseSnippetCondition+0x338>)
 800452c:	b2c0      	uxtb	r0, r0
 800452e:	781b      	ldrb	r3, [r3, #0]
					SetButtonEvents(port, 0, 0, 0, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], BUTTON_EVENT_MODE_OR);					
 8004530:	002a      	movs	r2, r5
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[16]);
 8004532:	435f      	muls	r7, r3
					SetButtonEvents(port, 0, 0, 0, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], BUTTON_EVENT_MODE_OR);					
 8004534:	2301      	movs	r3, #1
					snippets[numOfRecordedSnippets].cond.buffer1[2] = atoi((char *)&string[16]);
 8004536:	19e4      	adds	r4, r4, r7
 8004538:	7120      	strb	r0, [r4, #4]
					SetButtonEvents(port, 0, 0, 0, 0, 0, 0, 0, snippets[numOfRecordedSnippets].cond.buffer1[2], BUTTON_EVENT_MODE_OR);					
 800453a:	0029      	movs	r1, r5
 800453c:	9305      	str	r3, [sp, #20]
 800453e:	9004      	str	r0, [sp, #16]
 8004540:	9503      	str	r5, [sp, #12]
 8004542:	9502      	str	r5, [sp, #8]
 8004544:	9501      	str	r5, [sp, #4]
 8004546:	9500      	str	r5, [sp, #0]
 8004548:	002b      	movs	r3, r5
 800454a:	0030      	movs	r0, r6
 800454c:	f003 f8cc 	bl	80076e8 <SetButtonEvents>
					status = BOS_OK;	
 8004550:	002c      	movs	r4, r5
 8004552:	e712      	b.n	800437a <ParseSnippetCondition+0x82>
		strcpy( (char *)cInputString, string);
 8004554:	4d3d      	ldr	r5, [pc, #244]	; (800464c <ParseSnippetCondition+0x354>)
 8004556:	9906      	ldr	r1, [sp, #24]
 8004558:	0028      	movs	r0, r5
 800455a:	f010 fabb 	bl	8014ad4 <strcpy>
		firstPart = strtok ( (char *)cInputString, " ");
 800455e:	4c3c      	ldr	r4, [pc, #240]	; (8004650 <ParseSnippetCondition+0x358>)
 8004560:	0028      	movs	r0, r5
 8004562:	0021      	movs	r1, r4
 8004564:	f011 f936 	bl	80157d4 <strtok>
		secondPart = strtok ( NULL, " ");
 8004568:	0021      	movs	r1, r4
		firstPart = strtok ( (char *)cInputString, " ");
 800456a:	0005      	movs	r5, r0
		secondPart = strtok ( NULL, " ");
 800456c:	2000      	movs	r0, #0
 800456e:	f011 f931 	bl	80157d4 <strtok>
		thirdPart = strtok ( NULL, " ");
 8004572:	0021      	movs	r1, r4
		secondPart = strtok ( NULL, " ");
 8004574:	9006      	str	r0, [sp, #24]
		thirdPart = strtok ( NULL, " ");
 8004576:	2000      	movs	r0, #0
 8004578:	f011 f92c 	bl	80157d4 <strtok>
 800457c:	0004      	movs	r4, r0
		if (firstPart == NULL) 
 800457e:	2d00      	cmp	r5, #0
 8004580:	d103      	bne.n	800458a <ParseSnippetCondition+0x292>
			return BOS_ERR_WrongParam;
 8004582:	2467      	movs	r4, #103	; 0x67
	}
	
	// Note: after exiting this function, numOfRecordedSnippets refers to the next empty Snippet. Substract by one to reference the last Snippet.
	
	return status;
}
 8004584:	0020      	movs	r0, r4
 8004586:	b00d      	add	sp, #52	; 0x34
 8004588:	bdf0      	pop	{r4, r5, r6, r7, pc}
			modPar1 = IsModuleParameter(firstPart);
 800458a:	0028      	movs	r0, r5
 800458c:	f7fe ff6c 	bl	8003468 <IsModuleParameter>
			if (modPar1 && secondPart == NULL && thirdPart == NULL) 
 8004590:	9b06      	ldr	r3, [sp, #24]
			modPar1 = IsModuleParameter(firstPart);
 8004592:	1e06      	subs	r6, r0, #0
			if (modPar1 && secondPart == NULL && thirdPart == NULL) 
 8004594:	d00e      	beq.n	80045b4 <ParseSnippetCondition+0x2bc>
 8004596:	2b00      	cmp	r3, #0
 8004598:	d10e      	bne.n	80045b8 <ParseSnippetCondition+0x2c0>
 800459a:	2c00      	cmp	r4, #0
 800459c:	d1f1      	bne.n	8004582 <ParseSnippetCondition+0x28a>
				snippets[numOfRecordedSnippets].cond.conditionType = SNIP_COND_MODULE_EVENT;			
 800459e:	2014      	movs	r0, #20
 80045a0:	2202      	movs	r2, #2
 80045a2:	4b23      	ldr	r3, [pc, #140]	; (8004630 <ParseSnippetCondition+0x338>)
 80045a4:	781b      	ldrb	r3, [r3, #0]
 80045a6:	4358      	muls	r0, r3
 80045a8:	543a      	strb	r2, [r7, r0]
				snippets[numOfRecordedSnippets].cond.buffer1[1] = modPar1;		// Leaving first buffer byte for remote module ID
 80045aa:	1838      	adds	r0, r7, r0
 80045ac:	70c6      	strb	r6, [r0, #3]
				++numOfRecordedSnippets;		// Record a successful Snippet	
 80045ae:	3301      	adds	r3, #1
 80045b0:	4a1f      	ldr	r2, [pc, #124]	; (8004630 <ParseSnippetCondition+0x338>)
 80045b2:	e6e5      	b.n	8004380 <ParseSnippetCondition+0x88>
			else if (secondPart != NULL && thirdPart != NULL) 
 80045b4:	2b00      	cmp	r3, #0
 80045b6:	d0e4      	beq.n	8004582 <ParseSnippetCondition+0x28a>
 80045b8:	2c00      	cmp	r4, #0
 80045ba:	d0e2      	beq.n	8004582 <ParseSnippetCondition+0x28a>
				modPar2 = IsModuleParameter(thirdPart);
 80045bc:	0020      	movs	r0, r4
 80045be:	f7fe ff53 	bl	8003468 <IsModuleParameter>
					snippets[numOfRecordedSnippets].cond.conditionType = SNIP_COND_MODULE_PARAM_PARAM;
 80045c2:	4b1b      	ldr	r3, [pc, #108]	; (8004630 <ParseSnippetCondition+0x338>)
 80045c4:	2514      	movs	r5, #20
 80045c6:	781b      	ldrb	r3, [r3, #0]
				if (modPar2) 		// Found a module parameter
 80045c8:	2800      	cmp	r0, #0
 80045ca:	d01b      	beq.n	8004604 <ParseSnippetCondition+0x30c>
					snippets[numOfRecordedSnippets].cond.conditionType = SNIP_COND_MODULE_PARAM_PARAM;
 80045cc:	435d      	muls	r5, r3
 80045ce:	2304      	movs	r3, #4
 80045d0:	557b      	strb	r3, [r7, r5]
					snippets[numOfRecordedSnippets].cond.buffer1[1] = modPar1;		// Leaving first buffer byte for remote module ID
 80045d2:	197d      	adds	r5, r7, r5
 80045d4:	70ee      	strb	r6, [r5, #3]
					snippets[numOfRecordedSnippets].cond.buffer2[1] = modPar2;		// Leaving first buffer byte for remote module ID				
 80045d6:	71e8      	strb	r0, [r5, #7]
				snippets[numOfRecordedSnippets].cond.mathOperator = IsMathOperator(secondPart);
 80045d8:	4b15      	ldr	r3, [pc, #84]	; (8004630 <ParseSnippetCondition+0x338>)
 80045da:	9806      	ldr	r0, [sp, #24]
 80045dc:	781c      	ldrb	r4, [r3, #0]
 80045de:	f7fe ff4f 	bl	8003480 <IsMathOperator>
 80045e2:	2114      	movs	r1, #20
				if (!snippets[numOfRecordedSnippets].cond.mathOperator)
 80045e4:	4b12      	ldr	r3, [pc, #72]	; (8004630 <ParseSnippetCondition+0x338>)
				snippets[numOfRecordedSnippets].cond.mathOperator = IsMathOperator(secondPart);
 80045e6:	434c      	muls	r4, r1
				if (!snippets[numOfRecordedSnippets].cond.mathOperator)
 80045e8:	781b      	ldrb	r3, [r3, #0]
				snippets[numOfRecordedSnippets].cond.mathOperator = IsMathOperator(secondPart);
 80045ea:	4a12      	ldr	r2, [pc, #72]	; (8004634 <ParseSnippetCondition+0x33c>)
				if (!snippets[numOfRecordedSnippets].cond.mathOperator)
 80045ec:	4359      	muls	r1, r3
				snippets[numOfRecordedSnippets].cond.mathOperator = IsMathOperator(secondPart);
 80045ee:	1914      	adds	r4, r2, r4
 80045f0:	7060      	strb	r0, [r4, #1]
				if (!snippets[numOfRecordedSnippets].cond.mathOperator)
 80045f2:	1852      	adds	r2, r2, r1
 80045f4:	7852      	ldrb	r2, [r2, #1]
 80045f6:	2a00      	cmp	r2, #0
 80045f8:	d0c3      	beq.n	8004582 <ParseSnippetCondition+0x28a>
				++numOfRecordedSnippets;		// Record a successful Snippet
 80045fa:	4a0d      	ldr	r2, [pc, #52]	; (8004630 <ParseSnippetCondition+0x338>)
 80045fc:	3301      	adds	r3, #1
 80045fe:	7013      	strb	r3, [r2, #0]
				return BOS_OK;				
 8004600:	2400      	movs	r4, #0
 8004602:	e7bf      	b.n	8004584 <ParseSnippetCondition+0x28c>
					snippets[numOfRecordedSnippets].cond.conditionType = SNIP_COND_MODULE_PARAM_CONST;
 8004604:	2203      	movs	r2, #3
 8004606:	436b      	muls	r3, r5
 8004608:	54fa      	strb	r2, [r7, r3]
					snippets[numOfRecordedSnippets].cond.buffer1[1] = modPar1;		// Leaving first buffer byte for remote module ID
 800460a:	18fb      	adds	r3, r7, r3
 800460c:	70de      	strb	r6, [r3, #3]
					float constant = atof(thirdPart);
 800460e:	0020      	movs	r0, r4
 8004610:	f00f fd9b 	bl	801414a <atof>
 8004614:	f7fe fa98 	bl	8002b48 <__aeabi_d2f>
					memcpy(snippets[numOfRecordedSnippets].cond.buffer2, &constant, sizeof(float));		// This buffer can be misaligned and cause hardfault on F0
 8004618:	4b05      	ldr	r3, [pc, #20]	; (8004630 <ParseSnippetCondition+0x338>)
					float constant = atof(thirdPart);
 800461a:	900b      	str	r0, [sp, #44]	; 0x2c
					memcpy(snippets[numOfRecordedSnippets].cond.buffer2, &constant, sizeof(float));		// This buffer can be misaligned and cause hardfault on F0
 800461c:	7818      	ldrb	r0, [r3, #0]
 800461e:	2204      	movs	r2, #4
 8004620:	4368      	muls	r0, r5
 8004622:	3006      	adds	r0, #6
 8004624:	1838      	adds	r0, r7, r0
 8004626:	a90b      	add	r1, sp, #44	; 0x2c
 8004628:	f010 f814 	bl	8014654 <memcpy>
 800462c:	e7d4      	b.n	80045d8 <ParseSnippetCondition+0x2e0>
 800462e:	46c0      	nop			; (mov r8, r8)
 8004630:	200011c7 	.word	0x200011c7
 8004634:	20006f8c 	.word	0x20006f8c
 8004638:	0801a52d 	.word	0x0801a52d
 800463c:	20001458 	.word	0x20001458
 8004640:	0801a526 	.word	0x0801a526
 8004644:	08019788 	.word	0x08019788
 8004648:	08019795 	.word	0x08019795
 800464c:	20001130 	.word	0x20001130
 8004650:	08019df3 	.word	0x08019df3

08004654 <AddSnippet>:
{
 8004654:	0003      	movs	r3, r0
 8004656:	b510      	push	{r4, lr}
 8004658:	0008      	movs	r0, r1
	switch (code)
 800465a:	2b02      	cmp	r3, #2
 800465c:	d013      	beq.n	8004686 <AddSnippet+0x32>
 800465e:	2b03      	cmp	r3, #3
 8004660:	d004      	beq.n	800466c <AddSnippet+0x18>
 8004662:	2b01      	cmp	r3, #1
 8004664:	d10d      	bne.n	8004682 <AddSnippet+0x2e>
			return ParseSnippetCondition(string);
 8004666:	f7ff fe47 	bl	80042f8 <ParseSnippetCondition>
}
 800466a:	bd10      	pop	{r4, pc}
			snippets[numOfRecordedSnippets-1].state = true;
 800466c:	4b07      	ldr	r3, [pc, #28]	; (800468c <AddSnippet+0x38>)
 800466e:	781a      	ldrb	r2, [r3, #0]
 8004670:	2314      	movs	r3, #20
 8004672:	3a01      	subs	r2, #1
 8004674:	435a      	muls	r2, r3
 8004676:	4b06      	ldr	r3, [pc, #24]	; (8004690 <AddSnippet+0x3c>)
 8004678:	189b      	adds	r3, r3, r2
 800467a:	2201      	movs	r2, #1
 800467c:	741a      	strb	r2, [r3, #16]
			SaveToRO();
 800467e:	f005 f855 	bl	800972c <SaveToRO>
	return BOS_OK;
 8004682:	2000      	movs	r0, #0
 8004684:	e7f1      	b.n	800466a <AddSnippet+0x16>
 8004686:	f7ff fdd9 	bl	800423c <AddSnippet.part.0>
 800468a:	e7ee      	b.n	800466a <AddSnippet+0x16>
 800468c:	200011c7 	.word	0x200011c7
 8004690:	20006f8c 	.word	0x20006f8c

08004694 <CLI_CommandParser>:
{
 8004694:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004696:	b08d      	sub	sp, #52	; 0x34
 8004698:	9006      	str	r0, [sp, #24]
 800469a:	9107      	str	r1, [sp, #28]
 800469c:	9202      	str	r2, [sp, #8]
	char* loc = 0; int16_t id = 0; char idString[MaxLengthOfAlias] = {0};
 800469e:	2100      	movs	r1, #0
 80046a0:	2209      	movs	r2, #9
 80046a2:	a809      	add	r0, sp, #36	; 0x24
{
 80046a4:	001e      	movs	r6, r3
	char* loc = 0; int16_t id = 0; char idString[MaxLengthOfAlias] = {0};
 80046a6:	f00f ffde 	bl	8014666 <memset>
		StringToLowerCase(( char * )cInputString);
 80046aa:	9802      	ldr	r0, [sp, #8]
 80046ac:	f7ff fe12 	bl	80042d4 <StringToLowerCase>
		if (!recordSnippet && !strncmp((char *)cInputString, "if ", 3)) 
 80046b0:	4dc1      	ldr	r5, [pc, #772]	; (80049b8 <CLI_CommandParser+0x324>)
 80046b2:	782b      	ldrb	r3, [r5, #0]
 80046b4:	9303      	str	r3, [sp, #12]
 80046b6:	2b00      	cmp	r3, #0
 80046b8:	d14b      	bne.n	8004752 <CLI_CommandParser+0xbe>
 80046ba:	2203      	movs	r2, #3
 80046bc:	49bf      	ldr	r1, [pc, #764]	; (80049bc <CLI_CommandParser+0x328>)
 80046be:	9802      	ldr	r0, [sp, #8]
 80046c0:	f010 fa10 	bl	8014ae4 <strncmp>
 80046c4:	1e07      	subs	r7, r0, #0
 80046c6:	d15f      	bne.n	8004788 <CLI_CommandParser+0xf4>
			if (AddSnippet(SNIPPET_CONDITION, ( char * ) (cInputString+3)) != BOS_OK) {
 80046c8:	9b02      	ldr	r3, [sp, #8]
 80046ca:	1cd8      	adds	r0, r3, #3
			return ParseSnippetCondition(string);
 80046cc:	f7ff fe14 	bl	80042f8 <ParseSnippetCondition>
			if (AddSnippet(SNIPPET_CONDITION, ( char * ) (cInputString+3)) != BOS_OK) {
 80046d0:	2800      	cmp	r0, #0
 80046d2:	d038      	beq.n	8004746 <CLI_CommandParser+0xb2>
				sprintf( ( char * ) pcOutputString, "\nCannot store more Command Snippets. Please delete existing ones and try again.\n\r");
 80046d4:	49ba      	ldr	r1, [pc, #744]	; (80049c0 <CLI_CommandParser+0x32c>)
 80046d6:	0030      	movs	r0, r6
 80046d8:	f010 f9fc 	bl	8014ad4 <strcpy>
				recordSnippet = 0;
 80046dc:	702f      	strb	r7, [r5, #0]
			xReturned = pdFALSE;
 80046de:	2400      	movs	r4, #0
 80046e0:	0030      	movs	r0, r6
 80046e2:	f7fb fd19 	bl	8000118 <strlen>
		if (strlen((char*)pcOutputString) > 0 && enableOutput)
 80046e6:	7833      	ldrb	r3, [r6, #0]
 80046e8:	2b00      	cmp	r3, #0
 80046ea:	d00b      	beq.n	8004704 <CLI_CommandParser+0x70>
 80046ec:	9b07      	ldr	r3, [sp, #28]
 80046ee:	2b00      	cmp	r3, #0
 80046f0:	d008      	beq.n	8004704 <CLI_CommandParser+0x70>
			writePxMutex(port, (char*)pcOutputString, strlen((char*)pcOutputString), cmd50ms, HAL_MAX_DELAY);		
 80046f2:	2301      	movs	r3, #1
 80046f4:	425b      	negs	r3, r3
 80046f6:	b282      	uxth	r2, r0
 80046f8:	9300      	str	r3, [sp, #0]
 80046fa:	0031      	movs	r1, r6
 80046fc:	3333      	adds	r3, #51	; 0x33
 80046fe:	9806      	ldr	r0, [sp, #24]
 8004700:	f008 fe8a 	bl	800d418 <writePxMutex>
		memset( pcOutputString, 0x00, strlen((char*)pcOutputString) );
 8004704:	0030      	movs	r0, r6
 8004706:	f7fb fd07 	bl	8000118 <strlen>
 800470a:	2100      	movs	r1, #0
 800470c:	0002      	movs	r2, r0
 800470e:	0030      	movs	r0, r6
 8004710:	f00f ffa9 	bl	8014666 <memset>
	} while( xReturned != pdFALSE );
 8004714:	2c00      	cmp	r4, #0
 8004716:	d1c8      	bne.n	80046aa <CLI_CommandParser+0x16>
	memset( idString, 0x00, MaxLengthOfAlias );
 8004718:	2209      	movs	r2, #9
 800471a:	0021      	movs	r1, r4
 800471c:	a809      	add	r0, sp, #36	; 0x24
 800471e:	f00f ffa2 	bl	8014666 <memset>
	if(!recordSnippet && enableOutput)
 8004722:	4ba5      	ldr	r3, [pc, #660]	; (80049b8 <CLI_CommandParser+0x324>)
 8004724:	781b      	ldrb	r3, [r3, #0]
 8004726:	2b00      	cmp	r3, #0
 8004728:	d10b      	bne.n	8004742 <CLI_CommandParser+0xae>
 800472a:	9b07      	ldr	r3, [sp, #28]
 800472c:	2b00      	cmp	r3, #0
 800472e:	d008      	beq.n	8004742 <CLI_CommandParser+0xae>
		writePxMutex(port, pcEndOfCommandOutputString, strlen(pcEndOfCommandOutputString), cmd50ms, HAL_MAX_DELAY);		
 8004730:	2301      	movs	r3, #1
 8004732:	425b      	negs	r3, r3
 8004734:	9300      	str	r3, [sp, #0]
 8004736:	2238      	movs	r2, #56	; 0x38
 8004738:	3333      	adds	r3, #51	; 0x33
 800473a:	49a2      	ldr	r1, [pc, #648]	; (80049c4 <CLI_CommandParser+0x330>)
 800473c:	9806      	ldr	r0, [sp, #24]
 800473e:	f008 fe6b 	bl	800d418 <writePxMutex>
}
 8004742:	b00d      	add	sp, #52	; 0x34
 8004744:	bdf0      	pop	{r4, r5, r6, r7, pc}
				recordSnippet = SNIPPET_COMMANDS;
 8004746:	2302      	movs	r3, #2
 8004748:	702b      	strb	r3, [r5, #0]
				pcOutputString[0] = '\r';
 800474a:	230d      	movs	r3, #13
 800474c:	7033      	strb	r3, [r6, #0]
				xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );		
 800474e:	0004      	movs	r4, r0
 8004750:	e7c6      	b.n	80046e0 <CLI_CommandParser+0x4c>
		else if (recordSnippet && !strncmp((char *)cInputString, "end if", 6))
 8004752:	2206      	movs	r2, #6
 8004754:	499c      	ldr	r1, [pc, #624]	; (80049c8 <CLI_CommandParser+0x334>)
 8004756:	9802      	ldr	r0, [sp, #8]
 8004758:	f010 f9c4 	bl	8014ae4 <strncmp>
 800475c:	2800      	cmp	r0, #0
 800475e:	d109      	bne.n	8004774 <CLI_CommandParser+0xe0>
			recordSnippet = 0;
 8004760:	7028      	strb	r0, [r5, #0]
			AddSnippet(SNIPPET_ACTIVATE, "");				
 8004762:	499a      	ldr	r1, [pc, #616]	; (80049cc <CLI_CommandParser+0x338>)
 8004764:	2003      	movs	r0, #3
 8004766:	f7ff ff75 	bl	8004654 <AddSnippet>
			sprintf( ( char * ) pcOutputString, "\nConditional statement accepted and added to Command Snippets.\n\r");
 800476a:	4999      	ldr	r1, [pc, #612]	; (80049d0 <CLI_CommandParser+0x33c>)
				sprintf( ( char * ) pcOutputString, "\nCannot store more Command Snippets. Please delete existing ones and try again.\n\r");
 800476c:	0030      	movs	r0, r6
 800476e:	f010 f9b1 	bl	8014ad4 <strcpy>
 8004772:	e7b4      	b.n	80046de <CLI_CommandParser+0x4a>
		else if (recordSnippet == SNIPPET_COMMANDS)
 8004774:	9b03      	ldr	r3, [sp, #12]
 8004776:	2b02      	cmp	r3, #2
 8004778:	d106      	bne.n	8004788 <CLI_CommandParser+0xf4>
 800477a:	9802      	ldr	r0, [sp, #8]
 800477c:	f7ff fd5e 	bl	800423c <AddSnippet.part.0>
			if (AddSnippet(SNIPPET_COMMANDS, ( char * ) cInputString) != BOS_OK)
 8004780:	2800      	cmp	r0, #0
 8004782:	d0e2      	beq.n	800474a <CLI_CommandParser+0xb6>
				sprintf( ( char * ) pcOutputString, "\nCannot store more Command Snippets. Please delete existing ones and try again.\n\r");
 8004784:	498e      	ldr	r1, [pc, #568]	; (80049c0 <CLI_CommandParser+0x32c>)
 8004786:	e7f1      	b.n	800476c <CLI_CommandParser+0xd8>
			loc = strchr( ( char * ) cInputString, '.');
 8004788:	212e      	movs	r1, #46	; 0x2e
 800478a:	9802      	ldr	r0, [sp, #8]
 800478c:	f010 f994 	bl	8014ab8 <strchr>
 8004790:	1e05      	subs	r5, r0, #0
			if ( loc != NULL && strncmp((char *)loc-3, "bos", 3) && !isdigit(*(loc+1)) ) 
 8004792:	d100      	bne.n	8004796 <CLI_CommandParser+0x102>
 8004794:	e10a      	b.n	80049ac <CLI_CommandParser+0x318>
 8004796:	3803      	subs	r0, #3
 8004798:	2203      	movs	r2, #3
 800479a:	498e      	ldr	r1, [pc, #568]	; (80049d4 <CLI_CommandParser+0x340>)
 800479c:	f010 f9a2 	bl	8014ae4 <strncmp>
 80047a0:	2800      	cmp	r0, #0
 80047a2:	d100      	bne.n	80047a6 <CLI_CommandParser+0x112>
 80047a4:	e102      	b.n	80049ac <CLI_CommandParser+0x318>
 80047a6:	f00f fd09 	bl	80141bc <__locale_ctype_ptr>
 80047aa:	2204      	movs	r2, #4
 80047ac:	786b      	ldrb	r3, [r5, #1]
 80047ae:	18c0      	adds	r0, r0, r3
 80047b0:	7843      	ldrb	r3, [r0, #1]
 80047b2:	401a      	ands	r2, r3
 80047b4:	9204      	str	r2, [sp, #16]
 80047b6:	d000      	beq.n	80047ba <CLI_CommandParser+0x126>
 80047b8:	e0f8      	b.n	80049ac <CLI_CommandParser+0x318>
				strncpy(idString, ( char * ) cInputString, (size_t) (loc - (char*)cInputString));
 80047ba:	9b02      	ldr	r3, [sp, #8]
 80047bc:	a809      	add	r0, sp, #36	; 0x24
 80047be:	1aea      	subs	r2, r5, r3
 80047c0:	0019      	movs	r1, r3
 80047c2:	f010 f9a0 	bl	8014b06 <strncpy>
				id = GetID(idString);
 80047c6:	a809      	add	r0, sp, #36	; 0x24
 80047c8:	f7ff fa8a 	bl	8003ce0 <GetID>
				if (id == myID) {
 80047cc:	4b82      	ldr	r3, [pc, #520]	; (80049d8 <CLI_CommandParser+0x344>)
				id = GetID(idString);
 80047ce:	0007      	movs	r7, r0
				if (id == myID) {
 80047d0:	781b      	ldrb	r3, [r3, #0]
 80047d2:	9305      	str	r3, [sp, #20]
 80047d4:	4298      	cmp	r0, r3
 80047d6:	d106      	bne.n	80047e6 <CLI_CommandParser+0x152>
					xReturned = FreeRTOS_CLIProcessCommand( (const signed char*)(loc+1), pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );		
 80047d8:	2299      	movs	r2, #153	; 0x99
 80047da:	0031      	movs	r1, r6
 80047dc:	1c68      	adds	r0, r5, #1
 80047de:	0092      	lsls	r2, r2, #2
				xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );		
 80047e0:	f00b f84c 	bl	800f87c <FreeRTOS_CLIProcessCommand>
 80047e4:	e7b3      	b.n	800474e <CLI_CommandParser+0xba>
					sprintf( ( char * ) pcOutputString, "Wrong module name! Please try again.\n\r");
 80047e6:	497d      	ldr	r1, [pc, #500]	; (80049dc <CLI_CommandParser+0x348>)
				}	else if (id == BOS_ERR_WrongName) {		
 80047e8:	2864      	cmp	r0, #100	; 0x64
 80047ea:	d0bf      	beq.n	800476c <CLI_CommandParser+0xd8>
					sprintf( ( char * ) pcOutputString, "Wrong module ID! Please try again.\n\r");
 80047ec:	497c      	ldr	r1, [pc, #496]	; (80049e0 <CLI_CommandParser+0x34c>)
				}	else if (id == BOS_ERR_WrongID) {
 80047ee:	2866      	cmp	r0, #102	; 0x66
 80047f0:	d0bc      	beq.n	800476c <CLI_CommandParser+0xd8>
 80047f2:	1c6b      	adds	r3, r5, #1
 80047f4:	9303      	str	r3, [sp, #12]
				}	else if (id == BOS_BROADCAST) {
 80047f6:	28ff      	cmp	r0, #255	; 0xff
 80047f8:	d12b      	bne.n	8004852 <CLI_CommandParser+0x1be>
					memset( broadcastResponse, 0x00, sizeof(broadcastResponse) );
 80047fa:	9904      	ldr	r1, [sp, #16]
 80047fc:	2219      	movs	r2, #25
 80047fe:	4879      	ldr	r0, [pc, #484]	; (80049e4 <CLI_CommandParser+0x350>)
 8004800:	f00f ff31 	bl	8014666 <memset>
					strncpy( ( char * ) messageParams, loc+1, (size_t)(strlen( (char*) cInputString)-strlen( (char*) idString)-1));
 8004804:	9802      	ldr	r0, [sp, #8]
 8004806:	f7fb fc87 	bl	8000118 <strlen>
 800480a:	0004      	movs	r4, r0
 800480c:	a809      	add	r0, sp, #36	; 0x24
 800480e:	f7fb fc83 	bl	8000118 <strlen>
 8004812:	3c01      	subs	r4, #1
 8004814:	1a22      	subs	r2, r4, r0
 8004816:	9903      	ldr	r1, [sp, #12]
 8004818:	4873      	ldr	r0, [pc, #460]	; (80049e8 <CLI_CommandParser+0x354>)
 800481a:	f010 f974 	bl	8014b06 <strncpy>
							BroadcastMessage(myID, BOS_BROADCAST, CODE_CLI_COMMAND, strlen( (char*) cInputString)-strlen( (char*) idString));		// Send terminating zero
 800481e:	9802      	ldr	r0, [sp, #8]
 8004820:	f7fb fc7a 	bl	8000118 <strlen>
 8004824:	0004      	movs	r4, r0
 8004826:	a809      	add	r0, sp, #36	; 0x24
 8004828:	f7fb fc76 	bl	8000118 <strlen>
 800482c:	1a23      	subs	r3, r4, r0
 800482e:	b29b      	uxth	r3, r3
 8004830:	0039      	movs	r1, r7
 8004832:	2217      	movs	r2, #23
 8004834:	9805      	ldr	r0, [sp, #20]
 8004836:	f003 fb5b 	bl	8007ef0 <BroadcastMessage>
					xReturned = FreeRTOS_CLIProcessCommand( (const signed char*)(loc+1), pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 800483a:	2299      	movs	r2, #153	; 0x99
 800483c:	0031      	movs	r1, r6
 800483e:	0092      	lsls	r2, r2, #2
 8004840:	9803      	ldr	r0, [sp, #12]
 8004842:	f00b f81b 	bl	800f87c <FreeRTOS_CLIProcessCommand>
					strcat( ( char * ) pcOutputString, "Command broadcasted to all\n\r");
 8004846:	4969      	ldr	r1, [pc, #420]	; (80049ec <CLI_CommandParser+0x358>)
					xReturned = FreeRTOS_CLIProcessCommand( (const signed char*)(loc+1), pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 8004848:	0004      	movs	r4, r0
					strcat( ( char * ) pcOutputString, "Command broadcasted to all\n\r");
 800484a:	0030      	movs	r0, r6
 800484c:	f010 f926 	bl	8014a9c <strcat>
 8004850:	e746      	b.n	80046e0 <CLI_CommandParser+0x4c>
				}	else if ((uint8_t)id == BOS_MULTICAST) {	
 8004852:	b2c5      	uxtb	r5, r0
 8004854:	2dfe      	cmp	r5, #254	; 0xfe
 8004856:	d13c      	bne.n	80048d2 <CLI_CommandParser+0x23e>
					group = id >> 8;
 8004858:	4b65      	ldr	r3, [pc, #404]	; (80049f0 <CLI_CommandParser+0x35c>)
 800485a:	1207      	asrs	r7, r0, #8
					memset( broadcastResponse, 0x00, sizeof(broadcastResponse) );
 800485c:	2219      	movs	r2, #25
 800485e:	9904      	ldr	r1, [sp, #16]
					group = id >> 8;
 8004860:	b2ff      	uxtb	r7, r7
					memset( broadcastResponse, 0x00, sizeof(broadcastResponse) );
 8004862:	4860      	ldr	r0, [pc, #384]	; (80049e4 <CLI_CommandParser+0x350>)
					group = id >> 8;
 8004864:	701f      	strb	r7, [r3, #0]
					memset( broadcastResponse, 0x00, sizeof(broadcastResponse) );
 8004866:	f00f fefe 	bl	8014666 <memset>
					strncpy( ( char * ) messageParams, loc+1, (size_t)(strlen( (char*) cInputString)-strlen( (char*) idString)-1));
 800486a:	9802      	ldr	r0, [sp, #8]
 800486c:	f7fb fc54 	bl	8000118 <strlen>
 8004870:	0005      	movs	r5, r0
 8004872:	a809      	add	r0, sp, #36	; 0x24
 8004874:	f7fb fc50 	bl	8000118 <strlen>
 8004878:	3d01      	subs	r5, #1
 800487a:	1a2a      	subs	r2, r5, r0
 800487c:	9903      	ldr	r1, [sp, #12]
 800487e:	485a      	ldr	r0, [pc, #360]	; (80049e8 <CLI_CommandParser+0x354>)
 8004880:	f010 f941 	bl	8014b06 <strncpy>
							BroadcastMessage(myID, group, CODE_CLI_COMMAND, strlen( (char*) cInputString)-strlen( (char*) idString));		// Send terminating zero
 8004884:	9802      	ldr	r0, [sp, #8]
 8004886:	f7fb fc47 	bl	8000118 <strlen>
 800488a:	0005      	movs	r5, r0
 800488c:	a809      	add	r0, sp, #36	; 0x24
 800488e:	f7fb fc43 	bl	8000118 <strlen>
 8004892:	1a2b      	subs	r3, r5, r0
 8004894:	b29b      	uxth	r3, r3
 8004896:	2217      	movs	r2, #23
 8004898:	0039      	movs	r1, r7
 800489a:	9805      	ldr	r0, [sp, #20]
 800489c:	f003 fb28 	bl	8007ef0 <BroadcastMessage>
					if (InGroup(myID, group))
 80048a0:	4b4d      	ldr	r3, [pc, #308]	; (80049d8 <CLI_CommandParser+0x344>)
 80048a2:	4a54      	ldr	r2, [pc, #336]	; (80049f4 <CLI_CommandParser+0x360>)
 80048a4:	781b      	ldrb	r3, [r3, #0]
 80048a6:	3b01      	subs	r3, #1
 80048a8:	005b      	lsls	r3, r3, #1
 80048aa:	5a9b      	ldrh	r3, [r3, r2]
 80048ac:	4a50      	ldr	r2, [pc, #320]	; (80049f0 <CLI_CommandParser+0x35c>)
 80048ae:	7812      	ldrb	r2, [r2, #0]
 80048b0:	4113      	asrs	r3, r2
 80048b2:	07db      	lsls	r3, r3, #31
 80048b4:	d506      	bpl.n	80048c4 <CLI_CommandParser+0x230>
						xReturned = FreeRTOS_CLIProcessCommand( (const signed char*)(loc+1), pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 80048b6:	2299      	movs	r2, #153	; 0x99
 80048b8:	0031      	movs	r1, r6
 80048ba:	0092      	lsls	r2, r2, #2
 80048bc:	9803      	ldr	r0, [sp, #12]
 80048be:	f00a ffdd 	bl	800f87c <FreeRTOS_CLIProcessCommand>
 80048c2:	0004      	movs	r4, r0
					sprintf( ( char * ) pcOutputString, "%sMulticast Command forwarded to group %s\n\r", pcOutputString, idString);
 80048c4:	ab09      	add	r3, sp, #36	; 0x24
 80048c6:	0032      	movs	r2, r6
 80048c8:	494b      	ldr	r1, [pc, #300]	; (80049f8 <CLI_CommandParser+0x364>)
 80048ca:	0030      	movs	r0, r6
 80048cc:	f010 f8c6 	bl	8014a5c <sprintf>
 80048d0:	e706      	b.n	80046e0 <CLI_CommandParser+0x4c>
					if (!strncmp((char *)loc+1, "update", 6)) {			// remote update
 80048d2:	2206      	movs	r2, #6
 80048d4:	4949      	ldr	r1, [pc, #292]	; (80049fc <CLI_CommandParser+0x368>)
 80048d6:	9803      	ldr	r0, [sp, #12]
 80048d8:	f010 f904 	bl	8014ae4 <strncmp>
 80048dc:	1e04      	subs	r4, r0, #0
 80048de:	d12b      	bne.n	8004938 <CLI_CommandParser+0x2a4>
						BOS.response = BOS_RESPONSE_NONE;				
 80048e0:	4b47      	ldr	r3, [pc, #284]	; (8004a00 <CLI_CommandParser+0x36c>)
								SendMessageToModule(id, CODE_UPDATE, 0);
 80048e2:	0002      	movs	r2, r0
						BOS.response = BOS_RESPONSE_NONE;				
 80048e4:	7198      	strb	r0, [r3, #6]
								SendMessageToModule(id, CODE_UPDATE, 0);
 80048e6:	2119      	movs	r1, #25
 80048e8:	0028      	movs	r0, r5
 80048ea:	f003 fb1f 	bl	8007f2c <SendMessageToModule>
						osDelay(100);
 80048ee:	2064      	movs	r0, #100	; 0x64
 80048f0:	f00a ff37 	bl	800f762 <osDelay>
						remoteBootloaderUpdate(myID, id, PcPort, 0);
 80048f4:	4b43      	ldr	r3, [pc, #268]	; (8004a04 <CLI_CommandParser+0x370>)
 80048f6:	0029      	movs	r1, r5
 80048f8:	781a      	ldrb	r2, [r3, #0]
 80048fa:	4b37      	ldr	r3, [pc, #220]	; (80049d8 <CLI_CommandParser+0x344>)
 80048fc:	7818      	ldrb	r0, [r3, #0]
 80048fe:	0023      	movs	r3, r4
 8004900:	f7fe ff4c 	bl	800379c <remoteBootloaderUpdate>
					if (BOS.response == BOS_RESPONSE_ALL)
 8004904:	4b3e      	ldr	r3, [pc, #248]	; (8004a00 <CLI_CommandParser+0x36c>)
 8004906:	799b      	ldrb	r3, [r3, #6]
 8004908:	2b60      	cmp	r3, #96	; 0x60
 800490a:	d000      	beq.n	800490e <CLI_CommandParser+0x27a>
 800490c:	e6e7      	b.n	80046de <CLI_CommandParser+0x4a>
						ulTaskNotifyTake(pdTRUE, 1000);		//cmd500ms
 800490e:	21fa      	movs	r1, #250	; 0xfa
 8004910:	2001      	movs	r0, #1
 8004912:	0089      	lsls	r1, r1, #2
 8004914:	f00c fa0e 	bl	8010d34 <ulTaskNotifyTake>
								if (responseStatus != BOS_OK) {
 8004918:	4b3b      	ldr	r3, [pc, #236]	; (8004a08 <CLI_CommandParser+0x374>)
 800491a:	781b      	ldrb	r3, [r3, #0]
 800491c:	2b00      	cmp	r3, #0
 800491e:	d100      	bne.n	8004922 <CLI_CommandParser+0x28e>
 8004920:	e6dd      	b.n	80046de <CLI_CommandParser+0x4a>
									++timedoutMsg;
 8004922:	4a3a      	ldr	r2, [pc, #232]	; (8004a0c <CLI_CommandParser+0x378>)
									sprintf( ( char * ) pcOutputString, "%sModule %d is not reachable.\n\r", ( char * ) pcOutputString, id);
 8004924:	493a      	ldr	r1, [pc, #232]	; (8004a10 <CLI_CommandParser+0x37c>)
									++timedoutMsg;
 8004926:	8813      	ldrh	r3, [r2, #0]
									sprintf( ( char * ) pcOutputString, "%sModule %d is not reachable.\n\r", ( char * ) pcOutputString, id);
 8004928:	0030      	movs	r0, r6
									++timedoutMsg;
 800492a:	3301      	adds	r3, #1
 800492c:	8013      	strh	r3, [r2, #0]
									sprintf( ( char * ) pcOutputString, "%sModule %d is not reachable.\n\r", ( char * ) pcOutputString, id);
 800492e:	003b      	movs	r3, r7
 8004930:	0032      	movs	r2, r6
 8004932:	f010 f893 	bl	8014a5c <sprintf>
 8004936:	e6d2      	b.n	80046de <CLI_CommandParser+0x4a>
						strncpy( ( char * ) messageParams, loc+1, (size_t)(strlen((char*) cInputString)-strlen((char*) idString)-1));
 8004938:	9802      	ldr	r0, [sp, #8]
 800493a:	f7fb fbed 	bl	8000118 <strlen>
 800493e:	0004      	movs	r4, r0
 8004940:	a809      	add	r0, sp, #36	; 0x24
 8004942:	f7fb fbe9 	bl	8000118 <strlen>
 8004946:	3c01      	subs	r4, #1
 8004948:	1a22      	subs	r2, r4, r0
 800494a:	9903      	ldr	r1, [sp, #12]
 800494c:	4826      	ldr	r0, [pc, #152]	; (80049e8 <CLI_CommandParser+0x354>)
 800494e:	f010 f8da 	bl	8014b06 <strncpy>
								SendMessageToModule(id, CODE_CLI_COMMAND, strlen((char*) cInputString)-strlen((char*) idString)-1);
 8004952:	9802      	ldr	r0, [sp, #8]
 8004954:	f7fb fbe0 	bl	8000118 <strlen>
 8004958:	0004      	movs	r4, r0
 800495a:	a809      	add	r0, sp, #36	; 0x24
 800495c:	f7fb fbdc 	bl	8000118 <strlen>
 8004960:	3c01      	subs	r4, #1
 8004962:	1a22      	subs	r2, r4, r0
 8004964:	b292      	uxth	r2, r2
 8004966:	2117      	movs	r1, #23
 8004968:	0028      	movs	r0, r5
 800496a:	f003 fadf 	bl	8007f2c <SendMessageToModule>
						sprintf( ( char * ) pcOutputString, "Command forwarded to Module %d\n\r", id);
 800496e:	003a      	movs	r2, r7
 8004970:	4928      	ldr	r1, [pc, #160]	; (8004a14 <CLI_CommandParser+0x380>)
 8004972:	0030      	movs	r0, r6
 8004974:	f010 f872 	bl	8014a5c <sprintf>
						if ((strlen((char*)pcOutputString) > 0) && enableOutput)
 8004978:	7833      	ldrb	r3, [r6, #0]
 800497a:	2b00      	cmp	r3, #0
 800497c:	d00d      	beq.n	800499a <CLI_CommandParser+0x306>
 800497e:	0030      	movs	r0, r6
 8004980:	f7fb fbca 	bl	8000118 <strlen>
 8004984:	9b07      	ldr	r3, [sp, #28]
 8004986:	2b00      	cmp	r3, #0
 8004988:	d007      	beq.n	800499a <CLI_CommandParser+0x306>
							writePxMutex(port, (char*)pcOutputString, strlen((char*)pcOutputString), cmd50ms, 1);		
 800498a:	2301      	movs	r3, #1
 800498c:	b282      	uxth	r2, r0
 800498e:	9300      	str	r3, [sp, #0]
 8004990:	0031      	movs	r1, r6
 8004992:	3331      	adds	r3, #49	; 0x31
 8004994:	9806      	ldr	r0, [sp, #24]
 8004996:	f008 fd3f 	bl	800d418 <writePxMutex>
						memset( pcOutputString, 0x00, strlen((char*)pcOutputString) );
 800499a:	0030      	movs	r0, r6
 800499c:	f7fb fbbc 	bl	8000118 <strlen>
 80049a0:	2100      	movs	r1, #0
 80049a2:	0002      	movs	r2, r0
 80049a4:	0030      	movs	r0, r6
 80049a6:	f00f fe5e 	bl	8014666 <memset>
 80049aa:	e7ab      	b.n	8004904 <CLI_CommandParser+0x270>
				xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );		
 80049ac:	2299      	movs	r2, #153	; 0x99
 80049ae:	0031      	movs	r1, r6
 80049b0:	0092      	lsls	r2, r2, #2
 80049b2:	9802      	ldr	r0, [sp, #8]
 80049b4:	e714      	b.n	80047e0 <CLI_CommandParser+0x14c>
 80049b6:	46c0      	nop			; (mov r8, r8)
 80049b8:	200011f4 	.word	0x200011f4
 80049bc:	080195d0 	.word	0x080195d0
 80049c0:	080195d4 	.word	0x080195d4
 80049c4:	0801974f 	.word	0x0801974f
 80049c8:	08019626 	.word	0x08019626
 80049cc:	080192c5 	.word	0x080192c5
 80049d0:	0801962d 	.word	0x0801962d
 80049d4:	0801966e 	.word	0x0801966e
 80049d8:	20001039 	.word	0x20001039
 80049dc:	08019672 	.word	0x08019672
 80049e0:	08019699 	.word	0x08019699
 80049e4:	20000cfa 	.word	0x20000cfa
 80049e8:	20000f07 	.word	0x20000f07
 80049ec:	080196be 	.word	0x080196be
 80049f0:	200011c6 	.word	0x200011c6
 80049f4:	20000e94 	.word	0x20000e94
 80049f8:	080196db 	.word	0x080196db
 80049fc:	08019707 	.word	0x08019707
 8004a00:	20006f70 	.word	0x20006f70
 8004a04:	20000a9f 	.word	0x20000a9f
 8004a08:	200010c8 	.word	0x200010c8
 8004a0c:	20001666 	.word	0x20001666
 8004a10:	0801972f 	.word	0x0801972f
 8004a14:	0801970e 	.word	0x0801970e

08004a18 <prvCLITask>:
	ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
 8004a18:	2101      	movs	r1, #1
{
 8004a1a:	b5f0      	push	{r4, r5, r6, r7, lr}
	ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
 8004a1c:	4249      	negs	r1, r1
{
 8004a1e:	b087      	sub	sp, #28
	ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
 8004a20:	2001      	movs	r0, #1
 8004a22:	f00c f987 	bl	8010d34 <ulTaskNotifyTake>
	cRxedChar = '\0';
 8004a26:	2300      	movs	r3, #0
 8004a28:	aa02      	add	r2, sp, #8
 8004a2a:	73d3      	strb	r3, [r2, #15]
	if (BOS.clibaudrate != DEF_ARRAY_BAUDRATE)
 8004a2c:	26e1      	movs	r6, #225	; 0xe1
	pcOutputString = FreeRTOS_CLIGetOutputBuffer();
 8004a2e:	f00a ff91 	bl	800f954 <FreeRTOS_CLIGetOutputBuffer>
	if (BOS.clibaudrate != DEF_ARRAY_BAUDRATE)
 8004a32:	4b4a      	ldr	r3, [pc, #296]	; (8004b5c <prvCLITask+0x144>)
	pcOutputString = FreeRTOS_CLIGetOutputBuffer();
 8004a34:	9003      	str	r0, [sp, #12]
	if (BOS.clibaudrate != DEF_ARRAY_BAUDRATE)
 8004a36:	689b      	ldr	r3, [r3, #8]
 8004a38:	0336      	lsls	r6, r6, #12
 8004a3a:	4d49      	ldr	r5, [pc, #292]	; (8004b60 <prvCLITask+0x148>)
 8004a3c:	42b3      	cmp	r3, r6
 8004a3e:	d00b      	beq.n	8004a58 <prvCLITask+0x40>
		for (uint8_t port=1 ; port<=NumOfPorts ; port++) 
 8004a40:	2401      	movs	r4, #1
			if (port != PcPort)
 8004a42:	782b      	ldrb	r3, [r5, #0]
 8004a44:	42a3      	cmp	r3, r4
 8004a46:	d003      	beq.n	8004a50 <prvCLITask+0x38>
				UpdateBaudrate(port, DEF_ARRAY_BAUDRATE);
 8004a48:	0031      	movs	r1, r6
 8004a4a:	0020      	movs	r0, r4
 8004a4c:	f008 fd44 	bl	800d4d8 <UpdateBaudrate>
		for (uint8_t port=1 ; port<=NumOfPorts ; port++) 
 8004a50:	3401      	adds	r4, #1
 8004a52:	b2e4      	uxtb	r4, r4
 8004a54:	2c06      	cmp	r4, #6
 8004a56:	d1f4      	bne.n	8004a42 <prvCLITask+0x2a>
	sprintf(pcWelcomePortMessage, "Connected to module %d (%s), port P%d.\n\n\r>", myID, modulePNstring[myPN], PcPort);
 8004a58:	4b42      	ldr	r3, [pc, #264]	; (8004b64 <prvCLITask+0x14c>)
 8004a5a:	4c43      	ldr	r4, [pc, #268]	; (8004b68 <prvCLITask+0x150>)
 8004a5c:	881a      	ldrh	r2, [r3, #0]
 8004a5e:	2306      	movs	r3, #6
 8004a60:	4353      	muls	r3, r2
 8004a62:	4a42      	ldr	r2, [pc, #264]	; (8004b6c <prvCLITask+0x154>)
 8004a64:	7829      	ldrb	r1, [r5, #0]
 8004a66:	189b      	adds	r3, r3, r2
 8004a68:	4a41      	ldr	r2, [pc, #260]	; (8004b70 <prvCLITask+0x158>)
 8004a6a:	0020      	movs	r0, r4
 8004a6c:	7812      	ldrb	r2, [r2, #0]
 8004a6e:	9100      	str	r1, [sp, #0]
 8004a70:	4940      	ldr	r1, [pc, #256]	; (8004b74 <prvCLITask+0x15c>)
 8004a72:	f00f fff3 	bl	8014a5c <sprintf>
	writePxITMutex(PcPort, pcWelcomeMessage, strlen(pcWelcomeMessage), 10);
 8004a76:	230a      	movs	r3, #10
 8004a78:	4a3f      	ldr	r2, [pc, #252]	; (8004b78 <prvCLITask+0x160>)
 8004a7a:	4940      	ldr	r1, [pc, #256]	; (8004b7c <prvCLITask+0x164>)
 8004a7c:	7828      	ldrb	r0, [r5, #0]
 8004a7e:	f008 fcf1 	bl	800d464 <writePxITMutex>
	writePxITMutex(PcPort, pcWelcomePortMessage, strlen(pcWelcomePortMessage), 10);
 8004a82:	0020      	movs	r0, r4
 8004a84:	f7fb fb48 	bl	8000118 <strlen>
 8004a88:	0021      	movs	r1, r4
 8004a8a:	b282      	uxth	r2, r0
 8004a8c:	230a      	movs	r3, #10
 8004a8e:	7828      	ldrb	r0, [r5, #0]
 8004a90:	f008 fce8 	bl	800d464 <writePxITMutex>
char cRxedChar; int8_t cInputIndex = 0, *pcOutputString; 
 8004a94:	2400      	movs	r4, #0
		for (chr=UARTRxBufIndex[PcPort-1] ; chr<MSG_RX_BUF_SIZE ; chr++)
 8004a96:	4f3a      	ldr	r7, [pc, #232]	; (8004b80 <prvCLITask+0x168>)
 8004a98:	782b      	ldrb	r3, [r5, #0]
 8004a9a:	18fb      	adds	r3, r7, r3
 8004a9c:	3b01      	subs	r3, #1
 8004a9e:	781e      	ldrb	r6, [r3, #0]
 8004aa0:	7828      	ldrb	r0, [r5, #0]
 8004aa2:	2e3f      	cmp	r6, #63	; 0x3f
 8004aa4:	d80c      	bhi.n	8004ac0 <prvCLITask+0xa8>
			if (UARTRxBuf[PcPort-1][chr]) {
 8004aa6:	1e41      	subs	r1, r0, #1
 8004aa8:	4a36      	ldr	r2, [pc, #216]	; (8004b84 <prvCLITask+0x16c>)
 8004aaa:	018b      	lsls	r3, r1, #6
 8004aac:	18d2      	adds	r2, r2, r3
 8004aae:	5d93      	ldrb	r3, [r2, r6]
 8004ab0:	2b00      	cmp	r3, #0
 8004ab2:	d031      	beq.n	8004b18 <prvCLITask+0x100>
				cRxedChar = UARTRxBuf[PcPort-1][chr];
 8004ab4:	af02      	add	r7, sp, #8
 8004ab6:	73fb      	strb	r3, [r7, #15]
				UARTRxBuf[PcPort-1][chr] = 0;
 8004ab8:	2300      	movs	r3, #0
 8004aba:	5593      	strb	r3, [r2, r6]
				UARTRxBufIndex[PcPort-1] = chr;
 8004abc:	4b30      	ldr	r3, [pc, #192]	; (8004b80 <prvCLITask+0x168>)
 8004abe:	545e      	strb	r6, [r3, r1]
		writePxITMutex(PcPort, &cRxedChar, 1, 10);
 8004ac0:	210f      	movs	r1, #15
 8004ac2:	ae02      	add	r6, sp, #8
 8004ac4:	230a      	movs	r3, #10
 8004ac6:	2201      	movs	r2, #1
 8004ac8:	1989      	adds	r1, r1, r6
 8004aca:	f008 fccb 	bl	800d464 <writePxITMutex>
		if( cRxedChar == '\r' )
 8004ace:	ab02      	add	r3, sp, #8
 8004ad0:	7bdb      	ldrb	r3, [r3, #15]
 8004ad2:	2b0d      	cmp	r3, #13
 8004ad4:	d129      	bne.n	8004b2a <prvCLITask+0x112>
			writePxITMutex(PcPort, pcNewLine, strlen(pcNewLine), 10);
 8004ad6:	7828      	ldrb	r0, [r5, #0]
 8004ad8:	3b03      	subs	r3, #3
 8004ada:	2202      	movs	r2, #2
 8004adc:	492a      	ldr	r1, [pc, #168]	; (8004b88 <prvCLITask+0x170>)
 8004ade:	f008 fcc1 	bl	800d464 <writePxITMutex>
 8004ae2:	4f2a      	ldr	r7, [pc, #168]	; (8004b8c <prvCLITask+0x174>)
 8004ae4:	4e2a      	ldr	r6, [pc, #168]	; (8004b90 <prvCLITask+0x178>)
			if( cInputIndex == 0 )
 8004ae6:	2c00      	cmp	r4, #0
 8004ae8:	d103      	bne.n	8004af2 <prvCLITask+0xda>
				strcpy( ( char * ) cInputString, ( char * ) cLastInputString );
 8004aea:	0039      	movs	r1, r7
 8004aec:	0030      	movs	r0, r6
 8004aee:	f00f fff1 	bl	8014ad4 <strcpy>
			CLI_CommandParser(PcPort, true, cInputString, pcOutputString);
 8004af2:	9b03      	ldr	r3, [sp, #12]
 8004af4:	0032      	movs	r2, r6
 8004af6:	7828      	ldrb	r0, [r5, #0]
 8004af8:	2101      	movs	r1, #1
 8004afa:	f7ff fdcb 	bl	8004694 <CLI_CommandParser>
			strcpy( ( char * ) cLastInputString, ( char * ) cInputString );
 8004afe:	0031      	movs	r1, r6
 8004b00:	0038      	movs	r0, r7
 8004b02:	f00f ffe7 	bl	8014ad4 <strcpy>
			memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );
 8004b06:	2232      	movs	r2, #50	; 0x32
 8004b08:	2100      	movs	r1, #0
 8004b0a:	0030      	movs	r0, r6
 8004b0c:	f00f fdab 	bl	8014666 <memset>
			cInputIndex = 0;
 8004b10:	2400      	movs	r4, #0
		taskYIELD();
 8004b12:	f00c fb9f 	bl	8011254 <vPortYield>
		for (chr=UARTRxBufIndex[PcPort-1] ; chr<MSG_RX_BUF_SIZE ; chr++)
 8004b16:	e7be      	b.n	8004a96 <prvCLITask+0x7e>
			if (chr == MSG_RX_BUF_SIZE-1)	{
 8004b18:	2e3f      	cmp	r6, #63	; 0x3f
 8004b1a:	d101      	bne.n	8004b20 <prvCLITask+0x108>
				chr = UARTRxBufIndex[PcPort-1] = 0;
 8004b1c:	001e      	movs	r6, r3
 8004b1e:	547b      	strb	r3, [r7, r1]
		for (chr=UARTRxBufIndex[PcPort-1] ; chr<MSG_RX_BUF_SIZE ; chr++)
 8004b20:	3601      	adds	r6, #1
			taskYIELD();
 8004b22:	f00c fb97 	bl	8011254 <vPortYield>
		for (chr=UARTRxBufIndex[PcPort-1] ; chr<MSG_RX_BUF_SIZE ; chr++)
 8004b26:	b2b6      	uxth	r6, r6
 8004b28:	e7ba      	b.n	8004aa0 <prvCLITask+0x88>
			if( cRxedChar == '\n' )
 8004b2a:	2b0a      	cmp	r3, #10
 8004b2c:	d0f1      	beq.n	8004b12 <prvCLITask+0xfa>
			else if( cRxedChar == '\b' )
 8004b2e:	2b08      	cmp	r3, #8
 8004b30:	d108      	bne.n	8004b44 <prvCLITask+0x12c>
				if( cInputIndex > 0 )
 8004b32:	2c00      	cmp	r4, #0
 8004b34:	d0ed      	beq.n	8004b12 <prvCLITask+0xfa>
					cInputString[ cInputIndex ] = '\0';
 8004b36:	2100      	movs	r1, #0
					cInputIndex--;
 8004b38:	3c01      	subs	r4, #1
					cInputString[ cInputIndex ] = '\0';
 8004b3a:	4a15      	ldr	r2, [pc, #84]	; (8004b90 <prvCLITask+0x178>)
					cInputIndex--;
 8004b3c:	b2e3      	uxtb	r3, r4
 8004b3e:	b25c      	sxtb	r4, r3
					cInputString[ cInputIndex ] = '\0';
 8004b40:	54d1      	strb	r1, [r2, r3]
 8004b42:	e7e6      	b.n	8004b12 <prvCLITask+0xfa>
				if( ( cRxedChar >= ' ' ) && ( cRxedChar <= '~' ) )
 8004b44:	001a      	movs	r2, r3
 8004b46:	3a20      	subs	r2, #32
 8004b48:	2a5e      	cmp	r2, #94	; 0x5e
 8004b4a:	d8e2      	bhi.n	8004b12 <prvCLITask+0xfa>
					if( cInputIndex < cmdMAX_INPUT_SIZE )
 8004b4c:	2c31      	cmp	r4, #49	; 0x31
 8004b4e:	dce0      	bgt.n	8004b12 <prvCLITask+0xfa>
						cInputString[ cInputIndex ] = cRxedChar;
 8004b50:	4a0f      	ldr	r2, [pc, #60]	; (8004b90 <prvCLITask+0x178>)
 8004b52:	5513      	strb	r3, [r2, r4]
						cInputIndex++;
 8004b54:	3401      	adds	r4, #1
 8004b56:	b264      	sxtb	r4, r4
 8004b58:	e7db      	b.n	8004b12 <prvCLITask+0xfa>
 8004b5a:	46c0      	nop			; (mov r8, r8)
 8004b5c:	20006f70 	.word	0x20006f70
 8004b60:	20000a9f 	.word	0x20000a9f
 8004b64:	20000050 	.word	0x20000050
 8004b68:	200011c8 	.word	0x200011c8
 8004b6c:	0801930e 	.word	0x0801930e
 8004b70:	20001039 	.word	0x20001039
 8004b74:	080197a3 	.word	0x080197a3
 8004b78:	00000293 	.word	0x00000293
 8004b7c:	080197ce 	.word	0x080197ce
 8004b80:	200013b1 	.word	0x200013b1
 8004b84:	20001271 	.word	0x20001271
 8004b88:	0801aae8 	.word	0x0801aae8
 8004b8c:	20001194 	.word	0x20001194
 8004b90:	200010fe 	.word	0x200010fe

08004b94 <ParseSnippetCommand>:
/*-----------------------------------------------------------*/

/* Parse Snippet commands into the internal buffer
*/
bool ParseSnippetCommand(char *snippetBuffer, int8_t *cliBuffer)
{
 8004b94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static char *ptrStart, *ptrEnd;
	
	if (snippets[numOfRecordedSnippets-1].cmd == NULL)	return false;
 8004b96:	4b18      	ldr	r3, [pc, #96]	; (8004bf8 <ParseSnippetCommand+0x64>)
{
 8004b98:	0004      	movs	r4, r0
	if (snippets[numOfRecordedSnippets-1].cmd == NULL)	return false;
 8004b9a:	781a      	ldrb	r2, [r3, #0]
 8004b9c:	2314      	movs	r3, #20
 8004b9e:	3a01      	subs	r2, #1
 8004ba0:	435a      	muls	r2, r3
 8004ba2:	4b16      	ldr	r3, [pc, #88]	; (8004bfc <ParseSnippetCommand+0x68>)
{
 8004ba4:	000d      	movs	r5, r1
	if (snippets[numOfRecordedSnippets-1].cmd == NULL)	return false;
 8004ba6:	189b      	adds	r3, r3, r2
 8004ba8:	68db      	ldr	r3, [r3, #12]
 8004baa:	1e18      	subs	r0, r3, #0
 8004bac:	d009      	beq.n	8004bc2 <ParseSnippetCommand+0x2e>
	
	// Initialize the start pointer to snippet buffer address
	if (!ptrStart)	ptrStart = snippetBuffer;	
 8004bae:	4e14      	ldr	r6, [pc, #80]	; (8004c00 <ParseSnippetCommand+0x6c>)
 8004bb0:	6833      	ldr	r3, [r6, #0]
 8004bb2:	2b00      	cmp	r3, #0
 8004bb4:	d100      	bne.n	8004bb8 <ParseSnippetCommand+0x24>
 8004bb6:	6034      	str	r4, [r6, #0]
	
	// Did we already reach end of Snippet buffer?
	if (*ptrStart == 0x00) {
 8004bb8:	6834      	ldr	r4, [r6, #0]
 8004bba:	7820      	ldrb	r0, [r4, #0]
 8004bbc:	2800      	cmp	r0, #0
 8004bbe:	d101      	bne.n	8004bc4 <ParseSnippetCommand+0x30>
		ptrStart = 0;		// Initialize the start pointer for next Snippet
 8004bc0:	6030      	str	r0, [r6, #0]
		strcpy((char *)cliBuffer, ptrStart);
		ptrStart += strlen((const char *) cliBuffer);
	}

	return true;
}
 8004bc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ptrEnd = strchr(ptrStart,0x13);
 8004bc4:	2113      	movs	r1, #19
 8004bc6:	0020      	movs	r0, r4
 8004bc8:	f00f ff76 	bl	8014ab8 <strchr>
 8004bcc:	1e07      	subs	r7, r0, #0
	if (ptrEnd != NULL)
 8004bce:	d008      	beq.n	8004be2 <ParseSnippetCommand+0x4e>
		strncpy((char *)cliBuffer, ptrStart, ptrEnd-ptrStart);
 8004bd0:	1b02      	subs	r2, r0, r4
 8004bd2:	0021      	movs	r1, r4
 8004bd4:	0028      	movs	r0, r5
		ptrStart = ptrEnd+1;
 8004bd6:	3701      	adds	r7, #1
		strncpy((char *)cliBuffer, ptrStart, ptrEnd-ptrStart);
 8004bd8:	f00f ff95 	bl	8014b06 <strncpy>
		ptrStart = ptrEnd+1;
 8004bdc:	6037      	str	r7, [r6, #0]
	return true;
 8004bde:	2001      	movs	r0, #1
 8004be0:	e7ef      	b.n	8004bc2 <ParseSnippetCommand+0x2e>
		strcpy((char *)cliBuffer, ptrStart);
 8004be2:	0021      	movs	r1, r4
 8004be4:	0028      	movs	r0, r5
 8004be6:	f00f ff75 	bl	8014ad4 <strcpy>
		ptrStart += strlen((const char *) cliBuffer);
 8004bea:	0028      	movs	r0, r5
 8004bec:	f7fb fa94 	bl	8000118 <strlen>
 8004bf0:	1824      	adds	r4, r4, r0
 8004bf2:	6034      	str	r4, [r6, #0]
 8004bf4:	e7f3      	b.n	8004bde <ParseSnippetCommand+0x4a>
 8004bf6:	46c0      	nop			; (mov r8, r8)
 8004bf8:	200011c7 	.word	0x200011c7
 8004bfc:	20006f8c 	.word	0x20006f8c
 8004c00:	200011f0 	.word	0x200011f0

08004c04 <CheckSnippetCondition>:
	uint8_t temp8;
	float flt1, flt2;
	
	/* Check conditions based on Snippet tupe */	

	switch (snippets[index].cond.conditionType)
 8004c04:	2314      	movs	r3, #20
{
 8004c06:	b537      	push	{r0, r1, r2, r4, r5, lr}
	switch (snippets[index].cond.conditionType)
 8004c08:	4358      	muls	r0, r3
 8004c0a:	492d      	ldr	r1, [pc, #180]	; (8004cc0 <CheckSnippetCondition+0xbc>)
 8004c0c:	5c0b      	ldrb	r3, [r1, r0]
 8004c0e:	2b01      	cmp	r3, #1
 8004c10:	d003      	beq.n	8004c1a <CheckSnippetCondition+0x16>
 8004c12:	2b03      	cmp	r3, #3
 8004c14:	d00d      	beq.n	8004c32 <CheckSnippetCondition+0x2e>
					
  	default:
  		break;
  }
	
	return false;
 8004c16:	2000      	movs	r0, #0
 8004c18:	e00a      	b.n	8004c30 <CheckSnippetCondition+0x2c>
			if (snippets[index].cond.buffer1[1] == button[temp8].state)
 8004c1a:	2309      	movs	r3, #9
  		temp8 = snippets[index].cond.buffer1[0]; 	// Button port
 8004c1c:	1809      	adds	r1, r1, r0
			if (snippets[index].cond.buffer1[1] == button[temp8].state)
 8004c1e:	788a      	ldrb	r2, [r1, #2]
 8004c20:	4353      	muls	r3, r2
 8004c22:	4a28      	ldr	r2, [pc, #160]	; (8004cc4 <CheckSnippetCondition+0xc0>)
 8004c24:	5c98      	ldrb	r0, [r3, r2]
 8004c26:	78cb      	ldrb	r3, [r1, #3]
 8004c28:	1ac0      	subs	r0, r0, r3
 8004c2a:	4243      	negs	r3, r0
 8004c2c:	4158      	adcs	r0, r3
 8004c2e:	b2c0      	uxtb	r0, r0
}
 8004c30:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
			flt1 = *(float *)modParam[snippets[index].cond.buffer1[1]-1].paramPtr;
 8004c32:	230c      	movs	r3, #12
 8004c34:	180c      	adds	r4, r1, r0
 8004c36:	78e2      	ldrb	r2, [r4, #3]
			memcpy( (uint8_t *)&flt2, &snippets[index].cond.buffer2, sizeof(float));		// This buffer can be misaligned and cause hardfault on F0
 8004c38:	3006      	adds	r0, #6
			flt1 = *(float *)modParam[snippets[index].cond.buffer1[1]-1].paramPtr;
 8004c3a:	3a01      	subs	r2, #1
 8004c3c:	4353      	muls	r3, r2
 8004c3e:	4a22      	ldr	r2, [pc, #136]	; (8004cc8 <CheckSnippetCondition+0xc4>)
			memcpy( (uint8_t *)&flt2, &snippets[index].cond.buffer2, sizeof(float));		// This buffer can be misaligned and cause hardfault on F0
 8004c40:	1841      	adds	r1, r0, r1
			flt1 = *(float *)modParam[snippets[index].cond.buffer1[1]-1].paramPtr;
 8004c42:	589b      	ldr	r3, [r3, r2]
			memcpy( (uint8_t *)&flt2, &snippets[index].cond.buffer2, sizeof(float));		// This buffer can be misaligned and cause hardfault on F0
 8004c44:	a801      	add	r0, sp, #4
 8004c46:	2204      	movs	r2, #4
			flt1 = *(float *)modParam[snippets[index].cond.buffer1[1]-1].paramPtr;
 8004c48:	681d      	ldr	r5, [r3, #0]
			memcpy( (uint8_t *)&flt2, &snippets[index].cond.buffer2, sizeof(float));		// This buffer can be misaligned and cause hardfault on F0
 8004c4a:	f00f fd03 	bl	8014654 <memcpy>
			switch (snippets[index].cond.mathOperator)
 8004c4e:	7860      	ldrb	r0, [r4, #1]
 8004c50:	3801      	subs	r0, #1
 8004c52:	2805      	cmp	r0, #5
 8004c54:	d8df      	bhi.n	8004c16 <CheckSnippetCondition+0x12>
 8004c56:	f7fb fa71 	bl	800013c <__gnu_thumb1_case_uqi>
 8004c5a:	0c03      	.short	0x0c03
 8004c5c:	2c272112 	.word	0x2c272112
      	case MATH_EQUAL:					if (flt1 == flt2)	return true;	break;
 8004c60:	1c29      	adds	r1, r5, #0
 8004c62:	9801      	ldr	r0, [sp, #4]
 8004c64:	2401      	movs	r4, #1
 8004c66:	f7fb fc53 	bl	8000510 <__aeabi_fcmpeq>
			  case MATH_GREATER_EQUAL:	if (flt1 >= flt2)	return true;	break;
 8004c6a:	2800      	cmp	r0, #0
 8004c6c:	d114      	bne.n	8004c98 <CheckSnippetCondition+0x94>
				case MATH_NOT_EQUAL:			if (flt1 != flt2 && flt1 != 0.0f)	return true;	break;
 8004c6e:	2400      	movs	r4, #0
 8004c70:	e012      	b.n	8004c98 <CheckSnippetCondition+0x94>
      	case MATH_GREATER:				if (flt1 > flt2)	return true;	break;
 8004c72:	1c29      	adds	r1, r5, #0
 8004c74:	9801      	ldr	r0, [sp, #4]
 8004c76:	2401      	movs	r4, #1
 8004c78:	f7fb fc50 	bl	800051c <__aeabi_fcmplt>
 8004c7c:	e7f5      	b.n	8004c6a <CheckSnippetCondition+0x66>
		    case MATH_SMALLER:				if (flt1 < flt2 && flt1 != 0.0f)	return true;	break;
 8004c7e:	1c29      	adds	r1, r5, #0
 8004c80:	9801      	ldr	r0, [sp, #4]
 8004c82:	f7fb fc5f 	bl	8000544 <__aeabi_fcmpgt>
			  case MATH_SMALLER_EQUAL:	if (flt1 <= flt2 && flt1 != 0.0f)	return true;	break;
 8004c86:	2800      	cmp	r0, #0
 8004c88:	d0c5      	beq.n	8004c16 <CheckSnippetCondition+0x12>
				case MATH_NOT_EQUAL:			if (flt1 != flt2 && flt1 != 0.0f)	return true;	break;
 8004c8a:	2100      	movs	r1, #0
 8004c8c:	1c28      	adds	r0, r5, #0
 8004c8e:	2401      	movs	r4, #1
 8004c90:	f7fb fc3e 	bl	8000510 <__aeabi_fcmpeq>
 8004c94:	2800      	cmp	r0, #0
 8004c96:	d1ea      	bne.n	8004c6e <CheckSnippetCondition+0x6a>
 8004c98:	b2e0      	uxtb	r0, r4
 8004c9a:	e7c9      	b.n	8004c30 <CheckSnippetCondition+0x2c>
			  case MATH_GREATER_EQUAL:	if (flt1 >= flt2)	return true;	break;
 8004c9c:	1c29      	adds	r1, r5, #0
 8004c9e:	9801      	ldr	r0, [sp, #4]
 8004ca0:	2401      	movs	r4, #1
 8004ca2:	f7fb fc45 	bl	8000530 <__aeabi_fcmple>
 8004ca6:	e7e0      	b.n	8004c6a <CheckSnippetCondition+0x66>
			  case MATH_SMALLER_EQUAL:	if (flt1 <= flt2 && flt1 != 0.0f)	return true;	break;
 8004ca8:	1c29      	adds	r1, r5, #0
 8004caa:	9801      	ldr	r0, [sp, #4]
 8004cac:	f7fb fc54 	bl	8000558 <__aeabi_fcmpge>
 8004cb0:	e7e9      	b.n	8004c86 <CheckSnippetCondition+0x82>
				case MATH_NOT_EQUAL:			if (flt1 != flt2 && flt1 != 0.0f)	return true;	break;
 8004cb2:	1c29      	adds	r1, r5, #0
 8004cb4:	9801      	ldr	r0, [sp, #4]
 8004cb6:	f7fb fc2b 	bl	8000510 <__aeabi_fcmpeq>
 8004cba:	2800      	cmp	r0, #0
 8004cbc:	d0e5      	beq.n	8004c8a <CheckSnippetCondition+0x86>
 8004cbe:	e7aa      	b.n	8004c16 <CheckSnippetCondition+0x12>
 8004cc0:	20006f8c 	.word	0x20006f8c
 8004cc4:	20001458 	.word	0x20001458
 8004cc8:	2000008c 	.word	0x2000008c

08004ccc <ExecuteSnippet>:
/*-----------------------------------------------------------*/

/* Execute activated Command Snippets
*/
BOS_Status ExecuteSnippet(void)
{
 8004ccc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	
	/* Must get this address even if output is not used otherwise memory will corrupt */
	/* Obtain the address of the output buffer.  Note there is no mutual
	exclusion on this buffer as it is assumed only one command console
	interface will be used at any one time. */
	pcOutputString = FreeRTOS_CLIGetOutputBuffer();	
 8004cce:	f00a fe41 	bl	800f954 <FreeRTOS_CLIGetOutputBuffer>
	
	/* Go through activated Snippets */
	for(s=0 ; s<numOfRecordedSnippets ; s++)
 8004cd2:	2400      	movs	r4, #0
	pcOutputString = FreeRTOS_CLIGetOutputBuffer();	
 8004cd4:	0006      	movs	r6, r0
	for(s=0 ; s<numOfRecordedSnippets ; s++)
 8004cd6:	4b17      	ldr	r3, [pc, #92]	; (8004d34 <ExecuteSnippet+0x68>)
 8004cd8:	781a      	ldrb	r2, [r3, #0]
 8004cda:	b2a3      	uxth	r3, r4
 8004cdc:	429a      	cmp	r2, r3
 8004cde:	d801      	bhi.n	8004ce4 <ExecuteSnippet+0x18>
			}
		}
  }
	
	return result;
}
 8004ce0:	2000      	movs	r0, #0
 8004ce2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004ce4:	2514      	movs	r5, #20
 8004ce6:	4365      	muls	r5, r4
 8004ce8:	4b13      	ldr	r3, [pc, #76]	; (8004d38 <ExecuteSnippet+0x6c>)
 8004cea:	18ed      	adds	r5, r5, r3
		if (snippets[s].state)								// Check for activated Snippets
 8004cec:	7c2b      	ldrb	r3, [r5, #16]
 8004cee:	2b00      	cmp	r3, #0
 8004cf0:	d101      	bne.n	8004cf6 <ExecuteSnippet+0x2a>
 8004cf2:	3401      	adds	r4, #1
 8004cf4:	e7ef      	b.n	8004cd6 <ExecuteSnippet+0xa>
			if (CheckSnippetCondition(s))				// Process Snippet condition 				
 8004cf6:	b2e0      	uxtb	r0, r4
 8004cf8:	f7ff ff84 	bl	8004c04 <CheckSnippetCondition>
 8004cfc:	2800      	cmp	r0, #0
 8004cfe:	d0f8      	beq.n	8004cf2 <ExecuteSnippet+0x26>
				BOS.response = BOS_RESPONSE_MSG;		// Disable CLI response
 8004d00:	2220      	movs	r2, #32
 8004d02:	4b0e      	ldr	r3, [pc, #56]	; (8004d3c <ExecuteSnippet+0x70>)
 8004d04:	719a      	strb	r2, [r3, #6]
				while (ParseSnippetCommand(snippets[s].cmd, (int8_t *) &cInputString) != false)
 8004d06:	4f0e      	ldr	r7, [pc, #56]	; (8004d40 <ExecuteSnippet+0x74>)
 8004d08:	68e8      	ldr	r0, [r5, #12]
 8004d0a:	0039      	movs	r1, r7
 8004d0c:	f7ff ff42 	bl	8004b94 <ParseSnippetCommand>
 8004d10:	2800      	cmp	r0, #0
 8004d12:	d0ee      	beq.n	8004cf2 <ExecuteSnippet+0x26>
					CLI_CommandParser(PcPort, false, cInputString, pcOutputString);
 8004d14:	4b0b      	ldr	r3, [pc, #44]	; (8004d44 <ExecuteSnippet+0x78>)
 8004d16:	003a      	movs	r2, r7
 8004d18:	7818      	ldrb	r0, [r3, #0]
 8004d1a:	2100      	movs	r1, #0
 8004d1c:	0033      	movs	r3, r6
 8004d1e:	f7ff fcb9 	bl	8004694 <CLI_CommandParser>
					memset( pcOutputString, 0x00, strlen((char*) pcOutputString) );
 8004d22:	0030      	movs	r0, r6
 8004d24:	f7fb f9f8 	bl	8000118 <strlen>
 8004d28:	2100      	movs	r1, #0
 8004d2a:	0002      	movs	r2, r0
 8004d2c:	0030      	movs	r0, r6
 8004d2e:	f00f fc9a 	bl	8014666 <memset>
 8004d32:	e7e8      	b.n	8004d06 <ExecuteSnippet+0x3a>
 8004d34:	200011c7 	.word	0x200011c7
 8004d38:	20006f8c 	.word	0x20006f8c
 8004d3c:	20006f70 	.word	0x20006f70
 8004d40:	20001162 	.word	0x20001162
 8004d44:	20000a9f 	.word	0x20000a9f

08004d48 <exploreCommand>:
//	
//	/* There is no more data to return after this single string, so return
//	pdFALSE. */
//	return pdFALSE;
return 0;
}
 8004d48:	2000      	movs	r0, #0
 8004d4a:	4770      	bx	lr

08004d4c <setBaudrateCommand>:
}

/*-----------------------------------------------------------*/

static portBASE_TYPE setBaudrateCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
 8004d4c:	b5f0      	push	{r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;

	int8_t *pcParameterString1;
	int8_t *pcParameterString2;
	portBASE_TYPE xParameterStringLength1 = 0;
 8004d4e:	2500      	movs	r5, #0
{
 8004d50:	b085      	sub	sp, #20
 8004d52:	0004      	movs	r4, r0
 8004d54:	0017      	movs	r7, r2
	portBASE_TYPE xParameterStringLength1 = 0;
 8004d56:	9502      	str	r5, [sp, #8]
	portBASE_TYPE xParameterStringLength2 = 0;
 8004d58:	9503      	str	r5, [sp, #12]

	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 8004d5a:	42a8      	cmp	r0, r5
 8004d5c:	d101      	bne.n	8004d62 <setBaudrateCommand+0x16>
 8004d5e:	b672      	cpsid	i
 8004d60:	e7fe      	b.n	8004d60 <setBaudrateCommand+0x14>

	/* 1st parameter for port name: P1 to P6 */
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8004d62:	aa02      	add	r2, sp, #8
 8004d64:	2101      	movs	r1, #1
 8004d66:	0038      	movs	r0, r7
 8004d68:	f00a fdf8 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString1[0] == 'p') {
 8004d6c:	2300      	movs	r3, #0
 8004d6e:	56c3      	ldrsb	r3, [r0, r3]
		port = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
	}
	else
	{
		result = BOS_ERR_WrongValue;
 8004d70:	2668      	movs	r6, #104	; 0x68
	if (pcParameterString1[0] == 'p') {
 8004d72:	2b70      	cmp	r3, #112	; 0x70
 8004d74:	d105      	bne.n	8004d82 <setBaudrateCommand+0x36>
		port = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
 8004d76:	3001      	adds	r0, #1
 8004d78:	f00f f9f2 	bl	8014160 <atol>
	BOS_Status result = BOS_OK;
 8004d7c:	002e      	movs	r6, r5
		port = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
 8004d7e:	b2c3      	uxtb	r3, r0
 8004d80:	9301      	str	r3, [sp, #4]
	}
  /* 2nd parameter for baudrate */
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8004d82:	aa03      	add	r2, sp, #12
 8004d84:	2102      	movs	r1, #2
 8004d86:	0038      	movs	r0, r7
 8004d88:	f00a fde8 	bl	800f95c <FreeRTOS_CLIGetParameter>
	baudrate = ( uint32_t ) atol( ( char * ) pcParameterString2 );
 8004d8c:	f00f f9e8 	bl	8014160 <atol>
 8004d90:	0005      	movs	r5, r0

	/* Respond to the command */
	if (BOS_ERR_WrongValue == result)
 8004d92:	2e68      	cmp	r6, #104	; 0x68
 8004d94:	d106      	bne.n	8004da4 <setBaudrateCommand+0x58>
	{
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongParam );
 8004d96:	4909      	ldr	r1, [pc, #36]	; (8004dbc <setBaudrateCommand+0x70>)
 8004d98:	0020      	movs	r0, r4
 8004d9a:	f00f fe9b 	bl	8014ad4 <strcpy>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, baudrate, port);
  }

	/* There is no more data to return after this single string, so return pdFALSE. */
	return pdFALSE;
}
 8004d9e:	2000      	movs	r0, #0
 8004da0:	b005      	add	sp, #20
 8004da2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		UpdateBaudrate(port, baudrate);
 8004da4:	0001      	movs	r1, r0
 8004da6:	9801      	ldr	r0, [sp, #4]
 8004da8:	f008 fb96 	bl	800d4d8 <UpdateBaudrate>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, baudrate, port);
 8004dac:	9b01      	ldr	r3, [sp, #4]
 8004dae:	002a      	movs	r2, r5
 8004db0:	4903      	ldr	r1, [pc, #12]	; (8004dc0 <setBaudrateCommand+0x74>)
 8004db2:	0020      	movs	r0, r4
 8004db4:	f00f fe52 	bl	8014a5c <sprintf>
 8004db8:	e7f1      	b.n	8004d9e <setBaudrateCommand+0x52>
 8004dba:	46c0      	nop			; (mov r8, r8)
 8004dbc:	0801a2c4 	.word	0x0801a2c4
 8004dc0:	0801a2d7 	.word	0x0801a2d7

08004dc4 <flashsizeCommand>:
}

/*-----------------------------------------------------------*/

static portBASE_TYPE flashsizeCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{	
 8004dc4:	b510      	push	{r4, lr}
	
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 8004dc6:	2800      	cmp	r0, #0
 8004dc8:	d101      	bne.n	8004dce <flashsizeCommand+0xa>
 8004dca:	b672      	cpsid	i
 8004dcc:	e7fe      	b.n	8004dcc <flashsizeCommand+0x8>
	
	/* Respond to the command */
	sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageFLASH, (*(uint32_t *) (MCU_F0_FLASH_SIZE_BASE)) & 0x0000FFFF );
 8004dce:	4b04      	ldr	r3, [pc, #16]	; (8004de0 <flashsizeCommand+0x1c>)
 8004dd0:	4904      	ldr	r1, [pc, #16]	; (8004de4 <flashsizeCommand+0x20>)
 8004dd2:	681a      	ldr	r2, [r3, #0]
 8004dd4:	b292      	uxth	r2, r2
 8004dd6:	f00f fe41 	bl	8014a5c <sprintf>


	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
 8004dda:	2000      	movs	r0, #0
 8004ddc:	bd10      	pop	{r4, pc}
 8004dde:	46c0      	nop			; (mov r8, r8)
 8004de0:	1ffff7cc 	.word	0x1ffff7cc
 8004de4:	08019cd4 	.word	0x08019cd4

08004de8 <testportCommand>:
	static const int8_t *pcMessageWrong = ( int8_t * ) "Wrong syntax\n\r";
	static const int8_t *pcMessageFail = ( int8_t * ) "P%d test failed\n\r";
  static const int8_t *pcMessageWrong1 = ( int8_t * ) "the port number is wrong\n\r";
  static const int8_t *pcMessageWait = ( int8_t * )"Please shorten the next port and press any key to continue testing the next one\n\r\n\r";
	int8_t *pcParameterString1;
	portBASE_TYPE xParameterStringLength1 = 0;
 8004de8:	2300      	movs	r3, #0
{	
 8004dea:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004dec:	b087      	sub	sp, #28
	portBASE_TYPE xParameterStringLength1 = 0;
 8004dee:	9305      	str	r3, [sp, #20]
	BOS_Status result = BOS_OK;
	uint8_t portt,ports;
  extern uint8_t UARTRxBufIndex[NumOfPorts];
  char WriteVaule[1]="H";
 8004df0:	4b4e      	ldr	r3, [pc, #312]	; (8004f2c <testportCommand+0x144>)
 8004df2:	ae04      	add	r6, sp, #16
 8004df4:	781b      	ldrb	r3, [r3, #0]
{	
 8004df6:	0004      	movs	r4, r0
  char WriteVaule[1]="H";
 8004df8:	7033      	strb	r3, [r6, #0]
{	
 8004dfa:	0010      	movs	r0, r2
  int LastEnter=0;
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 8004dfc:	2c00      	cmp	r4, #0
 8004dfe:	d101      	bne.n	8004e04 <testportCommand+0x1c>
 8004e00:	b672      	cpsid	i
 8004e02:	e7fe      	b.n	8004e02 <testportCommand+0x1a>
	
	/* Obtain the 1st parameter string. */
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8004e04:	2101      	movs	r1, #1
 8004e06:	aa05      	add	r2, sp, #20
 8004e08:	f00a fda8 	bl	800f95c <FreeRTOS_CLIGetParameter>
  if(strcmp((char *)pcParameterString1,"all")==0)
 8004e0c:	4948      	ldr	r1, [pc, #288]	; (8004f30 <testportCommand+0x148>)
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8004e0e:	0005      	movs	r5, r0
  if(strcmp((char *)pcParameterString1,"all")==0)
 8004e10:	f7fb f978 	bl	8000104 <strcmp>
 8004e14:	2800      	cmp	r0, #0
 8004e16:	d15a      	bne.n	8004ece <testportCommand+0xe6>
  { 
    if(LastEnter==0)
      LastEnter=  UARTRxBufIndex[PcPort-1];
 8004e18:	2501      	movs	r5, #1
    for (ports=1;ports<=NumOfPorts;ports++)
    {
      if(PcPort!=ports)
      {
        WriteVaule[0]=rand();
        writePxMutex(ports, WriteVaule,1, 10, 100);
 8004e1a:	2764      	movs	r7, #100	; 0x64
      LastEnter=  UARTRxBufIndex[PcPort-1];
 8004e1c:	4b45      	ldr	r3, [pc, #276]	; (8004f34 <testportCommand+0x14c>)
 8004e1e:	781a      	ldrb	r2, [r3, #0]
 8004e20:	4b45      	ldr	r3, [pc, #276]	; (8004f38 <testportCommand+0x150>)
 8004e22:	189b      	adds	r3, r3, r2
 8004e24:	3b01      	subs	r3, #1
 8004e26:	781b      	ldrb	r3, [r3, #0]
 8004e28:	9302      	str	r3, [sp, #8]
 8004e2a:	b2eb      	uxtb	r3, r5
 8004e2c:	9303      	str	r3, [sp, #12]
      if(PcPort!=ports)
 8004e2e:	4b41      	ldr	r3, [pc, #260]	; (8004f34 <testportCommand+0x14c>)
 8004e30:	b2ea      	uxtb	r2, r5
 8004e32:	781b      	ldrb	r3, [r3, #0]
 8004e34:	4293      	cmp	r3, r2
 8004e36:	d03d      	beq.n	8004eb4 <testportCommand+0xcc>
        WriteVaule[0]=rand();
 8004e38:	f00f fc2e 	bl	8014698 <rand>
 8004e3c:	ae04      	add	r6, sp, #16
 8004e3e:	7030      	strb	r0, [r6, #0]
        writePxMutex(ports, WriteVaule,1, 10, 100);
 8004e40:	230a      	movs	r3, #10
 8004e42:	2201      	movs	r2, #1
 8004e44:	0031      	movs	r1, r6
 8004e46:	9700      	str	r7, [sp, #0]
 8004e48:	b2e8      	uxtb	r0, r5
 8004e4a:	f008 fae5 	bl	800d418 <writePxMutex>
        ReadValue[0]= (GetUart(ports)->Instance->RDR);
 8004e4e:	b2e8      	uxtb	r0, r5
 8004e50:	f008 fad6 	bl	800d400 <GetUart>
 8004e54:	6803      	ldr	r3, [r0, #0]
      if(WriteVaule[0]==ReadValue[0])
 8004e56:	7832      	ldrb	r2, [r6, #0]
        ReadValue[0]= (GetUart(ports)->Instance->RDR);
 8004e58:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
      if(WriteVaule[0]==ReadValue[0])
 8004e5a:	b2db      	uxtb	r3, r3
 8004e5c:	429a      	cmp	r2, r3
 8004e5e:	d12f      	bne.n	8004ec0 <testportCommand+0xd8>
        result = BOS_OK;
      else
        result = BOS_ERR_Keyword;
      
      if (result == BOS_OK){ 
       sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, ports);
 8004e60:	002a      	movs	r2, r5
 8004e62:	4936      	ldr	r1, [pc, #216]	; (8004f3c <testportCommand+0x154>)
       writePxMutex(PcPort, (char*) pcWriteBuffer, strlen((char*) pcWriteBuffer), 10, 100);}
     	else if (result == BOS_ERR_Keyword){
       sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageFail, ports );	
 8004e64:	0020      	movs	r0, r4
 8004e66:	f00f fdf9 	bl	8014a5c <sprintf>
       writePxMutex(PcPort, (char*) pcWriteBuffer, strlen((char*) pcWriteBuffer), 10, 100);}
 8004e6a:	0020      	movs	r0, r4
 8004e6c:	f7fb f954 	bl	8000118 <strlen>
 8004e70:	4b30      	ldr	r3, [pc, #192]	; (8004f34 <testportCommand+0x14c>)
 8004e72:	b282      	uxth	r2, r0
 8004e74:	0021      	movs	r1, r4
 8004e76:	7818      	ldrb	r0, [r3, #0]
 8004e78:	230a      	movs	r3, #10
 8004e7a:	9700      	str	r7, [sp, #0]
 8004e7c:	f008 facc 	bl	800d418 <writePxMutex>
       strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWait );	
 8004e80:	492f      	ldr	r1, [pc, #188]	; (8004f40 <testportCommand+0x158>)
 8004e82:	0020      	movs	r0, r4
 8004e84:	f00f fe26 	bl	8014ad4 <strcpy>
       writePxMutex(PcPort, (char*) pcWriteBuffer, strlen((char*) pcWriteBuffer), 10, 100);
 8004e88:	0020      	movs	r0, r4
 8004e8a:	f7fb f945 	bl	8000118 <strlen>
 8004e8e:	4e29      	ldr	r6, [pc, #164]	; (8004f34 <testportCommand+0x14c>)
 8004e90:	b282      	uxth	r2, r0
 8004e92:	230a      	movs	r3, #10
 8004e94:	7830      	ldrb	r0, [r6, #0]
 8004e96:	0021      	movs	r1, r4
 8004e98:	9700      	str	r7, [sp, #0]
 8004e9a:	f008 fabd 	bl	800d418 <writePxMutex>
       while(UARTRxBuf[PcPort-1][LastEnter+1]==0){Delay_ms(1);}
 8004e9e:	9b02      	ldr	r3, [sp, #8]
 8004ea0:	4928      	ldr	r1, [pc, #160]	; (8004f44 <testportCommand+0x15c>)
 8004ea2:	1c5a      	adds	r2, r3, #1
 8004ea4:	7833      	ldrb	r3, [r6, #0]
 8004ea6:	3b01      	subs	r3, #1
 8004ea8:	019b      	lsls	r3, r3, #6
 8004eaa:	18cb      	adds	r3, r1, r3
 8004eac:	5c9b      	ldrb	r3, [r3, r2]
 8004eae:	2b00      	cmp	r3, #0
 8004eb0:	d009      	beq.n	8004ec6 <testportCommand+0xde>
 8004eb2:	9202      	str	r2, [sp, #8]
 8004eb4:	3501      	adds	r5, #1
    for (ports=1;ports<=NumOfPorts;ports++)
 8004eb6:	2d06      	cmp	r5, #6
 8004eb8:	d1b7      	bne.n	8004e2a <testportCommand+0x42>
    strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );	
	}
	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
 8004eba:	2000      	movs	r0, #0
 8004ebc:	b007      	add	sp, #28
 8004ebe:	bdf0      	pop	{r4, r5, r6, r7, pc}
       sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageFail, ports );	
 8004ec0:	002a      	movs	r2, r5
 8004ec2:	4921      	ldr	r1, [pc, #132]	; (8004f48 <testportCommand+0x160>)
 8004ec4:	e7ce      	b.n	8004e64 <testportCommand+0x7c>
       while(UARTRxBuf[PcPort-1][LastEnter+1]==0){Delay_ms(1);}
 8004ec6:	2001      	movs	r0, #1
 8004ec8:	f00c fb20 	bl	801150c <HAL_Delay>
 8004ecc:	e7e7      	b.n	8004e9e <testportCommand+0xb6>
	else if (pcParameterString1[0] == 'p') {
 8004ece:	2300      	movs	r3, #0
 8004ed0:	56eb      	ldrsb	r3, [r5, r3]
    strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );	
 8004ed2:	491e      	ldr	r1, [pc, #120]	; (8004f4c <testportCommand+0x164>)
	else if (pcParameterString1[0] == 'p') {
 8004ed4:	2b70      	cmp	r3, #112	; 0x70
 8004ed6:	d124      	bne.n	8004f22 <testportCommand+0x13a>
		portt = ( uint8_t ) atol( ( char * ) pcParameterString1+1);
 8004ed8:	1c68      	adds	r0, r5, #1
 8004eda:	f00f f941 	bl	8014160 <atol>
 8004ede:	b2c7      	uxtb	r7, r0
    if(portt>0 && portt<=NumOfPorts)
 8004ee0:	1e7b      	subs	r3, r7, #1
		portt = ( uint8_t ) atol( ( char * ) pcParameterString1+1);
 8004ee2:	0005      	movs	r5, r0
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong1 );	
 8004ee4:	491a      	ldr	r1, [pc, #104]	; (8004f50 <testportCommand+0x168>)
    if(portt>0 && portt<=NumOfPorts)
 8004ee6:	2b04      	cmp	r3, #4
 8004ee8:	d81b      	bhi.n	8004f22 <testportCommand+0x13a>
        WriteVaule[0]=rand();
 8004eea:	f00f fbd5 	bl	8014698 <rand>
        writePxMutex(portt, WriteVaule,1, cmd50ms, 100);
 8004eee:	2364      	movs	r3, #100	; 0x64
        WriteVaule[0]=rand();
 8004ef0:	7030      	strb	r0, [r6, #0]
        writePxMutex(portt, WriteVaule,1, cmd50ms, 100);
 8004ef2:	2201      	movs	r2, #1
 8004ef4:	0031      	movs	r1, r6
 8004ef6:	9300      	str	r3, [sp, #0]
 8004ef8:	0038      	movs	r0, r7
 8004efa:	3b32      	subs	r3, #50	; 0x32
 8004efc:	f008 fa8c 	bl	800d418 <writePxMutex>
        ReadValue[0]= (GetUart(portt)->Instance->RDR);
 8004f00:	0038      	movs	r0, r7
 8004f02:	f008 fa7d 	bl	800d400 <GetUart>
 8004f06:	6803      	ldr	r3, [r0, #0]
  if(WriteVaule[0]==ReadValue[0])
 8004f08:	7831      	ldrb	r1, [r6, #0]
        ReadValue[0]= (GetUart(portt)->Instance->RDR);
 8004f0a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8004f0c:	b2ea      	uxtb	r2, r5
  if(WriteVaule[0]==ReadValue[0])
 8004f0e:	b2db      	uxtb	r3, r3
 8004f10:	4299      	cmp	r1, r3
 8004f12:	d104      	bne.n	8004f1e <testportCommand+0x136>
   sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, portt);
 8004f14:	4909      	ldr	r1, [pc, #36]	; (8004f3c <testportCommand+0x154>)
    sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageFail, portt );
 8004f16:	0020      	movs	r0, r4
 8004f18:	f00f fda0 	bl	8014a5c <sprintf>
 8004f1c:	e7cd      	b.n	8004eba <testportCommand+0xd2>
 8004f1e:	490a      	ldr	r1, [pc, #40]	; (8004f48 <testportCommand+0x160>)
 8004f20:	e7f9      	b.n	8004f16 <testportCommand+0x12e>
    strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );	
 8004f22:	0020      	movs	r0, r4
 8004f24:	f00f fdd6 	bl	8014ad4 <strcpy>
 8004f28:	e7c7      	b.n	8004eba <testportCommand+0xd2>
 8004f2a:	46c0      	nop			; (mov r8, r8)
 8004f2c:	08018f88 	.word	0x08018f88
 8004f30:	080192de 	.word	0x080192de
 8004f34:	20000a9f 	.word	0x20000a9f
 8004f38:	200013b1 	.word	0x200013b1
 8004f3c:	0801b353 	.word	0x0801b353
 8004f40:	0801b380 	.word	0x0801b380
 8004f44:	20001271 	.word	0x20001271
 8004f48:	0801b36e 	.word	0x0801b36e
 8004f4c:	0801b3ef 	.word	0x0801b3ef
 8004f50:	0801b3d4 	.word	0x0801b3d4

08004f54 <unbridgeCommand>:
{	
 8004f54:	b5f0      	push	{r4, r5, r6, r7, lr}
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0;
 8004f56:	2600      	movs	r6, #0
{	
 8004f58:	b085      	sub	sp, #20
 8004f5a:	0004      	movs	r4, r0
 8004f5c:	0017      	movs	r7, r2
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0;
 8004f5e:	9602      	str	r6, [sp, #8]
 8004f60:	9603      	str	r6, [sp, #12]
	configASSERT( pcWriteBuffer );
 8004f62:	42b0      	cmp	r0, r6
 8004f64:	d101      	bne.n	8004f6a <unbridgeCommand+0x16>
 8004f66:	b672      	cpsid	i
 8004f68:	e7fe      	b.n	8004f68 <unbridgeCommand+0x14>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8004f6a:	aa02      	add	r2, sp, #8
 8004f6c:	2101      	movs	r1, #1
 8004f6e:	0038      	movs	r0, r7
 8004f70:	f00a fcf4 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString1[0] == 'p') {
 8004f74:	2300      	movs	r3, #0
		result = BOS_ERR_WrongParam;
 8004f76:	2267      	movs	r2, #103	; 0x67
	if (pcParameterString1[0] == 'p') {
 8004f78:	56c3      	ldrsb	r3, [r0, r3]
		result = BOS_ERR_WrongParam;
 8004f7a:	9201      	str	r2, [sp, #4]
	if (pcParameterString1[0] == 'p') {
 8004f7c:	2b70      	cmp	r3, #112	; 0x70
 8004f7e:	d104      	bne.n	8004f8a <unbridgeCommand+0x36>
		port1 = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
 8004f80:	3001      	adds	r0, #1
 8004f82:	f00f f8ed 	bl	8014160 <atol>
	BOS_Status result = BOS_OK;
 8004f86:	9601      	str	r6, [sp, #4]
		port1 = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
 8004f88:	b2c5      	uxtb	r5, r0
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8004f8a:	aa03      	add	r2, sp, #12
 8004f8c:	2102      	movs	r1, #2
 8004f8e:	0038      	movs	r0, r7
 8004f90:	f00a fce4 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString2[0] == 'p') {
 8004f94:	2300      	movs	r3, #0
 8004f96:	56c3      	ldrsb	r3, [r0, r3]
 8004f98:	2b70      	cmp	r3, #112	; 0x70
 8004f9a:	d004      	beq.n	8004fa6 <unbridgeCommand+0x52>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );	
 8004f9c:	490f      	ldr	r1, [pc, #60]	; (8004fdc <unbridgeCommand+0x88>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageFail );	
 8004f9e:	0020      	movs	r0, r4
 8004fa0:	f00f fd98 	bl	8014ad4 <strcpy>
 8004fa4:	e012      	b.n	8004fcc <unbridgeCommand+0x78>
		port2 = ( uint8_t ) atol( ( char * ) pcParameterString2+1 );
 8004fa6:	3001      	adds	r0, #1
 8004fa8:	f00f f8da 	bl	8014160 <atol>
	if (result == BOS_OK) 
 8004fac:	9b01      	ldr	r3, [sp, #4]
		port2 = ( uint8_t ) atol( ( char * ) pcParameterString2+1 );
 8004fae:	0006      	movs	r6, r0
 8004fb0:	b2c1      	uxtb	r1, r0
	if (result == BOS_OK) 
 8004fb2:	2b00      	cmp	r3, #0
 8004fb4:	d1f2      	bne.n	8004f9c <unbridgeCommand+0x48>
		result = Unbridge(port1, port2);
 8004fb6:	0028      	movs	r0, r5
 8004fb8:	f7ff f910 	bl	80041dc <Unbridge>
	if (result == BOS_OK) 
 8004fbc:	2800      	cmp	r0, #0
 8004fbe:	d108      	bne.n	8004fd2 <unbridgeCommand+0x7e>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, port1, port2 );
 8004fc0:	b2f3      	uxtb	r3, r6
 8004fc2:	002a      	movs	r2, r5
 8004fc4:	4906      	ldr	r1, [pc, #24]	; (8004fe0 <unbridgeCommand+0x8c>)
 8004fc6:	0020      	movs	r0, r4
 8004fc8:	f00f fd48 	bl	8014a5c <sprintf>
}
 8004fcc:	2000      	movs	r0, #0
 8004fce:	b005      	add	sp, #20
 8004fd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else if (result == BOS_ERR_WrongParam) 
 8004fd2:	2867      	cmp	r0, #103	; 0x67
 8004fd4:	d0e2      	beq.n	8004f9c <unbridgeCommand+0x48>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageFail );	
 8004fd6:	4903      	ldr	r1, [pc, #12]	; (8004fe4 <unbridgeCommand+0x90>)
 8004fd8:	e7e1      	b.n	8004f9e <unbridgeCommand+0x4a>
 8004fda:	46c0      	nop			; (mov r8, r8)
 8004fdc:	0801b3ef 	.word	0x0801b3ef
 8004fe0:	0801b478 	.word	0x0801b478
 8004fe4:	0801b495 	.word	0x0801b495

08004fe8 <bridgeCommand>:
{	
 8004fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0;
 8004fea:	2600      	movs	r6, #0
{	
 8004fec:	b085      	sub	sp, #20
 8004fee:	0004      	movs	r4, r0
 8004ff0:	0017      	movs	r7, r2
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0;
 8004ff2:	9602      	str	r6, [sp, #8]
 8004ff4:	9603      	str	r6, [sp, #12]
	configASSERT( pcWriteBuffer );
 8004ff6:	42b0      	cmp	r0, r6
 8004ff8:	d101      	bne.n	8004ffe <bridgeCommand+0x16>
 8004ffa:	b672      	cpsid	i
 8004ffc:	e7fe      	b.n	8004ffc <bridgeCommand+0x14>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8004ffe:	aa02      	add	r2, sp, #8
 8005000:	2101      	movs	r1, #1
 8005002:	0038      	movs	r0, r7
 8005004:	f00a fcaa 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString1[0] == 'p') {
 8005008:	2300      	movs	r3, #0
		result = BOS_ERR_WrongParam;
 800500a:	2267      	movs	r2, #103	; 0x67
	if (pcParameterString1[0] == 'p') {
 800500c:	56c3      	ldrsb	r3, [r0, r3]
		result = BOS_ERR_WrongParam;
 800500e:	9201      	str	r2, [sp, #4]
	if (pcParameterString1[0] == 'p') {
 8005010:	2b70      	cmp	r3, #112	; 0x70
 8005012:	d104      	bne.n	800501e <bridgeCommand+0x36>
		port1 = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
 8005014:	3001      	adds	r0, #1
 8005016:	f00f f8a3 	bl	8014160 <atol>
	BOS_Status result = BOS_OK;
 800501a:	9601      	str	r6, [sp, #4]
		port1 = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
 800501c:	b2c5      	uxtb	r5, r0
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800501e:	aa03      	add	r2, sp, #12
 8005020:	2102      	movs	r1, #2
 8005022:	0038      	movs	r0, r7
 8005024:	f00a fc9a 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString2[0] == 'p') {
 8005028:	2300      	movs	r3, #0
 800502a:	56c3      	ldrsb	r3, [r0, r3]
 800502c:	2b70      	cmp	r3, #112	; 0x70
 800502e:	d004      	beq.n	800503a <bridgeCommand+0x52>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );	
 8005030:	490f      	ldr	r1, [pc, #60]	; (8005070 <bridgeCommand+0x88>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageFail );	
 8005032:	0020      	movs	r0, r4
 8005034:	f00f fd4e 	bl	8014ad4 <strcpy>
 8005038:	e012      	b.n	8005060 <bridgeCommand+0x78>
		port2 = ( uint8_t ) atol( ( char * ) pcParameterString2+1 );
 800503a:	3001      	adds	r0, #1
 800503c:	f00f f890 	bl	8014160 <atol>
	if (result == BOS_OK) 
 8005040:	9b01      	ldr	r3, [sp, #4]
		port2 = ( uint8_t ) atol( ( char * ) pcParameterString2+1 );
 8005042:	0006      	movs	r6, r0
 8005044:	b2c1      	uxtb	r1, r0
	if (result == BOS_OK) 
 8005046:	2b00      	cmp	r3, #0
 8005048:	d1f2      	bne.n	8005030 <bridgeCommand+0x48>
		result = Bridge(port1, port2);
 800504a:	0028      	movs	r0, r5
 800504c:	f7ff f8b4 	bl	80041b8 <Bridge>
	if (result == BOS_OK) 
 8005050:	2800      	cmp	r0, #0
 8005052:	d108      	bne.n	8005066 <bridgeCommand+0x7e>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, port1, port2 );
 8005054:	b2f3      	uxtb	r3, r6
 8005056:	002a      	movs	r2, r5
 8005058:	4906      	ldr	r1, [pc, #24]	; (8005074 <bridgeCommand+0x8c>)
 800505a:	0020      	movs	r0, r4
 800505c:	f00f fcfe 	bl	8014a5c <sprintf>
}
 8005060:	2000      	movs	r0, #0
 8005062:	b005      	add	sp, #20
 8005064:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else if (result == BOS_ERR_WrongParam) 
 8005066:	2867      	cmp	r0, #103	; 0x67
 8005068:	d0e2      	beq.n	8005030 <bridgeCommand+0x48>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageFail );	
 800506a:	4903      	ldr	r1, [pc, #12]	; (8005078 <bridgeCommand+0x90>)
 800506c:	e7e1      	b.n	8005032 <bridgeCommand+0x4a>
 800506e:	46c0      	nop			; (mov r8, r8)
 8005070:	0801b3ef 	.word	0x0801b3ef
 8005074:	08019b50 	.word	0x08019b50
 8005078:	08019b73 	.word	0x08019b73

0800507c <delSnipCommand>:
{	
 800507c:	b5f0      	push	{r4, r5, r6, r7, lr}
	portBASE_TYPE xParameterStringLength1 = 0;
 800507e:	2500      	movs	r5, #0
{	
 8005080:	b085      	sub	sp, #20
 8005082:	9001      	str	r0, [sp, #4]
	configASSERT( pcWriteBuffer );
 8005084:	9b01      	ldr	r3, [sp, #4]
{	
 8005086:	0010      	movs	r0, r2
	portBASE_TYPE xParameterStringLength1 = 0;
 8005088:	9503      	str	r5, [sp, #12]
	configASSERT( pcWriteBuffer );
 800508a:	42ab      	cmp	r3, r5
 800508c:	d101      	bne.n	8005092 <delSnipCommand+0x16>
 800508e:	b672      	cpsid	i
 8005090:	e7fe      	b.n	8005090 <delSnipCommand+0x14>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005092:	aa03      	add	r2, sp, #12
 8005094:	2101      	movs	r1, #1
 8005096:	f00a fc61 	bl	800f95c <FreeRTOS_CLIGetParameter>
	uint8_t index = ( uint8_t ) atoi( ( char * ) pcParameterString1 );
 800509a:	f00f f85b 	bl	8014154 <atoi>
 800509e:	b2c4      	uxtb	r4, r0
	if (!index || index > numOfRecordedSnippets)	result = BOS_ERROR;
 80050a0:	2c00      	cmp	r4, #0
 80050a2:	d040      	beq.n	8005126 <delSnipCommand+0xaa>
 80050a4:	4b21      	ldr	r3, [pc, #132]	; (800512c <delSnipCommand+0xb0>)
 80050a6:	781b      	ldrb	r3, [r3, #0]
 80050a8:	42a3      	cmp	r3, r4
 80050aa:	d33c      	bcc.n	8005126 <delSnipCommand+0xaa>
		snippets[index-1].cond.conditionType = 0;
 80050ac:	2314      	movs	r3, #20
 80050ae:	b2c0      	uxtb	r0, r0
 80050b0:	3801      	subs	r0, #1
 80050b2:	4358      	muls	r0, r3
 80050b4:	4f1e      	ldr	r7, [pc, #120]	; (8005130 <delSnipCommand+0xb4>)
		memset(snippets[index-1].cond.buffer1, 0, 4);
 80050b6:	0029      	movs	r1, r5
		snippets[index-1].cond.conditionType = 0;
 80050b8:	19c6      	adds	r6, r0, r7
		memset(snippets[index-1].cond.buffer1, 0, 4);
 80050ba:	3002      	adds	r0, #2
		snippets[index-1].cond.conditionType = 0;
 80050bc:	8035      	strh	r5, [r6, #0]
		memset(snippets[index-1].cond.buffer1, 0, 4);
 80050be:	2204      	movs	r2, #4
 80050c0:	19c0      	adds	r0, r0, r7
 80050c2:	f00f fad0 	bl	8014666 <memset>
		snippets[index-1].state = false;
 80050c6:	7435      	strb	r5, [r6, #16]
		free(snippets[index-1].cmd);
 80050c8:	68f0      	ldr	r0, [r6, #12]
 80050ca:	f00f f88f 	bl	80141ec <free>
		snippets[index-1].cmd = NULL;
 80050ce:	60f5      	str	r5, [r6, #12]
			if (snippets[s].cond.conditionType) {
 80050d0:	2514      	movs	r5, #20
		for(uint8_t s=index ; s<numOfRecordedSnippets ; s++) {
 80050d2:	4b16      	ldr	r3, [pc, #88]	; (800512c <delSnipCommand+0xb0>)
 80050d4:	781b      	ldrb	r3, [r3, #0]
 80050d6:	42a3      	cmp	r3, r4
 80050d8:	d80b      	bhi.n	80050f2 <delSnipCommand+0x76>
		--numOfRecordedSnippets;
 80050da:	4a14      	ldr	r2, [pc, #80]	; (800512c <delSnipCommand+0xb0>)
 80050dc:	3b01      	subs	r3, #1
 80050de:	7013      	strb	r3, [r2, #0]
		SaveToRO();
 80050e0:	f004 fb24 	bl	800972c <SaveToRO>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK );
 80050e4:	4913      	ldr	r1, [pc, #76]	; (8005134 <delSnipCommand+0xb8>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );
 80050e6:	9801      	ldr	r0, [sp, #4]
 80050e8:	f00f fcf4 	bl	8014ad4 <strcpy>
}
 80050ec:	2000      	movs	r0, #0
 80050ee:	b005      	add	sp, #20
 80050f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (snippets[s].cond.conditionType) {
 80050f2:	002b      	movs	r3, r5
 80050f4:	4363      	muls	r3, r4
 80050f6:	5cfb      	ldrb	r3, [r7, r3]
 80050f8:	2b00      	cmp	r3, #0
 80050fa:	d011      	beq.n	8005120 <delSnipCommand+0xa4>
				memcpy( &snippets[s-1], &snippets[s], sizeof(snippet_t) );
 80050fc:	1e63      	subs	r3, r4, #1
 80050fe:	436b      	muls	r3, r5
 8005100:	0018      	movs	r0, r3
 8005102:	3014      	adds	r0, #20
 8005104:	183a      	adds	r2, r7, r0
 8005106:	0011      	movs	r1, r2
 8005108:	18fb      	adds	r3, r7, r3
 800510a:	4694      	mov	ip, r2
 800510c:	c945      	ldmia	r1!, {r0, r2, r6}
 800510e:	c345      	stmia	r3!, {r0, r2, r6}
 8005110:	001a      	movs	r2, r3
 8005112:	c909      	ldmia	r1!, {r0, r3}
 8005114:	c209      	stmia	r2!, {r0, r3}
				memset( &snippets[s], 0, sizeof(snippet_t) );
 8005116:	002a      	movs	r2, r5
 8005118:	2100      	movs	r1, #0
 800511a:	4660      	mov	r0, ip
 800511c:	f00f faa3 	bl	8014666 <memset>
		for(uint8_t s=index ; s<numOfRecordedSnippets ; s++) {
 8005120:	3401      	adds	r4, #1
 8005122:	b2e4      	uxtb	r4, r4
 8005124:	e7d5      	b.n	80050d2 <delSnipCommand+0x56>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );
 8005126:	4904      	ldr	r1, [pc, #16]	; (8005138 <delSnipCommand+0xbc>)
 8005128:	e7dd      	b.n	80050e6 <delSnipCommand+0x6a>
 800512a:	46c0      	nop			; (mov r8, r8)
 800512c:	200011c7 	.word	0x200011c7
 8005130:	20006f8c 	.word	0x20006f8c
 8005134:	08019c58 	.word	0x08019c58
 8005138:	08019c8e 	.word	0x08019c8e

0800513c <pauseSnipCommand>:
{	
 800513c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	portBASE_TYPE xParameterStringLength1 = 0;
 800513e:	2500      	movs	r5, #0
{	
 8005140:	0004      	movs	r4, r0
	portBASE_TYPE xParameterStringLength1 = 0;
 8005142:	9501      	str	r5, [sp, #4]
{	
 8005144:	0010      	movs	r0, r2
	configASSERT( pcWriteBuffer );
 8005146:	42ac      	cmp	r4, r5
 8005148:	d101      	bne.n	800514e <pauseSnipCommand+0x12>
 800514a:	b672      	cpsid	i
 800514c:	e7fe      	b.n	800514c <pauseSnipCommand+0x10>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800514e:	aa01      	add	r2, sp, #4
 8005150:	2101      	movs	r1, #1
 8005152:	f00a fc03 	bl	800f95c <FreeRTOS_CLIGetParameter>
	uint8_t index = ( uint8_t ) atoi( ( char * ) pcParameterString1 );
 8005156:	f00e fffd 	bl	8014154 <atoi>
 800515a:	b2c3      	uxtb	r3, r0
	if (!index || index > numOfRecordedSnippets)	result = BOS_ERROR;
 800515c:	2b00      	cmp	r3, #0
 800515e:	d012      	beq.n	8005186 <pauseSnipCommand+0x4a>
 8005160:	4a0a      	ldr	r2, [pc, #40]	; (800518c <pauseSnipCommand+0x50>)
 8005162:	7812      	ldrb	r2, [r2, #0]
 8005164:	429a      	cmp	r2, r3
 8005166:	d30e      	bcc.n	8005186 <pauseSnipCommand+0x4a>
		snippets[index-1].state = false;
 8005168:	2314      	movs	r3, #20
 800516a:	b2c0      	uxtb	r0, r0
 800516c:	3801      	subs	r0, #1
 800516e:	4343      	muls	r3, r0
 8005170:	4807      	ldr	r0, [pc, #28]	; (8005190 <pauseSnipCommand+0x54>)
 8005172:	18c0      	adds	r0, r0, r3
 8005174:	7405      	strb	r5, [r0, #16]
		SaveToRO();
 8005176:	f004 fad9 	bl	800972c <SaveToRO>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK );
 800517a:	4906      	ldr	r1, [pc, #24]	; (8005194 <pauseSnipCommand+0x58>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );
 800517c:	0020      	movs	r0, r4
 800517e:	f00f fca9 	bl	8014ad4 <strcpy>
}
 8005182:	2000      	movs	r0, #0
 8005184:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );
 8005186:	4904      	ldr	r1, [pc, #16]	; (8005198 <pauseSnipCommand+0x5c>)
 8005188:	e7f8      	b.n	800517c <pauseSnipCommand+0x40>
 800518a:	46c0      	nop			; (mov r8, r8)
 800518c:	200011c7 	.word	0x200011c7
 8005190:	20006f8c 	.word	0x20006f8c
 8005194:	0801a06c 	.word	0x0801a06c
 8005198:	08019c8e 	.word	0x08019c8e

0800519c <actSnipCommand>:
	portBASE_TYPE xParameterStringLength1 = 0;
 800519c:	2300      	movs	r3, #0
{	
 800519e:	b513      	push	{r0, r1, r4, lr}
 80051a0:	0004      	movs	r4, r0
	portBASE_TYPE xParameterStringLength1 = 0;
 80051a2:	9301      	str	r3, [sp, #4]
{	
 80051a4:	0010      	movs	r0, r2
	configASSERT( pcWriteBuffer );
 80051a6:	429c      	cmp	r4, r3
 80051a8:	d101      	bne.n	80051ae <actSnipCommand+0x12>
 80051aa:	b672      	cpsid	i
 80051ac:	e7fe      	b.n	80051ac <actSnipCommand+0x10>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 80051ae:	aa01      	add	r2, sp, #4
 80051b0:	2101      	movs	r1, #1
 80051b2:	f00a fbd3 	bl	800f95c <FreeRTOS_CLIGetParameter>
	uint8_t index = ( uint8_t ) atoi( ( char * ) pcParameterString1 );
 80051b6:	f00e ffcd 	bl	8014154 <atoi>
 80051ba:	b2c3      	uxtb	r3, r0
	if (!index || index > numOfRecordedSnippets)	result = BOS_ERROR;
 80051bc:	2b00      	cmp	r3, #0
 80051be:	d013      	beq.n	80051e8 <actSnipCommand+0x4c>
 80051c0:	4a0a      	ldr	r2, [pc, #40]	; (80051ec <actSnipCommand+0x50>)
 80051c2:	7812      	ldrb	r2, [r2, #0]
 80051c4:	429a      	cmp	r2, r3
 80051c6:	d30f      	bcc.n	80051e8 <actSnipCommand+0x4c>
		snippets[index-1].state = true;
 80051c8:	2314      	movs	r3, #20
 80051ca:	b2c0      	uxtb	r0, r0
 80051cc:	3801      	subs	r0, #1
 80051ce:	4343      	muls	r3, r0
 80051d0:	4807      	ldr	r0, [pc, #28]	; (80051f0 <actSnipCommand+0x54>)
 80051d2:	18c0      	adds	r0, r0, r3
 80051d4:	2301      	movs	r3, #1
 80051d6:	7403      	strb	r3, [r0, #16]
		SaveToRO();
 80051d8:	f004 faa8 	bl	800972c <SaveToRO>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK );
 80051dc:	4905      	ldr	r1, [pc, #20]	; (80051f4 <actSnipCommand+0x58>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );
 80051de:	0020      	movs	r0, r4
 80051e0:	f00f fc78 	bl	8014ad4 <strcpy>
}
 80051e4:	2000      	movs	r0, #0
 80051e6:	bd16      	pop	{r1, r2, r4, pc}
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrong );
 80051e8:	4903      	ldr	r1, [pc, #12]	; (80051f8 <actSnipCommand+0x5c>)
 80051ea:	e7f8      	b.n	80051de <actSnipCommand+0x42>
 80051ec:	200011c7 	.word	0x200011c7
 80051f0:	20006f8c 	.word	0x20006f8c
 80051f4:	08019a62 	.word	0x08019a62
 80051f8:	08019c8e 	.word	0x08019c8e

080051fc <snipCommand>:
{	
 80051fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	char status[2][7] = {"Paused", "Active"};
 80051fe:	4961      	ldr	r1, [pc, #388]	; (8005384 <snipCommand+0x188>)
{	
 8005200:	b08d      	sub	sp, #52	; 0x34
 8005202:	0004      	movs	r4, r0
	char status[2][7] = {"Paused", "Active"};
 8005204:	220e      	movs	r2, #14
 8005206:	3102      	adds	r1, #2
 8005208:	a808      	add	r0, sp, #32
 800520a:	f00f fa23 	bl	8014654 <memcpy>
	configASSERT( pcWriteBuffer );
 800520e:	2c00      	cmp	r4, #0
 8005210:	d101      	bne.n	8005216 <snipCommand+0x1a>
 8005212:	b672      	cpsid	i
 8005214:	e7fe      	b.n	8005214 <snipCommand+0x18>
	writePxMutex(PcPort, (char*) pcMessageSnipWelcome, strlen((char*) pcMessageSnipWelcome), cmd50ms, HAL_MAX_DELAY);
 8005216:	4b5c      	ldr	r3, [pc, #368]	; (8005388 <snipCommand+0x18c>)
 8005218:	2237      	movs	r2, #55	; 0x37
 800521a:	7818      	ldrb	r0, [r3, #0]
 800521c:	2301      	movs	r3, #1
 800521e:	425b      	negs	r3, r3
 8005220:	9300      	str	r3, [sp, #0]
 8005222:	495a      	ldr	r1, [pc, #360]	; (800538c <snipCommand+0x190>)
 8005224:	3333      	adds	r3, #51	; 0x33
 8005226:	f008 f8f7 	bl	800d418 <writePxMutex>
	for(uint8_t s=0 ; s<numOfRecordedSnippets ; s++)
 800522a:	2600      	movs	r6, #0
 800522c:	1c73      	adds	r3, r6, #1
 800522e:	b2db      	uxtb	r3, r3
 8005230:	9305      	str	r3, [sp, #20]
 8005232:	4b57      	ldr	r3, [pc, #348]	; (8005390 <snipCommand+0x194>)
 8005234:	781b      	ldrb	r3, [r3, #0]
 8005236:	42b3      	cmp	r3, r6
 8005238:	d806      	bhi.n	8005248 <snipCommand+0x4c>
	strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipAction );
 800523a:	4956      	ldr	r1, [pc, #344]	; (8005394 <snipCommand+0x198>)
 800523c:	0020      	movs	r0, r4
 800523e:	f00f fc49 	bl	8014ad4 <strcpy>
}
 8005242:	2000      	movs	r0, #0
 8005244:	b00d      	add	sp, #52	; 0x34
 8005246:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (snippets[s].cond.conditionType)
 8005248:	2314      	movs	r3, #20
 800524a:	4373      	muls	r3, r6
 800524c:	4d52      	ldr	r5, [pc, #328]	; (8005398 <snipCommand+0x19c>)
 800524e:	5d5a      	ldrb	r2, [r3, r5]
 8005250:	2a00      	cmp	r2, #0
 8005252:	d00a      	beq.n	800526a <snipCommand+0x6e>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipStart, count, status[snippets[s].state]);
 8005254:	2207      	movs	r2, #7
 8005256:	18eb      	adds	r3, r5, r3
 8005258:	7c1b      	ldrb	r3, [r3, #16]
 800525a:	4950      	ldr	r1, [pc, #320]	; (800539c <snipCommand+0x1a0>)
 800525c:	4353      	muls	r3, r2
 800525e:	aa08      	add	r2, sp, #32
 8005260:	18d3      	adds	r3, r2, r3
 8005262:	0020      	movs	r0, r4
 8005264:	9a05      	ldr	r2, [sp, #20]
 8005266:	f00f fbf9 	bl	8014a5c <sprintf>
		switch (snippets[s].cond.conditionType)
 800526a:	2714      	movs	r7, #20
 800526c:	4377      	muls	r7, r6
 800526e:	5deb      	ldrb	r3, [r5, r7]
 8005270:	9304      	str	r3, [sp, #16]
 8005272:	2b01      	cmp	r3, #1
 8005274:	d01f      	beq.n	80052b6 <snipCommand+0xba>
 8005276:	2b03      	cmp	r3, #3
 8005278:	d054      	beq.n	8005324 <snipCommand+0x128>
		while (ParseSnippetCommand(snippets[s].cmd, (int8_t *) &commands) != false)
 800527a:	2314      	movs	r3, #20
 800527c:	435e      	muls	r6, r3
 800527e:	4b46      	ldr	r3, [pc, #280]	; (8005398 <snipCommand+0x19c>)
 8005280:	199e      	adds	r6, r3, r6
 8005282:	4d47      	ldr	r5, [pc, #284]	; (80053a0 <snipCommand+0x1a4>)
 8005284:	68f0      	ldr	r0, [r6, #12]
 8005286:	0029      	movs	r1, r5
 8005288:	f7ff fc84 	bl	8004b94 <ParseSnippetCommand>
 800528c:	2800      	cmp	r0, #0
 800528e:	d16a      	bne.n	8005366 <snipCommand+0x16a>
		strcat( ( char * ) pcWriteBuffer, ( char * ) pcMessageEnd);
 8005290:	4944      	ldr	r1, [pc, #272]	; (80053a4 <snipCommand+0x1a8>)
 8005292:	0020      	movs	r0, r4
 8005294:	f00f fc02 	bl	8014a9c <strcat>
		writePxMutex(PcPort, (char*) pcWriteBuffer, strlen((char*) pcWriteBuffer), cmd50ms, HAL_MAX_DELAY);
 8005298:	0020      	movs	r0, r4
 800529a:	f7fa ff3d 	bl	8000118 <strlen>
 800529e:	4b3a      	ldr	r3, [pc, #232]	; (8005388 <snipCommand+0x18c>)
 80052a0:	b282      	uxth	r2, r0
 80052a2:	7818      	ldrb	r0, [r3, #0]
 80052a4:	2301      	movs	r3, #1
 80052a6:	425b      	negs	r3, r3
 80052a8:	9300      	str	r3, [sp, #0]
 80052aa:	0021      	movs	r1, r4
 80052ac:	3333      	adds	r3, #51	; 0x33
 80052ae:	f008 f8b3 	bl	800d418 <writePxMutex>
	for(uint8_t s=0 ; s<numOfRecordedSnippets ; s++)
 80052b2:	9e05      	ldr	r6, [sp, #20]
 80052b4:	e7ba      	b.n	800522c <snipCommand+0x30>
 80052b6:	19ef      	adds	r7, r5, r7
				switch (snippets[s].cond.buffer1[1])
 80052b8:	78f8      	ldrb	r0, [r7, #3]
 80052ba:	68fa      	ldr	r2, [r7, #12]
 80052bc:	3805      	subs	r0, #5
 80052be:	2809      	cmp	r0, #9
 80052c0:	d8db      	bhi.n	800527a <snipCommand+0x7e>
 80052c2:	f7fa ff31 	bl	8000128 <__gnu_thumb1_case_sqi>
 80052c6:	1005      	.short	0x1005
 80052c8:	1818dada 	.word	0x1818dada
 80052cc:	25252518 	.word	0x25252518
						sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipButtonEventClicked, ( char * ) pcWriteBuffer, snippets[s].cond.buffer1[0], snippets[s].cmd);				
 80052d0:	2314      	movs	r3, #20
 80052d2:	4373      	muls	r3, r6
 80052d4:	18ed      	adds	r5, r5, r3
 80052d6:	78ab      	ldrb	r3, [r5, #2]
 80052d8:	9200      	str	r2, [sp, #0]
 80052da:	0022      	movs	r2, r4
 80052dc:	4932      	ldr	r1, [pc, #200]	; (80053a8 <snipCommand+0x1ac>)
						sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipButtonEventDblClicked, ( char * ) pcWriteBuffer, snippets[s].cond.buffer1[0], snippets[s].cmd);				
 80052de:	0020      	movs	r0, r4
 80052e0:	f00f fbbc 	bl	8014a5c <sprintf>
        		break;
 80052e4:	e7c9      	b.n	800527a <snipCommand+0x7e>
						sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipButtonEventDblClicked, ( char * ) pcWriteBuffer, snippets[s].cond.buffer1[0], snippets[s].cmd);				
 80052e6:	2314      	movs	r3, #20
 80052e8:	4373      	muls	r3, r6
 80052ea:	18ed      	adds	r5, r5, r3
 80052ec:	78ab      	ldrb	r3, [r5, #2]
 80052ee:	492f      	ldr	r1, [pc, #188]	; (80053ac <snipCommand+0x1b0>)
 80052f0:	9200      	str	r2, [sp, #0]
 80052f2:	0022      	movs	r2, r4
 80052f4:	e7f3      	b.n	80052de <snipCommand+0xe2>
						sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipButtonEventPressed, ( char * ) pcWriteBuffer, snippets[s].cond.buffer1[0], snippets[s].cond.buffer1[2], snippets[s].cmd);				
 80052f6:	2314      	movs	r3, #20
 80052f8:	4373      	muls	r3, r6
 80052fa:	18ed      	adds	r5, r5, r3
 80052fc:	78ab      	ldrb	r3, [r5, #2]
 80052fe:	9201      	str	r2, [sp, #4]
 8005300:	792a      	ldrb	r2, [r5, #4]
 8005302:	492b      	ldr	r1, [pc, #172]	; (80053b0 <snipCommand+0x1b4>)
 8005304:	9200      	str	r2, [sp, #0]
 8005306:	0022      	movs	r2, r4
 8005308:	0020      	movs	r0, r4
 800530a:	f00f fba7 	bl	8014a5c <sprintf>
        		break;
 800530e:	e7b4      	b.n	800527a <snipCommand+0x7e>
						sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipButtonEventReleased, ( char * ) pcWriteBuffer, snippets[s].cond.buffer1[0], snippets[s].cond.buffer1[2], snippets[s].cmd);				
 8005310:	2314      	movs	r3, #20
 8005312:	4373      	muls	r3, r6
 8005314:	18ed      	adds	r5, r5, r3
 8005316:	78ab      	ldrb	r3, [r5, #2]
 8005318:	9201      	str	r2, [sp, #4]
 800531a:	792a      	ldrb	r2, [r5, #4]
 800531c:	4925      	ldr	r1, [pc, #148]	; (80053b4 <snipCommand+0x1b8>)
 800531e:	9200      	str	r2, [sp, #0]
 8005320:	0022      	movs	r2, r4
 8005322:	e7f1      	b.n	8005308 <snipCommand+0x10c>
				memcpy( (uint8_t *)&flt1, &snippets[s].cond.buffer2, sizeof(float));	// This buffer can be misaligned and cause hardfault on F0
 8005324:	1db9      	adds	r1, r7, #6
 8005326:	1869      	adds	r1, r5, r1
				sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipModuleParamConst, ( char * ) pcWriteBuffer, modParam[snippets[s].cond.buffer1[1]-1].paramName, mathStr[snippets[s].cond.mathOperator-1], flt1);				      		
 8005328:	19ed      	adds	r5, r5, r7
 800532a:	270c      	movs	r7, #12
				memcpy( (uint8_t *)&flt1, &snippets[s].cond.buffer2, sizeof(float));	// This buffer can be misaligned and cause hardfault on F0
 800532c:	2204      	movs	r2, #4
 800532e:	a807      	add	r0, sp, #28
 8005330:	f00f f990 	bl	8014654 <memcpy>
				sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageSnipModuleParamConst, ( char * ) pcWriteBuffer, modParam[snippets[s].cond.buffer1[1]-1].paramName, mathStr[snippets[s].cond.mathOperator-1], flt1);				      		
 8005334:	78eb      	ldrb	r3, [r5, #3]
 8005336:	9807      	ldr	r0, [sp, #28]
 8005338:	3b01      	subs	r3, #1
 800533a:	435f      	muls	r7, r3
 800533c:	4b1e      	ldr	r3, [pc, #120]	; (80053b8 <snipCommand+0x1bc>)
 800533e:	19df      	adds	r7, r3, r7
 8005340:	f7fd fbb0 	bl	8002aa4 <__aeabi_f2d>
 8005344:	9002      	str	r0, [sp, #8]
 8005346:	9103      	str	r1, [sp, #12]
 8005348:	786b      	ldrb	r3, [r5, #1]
 800534a:	9a04      	ldr	r2, [sp, #16]
 800534c:	3b01      	subs	r3, #1
 800534e:	435a      	muls	r2, r3
 8005350:	0013      	movs	r3, r2
 8005352:	4a1a      	ldr	r2, [pc, #104]	; (80053bc <snipCommand+0x1c0>)
 8005354:	491a      	ldr	r1, [pc, #104]	; (80053c0 <snipCommand+0x1c4>)
 8005356:	18d3      	adds	r3, r2, r3
 8005358:	9300      	str	r3, [sp, #0]
 800535a:	68bb      	ldr	r3, [r7, #8]
 800535c:	0022      	movs	r2, r4
 800535e:	0020      	movs	r0, r4
 8005360:	f00f fb7c 	bl	8014a5c <sprintf>
				break;
 8005364:	e789      	b.n	800527a <snipCommand+0x7e>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageCmds, pcWriteBuffer, commands );
 8005366:	0022      	movs	r2, r4
 8005368:	002b      	movs	r3, r5
 800536a:	4916      	ldr	r1, [pc, #88]	; (80053c4 <snipCommand+0x1c8>)
 800536c:	0020      	movs	r0, r4
 800536e:	f00f fb75 	bl	8014a5c <sprintf>
			memset( &commands, 0x00, strlen((char*) commands) );
 8005372:	0028      	movs	r0, r5
 8005374:	f7fa fed0 	bl	8000118 <strlen>
 8005378:	2100      	movs	r1, #0
 800537a:	0002      	movs	r2, r0
 800537c:	0028      	movs	r0, r5
 800537e:	f00f f972 	bl	8014666 <memset>
 8005382:	e77e      	b.n	8005282 <snipCommand+0x86>
 8005384:	08018f88 	.word	0x08018f88
 8005388:	20000a9f 	.word	0x20000a9f
 800538c:	0801a4c8 	.word	0x0801a4c8
 8005390:	200011c7 	.word	0x200011c7
 8005394:	0801a58a 	.word	0x0801a58a
 8005398:	20006f8c 	.word	0x20006f8c
 800539c:	0801a500 	.word	0x0801a500
 80053a0:	200011f5 	.word	0x200011f5
 80053a4:	0801a57e 	.word	0x0801a57e
 80053a8:	0801a50c 	.word	0x0801a50c
 80053ac:	0801a51d 	.word	0x0801a51d
 80053b0:	0801a535 	.word	0x0801a535
 80053b4:	0801a54d 	.word	0x0801a54d
 80053b8:	2000008c 	.word	0x2000008c
 80053bc:	0801a030 	.word	0x0801a030
 80053c0:	0801a566 	.word	0x0801a566
 80053c4:	0801a576 	.word	0x0801a576

080053c8 <idcodeCommand>:
{	
 80053c8:	b510      	push	{r4, lr}
 80053ca:	1e04      	subs	r4, r0, #0
	configASSERT( pcWriteBuffer );
 80053cc:	d101      	bne.n	80053d2 <idcodeCommand+0xa>
 80053ce:	b672      	cpsid	i
 80053d0:	e7fe      	b.n	80053d0 <idcodeCommand+0x8>
	dev = HAL_GetDEVID();
 80053d2:	f00c f8ad 	bl	8011530 <HAL_GetDEVID>
	switch (dev)
 80053d6:	4b12      	ldr	r3, [pc, #72]	; (8005420 <idcodeCommand+0x58>)
 80053d8:	b280      	uxth	r0, r0
 80053da:	18c0      	adds	r0, r0, r3
 80053dc:	4911      	ldr	r1, [pc, #68]	; (8005424 <idcodeCommand+0x5c>)
 80053de:	2808      	cmp	r0, #8
 80053e0:	d81c      	bhi.n	800541c <idcodeCommand+0x54>
 80053e2:	f7fa feab 	bl	800013c <__gnu_thumb1_case_uqi>
 80053e6:	1b15      	.short	0x1b15
 80053e8:	13051b19 	.word	0x13051b19
 80053ec:	1b1b      	.short	0x1b1b
 80053ee:	17          	.byte	0x17
 80053ef:	00          	.byte	0x00
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageDEVID, "STM32F03x" );
 80053f0:	4a0d      	ldr	r2, [pc, #52]	; (8005428 <idcodeCommand+0x60>)
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageDEVID, "UNKNOWN" );
 80053f2:	0020      	movs	r0, r4
 80053f4:	f00f fb32 	bl	8014a5c <sprintf>
	sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageREVID, ( char * ) pcWriteBuffer, HAL_GetREVID()>>12 );
 80053f8:	f00c f894 	bl	8011524 <HAL_GetREVID>
 80053fc:	0022      	movs	r2, r4
 80053fe:	0b03      	lsrs	r3, r0, #12
 8005400:	490a      	ldr	r1, [pc, #40]	; (800542c <idcodeCommand+0x64>)
 8005402:	0020      	movs	r0, r4
 8005404:	f00f fb2a 	bl	8014a5c <sprintf>
}
 8005408:	2000      	movs	r0, #0
 800540a:	bd10      	pop	{r4, pc}
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageDEVID, "STM32F04x" );
 800540c:	4a08      	ldr	r2, [pc, #32]	; (8005430 <idcodeCommand+0x68>)
 800540e:	e7f0      	b.n	80053f2 <idcodeCommand+0x2a>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageDEVID, "STM32F05x" );
 8005410:	4a08      	ldr	r2, [pc, #32]	; (8005434 <idcodeCommand+0x6c>)
 8005412:	e7ee      	b.n	80053f2 <idcodeCommand+0x2a>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageDEVID, "STM32F07x" );
 8005414:	4a08      	ldr	r2, [pc, #32]	; (8005438 <idcodeCommand+0x70>)
 8005416:	e7ec      	b.n	80053f2 <idcodeCommand+0x2a>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageDEVID, "STM32F09x" );
 8005418:	4a08      	ldr	r2, [pc, #32]	; (800543c <idcodeCommand+0x74>)
 800541a:	e7ea      	b.n	80053f2 <idcodeCommand+0x2a>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageDEVID, "UNKNOWN" );
 800541c:	4a08      	ldr	r2, [pc, #32]	; (8005440 <idcodeCommand+0x78>)
 800541e:	e7e8      	b.n	80053f2 <idcodeCommand+0x2a>
 8005420:	fffffbc0 	.word	0xfffffbc0
 8005424:	08019f46 	.word	0x08019f46
 8005428:	08019f3c 	.word	0x08019f3c
 800542c:	08019f89 	.word	0x08019f89
 8005430:	08019f59 	.word	0x08019f59
 8005434:	08019f63 	.word	0x08019f63
 8005438:	08019f6d 	.word	0x08019f6d
 800543c:	08019f77 	.word	0x08019f77
 8005440:	08019f81 	.word	0x08019f81

08005444 <dateCommand>:
{
 8005444:	b510      	push	{r4, lr}
 8005446:	1e04      	subs	r4, r0, #0
	configASSERT( pcWriteBuffer );
 8005448:	d101      	bne.n	800544e <dateCommand+0xa>
 800544a:	b672      	cpsid	i
 800544c:	e7fe      	b.n	800544c <dateCommand+0x8>
	GetTimeDate();
 800544e:	f007 f89f 	bl	800c590 <GetTimeDate>
	sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageDate, GetDateString() );
 8005452:	f7fe fe79 	bl	8004148 <GetDateString>
 8005456:	4903      	ldr	r1, [pc, #12]	; (8005464 <dateCommand+0x20>)
 8005458:	0002      	movs	r2, r0
 800545a:	0020      	movs	r0, r4
 800545c:	f00f fafe 	bl	8014a5c <sprintf>
}
 8005460:	2000      	movs	r0, #0
 8005462:	bd10      	pop	{r4, pc}
 8005464:	08019b9c 	.word	0x08019b9c

08005468 <getCommand>:
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0;
 8005468:	2300      	movs	r3, #0
{
 800546a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800546c:	0004      	movs	r4, r0
 800546e:	0016      	movs	r6, r2
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0;
 8005470:	9300      	str	r3, [sp, #0]
 8005472:	9301      	str	r3, [sp, #4]
	configASSERT( pcWriteBuffer );
 8005474:	4298      	cmp	r0, r3
 8005476:	d101      	bne.n	800547c <getCommand+0x14>
 8005478:	b672      	cpsid	i
 800547a:	e7fe      	b.n	800547a <getCommand+0x12>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800547c:	466a      	mov	r2, sp
 800547e:	2101      	movs	r1, #1
 8005480:	0030      	movs	r0, r6
 8005482:	f00a fa6b 	bl	800f95c <FreeRTOS_CLIGetParameter>
 8005486:	4b53      	ldr	r3, [pc, #332]	; (80055d4 <getCommand+0x16c>)
	if (!strncmp((const char *)pcParameterString1, "bos.", 4)) 
 8005488:	2204      	movs	r2, #4
 800548a:	4953      	ldr	r1, [pc, #332]	; (80055d8 <getCommand+0x170>)
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800548c:	0007      	movs	r7, r0
 800548e:	6018      	str	r0, [r3, #0]
	if (!strncmp((const char *)pcParameterString1, "bos.", 4)) 
 8005490:	f00f fb28 	bl	8014ae4 <strncmp>
 8005494:	2800      	cmp	r0, #0
 8005496:	d15d      	bne.n	8005554 <getCommand+0xec>
		if (!strncmp((const char *)pcParameterString1+4, "response", xParameterStringLength1-4)) 
 8005498:	9b00      	ldr	r3, [sp, #0]
 800549a:	1d3e      	adds	r6, r7, #4
 800549c:	1f1d      	subs	r5, r3, #4
 800549e:	002a      	movs	r2, r5
 80054a0:	494e      	ldr	r1, [pc, #312]	; (80055dc <getCommand+0x174>)
 80054a2:	0030      	movs	r0, r6
 80054a4:	f00f fb1e 	bl	8014ae4 <strncmp>
 80054a8:	2800      	cmp	r0, #0
 80054aa:	d10d      	bne.n	80054c8 <getCommand+0x60>
			if (BOS.response == BOS_RESPONSE_ALL)
 80054ac:	4b4c      	ldr	r3, [pc, #304]	; (80055e0 <getCommand+0x178>)
 80054ae:	799b      	ldrb	r3, [r3, #6]
 80054b0:	2b60      	cmp	r3, #96	; 0x60
 80054b2:	d105      	bne.n	80054c0 <getCommand+0x58>
				sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, "all");
 80054b4:	4a4b      	ldr	r2, [pc, #300]	; (80055e4 <getCommand+0x17c>)
				sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, "msg");
 80054b6:	494c      	ldr	r1, [pc, #304]	; (80055e8 <getCommand+0x180>)
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageGroupDoesNotExist, ( char * ) pcParameterString2 );
 80054b8:	0020      	movs	r0, r4
 80054ba:	f00f facf 	bl	8014a5c <sprintf>
			return pdFALSE;
 80054be:	e077      	b.n	80055b0 <getCommand+0x148>
			else if (BOS.response == BOS_RESPONSE_MSG)
 80054c0:	2b20      	cmp	r3, #32
 80054c2:	d10e      	bne.n	80054e2 <getCommand+0x7a>
				sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, "msg");
 80054c4:	4a49      	ldr	r2, [pc, #292]	; (80055ec <getCommand+0x184>)
 80054c6:	e7f6      	b.n	80054b6 <getCommand+0x4e>
		else if (!strncmp((const char *)pcParameterString1+4, "trace", xParameterStringLength1-4)) 
 80054c8:	002a      	movs	r2, r5
 80054ca:	4949      	ldr	r1, [pc, #292]	; (80055f0 <getCommand+0x188>)
 80054cc:	0030      	movs	r0, r6
 80054ce:	f00f fb09 	bl	8014ae4 <strncmp>
 80054d2:	2800      	cmp	r0, #0
 80054d4:	d10b      	bne.n	80054ee <getCommand+0x86>
			if (BOS.trace == TRACE_BOTH)
 80054d6:	4b42      	ldr	r3, [pc, #264]	; (80055e0 <getCommand+0x178>)
 80054d8:	79db      	ldrb	r3, [r3, #7]
 80054da:	2b03      	cmp	r3, #3
 80054dc:	d0ea      	beq.n	80054b4 <getCommand+0x4c>
			else if (BOS.trace == TRACE_MESSAGE)
 80054de:	2b01      	cmp	r3, #1
 80054e0:	d0f0      	beq.n	80054c4 <getCommand+0x5c>
				sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, "none");
 80054e2:	4a44      	ldr	r2, [pc, #272]	; (80055f4 <getCommand+0x18c>)
			else if (BOS.response == BOS_RESPONSE_NONE)
 80054e4:	2b00      	cmp	r3, #0
 80054e6:	d0e6      	beq.n	80054b6 <getCommand+0x4e>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongValue, pcParameterString1);
 80054e8:	003a      	movs	r2, r7
 80054ea:	4943      	ldr	r1, [pc, #268]	; (80055f8 <getCommand+0x190>)
 80054ec:	e7e4      	b.n	80054b8 <getCommand+0x50>
		else if (!strncmp((const char *)pcParameterString1+4, "clibaudrate", xParameterStringLength1-4)) 
 80054ee:	002a      	movs	r2, r5
 80054f0:	4942      	ldr	r1, [pc, #264]	; (80055fc <getCommand+0x194>)
 80054f2:	0030      	movs	r0, r6
 80054f4:	f00f faf6 	bl	8014ae4 <strncmp>
 80054f8:	2800      	cmp	r0, #0
 80054fa:	d103      	bne.n	8005504 <getCommand+0x9c>
			sprintf( ( char * ) pcWriteBuffer, "%d\n\r", BOS.clibaudrate);
 80054fc:	4b38      	ldr	r3, [pc, #224]	; (80055e0 <getCommand+0x178>)
 80054fe:	689a      	ldr	r2, [r3, #8]
			sprintf( ( char * ) pcWriteBuffer, "%d\n\r", BOS.buttons.maxInterClickTime);
 8005500:	493f      	ldr	r1, [pc, #252]	; (8005600 <getCommand+0x198>)
 8005502:	e7d9      	b.n	80054b8 <getCommand+0x50>
		else if (!strncmp((const char *)pcParameterString1+4, "debounce", xParameterStringLength1-4)) 
 8005504:	002a      	movs	r2, r5
 8005506:	493f      	ldr	r1, [pc, #252]	; (8005604 <getCommand+0x19c>)
 8005508:	0030      	movs	r0, r6
 800550a:	f00f faeb 	bl	8014ae4 <strncmp>
 800550e:	2800      	cmp	r0, #0
 8005510:	d102      	bne.n	8005518 <getCommand+0xb0>
			sprintf( ( char * ) pcWriteBuffer, "%d\n\r", BOS.buttons.debounce);
 8005512:	4b33      	ldr	r3, [pc, #204]	; (80055e0 <getCommand+0x178>)
 8005514:	881a      	ldrh	r2, [r3, #0]
 8005516:	e7f3      	b.n	8005500 <getCommand+0x98>
		else if (!strncmp((const char *)pcParameterString1+4, "singleclicktime", xParameterStringLength1-4)) 
 8005518:	002a      	movs	r2, r5
 800551a:	493b      	ldr	r1, [pc, #236]	; (8005608 <getCommand+0x1a0>)
 800551c:	0030      	movs	r0, r6
 800551e:	f00f fae1 	bl	8014ae4 <strncmp>
 8005522:	2800      	cmp	r0, #0
 8005524:	d102      	bne.n	800552c <getCommand+0xc4>
			sprintf( ( char * ) pcWriteBuffer, "%d\n\r", BOS.buttons.singleClickTime);
 8005526:	4b2e      	ldr	r3, [pc, #184]	; (80055e0 <getCommand+0x178>)
 8005528:	885a      	ldrh	r2, [r3, #2]
 800552a:	e7e9      	b.n	8005500 <getCommand+0x98>
		else if (!strncmp((const char *)pcParameterString1+4, "mininterclicktime", xParameterStringLength1-4)) 
 800552c:	002a      	movs	r2, r5
 800552e:	4937      	ldr	r1, [pc, #220]	; (800560c <getCommand+0x1a4>)
 8005530:	0030      	movs	r0, r6
 8005532:	f00f fad7 	bl	8014ae4 <strncmp>
 8005536:	2800      	cmp	r0, #0
 8005538:	d102      	bne.n	8005540 <getCommand+0xd8>
			sprintf( ( char * ) pcWriteBuffer, "%d\n\r", BOS.buttons.minInterClickTime);
 800553a:	4b29      	ldr	r3, [pc, #164]	; (80055e0 <getCommand+0x178>)
 800553c:	791a      	ldrb	r2, [r3, #4]
 800553e:	e7df      	b.n	8005500 <getCommand+0x98>
		else if (!strncmp((const char *)pcParameterString1+4, "maxinterclicktime", xParameterStringLength1-4)) 
 8005540:	002a      	movs	r2, r5
 8005542:	4933      	ldr	r1, [pc, #204]	; (8005610 <getCommand+0x1a8>)
 8005544:	0030      	movs	r0, r6
 8005546:	f00f facd 	bl	8014ae4 <strncmp>
 800554a:	2800      	cmp	r0, #0
 800554c:	d132      	bne.n	80055b4 <getCommand+0x14c>
			sprintf( ( char * ) pcWriteBuffer, "%d\n\r", BOS.buttons.maxInterClickTime);
 800554e:	4b24      	ldr	r3, [pc, #144]	; (80055e0 <getCommand+0x178>)
 8005550:	795a      	ldrb	r2, [r3, #5]
 8005552:	e7d5      	b.n	8005500 <getCommand+0x98>
	else if (!strncmp((const char *)pcParameterString1, "group", 5))
 8005554:	2205      	movs	r2, #5
 8005556:	492f      	ldr	r1, [pc, #188]	; (8005614 <getCommand+0x1ac>)
 8005558:	0038      	movs	r0, r7
 800555a:	f00f fac3 	bl	8014ae4 <strncmp>
 800555e:	1e05      	subs	r5, r0, #0
 8005560:	d128      	bne.n	80055b4 <getCommand+0x14c>
		pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005562:	0030      	movs	r0, r6
 8005564:	aa01      	add	r2, sp, #4
 8005566:	2102      	movs	r1, #2
 8005568:	f00a f9f8 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800556c:	0006      	movs	r6, r0
			if (!strcmp( ( char * ) pcParameterString2, groupAlias[i]))	
 800556e:	4f2a      	ldr	r7, [pc, #168]	; (8005618 <getCommand+0x1b0>)
 8005570:	210a      	movs	r1, #10
 8005572:	4369      	muls	r1, r5
 8005574:	0030      	movs	r0, r6
 8005576:	19c9      	adds	r1, r1, r7
 8005578:	f7fa fdc4 	bl	8000104 <strcmp>
 800557c:	2800      	cmp	r0, #0
 800557e:	d01e      	beq.n	80055be <getCommand+0x156>
 8005580:	3501      	adds	r5, #1
		for(i=0 ; i<MaxNumOfGroups ; i++)
 8005582:	2d0a      	cmp	r5, #10
 8005584:	d1f4      	bne.n	8005570 <getCommand+0x108>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageGroupDoesNotExist, ( char * ) pcParameterString2 );
 8005586:	0032      	movs	r2, r6
 8005588:	4924      	ldr	r1, [pc, #144]	; (800561c <getCommand+0x1b4>)
 800558a:	e795      	b.n	80054b8 <getCommand+0x50>
				if (InGroup(j, i))
 800558c:	1e6b      	subs	r3, r5, #1
 800558e:	4a24      	ldr	r2, [pc, #144]	; (8005620 <getCommand+0x1b8>)
 8005590:	005b      	lsls	r3, r3, #1
 8005592:	5a9b      	ldrh	r3, [r3, r2]
 8005594:	421e      	tst	r6, r3
 8005596:	d005      	beq.n	80055a4 <getCommand+0x13c>
					sprintf( ( char * ) pcWriteBuffer, "%s#%d\n\r", ( char * ) pcWriteBuffer, j );
 8005598:	002b      	movs	r3, r5
 800559a:	0022      	movs	r2, r4
 800559c:	4921      	ldr	r1, [pc, #132]	; (8005624 <getCommand+0x1bc>)
 800559e:	0020      	movs	r0, r4
 80055a0:	f00f fa5c 	bl	8014a5c <sprintf>
			for(j=1 ; j<=N ; j++)						// N modules
 80055a4:	3501      	adds	r5, #1
 80055a6:	b2ed      	uxtb	r5, r5
 80055a8:	4b1f      	ldr	r3, [pc, #124]	; (8005628 <getCommand+0x1c0>)
 80055aa:	781b      	ldrb	r3, [r3, #0]
 80055ac:	42ab      	cmp	r3, r5
 80055ae:	d2ed      	bcs.n	800558c <getCommand+0x124>
}
 80055b0:	2000      	movs	r0, #0
 80055b2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongParam );
 80055b4:	491d      	ldr	r1, [pc, #116]	; (800562c <getCommand+0x1c4>)
 80055b6:	0020      	movs	r0, r4
 80055b8:	f00f fa8c 	bl	8014ad4 <strcpy>
 80055bc:	e7f8      	b.n	80055b0 <getCommand+0x148>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageGroupExists, ( char * ) pcParameterString2 );
 80055be:	0032      	movs	r2, r6
 80055c0:	491b      	ldr	r1, [pc, #108]	; (8005630 <getCommand+0x1c8>)
 80055c2:	0020      	movs	r0, r4
 80055c4:	f00f fa4a 	bl	8014a5c <sprintf>
 80055c8:	2301      	movs	r3, #1
 80055ca:	001e      	movs	r6, r3
 80055cc:	40ae      	lsls	r6, r5
			for(j=1 ; j<=N ; j++)						// N modules
 80055ce:	001d      	movs	r5, r3
 80055d0:	e7ea      	b.n	80055a8 <getCommand+0x140>
 80055d2:	46c0      	nop			; (mov r8, r8)
 80055d4:	20001238 	.word	0x20001238
 80055d8:	08019d04 	.word	0x08019d04
 80055dc:	08019d09 	.word	0x08019d09
 80055e0:	20006f70 	.word	0x20006f70
 80055e4:	080192de 	.word	0x080192de
 80055e8:	0801915d 	.word	0x0801915d
 80055ec:	08019d12 	.word	0x08019d12
 80055f0:	08019d1b 	.word	0x08019d1b
 80055f4:	08019d16 	.word	0x08019d16
 80055f8:	08019d8b 	.word	0x08019d8b
 80055fc:	08019d21 	.word	0x08019d21
 8005600:	0801972a 	.word	0x0801972a
 8005604:	08019d2d 	.word	0x08019d2d
 8005608:	08019d36 	.word	0x08019d36
 800560c:	08019d46 	.word	0x08019d46
 8005610:	08019d58 	.word	0x08019d58
 8005614:	08019d6a 	.word	0x08019d6a
 8005618:	20000e2f 	.word	0x20000e2f
 800561c:	08019da9 	.word	0x08019da9
 8005620:	20000e94 	.word	0x20000e94
 8005624:	08019d70 	.word	0x08019d70
 8005628:	2000001c 	.word	0x2000001c
 800562c:	08019d78 	.word	0x08019d78
 8005630:	08019dc4 	.word	0x08019dc4

08005634 <defaultCommand>:
	portBASE_TYPE xParameterStringLength1 = 0;
 8005634:	2300      	movs	r3, #0
{
 8005636:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8005638:	0004      	movs	r4, r0
	portBASE_TYPE xParameterStringLength1 = 0;
 800563a:	9301      	str	r3, [sp, #4]
{
 800563c:	0010      	movs	r0, r2
	configASSERT( pcWriteBuffer );
 800563e:	429c      	cmp	r4, r3
 8005640:	d101      	bne.n	8005646 <defaultCommand+0x12>
 8005642:	b672      	cpsid	i
 8005644:	e7fe      	b.n	8005644 <defaultCommand+0x10>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005646:	aa01      	add	r2, sp, #4
 8005648:	2101      	movs	r1, #1
 800564a:	f00a f987 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (!strncmp((const char *)pcParameterString1, "params", xParameterStringLength1)) 
 800564e:	9e01      	ldr	r6, [sp, #4]
 8005650:	4919      	ldr	r1, [pc, #100]	; (80056b8 <defaultCommand+0x84>)
 8005652:	0032      	movs	r2, r6
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005654:	0005      	movs	r5, r0
	if (!strncmp((const char *)pcParameterString1, "params", xParameterStringLength1)) 
 8005656:	f00f fa45 	bl	8014ae4 <strncmp>
 800565a:	2800      	cmp	r0, #0
 800565c:	d110      	bne.n	8005680 <defaultCommand+0x4c>
		memcpy(&BOS, &BOS_default, sizeof(BOS_default));
 800565e:	4917      	ldr	r1, [pc, #92]	; (80056bc <defaultCommand+0x88>)
 8005660:	4b17      	ldr	r3, [pc, #92]	; (80056c0 <defaultCommand+0x8c>)
 8005662:	000a      	movs	r2, r1
 8005664:	cb23      	ldmia	r3!, {r0, r1, r5}
 8005666:	c223      	stmia	r2!, {r0, r1, r5}
 8005668:	cb23      	ldmia	r3!, {r0, r1, r5}
 800566a:	c223      	stmia	r2!, {r0, r1, r5}
 800566c:	681b      	ldr	r3, [r3, #0]
 800566e:	6013      	str	r3, [r2, #0]
		SaveEEparams();
 8005670:	f7fd fdda 	bl	8003228 <SaveEEparams>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageOKParams );
 8005674:	4913      	ldr	r1, [pc, #76]	; (80056c4 <defaultCommand+0x90>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageOKArray );
 8005676:	0020      	movs	r0, r4
 8005678:	f00f fa2c 	bl	8014ad4 <strcpy>
}
 800567c:	2000      	movs	r0, #0
 800567e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
	else if (!strncmp((const char *)pcParameterString1, "array", xParameterStringLength1)) 
 8005680:	0032      	movs	r2, r6
 8005682:	4911      	ldr	r1, [pc, #68]	; (80056c8 <defaultCommand+0x94>)
 8005684:	0028      	movs	r0, r5
 8005686:	f00f fa2d 	bl	8014ae4 <strncmp>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongValue );
 800568a:	4910      	ldr	r1, [pc, #64]	; (80056cc <defaultCommand+0x98>)
	else if (!strncmp((const char *)pcParameterString1, "array", xParameterStringLength1)) 
 800568c:	1e02      	subs	r2, r0, #0
 800568e:	d1f2      	bne.n	8005676 <defaultCommand+0x42>
		SendMessageToModule(BOS_BROADCAST, CODE_DEF_ARRAY, 0);
 8005690:	2116      	movs	r1, #22
 8005692:	20ff      	movs	r0, #255	; 0xff
 8005694:	f002 fc4a 	bl	8007f2c <SendMessageToModule>
		indMode = IND_TOPOLOGY; osDelay(100);
 8005698:	2202      	movs	r2, #2
 800569a:	4b0d      	ldr	r3, [pc, #52]	; (80056d0 <defaultCommand+0x9c>)
 800569c:	2064      	movs	r0, #100	; 0x64
 800569e:	701a      	strb	r2, [r3, #0]
 80056a0:	f00a f85f 	bl	800f762 <osDelay>
		ClearEEportsDir();
 80056a4:	f7fd fb8e 	bl	8002dc4 <ClearEEportsDir>
		ClearROtopology();
 80056a8:	f004 f90e 	bl	80098c8 <ClearROtopology>
		osDelay(100);
 80056ac:	2064      	movs	r0, #100	; 0x64
 80056ae:	f00a f858 	bl	800f762 <osDelay>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageOKArray );
 80056b2:	4908      	ldr	r1, [pc, #32]	; (80056d4 <defaultCommand+0xa0>)
 80056b4:	e7df      	b.n	8005676 <defaultCommand+0x42>
 80056b6:	46c0      	nop			; (mov r8, r8)
 80056b8:	08019bc4 	.word	0x08019bc4
 80056bc:	20006f70 	.word	0x20006f70
 80056c0:	20000000 	.word	0x20000000
 80056c4:	08019bcb 	.word	0x08019bcb
 80056c8:	08019bf2 	.word	0x08019bf2
 80056cc:	08019bf8 	.word	0x08019bf8
 80056d0:	20000ec6 	.word	0x20000ec6
 80056d4:	08019c07 	.word	0x08019c07

080056d8 <setCommand>:
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0, xParameterStringLength3 = 0;
 80056d8:	2300      	movs	r3, #0
{
 80056da:	b5f0      	push	{r4, r5, r6, r7, lr}
 80056dc:	b091      	sub	sp, #68	; 0x44
 80056de:	9007      	str	r0, [sp, #28]
 80056e0:	0014      	movs	r4, r2
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0, xParameterStringLength3 = 0;
 80056e2:	930b      	str	r3, [sp, #44]	; 0x2c
 80056e4:	930c      	str	r3, [sp, #48]	; 0x30
 80056e6:	930d      	str	r3, [sp, #52]	; 0x34
	portBASE_TYPE xParameterStringLength4 = 0, xParameterStringLength5 = 0;
 80056e8:	930e      	str	r3, [sp, #56]	; 0x38
 80056ea:	930f      	str	r3, [sp, #60]	; 0x3c
	configASSERT( pcWriteBuffer );
 80056ec:	2800      	cmp	r0, #0
 80056ee:	d101      	bne.n	80056f4 <setCommand+0x1c>
 80056f0:	b672      	cpsid	i
 80056f2:	e7fe      	b.n	80056f2 <setCommand+0x1a>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 80056f4:	aa0b      	add	r2, sp, #44	; 0x2c
 80056f6:	2101      	movs	r1, #1
 80056f8:	0020      	movs	r0, r4
 80056fa:	f00a f92f 	bl	800f95c <FreeRTOS_CLIGetParameter>
 80056fe:	4ec6      	ldr	r6, [pc, #792]	; (8005a18 <setCommand+0x340>)
	if (!strncmp((const char *)pcParameterString1, "bos.", 4)) 
 8005700:	2204      	movs	r2, #4
 8005702:	49c6      	ldr	r1, [pc, #792]	; (8005a1c <setCommand+0x344>)
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005704:	0005      	movs	r5, r0
 8005706:	6030      	str	r0, [r6, #0]
	if (!strncmp((const char *)pcParameterString1, "bos.", 4)) 
 8005708:	f00f f9ec 	bl	8014ae4 <strncmp>
 800570c:	2800      	cmp	r0, #0
 800570e:	d000      	beq.n	8005712 <setCommand+0x3a>
 8005710:	e119      	b.n	8005946 <setCommand+0x26e>
		pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005712:	aa0c      	add	r2, sp, #48	; 0x30
 8005714:	2102      	movs	r1, #2
 8005716:	0020      	movs	r0, r4
 8005718:	f00a f920 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800571c:	4bc0      	ldr	r3, [pc, #768]	; (8005a20 <setCommand+0x348>)
		if (!strncmp((const char *)pcParameterString1+4, "response", xParameterStringLength1-4)) 
 800571e:	6836      	ldr	r6, [r6, #0]
		pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005720:	6018      	str	r0, [r3, #0]
		if (!strncmp((const char *)pcParameterString1+4, "response", xParameterStringLength1-4)) 
 8005722:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005724:	4cbf      	ldr	r4, [pc, #764]	; (8005a24 <setCommand+0x34c>)
 8005726:	3604      	adds	r6, #4
 8005728:	1f1f      	subs	r7, r3, #4
		pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800572a:	0005      	movs	r5, r0
		if (!strncmp((const char *)pcParameterString1+4, "response", xParameterStringLength1-4)) 
 800572c:	003a      	movs	r2, r7
 800572e:	0021      	movs	r1, r4
 8005730:	0030      	movs	r0, r6
 8005732:	f00f f9d7 	bl	8014ae4 <strncmp>
 8005736:	2800      	cmp	r0, #0
 8005738:	d14e      	bne.n	80057d8 <setCommand+0x100>
			if (!strncmp((const char *)pcParameterString2, "all", xParameterStringLength2)) {
 800573a:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 800573c:	49ba      	ldr	r1, [pc, #744]	; (8005a28 <setCommand+0x350>)
 800573e:	003a      	movs	r2, r7
 8005740:	0028      	movs	r0, r5
 8005742:	f00f f9cf 	bl	8014ae4 <strncmp>
 8005746:	1e04      	subs	r4, r0, #0
 8005748:	d106      	bne.n	8005758 <setCommand+0x80>
				BOS.response = BOS_RESPONSE_ALL;
 800574a:	2160      	movs	r1, #96	; 0x60
 800574c:	4bb7      	ldr	r3, [pc, #732]	; (8005a2c <setCommand+0x354>)
				BOS.response = BOS_RESPONSE_CLI;
 800574e:	7199      	strb	r1, [r3, #6]
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005750:	79db      	ldrb	r3, [r3, #7]
 8005752:	021b      	lsls	r3, r3, #8
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005754:	4319      	orrs	r1, r3
 8005756:	e025      	b.n	80057a4 <setCommand+0xcc>
			} else if (!strncmp((const char *)pcParameterString2, "message", xParameterStringLength2)) {
 8005758:	003a      	movs	r2, r7
 800575a:	49b5      	ldr	r1, [pc, #724]	; (8005a30 <setCommand+0x358>)
 800575c:	0028      	movs	r0, r5
 800575e:	f00f f9c1 	bl	8014ae4 <strncmp>
 8005762:	1e04      	subs	r4, r0, #0
 8005764:	d102      	bne.n	800576c <setCommand+0x94>
				BOS.response = BOS_RESPONSE_MSG;
 8005766:	4bb1      	ldr	r3, [pc, #708]	; (8005a2c <setCommand+0x354>)
 8005768:	2120      	movs	r1, #32
 800576a:	e7f0      	b.n	800574e <setCommand+0x76>
		  } else if (!strncmp((const char *)pcParameterString2, "cli", xParameterStringLength2)) {
 800576c:	003a      	movs	r2, r7
 800576e:	49b1      	ldr	r1, [pc, #708]	; (8005a34 <setCommand+0x35c>)
 8005770:	0028      	movs	r0, r5
 8005772:	f00f f9b7 	bl	8014ae4 <strncmp>
 8005776:	1e04      	subs	r4, r0, #0
 8005778:	d102      	bne.n	8005780 <setCommand+0xa8>
				BOS.response = BOS_RESPONSE_CLI;
 800577a:	4bac      	ldr	r3, [pc, #688]	; (8005a2c <setCommand+0x354>)
 800577c:	2140      	movs	r1, #64	; 0x40
 800577e:	e7e6      	b.n	800574e <setCommand+0x76>
		  } else if (!strncmp((const char *)pcParameterString2, "none", xParameterStringLength2)) {
 8005780:	003a      	movs	r2, r7
 8005782:	49ad      	ldr	r1, [pc, #692]	; (8005a38 <setCommand+0x360>)
 8005784:	0028      	movs	r0, r5
 8005786:	f00f f9ad 	bl	8014ae4 <strncmp>
 800578a:	1e04      	subs	r4, r0, #0
 800578c:	d006      	beq.n	800579c <setCommand+0xc4>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongValue );
 800578e:	49ab      	ldr	r1, [pc, #684]	; (8005a3c <setCommand+0x364>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongParam );
 8005790:	9807      	ldr	r0, [sp, #28]
 8005792:	f00f f99f 	bl	8014ad4 <strcpy>
}
 8005796:	2000      	movs	r0, #0
 8005798:	b011      	add	sp, #68	; 0x44
 800579a:	bdf0      	pop	{r4, r5, r6, r7, pc}
				BOS.response = BOS_RESPONSE_NONE;
 800579c:	4ba3      	ldr	r3, [pc, #652]	; (8005a2c <setCommand+0x354>)
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 800579e:	79d9      	ldrb	r1, [r3, #7]
				BOS.response = BOS_RESPONSE_NONE;
 80057a0:	7198      	strb	r0, [r3, #6]
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 80057a2:	0209      	lsls	r1, r1, #8
 80057a4:	208a      	movs	r0, #138	; 0x8a
 80057a6:	0040      	lsls	r0, r0, #1
 80057a8:	f001 f928 	bl	80069fc <EE_WriteVariable>
		pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 80057ac:	4b9a      	ldr	r3, [pc, #616]	; (8005a18 <setCommand+0x340>)
 80057ae:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80057b0:	681a      	ldr	r2, [r3, #0]
 80057b2:	2300      	movs	r3, #0
 80057b4:	5453      	strb	r3, [r2, r1]
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, pcParameterString1, pcParameterString2);
 80057b6:	4b9a      	ldr	r3, [pc, #616]	; (8005a20 <setCommand+0x348>)
 80057b8:	49a1      	ldr	r1, [pc, #644]	; (8005a40 <setCommand+0x368>)
 80057ba:	681b      	ldr	r3, [r3, #0]
 80057bc:	9807      	ldr	r0, [sp, #28]
 80057be:	f00f f94d 	bl	8014a5c <sprintf>
		if (extraMessage == 1) {
 80057c2:	2c01      	cmp	r4, #1
 80057c4:	d1e7      	bne.n	8005796 <setCommand+0xbe>
			strcat(( char * ) pcWriteBuffer, ( char * ) pcMessageCLI1);
 80057c6:	499f      	ldr	r1, [pc, #636]	; (8005a44 <setCommand+0x36c>)
 80057c8:	9807      	ldr	r0, [sp, #28]
 80057ca:	f00f f967 	bl	8014a9c <strcat>
			strcat(( char * ) pcWriteBuffer, ( char * ) pcMessageCLI2);
 80057ce:	499e      	ldr	r1, [pc, #632]	; (8005a48 <setCommand+0x370>)
 80057d0:	9807      	ldr	r0, [sp, #28]
 80057d2:	f00f f963 	bl	8014a9c <strcat>
 80057d6:	e7de      	b.n	8005796 <setCommand+0xbe>
		else if (!strncmp((const char *)pcParameterString1+4, "trace", xParameterStringLength1-4)) 
 80057d8:	003a      	movs	r2, r7
 80057da:	499c      	ldr	r1, [pc, #624]	; (8005a4c <setCommand+0x374>)
 80057dc:	0030      	movs	r0, r6
 80057de:	f00f f981 	bl	8014ae4 <strncmp>
 80057e2:	2800      	cmp	r0, #0
 80057e4:	d13b      	bne.n	800585e <setCommand+0x186>
			if (!strncmp((const char *)pcParameterString2, "all", xParameterStringLength2)) {
 80057e6:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 80057e8:	498f      	ldr	r1, [pc, #572]	; (8005a28 <setCommand+0x350>)
 80057ea:	003a      	movs	r2, r7
 80057ec:	0028      	movs	r0, r5
 80057ee:	f00f f979 	bl	8014ae4 <strncmp>
 80057f2:	2800      	cmp	r0, #0
 80057f4:	d10c      	bne.n	8005810 <setCommand+0x138>
				BOS.trace = TRACE_BOTH;
 80057f6:	2203      	movs	r2, #3
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 80057f8:	21c0      	movs	r1, #192	; 0xc0
				BOS.trace = TRACE_BOTH;
 80057fa:	4b8c      	ldr	r3, [pc, #560]	; (8005a2c <setCommand+0x354>)
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 80057fc:	0089      	lsls	r1, r1, #2
				BOS.trace = TRACE_BOTH;
 80057fe:	71da      	strb	r2, [r3, #7]
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005800:	799b      	ldrb	r3, [r3, #6]
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005802:	208a      	movs	r0, #138	; 0x8a
 8005804:	4319      	orrs	r1, r3
 8005806:	0040      	lsls	r0, r0, #1
				EE_WriteVariable(_EE_PARAMS_DBL_CLICK, ((uint16_t)BOS.buttons.maxInterClickTime<<8) | (uint16_t)BOS.buttons.minInterClickTime);
 8005808:	f001 f8f8 	bl	80069fc <EE_WriteVariable>
	uint16_t temp16 = 0; uint32_t temp2 = 0; uint8_t extraMessage = 0, temp81, temp82, temp83, temp84;
 800580c:	2400      	movs	r4, #0
 800580e:	e7cd      	b.n	80057ac <setCommand+0xd4>
			} else if (!strncmp((const char *)pcParameterString2, "message", xParameterStringLength2)) {
 8005810:	003a      	movs	r2, r7
 8005812:	4987      	ldr	r1, [pc, #540]	; (8005a30 <setCommand+0x358>)
 8005814:	0028      	movs	r0, r5
 8005816:	f00f f965 	bl	8014ae4 <strncmp>
 800581a:	2800      	cmp	r0, #0
 800581c:	d106      	bne.n	800582c <setCommand+0x154>
				BOS.trace = TRACE_MESSAGE;
 800581e:	2201      	movs	r2, #1
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005820:	2180      	movs	r1, #128	; 0x80
				BOS.trace = TRACE_MESSAGE;
 8005822:	4b82      	ldr	r3, [pc, #520]	; (8005a2c <setCommand+0x354>)
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005824:	0049      	lsls	r1, r1, #1
				BOS.trace = TRACE_MESSAGE;
 8005826:	71da      	strb	r2, [r3, #7]
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005828:	799b      	ldrb	r3, [r3, #6]
 800582a:	e7ea      	b.n	8005802 <setCommand+0x12a>
			} else if (!strncmp((const char *)pcParameterString2, "response", xParameterStringLength2)) {
 800582c:	0021      	movs	r1, r4
 800582e:	003a      	movs	r2, r7
 8005830:	0028      	movs	r0, r5
 8005832:	f00f f957 	bl	8014ae4 <strncmp>
 8005836:	1e04      	subs	r4, r0, #0
 8005838:	d106      	bne.n	8005848 <setCommand+0x170>
				BOS.trace = TRACE_RESPONSE;
 800583a:	2202      	movs	r2, #2
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 800583c:	2180      	movs	r1, #128	; 0x80
				BOS.trace = TRACE_RESPONSE;
 800583e:	4b7b      	ldr	r3, [pc, #492]	; (8005a2c <setCommand+0x354>)
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005840:	0089      	lsls	r1, r1, #2
				BOS.trace = TRACE_RESPONSE;
 8005842:	71da      	strb	r2, [r3, #7]
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 8005844:	799b      	ldrb	r3, [r3, #6]
 8005846:	e785      	b.n	8005754 <setCommand+0x7c>
		  } else if (!strncmp((const char *)pcParameterString2, "none", xParameterStringLength2)) {
 8005848:	003a      	movs	r2, r7
 800584a:	497b      	ldr	r1, [pc, #492]	; (8005a38 <setCommand+0x360>)
 800584c:	0028      	movs	r0, r5
 800584e:	f00f f949 	bl	8014ae4 <strncmp>
 8005852:	1e04      	subs	r4, r0, #0
 8005854:	d19b      	bne.n	800578e <setCommand+0xb6>
				BOS.trace = TRACE_NONE;
 8005856:	4b75      	ldr	r3, [pc, #468]	; (8005a2c <setCommand+0x354>)
 8005858:	71d8      	strb	r0, [r3, #7]
				EE_WriteVariable(_EE_PARAMS_BASE, ((uint16_t)BOS.trace<<8) | (uint16_t)BOS.response);
 800585a:	7999      	ldrb	r1, [r3, #6]
 800585c:	e7a2      	b.n	80057a4 <setCommand+0xcc>
		else if (!strncmp((const char *)pcParameterString1+4, "clibaudrate", xParameterStringLength1-4)) 
 800585e:	003a      	movs	r2, r7
 8005860:	497b      	ldr	r1, [pc, #492]	; (8005a50 <setCommand+0x378>)
 8005862:	0030      	movs	r0, r6
 8005864:	f00f f93e 	bl	8014ae4 <strncmp>
 8005868:	2800      	cmp	r0, #0
 800586a:	d116      	bne.n	800589a <setCommand+0x1c2>
			temp2 = atoi((const char *)pcParameterString2);
 800586c:	0028      	movs	r0, r5
 800586e:	f00e fc71 	bl	8014154 <atoi>
			if (temp2 <= DEF_CLI_BAUDRATE) {
 8005872:	23e1      	movs	r3, #225	; 0xe1
 8005874:	031b      	lsls	r3, r3, #12
 8005876:	4298      	cmp	r0, r3
 8005878:	d900      	bls.n	800587c <setCommand+0x1a4>
 800587a:	e788      	b.n	800578e <setCommand+0xb6>
				BOS.clibaudrate = temp2;
 800587c:	4c6b      	ldr	r4, [pc, #428]	; (8005a2c <setCommand+0x354>)
				EE_WriteVariable(_EE_CLI_BAUD, (uint16_t)BOS.clibaudrate);
 800587e:	b281      	uxth	r1, r0
				BOS.clibaudrate = temp2;
 8005880:	60a0      	str	r0, [r4, #8]
				EE_WriteVariable(_EE_CLI_BAUD, (uint16_t)BOS.clibaudrate);
 8005882:	208c      	movs	r0, #140	; 0x8c
 8005884:	0040      	lsls	r0, r0, #1
 8005886:	f001 f8b9 	bl	80069fc <EE_WriteVariable>
				EE_WriteVariable(_EE_CLI_BAUD+1, (uint16_t)(BOS.clibaudrate>>16));
 800588a:	201a      	movs	r0, #26
 800588c:	68a1      	ldr	r1, [r4, #8]
 800588e:	30ff      	adds	r0, #255	; 0xff
 8005890:	0c09      	lsrs	r1, r1, #16
 8005892:	f001 f8b3 	bl	80069fc <EE_WriteVariable>
				extraMessage = 1;
 8005896:	2401      	movs	r4, #1
 8005898:	e788      	b.n	80057ac <setCommand+0xd4>
		else if (!strncmp((const char *)pcParameterString1+4, "debounce", xParameterStringLength1-4)) 
 800589a:	003a      	movs	r2, r7
 800589c:	496d      	ldr	r1, [pc, #436]	; (8005a54 <setCommand+0x37c>)
 800589e:	0030      	movs	r0, r6
 80058a0:	f00f f920 	bl	8014ae4 <strncmp>
 80058a4:	1e04      	subs	r4, r0, #0
 80058a6:	d10b      	bne.n	80058c0 <setCommand+0x1e8>
			temp16 = atoi((const char *)pcParameterString2);
 80058a8:	0028      	movs	r0, r5
 80058aa:	f00e fc53 	bl	8014154 <atoi>
 80058ae:	b281      	uxth	r1, r0
			if (temp16 >= 1 && temp16 <= USHRT_MAX) {
 80058b0:	2900      	cmp	r1, #0
 80058b2:	d100      	bne.n	80058b6 <setCommand+0x1de>
 80058b4:	e76b      	b.n	800578e <setCommand+0xb6>
				EE_WriteVariable(_EE_PARAMS_DEBOUNCE, temp16);
 80058b6:	2016      	movs	r0, #22
				BOS.buttons.debounce = temp16;
 80058b8:	4b5c      	ldr	r3, [pc, #368]	; (8005a2c <setCommand+0x354>)
 80058ba:	8019      	strh	r1, [r3, #0]
				EE_WriteVariable(_EE_PARAMS_DBL_CLICK, ((uint16_t)BOS.buttons.maxInterClickTime<<8) | (uint16_t)BOS.buttons.minInterClickTime);
 80058bc:	30ff      	adds	r0, #255	; 0xff
 80058be:	e773      	b.n	80057a8 <setCommand+0xd0>
		else if (!strncmp((const char *)pcParameterString1+4, "singleclicktime", xParameterStringLength1-4)) 
 80058c0:	003a      	movs	r2, r7
 80058c2:	4965      	ldr	r1, [pc, #404]	; (8005a58 <setCommand+0x380>)
 80058c4:	0030      	movs	r0, r6
 80058c6:	f00f f90d 	bl	8014ae4 <strncmp>
 80058ca:	1e04      	subs	r4, r0, #0
 80058cc:	d10a      	bne.n	80058e4 <setCommand+0x20c>
			temp16 = atoi((const char *)pcParameterString2);
 80058ce:	0028      	movs	r0, r5
 80058d0:	f00e fc40 	bl	8014154 <atoi>
 80058d4:	b281      	uxth	r1, r0
			if (temp16 >= 1 && temp16 <= USHRT_MAX) {
 80058d6:	2900      	cmp	r1, #0
 80058d8:	d100      	bne.n	80058dc <setCommand+0x204>
 80058da:	e758      	b.n	800578e <setCommand+0xb6>
				BOS.buttons.singleClickTime = temp16;
 80058dc:	4b53      	ldr	r3, [pc, #332]	; (8005a2c <setCommand+0x354>)
				EE_WriteVariable(_EE_PARAMS_SINGLE_CLICK, temp16);
 80058de:	208b      	movs	r0, #139	; 0x8b
				BOS.buttons.singleClickTime = temp16;
 80058e0:	8059      	strh	r1, [r3, #2]
 80058e2:	e760      	b.n	80057a6 <setCommand+0xce>
		else if (!strncmp((const char *)pcParameterString1+4, "mininterclicktime", xParameterStringLength1-4)) 
 80058e4:	003a      	movs	r2, r7
 80058e6:	495d      	ldr	r1, [pc, #372]	; (8005a5c <setCommand+0x384>)
 80058e8:	0030      	movs	r0, r6
 80058ea:	f00f f8fb 	bl	8014ae4 <strncmp>
 80058ee:	1e04      	subs	r4, r0, #0
 80058f0:	d10f      	bne.n	8005912 <setCommand+0x23a>
			temp16 = atoi((const char *)pcParameterString2);
 80058f2:	0028      	movs	r0, r5
 80058f4:	f00e fc2e 	bl	8014154 <atoi>
			if (temp16 >= 1 && temp16 <= UCHAR_MAX) {
 80058f8:	1e43      	subs	r3, r0, #1
 80058fa:	b29b      	uxth	r3, r3
 80058fc:	2bfe      	cmp	r3, #254	; 0xfe
 80058fe:	d900      	bls.n	8005902 <setCommand+0x22a>
 8005900:	e745      	b.n	800578e <setCommand+0xb6>
				BOS.buttons.minInterClickTime = temp16;
 8005902:	4b4a      	ldr	r3, [pc, #296]	; (8005a2c <setCommand+0x354>)
 8005904:	b2c0      	uxtb	r0, r0
				EE_WriteVariable(_EE_PARAMS_DBL_CLICK, ((uint16_t)BOS.buttons.maxInterClickTime<<8) | (uint16_t)BOS.buttons.minInterClickTime);
 8005906:	7959      	ldrb	r1, [r3, #5]
				BOS.buttons.minInterClickTime = temp16;
 8005908:	7118      	strb	r0, [r3, #4]
				EE_WriteVariable(_EE_PARAMS_DBL_CLICK, ((uint16_t)BOS.buttons.maxInterClickTime<<8) | (uint16_t)BOS.buttons.minInterClickTime);
 800590a:	0209      	lsls	r1, r1, #8
 800590c:	4301      	orrs	r1, r0
 800590e:	2018      	movs	r0, #24
 8005910:	e7d4      	b.n	80058bc <setCommand+0x1e4>
		else if (!strncmp((const char *)pcParameterString1+4, "maxinterclicktime", xParameterStringLength1-4)) 
 8005912:	003a      	movs	r2, r7
 8005914:	4952      	ldr	r1, [pc, #328]	; (8005a60 <setCommand+0x388>)
 8005916:	0030      	movs	r0, r6
 8005918:	f00f f8e4 	bl	8014ae4 <strncmp>
 800591c:	2800      	cmp	r0, #0
 800591e:	d001      	beq.n	8005924 <setCommand+0x24c>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongParam );
 8005920:	4950      	ldr	r1, [pc, #320]	; (8005a64 <setCommand+0x38c>)
 8005922:	e735      	b.n	8005790 <setCommand+0xb8>
			temp16 = atoi((const char *)pcParameterString2);
 8005924:	0028      	movs	r0, r5
 8005926:	f00e fc15 	bl	8014154 <atoi>
			if (temp16 >= 1 && temp16 <= UCHAR_MAX) {
 800592a:	1e43      	subs	r3, r0, #1
 800592c:	b29b      	uxth	r3, r3
 800592e:	2bfe      	cmp	r3, #254	; 0xfe
 8005930:	d900      	bls.n	8005934 <setCommand+0x25c>
 8005932:	e72c      	b.n	800578e <setCommand+0xb6>
				BOS.buttons.maxInterClickTime = temp16;
 8005934:	4b3d      	ldr	r3, [pc, #244]	; (8005a2c <setCommand+0x354>)
				EE_WriteVariable(_EE_PARAMS_DBL_CLICK, ((uint16_t)BOS.buttons.maxInterClickTime<<8) | (uint16_t)BOS.buttons.minInterClickTime);
 8005936:	7919      	ldrb	r1, [r3, #4]
				BOS.buttons.maxInterClickTime = temp16;
 8005938:	7158      	strb	r0, [r3, #5]
				EE_WriteVariable(_EE_PARAMS_DBL_CLICK, ((uint16_t)BOS.buttons.maxInterClickTime<<8) | (uint16_t)BOS.buttons.minInterClickTime);
 800593a:	0200      	lsls	r0, r0, #8
 800593c:	4301      	orrs	r1, r0
 800593e:	2018      	movs	r0, #24
 8005940:	b289      	uxth	r1, r1
 8005942:	30ff      	adds	r0, #255	; 0xff
 8005944:	e760      	b.n	8005808 <setCommand+0x130>
	else if (!strncmp((const char *)pcParameterString1, "time", 4))
 8005946:	2204      	movs	r2, #4
 8005948:	4947      	ldr	r1, [pc, #284]	; (8005a68 <setCommand+0x390>)
 800594a:	0028      	movs	r0, r5
 800594c:	f00f f8ca 	bl	8014ae4 <strncmp>
 8005950:	2800      	cmp	r0, #0
 8005952:	d000      	beq.n	8005956 <setCommand+0x27e>
 8005954:	e094      	b.n	8005a80 <setCommand+0x3a8>
		pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005956:	aa0c      	add	r2, sp, #48	; 0x30
 8005958:	2102      	movs	r1, #2
 800595a:	0020      	movs	r0, r4
 800595c:	f009 fffe 	bl	800f95c <FreeRTOS_CLIGetParameter>
 8005960:	4f2f      	ldr	r7, [pc, #188]	; (8005a20 <setCommand+0x348>)
		pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005962:	aa0d      	add	r2, sp, #52	; 0x34
		pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005964:	6038      	str	r0, [r7, #0]
		pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005966:	2103      	movs	r1, #3
 8005968:	0020      	movs	r0, r4
 800596a:	f009 fff7 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800596e:	4e3f      	ldr	r6, [pc, #252]	; (8005a6c <setCommand+0x394>)
		pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 8005970:	aa0e      	add	r2, sp, #56	; 0x38
		pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005972:	6030      	str	r0, [r6, #0]
		pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 8005974:	2104      	movs	r1, #4
 8005976:	0020      	movs	r0, r4
 8005978:	f009 fff0 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800597c:	4d3c      	ldr	r5, [pc, #240]	; (8005a70 <setCommand+0x398>)
		pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 800597e:	aa0f      	add	r2, sp, #60	; 0x3c
 8005980:	2105      	movs	r1, #5
		pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 8005982:	6028      	str	r0, [r5, #0]
		pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 8005984:	0020      	movs	r0, r4
 8005986:	f009 ffe9 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800598a:	4c3a      	ldr	r4, [pc, #232]	; (8005a74 <setCommand+0x39c>)
 800598c:	6020      	str	r0, [r4, #0]
		temp81 = atoi((const char *)pcParameterString2);		// Hours
 800598e:	6838      	ldr	r0, [r7, #0]
 8005990:	f00e fbe0 	bl	8014154 <atoi>
 8005994:	b2c7      	uxtb	r7, r0
		temp82 = atoi((const char *)pcParameterString3);		// Minutes
 8005996:	6830      	ldr	r0, [r6, #0]
 8005998:	f00e fbdc 	bl	8014154 <atoi>
 800599c:	b2c6      	uxtb	r6, r0
		temp83 = atoi((const char *)pcParameterString4);		// Seconds
 800599e:	6828      	ldr	r0, [r5, #0]
 80059a0:	f00e fbd8 	bl	8014154 <atoi>
		if (pcParameterString5 != NULL) {
 80059a4:	6824      	ldr	r4, [r4, #0]
		temp83 = atoi((const char *)pcParameterString4);		// Seconds
 80059a6:	b2c5      	uxtb	r5, r0
		if (pcParameterString5 != NULL) {
 80059a8:	2c00      	cmp	r4, #0
 80059aa:	d010      	beq.n	80059ce <setCommand+0x2f6>
			if (!strncmp((const char *)pcParameterString5, "am", 2))
 80059ac:	2202      	movs	r2, #2
 80059ae:	4932      	ldr	r1, [pc, #200]	; (8005a78 <setCommand+0x3a0>)
 80059b0:	0020      	movs	r0, r4
 80059b2:	f00f f897 	bl	8014ae4 <strncmp>
 80059b6:	2800      	cmp	r0, #0
 80059b8:	d02c      	beq.n	8005a14 <setCommand+0x33c>
			else if (!strncmp((const char *)pcParameterString5, "pm", 2))
 80059ba:	2202      	movs	r2, #2
 80059bc:	492f      	ldr	r1, [pc, #188]	; (8005a7c <setCommand+0x3a4>)
 80059be:	0020      	movs	r0, r4
 80059c0:	f00f f890 	bl	8014ae4 <strncmp>
				temp84 = RTC_PM;
 80059c4:	2302      	movs	r3, #2
			else if (!strncmp((const char *)pcParameterString5, "pm", 2))
 80059c6:	2800      	cmp	r0, #0
 80059c8:	d000      	beq.n	80059cc <setCommand+0x2f4>
 80059ca:	e6e0      	b.n	800578e <setCommand+0xb6>
				temp84 = RTC_AM;
 80059cc:	9308      	str	r3, [sp, #32]
			if (temp81 > 23 || temp82 > 59 || temp83 > 59)
 80059ce:	2f17      	cmp	r7, #23
 80059d0:	d900      	bls.n	80059d4 <setCommand+0x2fc>
 80059d2:	e6dc      	b.n	800578e <setCommand+0xb6>
 80059d4:	2e3b      	cmp	r6, #59	; 0x3b
 80059d6:	d900      	bls.n	80059da <setCommand+0x302>
 80059d8:	e6d9      	b.n	800578e <setCommand+0xb6>
 80059da:	2d3b      	cmp	r5, #59	; 0x3b
 80059dc:	d900      	bls.n	80059e0 <setCommand+0x308>
 80059de:	e6d6      	b.n	800578e <setCommand+0xb6>
				GetTimeDate();				
 80059e0:	f006 fdd6 	bl	800c590 <GetTimeDate>
				result = BOS_CalendarConfig(BOS.date.month, BOS.date.day, BOS.date.year, BOS.date.weekday, temp83, temp82, temp81, temp84, BOS.daylightsaving);
 80059e4:	4c11      	ldr	r4, [pc, #68]	; (8005a2c <setCommand+0x354>)
 80059e6:	7d23      	ldrb	r3, [r4, #20]
 80059e8:	8b22      	ldrh	r2, [r4, #24]
 80059ea:	7d61      	ldrb	r1, [r4, #21]
 80059ec:	7da0      	ldrb	r0, [r4, #22]
 80059ee:	7b24      	ldrb	r4, [r4, #12]
 80059f0:	9702      	str	r7, [sp, #8]
 80059f2:	b264      	sxtb	r4, r4
 80059f4:	9404      	str	r4, [sp, #16]
 80059f6:	9c08      	ldr	r4, [sp, #32]
 80059f8:	9601      	str	r6, [sp, #4]
 80059fa:	9403      	str	r4, [sp, #12]
 80059fc:	9500      	str	r5, [sp, #0]
				result = BOS_CalendarConfig(temp82, temp83, temp16, temp81, BOS.time.seconds, BOS.time.minutes, BOS.time.hours, BOS.time.ampm, BOS.daylightsaving);
 80059fe:	f006 fd7b 	bl	800c4f8 <BOS_CalendarConfig>
 8005a02:	1e04      	subs	r4, r0, #0
	if (result == BOS_OK) 
 8005a04:	d100      	bne.n	8005a08 <setCommand+0x330>
 8005a06:	e6d1      	b.n	80057ac <setCommand+0xd4>
	else if (result == BOS_ERR_WrongParam)
 8005a08:	2c67      	cmp	r4, #103	; 0x67
 8005a0a:	d089      	beq.n	8005920 <setCommand+0x248>
	else if (result == BOS_ERR_WrongValue)
 8005a0c:	2c68      	cmp	r4, #104	; 0x68
 8005a0e:	d000      	beq.n	8005a12 <setCommand+0x33a>
 8005a10:	e6c1      	b.n	8005796 <setCommand+0xbe>
 8005a12:	e6bc      	b.n	800578e <setCommand+0xb6>
				temp84 = RTC_AM;
 8005a14:	2301      	movs	r3, #1
 8005a16:	e7d9      	b.n	80059cc <setCommand+0x2f4>
 8005a18:	20001234 	.word	0x20001234
 8005a1c:	08019d04 	.word	0x08019d04
 8005a20:	20001240 	.word	0x20001240
 8005a24:	08019d09 	.word	0x08019d09
 8005a28:	080192de 	.word	0x080192de
 8005a2c:	20006f70 	.word	0x20006f70
 8005a30:	0801a310 	.word	0x0801a310
 8005a34:	0801a318 	.word	0x0801a318
 8005a38:	08019d16 	.word	0x08019d16
 8005a3c:	08019bf8 	.word	0x08019bf8
 8005a40:	0801a3d2 	.word	0x0801a3d2
 8005a44:	0801a3e5 	.word	0x0801a3e5
 8005a48:	0801a415 	.word	0x0801a415
 8005a4c:	08019d1b 	.word	0x08019d1b
 8005a50:	08019d21 	.word	0x08019d21
 8005a54:	08019d2d 	.word	0x08019d2d
 8005a58:	08019d36 	.word	0x08019d36
 8005a5c:	08019d46 	.word	0x08019d46
 8005a60:	08019d58 	.word	0x08019d58
 8005a64:	08019d78 	.word	0x08019d78
 8005a68:	08019d41 	.word	0x08019d41
 8005a6c:	20001248 	.word	0x20001248
 8005a70:	2000124c 	.word	0x2000124c
 8005a74:	20001250 	.word	0x20001250
 8005a78:	0801a31c 	.word	0x0801a31c
 8005a7c:	0801a31f 	.word	0x0801a31f
	else if (!strncmp((const char *)pcParameterString1, "date", 4))
 8005a80:	2204      	movs	r2, #4
 8005a82:	49af      	ldr	r1, [pc, #700]	; (8005d40 <setCommand+0x668>)
 8005a84:	0028      	movs	r0, r5
 8005a86:	f00f f82d 	bl	8014ae4 <strncmp>
 8005a8a:	2800      	cmp	r0, #0
 8005a8c:	d000      	beq.n	8005a90 <setCommand+0x3b8>
 8005a8e:	e747      	b.n	8005920 <setCommand+0x248>
		pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005a90:	aa0c      	add	r2, sp, #48	; 0x30
 8005a92:	2102      	movs	r1, #2
 8005a94:	0020      	movs	r0, r4
 8005a96:	f009 ff61 	bl	800f95c <FreeRTOS_CLIGetParameter>
 8005a9a:	4eaa      	ldr	r6, [pc, #680]	; (8005d44 <setCommand+0x66c>)
		pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005a9c:	aa0d      	add	r2, sp, #52	; 0x34
		pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005a9e:	6030      	str	r0, [r6, #0]
		pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005aa0:	2103      	movs	r1, #3
 8005aa2:	0020      	movs	r0, r4
 8005aa4:	f009 ff5a 	bl	800f95c <FreeRTOS_CLIGetParameter>
 8005aa8:	4da7      	ldr	r5, [pc, #668]	; (8005d48 <setCommand+0x670>)
		pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 8005aaa:	aa0e      	add	r2, sp, #56	; 0x38
		pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005aac:	6028      	str	r0, [r5, #0]
		pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 8005aae:	2104      	movs	r1, #4
 8005ab0:	0020      	movs	r0, r4
 8005ab2:	f009 ff53 	bl	800f95c <FreeRTOS_CLIGetParameter>
 8005ab6:	4fa5      	ldr	r7, [pc, #660]	; (8005d4c <setCommand+0x674>)
		pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 8005ab8:	aa0f      	add	r2, sp, #60	; 0x3c
 8005aba:	2105      	movs	r1, #5
		pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 8005abc:	6038      	str	r0, [r7, #0]
		pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 8005abe:	0020      	movs	r0, r4
 8005ac0:	f009 ff4c 	bl	800f95c <FreeRTOS_CLIGetParameter>
 8005ac4:	4ca2      	ldr	r4, [pc, #648]	; (8005d50 <setCommand+0x678>)
 8005ac6:	6020      	str	r0, [r4, #0]
		temp83 = atoi((const char *)pcParameterString4);		// day
 8005ac8:	6838      	ldr	r0, [r7, #0]
 8005aca:	f00e fb43 	bl	8014154 <atoi>
 8005ace:	b2c3      	uxtb	r3, r0
		temp16 = atoi((const char *)pcParameterString5);		// year	
 8005ad0:	6820      	ldr	r0, [r4, #0]
		temp83 = atoi((const char *)pcParameterString4);		// day
 8005ad2:	9308      	str	r3, [sp, #32]
		temp16 = atoi((const char *)pcParameterString5);		// year	
 8005ad4:	f00e fb3e 	bl	8014154 <atoi>
		if (!strncmp((const char *)pcParameterString2, "monday", 6))
 8005ad8:	6837      	ldr	r7, [r6, #0]
		temp16 = atoi((const char *)pcParameterString5);		// year	
 8005ada:	b283      	uxth	r3, r0
		if (!strncmp((const char *)pcParameterString2, "monday", 6))
 8005adc:	2206      	movs	r2, #6
 8005ade:	499d      	ldr	r1, [pc, #628]	; (8005d54 <setCommand+0x67c>)
 8005ae0:	0038      	movs	r0, r7
		temp16 = atoi((const char *)pcParameterString5);		// year	
 8005ae2:	9309      	str	r3, [sp, #36]	; 0x24
		if (!strncmp((const char *)pcParameterString2, "monday", 6))
 8005ae4:	f00e fffe 	bl	8014ae4 <strncmp>
 8005ae8:	2800      	cmp	r0, #0
 8005aea:	d02c      	beq.n	8005b46 <setCommand+0x46e>
		else if (!strncmp((const char *)pcParameterString2, "tuesday", 7))
 8005aec:	2207      	movs	r2, #7
 8005aee:	499a      	ldr	r1, [pc, #616]	; (8005d58 <setCommand+0x680>)
 8005af0:	0038      	movs	r0, r7
 8005af2:	f00e fff7 	bl	8014ae4 <strncmp>
 8005af6:	2800      	cmp	r0, #0
 8005af8:	d029      	beq.n	8005b4e <setCommand+0x476>
		else if (!strncmp((const char *)pcParameterString2, "wednesday", 9))
 8005afa:	2209      	movs	r2, #9
 8005afc:	4997      	ldr	r1, [pc, #604]	; (8005d5c <setCommand+0x684>)
 8005afe:	0038      	movs	r0, r7
 8005b00:	f00e fff0 	bl	8014ae4 <strncmp>
 8005b04:	2800      	cmp	r0, #0
 8005b06:	d024      	beq.n	8005b52 <setCommand+0x47a>
		else if (!strncmp((const char *)pcParameterString2, "thursday", 8))
 8005b08:	2208      	movs	r2, #8
 8005b0a:	4995      	ldr	r1, [pc, #596]	; (8005d60 <setCommand+0x688>)
 8005b0c:	0038      	movs	r0, r7
 8005b0e:	f00e ffe9 	bl	8014ae4 <strncmp>
 8005b12:	2800      	cmp	r0, #0
 8005b14:	d01f      	beq.n	8005b56 <setCommand+0x47e>
		else if (!strncmp((const char *)pcParameterString2, "friday", 6))
 8005b16:	2206      	movs	r2, #6
 8005b18:	4992      	ldr	r1, [pc, #584]	; (8005d64 <setCommand+0x68c>)
 8005b1a:	0038      	movs	r0, r7
 8005b1c:	f00e ffe2 	bl	8014ae4 <strncmp>
 8005b20:	2800      	cmp	r0, #0
 8005b22:	d01a      	beq.n	8005b5a <setCommand+0x482>
		else if (!strncmp((const char *)pcParameterString2, "saturday", 8))
 8005b24:	2208      	movs	r2, #8
 8005b26:	4990      	ldr	r1, [pc, #576]	; (8005d68 <setCommand+0x690>)
 8005b28:	0038      	movs	r0, r7
 8005b2a:	f00e ffdb 	bl	8014ae4 <strncmp>
 8005b2e:	2800      	cmp	r0, #0
 8005b30:	d015      	beq.n	8005b5e <setCommand+0x486>
		else if (!strncmp((const char *)pcParameterString2, "sunday", 6))
 8005b32:	2206      	movs	r2, #6
 8005b34:	498d      	ldr	r1, [pc, #564]	; (8005d6c <setCommand+0x694>)
 8005b36:	0038      	movs	r0, r7
 8005b38:	f00e ffd4 	bl	8014ae4 <strncmp>
			result = BOS_ERR_WrongValue;		
 8005b3c:	2468      	movs	r4, #104	; 0x68
		else if (!strncmp((const char *)pcParameterString2, "sunday", 6))
 8005b3e:	2800      	cmp	r0, #0
 8005b40:	d110      	bne.n	8005b64 <setCommand+0x48c>
			temp81 = SUNDAY;
 8005b42:	2307      	movs	r3, #7
 8005b44:	e000      	b.n	8005b48 <setCommand+0x470>
			temp81 = MONDAY;
 8005b46:	2301      	movs	r3, #1
			temp81 = SUNDAY;
 8005b48:	9306      	str	r3, [sp, #24]
	BOS_Status result = BOS_OK; 
 8005b4a:	0004      	movs	r4, r0
 8005b4c:	e00a      	b.n	8005b64 <setCommand+0x48c>
			temp81 = TUESDAY;
 8005b4e:	2302      	movs	r3, #2
 8005b50:	e7fa      	b.n	8005b48 <setCommand+0x470>
			temp81 = WEDNESDAY;
 8005b52:	2303      	movs	r3, #3
 8005b54:	e7f8      	b.n	8005b48 <setCommand+0x470>
			temp81 = THURSDAY;
 8005b56:	2304      	movs	r3, #4
 8005b58:	e7f6      	b.n	8005b48 <setCommand+0x470>
			temp81 = FRIDAY;
 8005b5a:	2305      	movs	r3, #5
 8005b5c:	e7f4      	b.n	8005b48 <setCommand+0x470>
			temp81 = SATURDAY;
 8005b5e:	2306      	movs	r3, #6
	BOS_Status result = BOS_OK; 
 8005b60:	2400      	movs	r4, #0
			temp81 = SATURDAY;
 8005b62:	9306      	str	r3, [sp, #24]
		if (!strncmp((const char *)pcParameterString3, "january", 7) || !strncmp((const char *)pcParameterString3, "1 ", 2))
 8005b64:	682d      	ldr	r5, [r5, #0]
 8005b66:	2207      	movs	r2, #7
 8005b68:	4981      	ldr	r1, [pc, #516]	; (8005d70 <setCommand+0x698>)
 8005b6a:	0028      	movs	r0, r5
 8005b6c:	f00e ffba 	bl	8014ae4 <strncmp>
 8005b70:	2800      	cmp	r0, #0
 8005b72:	d100      	bne.n	8005b76 <setCommand+0x49e>
 8005b74:	e0ae      	b.n	8005cd4 <setCommand+0x5fc>
 8005b76:	2202      	movs	r2, #2
 8005b78:	497e      	ldr	r1, [pc, #504]	; (8005d74 <setCommand+0x69c>)
 8005b7a:	0028      	movs	r0, r5
 8005b7c:	f00e ffb2 	bl	8014ae4 <strncmp>
 8005b80:	2800      	cmp	r0, #0
 8005b82:	d100      	bne.n	8005b86 <setCommand+0x4ae>
 8005b84:	e0a6      	b.n	8005cd4 <setCommand+0x5fc>
		else if (!strncmp((const char *)pcParameterString3, "february", 8) || !strncmp((const char *)pcParameterString3, "2 ", 2))
 8005b86:	2208      	movs	r2, #8
 8005b88:	497b      	ldr	r1, [pc, #492]	; (8005d78 <setCommand+0x6a0>)
 8005b8a:	0028      	movs	r0, r5
 8005b8c:	f00e ffaa 	bl	8014ae4 <strncmp>
 8005b90:	2800      	cmp	r0, #0
 8005b92:	d100      	bne.n	8005b96 <setCommand+0x4be>
 8005b94:	e0c0      	b.n	8005d18 <setCommand+0x640>
 8005b96:	2202      	movs	r2, #2
 8005b98:	4978      	ldr	r1, [pc, #480]	; (8005d7c <setCommand+0x6a4>)
 8005b9a:	0028      	movs	r0, r5
 8005b9c:	f00e ffa2 	bl	8014ae4 <strncmp>
 8005ba0:	2800      	cmp	r0, #0
 8005ba2:	d100      	bne.n	8005ba6 <setCommand+0x4ce>
 8005ba4:	e0b8      	b.n	8005d18 <setCommand+0x640>
		else if (!strncmp((const char *)pcParameterString3, "march", 5) || !strncmp((const char *)pcParameterString3, "3 ", 2))
 8005ba6:	2205      	movs	r2, #5
 8005ba8:	4975      	ldr	r1, [pc, #468]	; (8005d80 <setCommand+0x6a8>)
 8005baa:	0028      	movs	r0, r5
 8005bac:	f00e ff9a 	bl	8014ae4 <strncmp>
 8005bb0:	2800      	cmp	r0, #0
 8005bb2:	d100      	bne.n	8005bb6 <setCommand+0x4de>
 8005bb4:	e0b2      	b.n	8005d1c <setCommand+0x644>
 8005bb6:	2202      	movs	r2, #2
 8005bb8:	4972      	ldr	r1, [pc, #456]	; (8005d84 <setCommand+0x6ac>)
 8005bba:	0028      	movs	r0, r5
 8005bbc:	f00e ff92 	bl	8014ae4 <strncmp>
 8005bc0:	2800      	cmp	r0, #0
 8005bc2:	d100      	bne.n	8005bc6 <setCommand+0x4ee>
 8005bc4:	e0aa      	b.n	8005d1c <setCommand+0x644>
		else if (!strncmp((const char *)pcParameterString3, "april", 5) || !strncmp((const char *)pcParameterString3, "4 ", 2))
 8005bc6:	2205      	movs	r2, #5
 8005bc8:	496f      	ldr	r1, [pc, #444]	; (8005d88 <setCommand+0x6b0>)
 8005bca:	0028      	movs	r0, r5
 8005bcc:	f00e ff8a 	bl	8014ae4 <strncmp>
 8005bd0:	2800      	cmp	r0, #0
 8005bd2:	d100      	bne.n	8005bd6 <setCommand+0x4fe>
 8005bd4:	e0a4      	b.n	8005d20 <setCommand+0x648>
 8005bd6:	2202      	movs	r2, #2
 8005bd8:	496c      	ldr	r1, [pc, #432]	; (8005d8c <setCommand+0x6b4>)
 8005bda:	0028      	movs	r0, r5
 8005bdc:	f00e ff82 	bl	8014ae4 <strncmp>
 8005be0:	2800      	cmp	r0, #0
 8005be2:	d100      	bne.n	8005be6 <setCommand+0x50e>
 8005be4:	e09c      	b.n	8005d20 <setCommand+0x648>
		else if (!strncmp((const char *)pcParameterString3, "may", 3) || !strncmp((const char *)pcParameterString3, "5 ", 2))
 8005be6:	2203      	movs	r2, #3
 8005be8:	4969      	ldr	r1, [pc, #420]	; (8005d90 <setCommand+0x6b8>)
 8005bea:	0028      	movs	r0, r5
 8005bec:	f00e ff7a 	bl	8014ae4 <strncmp>
 8005bf0:	2800      	cmp	r0, #0
 8005bf2:	d100      	bne.n	8005bf6 <setCommand+0x51e>
 8005bf4:	e096      	b.n	8005d24 <setCommand+0x64c>
 8005bf6:	2202      	movs	r2, #2
 8005bf8:	4966      	ldr	r1, [pc, #408]	; (8005d94 <setCommand+0x6bc>)
 8005bfa:	0028      	movs	r0, r5
 8005bfc:	f00e ff72 	bl	8014ae4 <strncmp>
 8005c00:	2800      	cmp	r0, #0
 8005c02:	d100      	bne.n	8005c06 <setCommand+0x52e>
 8005c04:	e08e      	b.n	8005d24 <setCommand+0x64c>
		else if (!strncmp((const char *)pcParameterString3, "june", 4) || !strncmp((const char *)pcParameterString3, "6 ", 2))
 8005c06:	2204      	movs	r2, #4
 8005c08:	4963      	ldr	r1, [pc, #396]	; (8005d98 <setCommand+0x6c0>)
 8005c0a:	0028      	movs	r0, r5
 8005c0c:	f00e ff6a 	bl	8014ae4 <strncmp>
 8005c10:	2800      	cmp	r0, #0
 8005c12:	d100      	bne.n	8005c16 <setCommand+0x53e>
 8005c14:	e088      	b.n	8005d28 <setCommand+0x650>
 8005c16:	2202      	movs	r2, #2
 8005c18:	4960      	ldr	r1, [pc, #384]	; (8005d9c <setCommand+0x6c4>)
 8005c1a:	0028      	movs	r0, r5
 8005c1c:	f00e ff62 	bl	8014ae4 <strncmp>
 8005c20:	2800      	cmp	r0, #0
 8005c22:	d100      	bne.n	8005c26 <setCommand+0x54e>
 8005c24:	e080      	b.n	8005d28 <setCommand+0x650>
		else if (!strncmp((const char *)pcParameterString3, "july", 4) || !strncmp((const char *)pcParameterString3, "7 ", 2))
 8005c26:	2204      	movs	r2, #4
 8005c28:	495d      	ldr	r1, [pc, #372]	; (8005da0 <setCommand+0x6c8>)
 8005c2a:	0028      	movs	r0, r5
 8005c2c:	f00e ff5a 	bl	8014ae4 <strncmp>
 8005c30:	2800      	cmp	r0, #0
 8005c32:	d07b      	beq.n	8005d2c <setCommand+0x654>
 8005c34:	2202      	movs	r2, #2
 8005c36:	495b      	ldr	r1, [pc, #364]	; (8005da4 <setCommand+0x6cc>)
 8005c38:	0028      	movs	r0, r5
 8005c3a:	f00e ff53 	bl	8014ae4 <strncmp>
 8005c3e:	2800      	cmp	r0, #0
 8005c40:	d074      	beq.n	8005d2c <setCommand+0x654>
		else if (!strncmp((const char *)pcParameterString3, "august", 5) || !strncmp((const char *)pcParameterString3, "8 ", 2))
 8005c42:	2205      	movs	r2, #5
 8005c44:	4958      	ldr	r1, [pc, #352]	; (8005da8 <setCommand+0x6d0>)
 8005c46:	0028      	movs	r0, r5
 8005c48:	f00e ff4c 	bl	8014ae4 <strncmp>
 8005c4c:	2800      	cmp	r0, #0
 8005c4e:	d06f      	beq.n	8005d30 <setCommand+0x658>
 8005c50:	2202      	movs	r2, #2
 8005c52:	4956      	ldr	r1, [pc, #344]	; (8005dac <setCommand+0x6d4>)
 8005c54:	0028      	movs	r0, r5
 8005c56:	f00e ff45 	bl	8014ae4 <strncmp>
 8005c5a:	2800      	cmp	r0, #0
 8005c5c:	d068      	beq.n	8005d30 <setCommand+0x658>
		else if (!strncmp((const char *)pcParameterString3, "september", 9) || !strncmp((const char *)pcParameterString3, "9 ", 2))
 8005c5e:	2209      	movs	r2, #9
 8005c60:	4953      	ldr	r1, [pc, #332]	; (8005db0 <setCommand+0x6d8>)
 8005c62:	0028      	movs	r0, r5
 8005c64:	f00e ff3e 	bl	8014ae4 <strncmp>
 8005c68:	2800      	cmp	r0, #0
 8005c6a:	d063      	beq.n	8005d34 <setCommand+0x65c>
 8005c6c:	2202      	movs	r2, #2
 8005c6e:	4951      	ldr	r1, [pc, #324]	; (8005db4 <setCommand+0x6dc>)
 8005c70:	0028      	movs	r0, r5
 8005c72:	f00e ff37 	bl	8014ae4 <strncmp>
 8005c76:	2800      	cmp	r0, #0
 8005c78:	d05c      	beq.n	8005d34 <setCommand+0x65c>
		else if (!strncmp((const char *)pcParameterString3, "october", 7) || !strncmp((const char *)pcParameterString3, "10", 2))
 8005c7a:	2207      	movs	r2, #7
 8005c7c:	494e      	ldr	r1, [pc, #312]	; (8005db8 <setCommand+0x6e0>)
 8005c7e:	0028      	movs	r0, r5
 8005c80:	f00e ff30 	bl	8014ae4 <strncmp>
 8005c84:	2800      	cmp	r0, #0
 8005c86:	d057      	beq.n	8005d38 <setCommand+0x660>
 8005c88:	2202      	movs	r2, #2
 8005c8a:	494c      	ldr	r1, [pc, #304]	; (8005dbc <setCommand+0x6e4>)
 8005c8c:	0028      	movs	r0, r5
 8005c8e:	f00e ff29 	bl	8014ae4 <strncmp>
 8005c92:	2800      	cmp	r0, #0
 8005c94:	d050      	beq.n	8005d38 <setCommand+0x660>
		else if (!strncmp((const char *)pcParameterString3, "november", 8) || !strncmp((const char *)pcParameterString3, "11", 2))
 8005c96:	2208      	movs	r2, #8
 8005c98:	4949      	ldr	r1, [pc, #292]	; (8005dc0 <setCommand+0x6e8>)
 8005c9a:	0028      	movs	r0, r5
 8005c9c:	f00e ff22 	bl	8014ae4 <strncmp>
 8005ca0:	2800      	cmp	r0, #0
 8005ca2:	d04b      	beq.n	8005d3c <setCommand+0x664>
 8005ca4:	2202      	movs	r2, #2
 8005ca6:	4947      	ldr	r1, [pc, #284]	; (8005dc4 <setCommand+0x6ec>)
 8005ca8:	0028      	movs	r0, r5
 8005caa:	f00e ff1b 	bl	8014ae4 <strncmp>
 8005cae:	2800      	cmp	r0, #0
 8005cb0:	d044      	beq.n	8005d3c <setCommand+0x664>
		else if (!strncmp((const char *)pcParameterString3, "december", 8) || !strncmp((const char *)pcParameterString3, "12", 2))
 8005cb2:	2208      	movs	r2, #8
 8005cb4:	4944      	ldr	r1, [pc, #272]	; (8005dc8 <setCommand+0x6f0>)
 8005cb6:	0028      	movs	r0, r5
 8005cb8:	f00e ff14 	bl	8014ae4 <strncmp>
 8005cbc:	2800      	cmp	r0, #0
 8005cbe:	d007      	beq.n	8005cd0 <setCommand+0x5f8>
 8005cc0:	2202      	movs	r2, #2
 8005cc2:	4942      	ldr	r1, [pc, #264]	; (8005dcc <setCommand+0x6f4>)
 8005cc4:	0028      	movs	r0, r5
 8005cc6:	f00e ff0d 	bl	8014ae4 <strncmp>
 8005cca:	2800      	cmp	r0, #0
 8005ccc:	d000      	beq.n	8005cd0 <setCommand+0x5f8>
 8005cce:	e55e      	b.n	800578e <setCommand+0xb6>
			temp82 = DECEMBER;
 8005cd0:	250c      	movs	r5, #12
 8005cd2:	e000      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = JANUARY;
 8005cd4:	2501      	movs	r5, #1
		if (result == BOS_OK) 
 8005cd6:	2c00      	cmp	r4, #0
 8005cd8:	d000      	beq.n	8005cdc <setCommand+0x604>
 8005cda:	e695      	b.n	8005a08 <setCommand+0x330>
			if (temp83 < 1 || temp83 > 31 || temp16 < 2000 || temp16 > 2100)
 8005cdc:	9b08      	ldr	r3, [sp, #32]
 8005cde:	3b01      	subs	r3, #1
 8005ce0:	2b1e      	cmp	r3, #30
 8005ce2:	d900      	bls.n	8005ce6 <setCommand+0x60e>
 8005ce4:	e553      	b.n	800578e <setCommand+0xb6>
 8005ce6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005ce8:	4a39      	ldr	r2, [pc, #228]	; (8005dd0 <setCommand+0x6f8>)
 8005cea:	189b      	adds	r3, r3, r2
 8005cec:	2b64      	cmp	r3, #100	; 0x64
 8005cee:	d900      	bls.n	8005cf2 <setCommand+0x61a>
 8005cf0:	e54d      	b.n	800578e <setCommand+0xb6>
				GetTimeDate();
 8005cf2:	f006 fc4d 	bl	800c590 <GetTimeDate>
				result = BOS_CalendarConfig(temp82, temp83, temp16, temp81, BOS.time.seconds, BOS.time.minutes, BOS.time.hours, BOS.time.ampm, BOS.daylightsaving);
 8005cf6:	220c      	movs	r2, #12
 8005cf8:	4b36      	ldr	r3, [pc, #216]	; (8005dd4 <setCommand+0x6fc>)
 8005cfa:	9908      	ldr	r1, [sp, #32]
 8005cfc:	569a      	ldrsb	r2, [r3, r2]
 8005cfe:	0028      	movs	r0, r5
 8005d00:	9204      	str	r2, [sp, #16]
 8005d02:	7cda      	ldrb	r2, [r3, #19]
 8005d04:	9203      	str	r2, [sp, #12]
 8005d06:	7c9a      	ldrb	r2, [r3, #18]
 8005d08:	9202      	str	r2, [sp, #8]
 8005d0a:	7c5a      	ldrb	r2, [r3, #17]
 8005d0c:	9201      	str	r2, [sp, #4]
 8005d0e:	7c1b      	ldrb	r3, [r3, #16]
 8005d10:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8005d12:	9300      	str	r3, [sp, #0]
 8005d14:	9b06      	ldr	r3, [sp, #24]
 8005d16:	e672      	b.n	80059fe <setCommand+0x326>
			temp82 = FEBRUARY;
 8005d18:	2502      	movs	r5, #2
 8005d1a:	e7dc      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = MARCH;
 8005d1c:	2503      	movs	r5, #3
 8005d1e:	e7da      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = APRIL;
 8005d20:	2504      	movs	r5, #4
 8005d22:	e7d8      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = MAY;
 8005d24:	2505      	movs	r5, #5
 8005d26:	e7d6      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = JUNE;
 8005d28:	2506      	movs	r5, #6
 8005d2a:	e7d4      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = JULY;
 8005d2c:	2507      	movs	r5, #7
 8005d2e:	e7d2      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = AUGUST;
 8005d30:	2508      	movs	r5, #8
 8005d32:	e7d0      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = SEPTEMBER;
 8005d34:	2509      	movs	r5, #9
 8005d36:	e7ce      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = OCTOBER;
 8005d38:	250a      	movs	r5, #10
 8005d3a:	e7cc      	b.n	8005cd6 <setCommand+0x5fe>
			temp82 = NOVEMBER;
 8005d3c:	250b      	movs	r5, #11
 8005d3e:	e7ca      	b.n	8005cd6 <setCommand+0x5fe>
 8005d40:	08019709 	.word	0x08019709
 8005d44:	20001240 	.word	0x20001240
 8005d48:	20001248 	.word	0x20001248
 8005d4c:	2000124c 	.word	0x2000124c
 8005d50:	20001250 	.word	0x20001250
 8005d54:	0801a322 	.word	0x0801a322
 8005d58:	0801a329 	.word	0x0801a329
 8005d5c:	0801a331 	.word	0x0801a331
 8005d60:	0801a33b 	.word	0x0801a33b
 8005d64:	0801a344 	.word	0x0801a344
 8005d68:	0801a34b 	.word	0x0801a34b
 8005d6c:	0801a354 	.word	0x0801a354
 8005d70:	0801a35b 	.word	0x0801a35b
 8005d74:	0801a363 	.word	0x0801a363
 8005d78:	0801a366 	.word	0x0801a366
 8005d7c:	0801a36f 	.word	0x0801a36f
 8005d80:	0801a372 	.word	0x0801a372
 8005d84:	0801a378 	.word	0x0801a378
 8005d88:	0801a37b 	.word	0x0801a37b
 8005d8c:	0801a381 	.word	0x0801a381
 8005d90:	0801a384 	.word	0x0801a384
 8005d94:	0801a388 	.word	0x0801a388
 8005d98:	0801a38b 	.word	0x0801a38b
 8005d9c:	0801a390 	.word	0x0801a390
 8005da0:	0801a393 	.word	0x0801a393
 8005da4:	0801a398 	.word	0x0801a398
 8005da8:	0801a39b 	.word	0x0801a39b
 8005dac:	0801a3a2 	.word	0x0801a3a2
 8005db0:	0801a3a5 	.word	0x0801a3a5
 8005db4:	0801a3af 	.word	0x0801a3af
 8005db8:	0801a3b2 	.word	0x0801a3b2
 8005dbc:	08019146 	.word	0x08019146
 8005dc0:	0801a3ba 	.word	0x0801a3ba
 8005dc4:	0801a3c3 	.word	0x0801a3c3
 8005dc8:	0801a3c6 	.word	0x0801a3c6
 8005dcc:	0801a3cf 	.word	0x0801a3cf
 8005dd0:	fffff830 	.word	0xfffff830
 8005dd4:	20006f70 	.word	0x20006f70

08005dd8 <removebuttonCommand>:
{
 8005dd8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	portBASE_TYPE xParameterStringLength1 = 0; 
 8005dda:	2400      	movs	r4, #0
{
 8005ddc:	0005      	movs	r5, r0
	portBASE_TYPE xParameterStringLength1 = 0; 
 8005dde:	9401      	str	r4, [sp, #4]
{
 8005de0:	0010      	movs	r0, r2
	configASSERT( pcWriteBuffer );
 8005de2:	42a5      	cmp	r5, r4
 8005de4:	d101      	bne.n	8005dea <removebuttonCommand+0x12>
 8005de6:	b672      	cpsid	i
 8005de8:	e7fe      	b.n	8005de8 <removebuttonCommand+0x10>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005dea:	aa01      	add	r2, sp, #4
 8005dec:	2101      	movs	r1, #1
 8005dee:	f009 fdb5 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString1[0] == 'p') {
 8005df2:	2300      	movs	r3, #0
 8005df4:	56c3      	ldrsb	r3, [r0, r3]
 8005df6:	2b70      	cmp	r3, #112	; 0x70
 8005df8:	d103      	bne.n	8005e02 <removebuttonCommand+0x2a>
		port = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
 8005dfa:	3001      	adds	r0, #1
 8005dfc:	f00e f9b0 	bl	8014160 <atol>
 8005e00:	b2c4      	uxtb	r4, r0
	result = RemovePortButton(port);
 8005e02:	0020      	movs	r0, r4
 8005e04:	f001 fbf4 	bl	80075f0 <RemovePortButton>
	if (result == BOS_OK) 
 8005e08:	2800      	cmp	r0, #0
 8005e0a:	d105      	bne.n	8005e18 <removebuttonCommand+0x40>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage, port, port);
 8005e0c:	0023      	movs	r3, r4
 8005e0e:	0022      	movs	r2, r4
 8005e10:	4902      	ldr	r1, [pc, #8]	; (8005e1c <removebuttonCommand+0x44>)
 8005e12:	0028      	movs	r0, r5
 8005e14:	f00e fe22 	bl	8014a5c <sprintf>
}
 8005e18:	2000      	movs	r0, #0
 8005e1a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8005e1c:	0801a1c4 	.word	0x0801a1c4

08005e20 <addbuttonCommand>:
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0; 
 8005e20:	2300      	movs	r3, #0
{
 8005e22:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005e24:	b087      	sub	sp, #28
 8005e26:	9002      	str	r0, [sp, #8]
 8005e28:	9203      	str	r2, [sp, #12]
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0; 
 8005e2a:	9304      	str	r3, [sp, #16]
 8005e2c:	9305      	str	r3, [sp, #20]
	configASSERT( pcWriteBuffer );
 8005e2e:	2800      	cmp	r0, #0
 8005e30:	d101      	bne.n	8005e36 <addbuttonCommand+0x16>
 8005e32:	b672      	cpsid	i
 8005e34:	e7fe      	b.n	8005e34 <addbuttonCommand+0x14>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005e36:	aa04      	add	r2, sp, #16
 8005e38:	2101      	movs	r1, #1
 8005e3a:	9803      	ldr	r0, [sp, #12]
 8005e3c:	f009 fd8e 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (!strncmp((const char *)pcParameterString1, "momentary-no", xParameterStringLength1)) {
 8005e40:	9e04      	ldr	r6, [sp, #16]
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005e42:	4f21      	ldr	r7, [pc, #132]	; (8005ec8 <addbuttonCommand+0xa8>)
	if (!strncmp((const char *)pcParameterString1, "momentary-no", xParameterStringLength1)) {
 8005e44:	0032      	movs	r2, r6
 8005e46:	4921      	ldr	r1, [pc, #132]	; (8005ecc <addbuttonCommand+0xac>)
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005e48:	0005      	movs	r5, r0
 8005e4a:	6038      	str	r0, [r7, #0]
	if (!strncmp((const char *)pcParameterString1, "momentary-no", xParameterStringLength1)) {
 8005e4c:	f00e fe4a 	bl	8014ae4 <strncmp>
		type = MOMENTARY_NO;
 8005e50:	2401      	movs	r4, #1
	if (!strncmp((const char *)pcParameterString1, "momentary-no", xParameterStringLength1)) {
 8005e52:	2800      	cmp	r0, #0
 8005e54:	d017      	beq.n	8005e86 <addbuttonCommand+0x66>
	} else if (!strncmp((const char *)pcParameterString1, "momentary-nc", xParameterStringLength1)) {
 8005e56:	0032      	movs	r2, r6
 8005e58:	491d      	ldr	r1, [pc, #116]	; (8005ed0 <addbuttonCommand+0xb0>)
 8005e5a:	0028      	movs	r0, r5
 8005e5c:	f00e fe42 	bl	8014ae4 <strncmp>
		type = MOMENTARY_NC;
 8005e60:	1924      	adds	r4, r4, r4
	} else if (!strncmp((const char *)pcParameterString1, "momentary-nc", xParameterStringLength1)) {
 8005e62:	2800      	cmp	r0, #0
 8005e64:	d00f      	beq.n	8005e86 <addbuttonCommand+0x66>
	} else if (!strncmp((const char *)pcParameterString1, "onoff-no", xParameterStringLength1)) {
 8005e66:	0032      	movs	r2, r6
 8005e68:	491a      	ldr	r1, [pc, #104]	; (8005ed4 <addbuttonCommand+0xb4>)
 8005e6a:	0028      	movs	r0, r5
 8005e6c:	f00e fe3a 	bl	8014ae4 <strncmp>
		type = ONOFF_NO;
 8005e70:	3401      	adds	r4, #1
	} else if (!strncmp((const char *)pcParameterString1, "onoff-no", xParameterStringLength1)) {
 8005e72:	2800      	cmp	r0, #0
 8005e74:	d007      	beq.n	8005e86 <addbuttonCommand+0x66>
	} else if (!strncmp((const char *)pcParameterString1, "onoff-nc", xParameterStringLength1)) {
 8005e76:	0032      	movs	r2, r6
 8005e78:	4917      	ldr	r1, [pc, #92]	; (8005ed8 <addbuttonCommand+0xb8>)
 8005e7a:	0028      	movs	r0, r5
 8005e7c:	f00e fe32 	bl	8014ae4 <strncmp>
		type = ONOFF_NC;
 8005e80:	4244      	negs	r4, r0
 8005e82:	4144      	adcs	r4, r0
 8005e84:	00a4      	lsls	r4, r4, #2
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005e86:	aa05      	add	r2, sp, #20
 8005e88:	2102      	movs	r1, #2
 8005e8a:	9803      	ldr	r0, [sp, #12]
 8005e8c:	f009 fd66 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString2[0] == 'p') {
 8005e90:	2300      	movs	r3, #0
 8005e92:	56c3      	ldrsb	r3, [r0, r3]
	uint8_t port = 0, type = 0;
 8005e94:	2500      	movs	r5, #0
	if (pcParameterString2[0] == 'p') {
 8005e96:	2b70      	cmp	r3, #112	; 0x70
 8005e98:	d103      	bne.n	8005ea2 <addbuttonCommand+0x82>
		port = ( uint8_t ) atol( ( char * ) pcParameterString2+1 );
 8005e9a:	3001      	adds	r0, #1
 8005e9c:	f00e f960 	bl	8014160 <atol>
 8005ea0:	b2c5      	uxtb	r5, r0
	result = AddPortButton(type, port);
 8005ea2:	0029      	movs	r1, r5
 8005ea4:	0020      	movs	r0, r4
 8005ea6:	f001 fb15 	bl	80074d4 <AddPortButton>
	if (result == BOS_OK) 
 8005eaa:	2800      	cmp	r0, #0
 8005eac:	d108      	bne.n	8005ec0 <addbuttonCommand+0xa0>
		pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 8005eae:	683a      	ldr	r2, [r7, #0]
 8005eb0:	9b04      	ldr	r3, [sp, #16]
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage, pcParameterString1, port, port);
 8005eb2:	490a      	ldr	r1, [pc, #40]	; (8005edc <addbuttonCommand+0xbc>)
		pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 8005eb4:	54d0      	strb	r0, [r2, r3]
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage, pcParameterString1, port, port);
 8005eb6:	9500      	str	r5, [sp, #0]
 8005eb8:	002b      	movs	r3, r5
 8005eba:	9802      	ldr	r0, [sp, #8]
 8005ebc:	f00e fdce 	bl	8014a5c <sprintf>
}
 8005ec0:	2000      	movs	r0, #0
 8005ec2:	b007      	add	sp, #28
 8005ec4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005ec6:	46c0      	nop			; (mov r8, r8)
 8005ec8:	20001230 	.word	0x20001230
 8005ecc:	08019aac 	.word	0x08019aac
 8005ed0:	08019ab9 	.word	0x08019ab9
 8005ed4:	08019ac6 	.word	0x08019ac6
 8005ed8:	08019acf 	.word	0x08019acf
 8005edc:	08019ad8 	.word	0x08019ad8

08005ee0 <scastCommand>:
{
 8005ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0, xParameterStringLength3 = 0; 
 8005ee2:	2400      	movs	r4, #0
{
 8005ee4:	b09d      	sub	sp, #116	; 0x74
 8005ee6:	9009      	str	r0, [sp, #36]	; 0x24
	char par1[MaxLengthOfAlias+1] = {0}, par2[MaxLengthOfAlias+1] = {0}, par3[MaxLengthOfAlias+1] = {0};
 8005ee8:	0021      	movs	r1, r4
{
 8005eea:	0015      	movs	r5, r2
	char par1[MaxLengthOfAlias+1] = {0}, par2[MaxLengthOfAlias+1] = {0}, par3[MaxLengthOfAlias+1] = {0};
 8005eec:	a813      	add	r0, sp, #76	; 0x4c
 8005eee:	220a      	movs	r2, #10
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0, xParameterStringLength3 = 0; 
 8005ef0:	940c      	str	r4, [sp, #48]	; 0x30
 8005ef2:	940d      	str	r4, [sp, #52]	; 0x34
 8005ef4:	940e      	str	r4, [sp, #56]	; 0x38
	portBASE_TYPE xParameterStringLength4 = 0, xParameterStringLength5 = 0, xParameterStringLength6 = 0;
 8005ef6:	940f      	str	r4, [sp, #60]	; 0x3c
 8005ef8:	9410      	str	r4, [sp, #64]	; 0x40
 8005efa:	9411      	str	r4, [sp, #68]	; 0x44
	portBASE_TYPE xParameterStringLength7 = 0;
 8005efc:	9412      	str	r4, [sp, #72]	; 0x48
	char par1[MaxLengthOfAlias+1] = {0}, par2[MaxLengthOfAlias+1] = {0}, par3[MaxLengthOfAlias+1] = {0};
 8005efe:	f00e fbb2 	bl	8014666 <memset>
 8005f02:	220a      	movs	r2, #10
 8005f04:	0021      	movs	r1, r4
 8005f06:	a816      	add	r0, sp, #88	; 0x58
 8005f08:	f00e fbad 	bl	8014666 <memset>
 8005f0c:	220a      	movs	r2, #10
 8005f0e:	0021      	movs	r1, r4
 8005f10:	a819      	add	r0, sp, #100	; 0x64
 8005f12:	f00e fba8 	bl	8014666 <memset>
	configASSERT( pcWriteBuffer );
 8005f16:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005f18:	42a3      	cmp	r3, r4
 8005f1a:	d101      	bne.n	8005f20 <scastCommand+0x40>
 8005f1c:	b672      	cpsid	i
 8005f1e:	e7fe      	b.n	8005f1e <scastCommand+0x3e>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8005f20:	aa0c      	add	r2, sp, #48	; 0x30
 8005f22:	2101      	movs	r1, #1
 8005f24:	0028      	movs	r0, r5
 8005f26:	f009 fd19 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString1[0] == 'P') {
 8005f2a:	2300      	movs	r3, #0
 8005f2c:	56c3      	ldrsb	r3, [r0, r3]
	uint8_t direction = 0, srcP = 0, dstP = 0, srcM = 0, dstM = 0; uint32_t count = 0, timeout = 0;
 8005f2e:	9407      	str	r4, [sp, #28]
	if (pcParameterString1[0] == 'P') {
 8005f30:	2b50      	cmp	r3, #80	; 0x50
 8005f32:	d104      	bne.n	8005f3e <scastCommand+0x5e>
		srcP = ( uint8_t ) atol( ( char * ) pcParameterString1+1 );
 8005f34:	3001      	adds	r0, #1
 8005f36:	f00e f913 	bl	8014160 <atol>
 8005f3a:	b2c3      	uxtb	r3, r0
 8005f3c:	9307      	str	r3, [sp, #28]
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005f3e:	aa0d      	add	r2, sp, #52	; 0x34
 8005f40:	2102      	movs	r1, #2
 8005f42:	0028      	movs	r0, r5
 8005f44:	f009 fd0a 	bl	800f95c <FreeRTOS_CLIGetParameter>
	strncpy(par1, ( char * ) pcParameterString2, xParameterStringLength2);
 8005f48:	9a0d      	ldr	r2, [sp, #52]	; 0x34
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8005f4a:	0001      	movs	r1, r0
	strncpy(par1, ( char * ) pcParameterString2, xParameterStringLength2);
 8005f4c:	a813      	add	r0, sp, #76	; 0x4c
 8005f4e:	f00e fdda 	bl	8014b06 <strncpy>
	srcM = (uint8_t) GetID(par1);
 8005f52:	a813      	add	r0, sp, #76	; 0x4c
 8005f54:	f7fd fec4 	bl	8003ce0 <GetID>
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005f58:	aa0e      	add	r2, sp, #56	; 0x38
	srcM = (uint8_t) GetID(par1);
 8005f5a:	b2c3      	uxtb	r3, r0
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005f5c:	2103      	movs	r1, #3
 8005f5e:	0028      	movs	r0, r5
	srcM = (uint8_t) GetID(par1);
 8005f60:	930a      	str	r3, [sp, #40]	; 0x28
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8005f62:	f009 fcfb 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString3[0] == 'p') {
 8005f66:	2300      	movs	r3, #0
	uint8_t direction = 0, srcP = 0, dstP = 0, srcM = 0, dstM = 0; uint32_t count = 0, timeout = 0;
 8005f68:	2200      	movs	r2, #0
	if (pcParameterString3[0] == 'p') {
 8005f6a:	56c3      	ldrsb	r3, [r0, r3]
	uint8_t direction = 0, srcP = 0, dstP = 0, srcM = 0, dstM = 0; uint32_t count = 0, timeout = 0;
 8005f6c:	9208      	str	r2, [sp, #32]
	if (pcParameterString3[0] == 'p') {
 8005f6e:	2b70      	cmp	r3, #112	; 0x70
 8005f70:	d104      	bne.n	8005f7c <scastCommand+0x9c>
		dstP = ( uint8_t ) atol( ( char * ) pcParameterString3+1 );
 8005f72:	3001      	adds	r0, #1
 8005f74:	f00e f8f4 	bl	8014160 <atol>
 8005f78:	b2c3      	uxtb	r3, r0
 8005f7a:	9308      	str	r3, [sp, #32]
	pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 8005f7c:	aa0f      	add	r2, sp, #60	; 0x3c
 8005f7e:	2104      	movs	r1, #4
 8005f80:	0028      	movs	r0, r5
 8005f82:	f009 fceb 	bl	800f95c <FreeRTOS_CLIGetParameter>
	strncpy(par2, ( char * ) pcParameterString4, xParameterStringLength4);
 8005f86:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
	pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 8005f88:	0001      	movs	r1, r0
	strncpy(par2, ( char * ) pcParameterString4, xParameterStringLength4);
 8005f8a:	a816      	add	r0, sp, #88	; 0x58
 8005f8c:	f00e fdbb 	bl	8014b06 <strncpy>
	dstM = (uint8_t) GetID(par2);
 8005f90:	a816      	add	r0, sp, #88	; 0x58
 8005f92:	f7fd fea5 	bl	8003ce0 <GetID>
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 8005f96:	aa10      	add	r2, sp, #64	; 0x40
	dstM = (uint8_t) GetID(par2);
 8005f98:	b2c3      	uxtb	r3, r0
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 8005f9a:	2105      	movs	r1, #5
 8005f9c:	0028      	movs	r0, r5
	dstM = (uint8_t) GetID(par2);
 8005f9e:	930b      	str	r3, [sp, #44]	; 0x2c
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 8005fa0:	f009 fcdc 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (!strncmp((const char *)pcParameterString5, "forward", xParameterStringLength5))
 8005fa4:	9f10      	ldr	r7, [sp, #64]	; 0x40
 8005fa6:	4925      	ldr	r1, [pc, #148]	; (800603c <scastCommand+0x15c>)
 8005fa8:	003a      	movs	r2, r7
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 8005faa:	0006      	movs	r6, r0
		direction = FORWARD;
 8005fac:	2400      	movs	r4, #0
	if (!strncmp((const char *)pcParameterString5, "forward", xParameterStringLength5))
 8005fae:	f00e fd99 	bl	8014ae4 <strncmp>
 8005fb2:	42a0      	cmp	r0, r4
 8005fb4:	d00f      	beq.n	8005fd6 <scastCommand+0xf6>
	else if (!strncmp(( const char *)pcParameterString5, "backward", xParameterStringLength5))
 8005fb6:	003a      	movs	r2, r7
 8005fb8:	4921      	ldr	r1, [pc, #132]	; (8006040 <scastCommand+0x160>)
 8005fba:	0030      	movs	r0, r6
 8005fbc:	f00e fd92 	bl	8014ae4 <strncmp>
		direction = BACKWARD;
 8005fc0:	3401      	adds	r4, #1
	else if (!strncmp(( const char *)pcParameterString5, "backward", xParameterStringLength5))
 8005fc2:	2800      	cmp	r0, #0
 8005fc4:	d007      	beq.n	8005fd6 <scastCommand+0xf6>
	else if (!strncmp((const char *)pcParameterString5, "bidirectional", xParameterStringLength5))
 8005fc6:	003a      	movs	r2, r7
 8005fc8:	491e      	ldr	r1, [pc, #120]	; (8006044 <scastCommand+0x164>)
 8005fca:	0030      	movs	r0, r6
 8005fcc:	f00e fd8a 	bl	8014ae4 <strncmp>
		direction = BIDIRECTIONAL;
 8005fd0:	4244      	negs	r4, r0
 8005fd2:	4144      	adcs	r4, r0
 8005fd4:	0064      	lsls	r4, r4, #1
	strncpy(par3, ( char * ) pcParameterString5, xParameterStringLength5);
 8005fd6:	0031      	movs	r1, r6
 8005fd8:	003a      	movs	r2, r7
 8005fda:	a819      	add	r0, sp, #100	; 0x64
 8005fdc:	f00e fd93 	bl	8014b06 <strncpy>
	pcParameterString6 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 6, &xParameterStringLength6);
 8005fe0:	aa11      	add	r2, sp, #68	; 0x44
 8005fe2:	2106      	movs	r1, #6
 8005fe4:	0028      	movs	r0, r5
 8005fe6:	f009 fcb9 	bl	800f95c <FreeRTOS_CLIGetParameter>
	count = ( uint32_t ) atol( ( char * ) pcParameterString6 );
 8005fea:	f00e f8b9 	bl	8014160 <atol>
	pcParameterString7 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 7, &xParameterStringLength7);
 8005fee:	aa12      	add	r2, sp, #72	; 0x48
 8005ff0:	2107      	movs	r1, #7
	count = ( uint32_t ) atol( ( char * ) pcParameterString6 );
 8005ff2:	0006      	movs	r6, r0
	pcParameterString7 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 7, &xParameterStringLength7);
 8005ff4:	0028      	movs	r0, r5
 8005ff6:	f009 fcb1 	bl	800f95c <FreeRTOS_CLIGetParameter>
	timeout = ( uint32_t ) atol( ( char * ) pcParameterString7 );
 8005ffa:	f00e f8b1 	bl	8014160 <atol>
	result = StartScastDMAStream(srcP, srcM, dstP, dstM, direction, count, timeout, false);
 8005ffe:	2300      	movs	r3, #0
	timeout = ( uint32_t ) atol( ( char * ) pcParameterString7 );
 8006000:	0005      	movs	r5, r0
	result = StartScastDMAStream(srcP, srcM, dstP, dstM, direction, count, timeout, false);
 8006002:	9303      	str	r3, [sp, #12]
 8006004:	9002      	str	r0, [sp, #8]
 8006006:	9601      	str	r6, [sp, #4]
 8006008:	9400      	str	r4, [sp, #0]
 800600a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800600c:	9a08      	ldr	r2, [sp, #32]
 800600e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8006010:	9807      	ldr	r0, [sp, #28]
 8006012:	f001 ffad 	bl	8007f70 <StartScastDMAStream>
	if (result == BOS_OK) 
 8006016:	2800      	cmp	r0, #0
 8006018:	d10d      	bne.n	8006036 <scastCommand+0x156>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage, par3, srcP, par1, dstP, par2, count, timeout);
 800601a:	ab16      	add	r3, sp, #88	; 0x58
 800601c:	9302      	str	r3, [sp, #8]
 800601e:	9b08      	ldr	r3, [sp, #32]
 8006020:	9504      	str	r5, [sp, #16]
 8006022:	9301      	str	r3, [sp, #4]
 8006024:	ab13      	add	r3, sp, #76	; 0x4c
 8006026:	9300      	str	r3, [sp, #0]
 8006028:	9603      	str	r6, [sp, #12]
 800602a:	9b07      	ldr	r3, [sp, #28]
 800602c:	aa19      	add	r2, sp, #100	; 0x64
 800602e:	4906      	ldr	r1, [pc, #24]	; (8006048 <scastCommand+0x168>)
 8006030:	9809      	ldr	r0, [sp, #36]	; 0x24
 8006032:	f00e fd13 	bl	8014a5c <sprintf>
}
 8006036:	2000      	movs	r0, #0
 8006038:	b01d      	add	sp, #116	; 0x74
 800603a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800603c:	0801a20c 	.word	0x0801a20c
 8006040:	0801a214 	.word	0x0801a214
 8006044:	0801a21d 	.word	0x0801a21d
 8006048:	0801a22b 	.word	0x0801a22b

0800604c <infoCommand>:
{
 800604c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800604e:	1e04      	subs	r4, r0, #0
	configASSERT( pcWriteBuffer );
 8006050:	d101      	bne.n	8006056 <infoCommand+0xa>
 8006052:	b672      	cpsid	i
 8006054:	e7fe      	b.n	8006054 <infoCommand+0x8>
	if (N > 1)
 8006056:	4d22      	ldr	r5, [pc, #136]	; (80060e0 <infoCommand+0x94>)
	BOS_Status result = BOS_OK; 
 8006058:	2700      	movs	r7, #0
	if (N > 1)
 800605a:	782b      	ldrb	r3, [r5, #0]
 800605c:	2b01      	cmp	r3, #1
 800605e:	d902      	bls.n	8006066 <infoCommand+0x1a>
		result = ReadPortsDir();
 8006060:	f7fd ff7c 	bl	8003f5c <ReadPortsDir>
 8006064:	0007      	movs	r7, r0
	sprintf( ( char * ) pcWriteBuffer, "\n\rNumber of modules: %d\n", N);
 8006066:	782a      	ldrb	r2, [r5, #0]
 8006068:	491e      	ldr	r1, [pc, #120]	; (80060e4 <infoCommand+0x98>)
 800606a:	0020      	movs	r0, r4
 800606c:	f00e fcf6 	bl	8014a5c <sprintf>
	writePxMutex(PcPort, (char*) pcWriteBuffer, strlen((char*) pcWriteBuffer), cmd50ms, HAL_MAX_DELAY);
 8006070:	2601      	movs	r6, #1
 8006072:	0020      	movs	r0, r4
 8006074:	f7fa f850 	bl	8000118 <strlen>
 8006078:	4d1b      	ldr	r5, [pc, #108]	; (80060e8 <infoCommand+0x9c>)
 800607a:	4276      	negs	r6, r6
 800607c:	b282      	uxth	r2, r0
 800607e:	2332      	movs	r3, #50	; 0x32
 8006080:	7828      	ldrb	r0, [r5, #0]
 8006082:	0021      	movs	r1, r4
 8006084:	9600      	str	r6, [sp, #0]
 8006086:	f007 f9c7 	bl	800d418 <writePxMutex>
	sprintf( ( char * ) pcWriteBuffer, "\n\rArray topology:\n");
 800608a:	4918      	ldr	r1, [pc, #96]	; (80060ec <infoCommand+0xa0>)
 800608c:	0020      	movs	r0, r4
 800608e:	f00e fd21 	bl	8014ad4 <strcpy>
	writePxMutex(PcPort, (char*) pcWriteBuffer, strlen((char*) pcWriteBuffer), cmd50ms, HAL_MAX_DELAY);
 8006092:	0020      	movs	r0, r4
 8006094:	f7fa f840 	bl	8000118 <strlen>
 8006098:	2332      	movs	r3, #50	; 0x32
 800609a:	b282      	uxth	r2, r0
 800609c:	0021      	movs	r1, r4
 800609e:	7828      	ldrb	r0, [r5, #0]
 80060a0:	9600      	str	r6, [sp, #0]
 80060a2:	f007 f9b9 	bl	800d418 <writePxMutex>
	DisplayTopology(PcPort);
 80060a6:	7828      	ldrb	r0, [r5, #0]
 80060a8:	f7fd fbe8 	bl	800387c <DisplayTopology>
	DisplayPortsDir(PcPort);
 80060ac:	7828      	ldrb	r0, [r5, #0]
 80060ae:	f7fd fc9f 	bl	80039f0 <DisplayPortsDir>
	if (result == BOS_ERR_NoResponse) {
 80060b2:	2f02      	cmp	r7, #2
 80060b4:	d10d      	bne.n	80060d2 <infoCommand+0x86>
		sprintf( ( char * ) pcWriteBuffer, "Could not read ports direction for some modules! Please try again\n\r");
 80060b6:	490e      	ldr	r1, [pc, #56]	; (80060f0 <infoCommand+0xa4>)
 80060b8:	0020      	movs	r0, r4
 80060ba:	f00e fd0b 	bl	8014ad4 <strcpy>
		writePxMutex(PcPort, (char*) pcWriteBuffer, strlen((char*) pcWriteBuffer), cmd50ms, HAL_MAX_DELAY);		
 80060be:	0020      	movs	r0, r4
 80060c0:	f7fa f82a 	bl	8000118 <strlen>
 80060c4:	2332      	movs	r3, #50	; 0x32
 80060c6:	b282      	uxth	r2, r0
 80060c8:	0021      	movs	r1, r4
 80060ca:	7828      	ldrb	r0, [r5, #0]
 80060cc:	9600      	str	r6, [sp, #0]
 80060ce:	f007 f9a3 	bl	800d418 <writePxMutex>
	sprintf( ( char * ) pcWriteBuffer, " ");
 80060d2:	4908      	ldr	r1, [pc, #32]	; (80060f4 <infoCommand+0xa8>)
 80060d4:	0020      	movs	r0, r4
 80060d6:	f00e fcfd 	bl	8014ad4 <strcpy>
}
 80060da:	2000      	movs	r0, #0
 80060dc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80060de:	46c0      	nop			; (mov r8, r8)
 80060e0:	2000001c 	.word	0x2000001c
 80060e4:	08019fb0 	.word	0x08019fb0
 80060e8:	20000a9f 	.word	0x20000a9f
 80060ec:	08019fc9 	.word	0x08019fc9
 80060f0:	08019fdc 	.word	0x08019fdc
 80060f4:	08019df3 	.word	0x08019df3

080060f8 <statusCommand>:
{
 80060f8:	b510      	push	{r4, lr}
	configASSERT( pcWriteBuffer );
 80060fa:	2800      	cmp	r0, #0
 80060fc:	d101      	bne.n	8006102 <statusCommand+0xa>
 80060fe:	b672      	cpsid	i
 8006100:	e7fe      	b.n	8006100 <statusCommand+0x8>
	DisplayModuleStatus(0);
 8006102:	2000      	movs	r0, #0
 8006104:	f7fd fcd0 	bl	8003aa8 <DisplayModuleStatus>
}
 8006108:	2000      	movs	r0, #0
 800610a:	bd10      	pop	{r4, pc}

0800610c <groupCommand>:
{
 800610c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800610e:	b091      	sub	sp, #68	; 0x44
	char module[MaxLengthOfAlias+30] = {0}; int16_t modID = 0, type = 0; char alias[MaxLengthOfAlias+1] = {0};
 8006110:	ad06      	add	r5, sp, #24
{
 8006112:	0004      	movs	r4, r0
	char module[MaxLengthOfAlias+30] = {0}; int16_t modID = 0, type = 0; char alias[MaxLengthOfAlias+1] = {0};
 8006114:	2100      	movs	r1, #0
{
 8006116:	0017      	movs	r7, r2
	char module[MaxLengthOfAlias+30] = {0}; int16_t modID = 0, type = 0; char alias[MaxLengthOfAlias+1] = {0};
 8006118:	0028      	movs	r0, r5
 800611a:	2227      	movs	r2, #39	; 0x27
 800611c:	f00e faa3 	bl	8014666 <memset>
 8006120:	220a      	movs	r2, #10
 8006122:	2100      	movs	r1, #0
 8006124:	a803      	add	r0, sp, #12
 8006126:	f00e fa9e 	bl	8014666 <memset>
	configASSERT( pcWriteBuffer );
 800612a:	2c00      	cmp	r4, #0
 800612c:	d101      	bne.n	8006132 <groupCommand+0x26>
 800612e:	b672      	cpsid	i
 8006130:	e7fe      	b.n	8006130 <groupCommand+0x24>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8006132:	4e42      	ldr	r6, [pc, #264]	; (800623c <groupCommand+0x130>)
 8006134:	2101      	movs	r1, #1
 8006136:	0032      	movs	r2, r6
 8006138:	0038      	movs	r0, r7
 800613a:	f009 fc0f 	bl	800f95c <FreeRTOS_CLIGetParameter>
	strncpy( alias, ( char * ) pcParameterString1, xParameterStringLength1);
 800613e:	6832      	ldr	r2, [r6, #0]
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8006140:	0001      	movs	r1, r0
	strncpy( alias, ( char * ) pcParameterString1, xParameterStringLength1);
 8006142:	a803      	add	r0, sp, #12
 8006144:	f00e fcdf 	bl	8014b06 <strncpy>
 8006148:	2600      	movs	r6, #0
		if (!strcmp(alias, groupAlias[i]))	
 800614a:	210a      	movs	r1, #10
 800614c:	4371      	muls	r1, r6
 800614e:	4b3c      	ldr	r3, [pc, #240]	; (8006240 <groupCommand+0x134>)
 8006150:	a803      	add	r0, sp, #12
 8006152:	18c9      	adds	r1, r1, r3
 8006154:	f7f9 ffd6 	bl	8000104 <strcmp>
 8006158:	2800      	cmp	r0, #0
 800615a:	d022      	beq.n	80061a2 <groupCommand+0x96>
 800615c:	3601      	adds	r6, #1
	for(uint8_t i=0 ; i<MaxNumOfGroups ; i++)
 800615e:	2e0a      	cmp	r6, #10
 8006160:	d1f3      	bne.n	800614a <groupCommand+0x3e>
	type = 1;
 8006162:	2301      	movs	r3, #1
 8006164:	9301      	str	r3, [sp, #4]
	count = 2;
 8006166:	2602      	movs	r6, #2
 8006168:	4b36      	ldr	r3, [pc, #216]	; (8006244 <groupCommand+0x138>)
	strcpy( ( char * ) pcWriteBuffer, "Modules [");
 800616a:	4937      	ldr	r1, [pc, #220]	; (8006248 <groupCommand+0x13c>)
 800616c:	0020      	movs	r0, r4
	count = 2;
 800616e:	701e      	strb	r6, [r3, #0]
	strcpy( ( char * ) pcWriteBuffer, "Modules [");
 8006170:	f00e fcb0 	bl	8014ad4 <strcpy>
	pcParameterString = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, count, &xParameterStringLength);
 8006174:	0031      	movs	r1, r6
 8006176:	4a35      	ldr	r2, [pc, #212]	; (800624c <groupCommand+0x140>)
		pcParameterString = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, ++count, &xParameterStringLength);	
 8006178:	0038      	movs	r0, r7
 800617a:	f009 fbef 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800617e:	4b34      	ldr	r3, [pc, #208]	; (8006250 <groupCommand+0x144>)
 8006180:	6018      	str	r0, [r3, #0]
	while (pcParameterString != NULL)
 8006182:	4b33      	ldr	r3, [pc, #204]	; (8006250 <groupCommand+0x144>)
 8006184:	6819      	ldr	r1, [r3, #0]
 8006186:	2900      	cmp	r1, #0
 8006188:	d10d      	bne.n	80061a6 <groupCommand+0x9a>
 800618a:	0008      	movs	r0, r1
	else if (count == 2)
 800618c:	4b2d      	ldr	r3, [pc, #180]	; (8006244 <groupCommand+0x138>)
 800618e:	781b      	ldrb	r3, [r3, #0]
 8006190:	b25b      	sxtb	r3, r3
 8006192:	2b02      	cmp	r3, #2
 8006194:	d12d      	bne.n	80061f2 <groupCommand+0xe6>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageNoModules, alias);
 8006196:	492f      	ldr	r1, [pc, #188]	; (8006254 <groupCommand+0x148>)
 8006198:	aa03      	add	r2, sp, #12
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongModule, module);
 800619a:	0020      	movs	r0, r4
 800619c:	f00e fc5e 	bl	8014a5c <sprintf>
	return pdFALSE;
 80061a0:	e036      	b.n	8006210 <groupCommand+0x104>
			type = 0; break;
 80061a2:	9001      	str	r0, [sp, #4]
 80061a4:	e7df      	b.n	8006166 <groupCommand+0x5a>
		strncpy(module, ( char * ) pcParameterString, xParameterStringLength); module[xParameterStringLength] = '\0';
 80061a6:	4b29      	ldr	r3, [pc, #164]	; (800624c <groupCommand+0x140>)
 80061a8:	0028      	movs	r0, r5
 80061aa:	681e      	ldr	r6, [r3, #0]
 80061ac:	0032      	movs	r2, r6
 80061ae:	f00e fcaa 	bl	8014b06 <strncpy>
 80061b2:	2300      	movs	r3, #0
		modID = GetID(module);
 80061b4:	0028      	movs	r0, r5
		strncpy(module, ( char * ) pcParameterString, xParameterStringLength); module[xParameterStringLength] = '\0';
 80061b6:	55ab      	strb	r3, [r5, r6]
		modID = GetID(module);
 80061b8:	f7fd fd92 	bl	8003ce0 <GetID>
		if (modID < 0)	break;
 80061bc:	2800      	cmp	r0, #0
 80061be:	db39      	blt.n	8006234 <groupCommand+0x128>
		result = AddModuleToGroup(modID, alias);
 80061c0:	b2c0      	uxtb	r0, r0
 80061c2:	a903      	add	r1, sp, #12
 80061c4:	f7fd fe4c 	bl	8003e60 <AddModuleToGroup>
		if (result != BOS_OK)	break;
 80061c8:	2800      	cmp	r0, #0
 80061ca:	d1df      	bne.n	800618c <groupCommand+0x80>
		if (count > 2)
 80061cc:	2600      	movs	r6, #0
 80061ce:	4b1d      	ldr	r3, [pc, #116]	; (8006244 <groupCommand+0x138>)
 80061d0:	579e      	ldrsb	r6, [r3, r6]
 80061d2:	2e02      	cmp	r6, #2
 80061d4:	dd03      	ble.n	80061de <groupCommand+0xd2>
			strcat( ( char * ) pcWriteBuffer, ", "); 
 80061d6:	4920      	ldr	r1, [pc, #128]	; (8006258 <groupCommand+0x14c>)
 80061d8:	0020      	movs	r0, r4
 80061da:	f00e fc5f 	bl	8014a9c <strcat>
		strcat( ( char * ) pcWriteBuffer, module);
 80061de:	0029      	movs	r1, r5
 80061e0:	0020      	movs	r0, r4
 80061e2:	f00e fc5b 	bl	8014a9c <strcat>
		pcParameterString = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, ++count, &xParameterStringLength);	
 80061e6:	3601      	adds	r6, #1
 80061e8:	4b16      	ldr	r3, [pc, #88]	; (8006244 <groupCommand+0x138>)
 80061ea:	b271      	sxtb	r1, r6
 80061ec:	7019      	strb	r1, [r3, #0]
 80061ee:	4a17      	ldr	r2, [pc, #92]	; (800624c <groupCommand+0x140>)
 80061f0:	e7c2      	b.n	8006178 <groupCommand+0x6c>
	else if (result == BOS_OK && type) {
 80061f2:	2800      	cmp	r0, #0
 80061f4:	d10f      	bne.n	8006216 <groupCommand+0x10a>
 80061f6:	9b01      	ldr	r3, [sp, #4]
		sprintf( module, ( char * ) pcMessageOKnew, alias); 
 80061f8:	aa03      	add	r2, sp, #12
 80061fa:	4918      	ldr	r1, [pc, #96]	; (800625c <groupCommand+0x150>)
	else if (result == BOS_OK && type) {
 80061fc:	2b00      	cmp	r3, #0
 80061fe:	d100      	bne.n	8006202 <groupCommand+0xf6>
		sprintf( module, ( char * ) pcMessageOKexist, alias);
 8006200:	4917      	ldr	r1, [pc, #92]	; (8006260 <groupCommand+0x154>)
 8006202:	0028      	movs	r0, r5
 8006204:	f00e fc2a 	bl	8014a5c <sprintf>
		strcat( ( char * ) pcWriteBuffer, module);
 8006208:	0029      	movs	r1, r5
 800620a:	0020      	movs	r0, r4
 800620c:	f00e fc46 	bl	8014a9c <strcat>
}
 8006210:	2000      	movs	r0, #0
 8006212:	b011      	add	sp, #68	; 0x44
 8006214:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (result == BOS_ERR_Keyword)
 8006216:	2806      	cmp	r0, #6
 8006218:	d102      	bne.n	8006220 <groupCommand+0x114>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageKey, alias);
 800621a:	aa03      	add	r2, sp, #12
 800621c:	4911      	ldr	r1, [pc, #68]	; (8006264 <groupCommand+0x158>)
 800621e:	e7bc      	b.n	800619a <groupCommand+0x8e>
	else if (result == BOS_ERR_ExistingAlias)
 8006220:	2807      	cmp	r0, #7
 8006222:	d102      	bne.n	800622a <groupCommand+0x11e>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageAlias, alias);	
 8006224:	aa03      	add	r2, sp, #12
 8006226:	4910      	ldr	r1, [pc, #64]	; (8006268 <groupCommand+0x15c>)
 8006228:	e7b7      	b.n	800619a <groupCommand+0x8e>
	else if (result == BOS_ERR_ExistingCmd)
 800622a:	2808      	cmp	r0, #8
 800622c:	d1f0      	bne.n	8006210 <groupCommand+0x104>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageCmd, alias);	
 800622e:	aa03      	add	r2, sp, #12
 8006230:	490e      	ldr	r1, [pc, #56]	; (800626c <groupCommand+0x160>)
 8006232:	e7b2      	b.n	800619a <groupCommand+0x8e>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongModule, module);
 8006234:	002a      	movs	r2, r5
 8006236:	490e      	ldr	r1, [pc, #56]	; (8006270 <groupCommand+0x164>)
 8006238:	e7af      	b.n	800619a <groupCommand+0x8e>
 800623a:	46c0      	nop			; (mov r8, r8)
 800623c:	20001260 	.word	0x20001260
 8006240:	20000e2f 	.word	0x20000e2f
 8006244:	20001227 	.word	0x20001227
 8006248:	08019de8 	.word	0x08019de8
 800624c:	20001254 	.word	0x20001254
 8006250:	20001228 	.word	0x20001228
 8006254:	08019df5 	.word	0x08019df5
 8006258:	08019df2 	.word	0x08019df2
 800625c:	08019e21 	.word	0x08019e21
 8006260:	08019e3b 	.word	0x08019e3b
 8006264:	08019e5a 	.word	0x08019e5a
 8006268:	08019e97 	.word	0x08019e97
 800626c:	08019eca 	.word	0x08019eca
 8006270:	08019f08 	.word	0x08019f08

08006274 <nameCommand>:
{
 8006274:	b570      	push	{r4, r5, r6, lr}
 8006276:	0004      	movs	r4, r0
 8006278:	0010      	movs	r0, r2
	configASSERT( pcWriteBuffer );
 800627a:	2c00      	cmp	r4, #0
 800627c:	d101      	bne.n	8006282 <nameCommand+0xe>
 800627e:	b672      	cpsid	i
 8006280:	e7fe      	b.n	8006280 <nameCommand+0xc>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8006282:	4e16      	ldr	r6, [pc, #88]	; (80062dc <nameCommand+0x68>)
 8006284:	2101      	movs	r1, #1
 8006286:	0032      	movs	r2, r6
 8006288:	f009 fb68 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800628c:	4d14      	ldr	r5, [pc, #80]	; (80062e0 <nameCommand+0x6c>)
	if (xParameterStringLength1 > MaxLengthOfAlias) {
 800628e:	6833      	ldr	r3, [r6, #0]
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8006290:	0001      	movs	r1, r0
 8006292:	6028      	str	r0, [r5, #0]
	if (xParameterStringLength1 > MaxLengthOfAlias) {
 8006294:	2b09      	cmp	r3, #9
 8006296:	dd01      	ble.n	800629c <nameCommand+0x28>
		pcParameterString1[MaxLengthOfAlias] = '\0';
 8006298:	2300      	movs	r3, #0
 800629a:	7243      	strb	r3, [r0, #9]
	result = NameModule(myID, (char*) pcParameterString1);
 800629c:	4e11      	ldr	r6, [pc, #68]	; (80062e4 <nameCommand+0x70>)
 800629e:	7830      	ldrb	r0, [r6, #0]
 80062a0:	f7fd fd7c 	bl	8003d9c <NameModule>
	if (result == BOS_OK)
 80062a4:	2800      	cmp	r0, #0
 80062a6:	d107      	bne.n	80062b8 <nameCommand+0x44>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageOK, myID, pcParameterString1);
 80062a8:	7832      	ldrb	r2, [r6, #0]
 80062aa:	682b      	ldr	r3, [r5, #0]
 80062ac:	490e      	ldr	r1, [pc, #56]	; (80062e8 <nameCommand+0x74>)
 80062ae:	0020      	movs	r0, r4
 80062b0:	f00e fbd4 	bl	8014a5c <sprintf>
}
 80062b4:	2000      	movs	r0, #0
 80062b6:	bd70      	pop	{r4, r5, r6, pc}
	else if (result == BOS_ERR_Keyword)
 80062b8:	2806      	cmp	r0, #6
 80062ba:	d105      	bne.n	80062c8 <nameCommand+0x54>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageKey, pcParameterString1);
 80062bc:	682a      	ldr	r2, [r5, #0]
 80062be:	490b      	ldr	r1, [pc, #44]	; (80062ec <nameCommand+0x78>)
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageCmd, pcParameterString1);	
 80062c0:	0020      	movs	r0, r4
 80062c2:	f00e fbcb 	bl	8014a5c <sprintf>
 80062c6:	e7f5      	b.n	80062b4 <nameCommand+0x40>
	else if (result == BOS_ERR_ExistingAlias)
 80062c8:	2807      	cmp	r0, #7
 80062ca:	d102      	bne.n	80062d2 <nameCommand+0x5e>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageAlias, pcParameterString1);	
 80062cc:	682a      	ldr	r2, [r5, #0]
 80062ce:	4908      	ldr	r1, [pc, #32]	; (80062f0 <nameCommand+0x7c>)
 80062d0:	e7f6      	b.n	80062c0 <nameCommand+0x4c>
	else if (result == BOS_ERR_ExistingCmd)
 80062d2:	2808      	cmp	r0, #8
 80062d4:	d1ee      	bne.n	80062b4 <nameCommand+0x40>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessageCmd, pcParameterString1);	
 80062d6:	682a      	ldr	r2, [r5, #0]
 80062d8:	4906      	ldr	r1, [pc, #24]	; (80062f4 <nameCommand+0x80>)
 80062da:	e7f1      	b.n	80062c0 <nameCommand+0x4c>
 80062dc:	2000125c 	.word	0x2000125c
 80062e0:	2000122c 	.word	0x2000122c
 80062e4:	20001039 	.word	0x20001039
 80062e8:	0801a042 	.word	0x0801a042
 80062ec:	08019e5a 	.word	0x08019e5a
 80062f0:	08019e97 	.word	0x08019e97
 80062f4:	08019eca 	.word	0x08019eca

080062f8 <bootloaderUpdateCommand>:
{
 80062f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80062fa:	0004      	movs	r4, r0
 80062fc:	b085      	sub	sp, #20
 80062fe:	0015      	movs	r5, r2
	configASSERT( pcWriteBuffer );
 8006300:	2800      	cmp	r0, #0
 8006302:	d101      	bne.n	8006308 <bootloaderUpdateCommand+0x10>
 8006304:	b672      	cpsid	i
 8006306:	e7fe      	b.n	8006306 <bootloaderUpdateCommand+0xe>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8006308:	4e47      	ldr	r6, [pc, #284]	; (8006428 <bootloaderUpdateCommand+0x130>)
 800630a:	2101      	movs	r1, #1
 800630c:	0032      	movs	r2, r6
 800630e:	0028      	movs	r0, r5
 8006310:	f009 fb24 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString1 == NULL)
 8006314:	2800      	cmp	r0, #0
 8006316:	d129      	bne.n	800636c <bootloaderUpdateCommand+0x74>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage, myID);
 8006318:	4b44      	ldr	r3, [pc, #272]	; (800642c <bootloaderUpdateCommand+0x134>)
 800631a:	4945      	ldr	r1, [pc, #276]	; (8006430 <bootloaderUpdateCommand+0x138>)
 800631c:	781a      	ldrb	r2, [r3, #0]
 800631e:	0020      	movs	r0, r4
 8006320:	f00e fb9c 	bl	8014a5c <sprintf>
		strcat( ( char * ) pcWriteBuffer, ( char * ) pcBootloaderUpdateMessage );
 8006324:	4b43      	ldr	r3, [pc, #268]	; (8006434 <bootloaderUpdateCommand+0x13c>)
 8006326:	0020      	movs	r0, r4
 8006328:	6819      	ldr	r1, [r3, #0]
 800632a:	f00e fbb7 	bl	8014a9c <strcat>
		writePxMutex(PcPort, (char*) pcWriteBuffer, strlen((char*) pcWriteBuffer), cmd50ms, HAL_MAX_DELAY);
 800632e:	0020      	movs	r0, r4
 8006330:	f7f9 fef2 	bl	8000118 <strlen>
 8006334:	4b40      	ldr	r3, [pc, #256]	; (8006438 <bootloaderUpdateCommand+0x140>)
 8006336:	b282      	uxth	r2, r0
 8006338:	7818      	ldrb	r0, [r3, #0]
 800633a:	2301      	movs	r3, #1
 800633c:	425b      	negs	r3, r3
 800633e:	9300      	str	r3, [sp, #0]
 8006340:	0021      	movs	r1, r4
 8006342:	3333      	adds	r3, #51	; 0x33
 8006344:	f007 f868 	bl	800d418 <writePxMutex>
		*((unsigned long *)0x20007FF0) = 0xDEADBEEF;   
 8006348:	4b3c      	ldr	r3, [pc, #240]	; (800643c <bootloaderUpdateCommand+0x144>)
 800634a:	4a3d      	ldr	r2, [pc, #244]	; (8006440 <bootloaderUpdateCommand+0x148>)
		osDelay(10);
 800634c:	200a      	movs	r0, #10
		*((unsigned long *)0x20007FF0) = 0xDEADBEEF;   
 800634e:	601a      	str	r2, [r3, #0]
		indMode = IND_PING;
 8006350:	2201      	movs	r2, #1
 8006352:	4b3c      	ldr	r3, [pc, #240]	; (8006444 <bootloaderUpdateCommand+0x14c>)
 8006354:	701a      	strb	r2, [r3, #0]
		osDelay(10);
 8006356:	f009 fa04 	bl	800f762 <osDelay>
  __ASM volatile ("dsb 0xF":::"memory");
 800635a:	f3bf 8f4f 	dsb	sy
 800635e:	4b3a      	ldr	r3, [pc, #232]	; (8006448 <bootloaderUpdateCommand+0x150>)
 8006360:	4a3a      	ldr	r2, [pc, #232]	; (800644c <bootloaderUpdateCommand+0x154>)
 8006362:	60da      	str	r2, [r3, #12]
 8006364:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8006368:	46c0      	nop			; (mov r8, r8)
 800636a:	e7fd      	b.n	8006368 <bootloaderUpdateCommand+0x70>
		if (!strncmp((const char *)pcParameterString1, "via", xParameterStringLength1)) 
 800636c:	6832      	ldr	r2, [r6, #0]
 800636e:	4938      	ldr	r1, [pc, #224]	; (8006450 <bootloaderUpdateCommand+0x158>)
 8006370:	f00e fbb8 	bl	8014ae4 <strncmp>
 8006374:	1e06      	subs	r6, r0, #0
 8006376:	d006      	beq.n	8006386 <bootloaderUpdateCommand+0x8e>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMessageWrongValue );			
 8006378:	4936      	ldr	r1, [pc, #216]	; (8006454 <bootloaderUpdateCommand+0x15c>)
 800637a:	0020      	movs	r0, r4
 800637c:	f00e fbaa 	bl	8014ad4 <strcpy>
}
 8006380:	2000      	movs	r0, #0
 8006382:	b005      	add	sp, #20
 8006384:	bdf0      	pop	{r4, r5, r6, r7, pc}
			pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8006386:	4a34      	ldr	r2, [pc, #208]	; (8006458 <bootloaderUpdateCommand+0x160>)
 8006388:	2102      	movs	r1, #2
 800638a:	0028      	movs	r0, r5
 800638c:	f009 fae6 	bl	800f95c <FreeRTOS_CLIGetParameter>
 8006390:	4f32      	ldr	r7, [pc, #200]	; (800645c <bootloaderUpdateCommand+0x164>)
			pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8006392:	4a33      	ldr	r2, [pc, #204]	; (8006460 <bootloaderUpdateCommand+0x168>)
			pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 8006394:	6038      	str	r0, [r7, #0]
			pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 8006396:	2103      	movs	r1, #3
 8006398:	0028      	movs	r0, r5
 800639a:	f009 fadf 	bl	800f95c <FreeRTOS_CLIGetParameter>
			if (pcParameterString2[0] == '#') {
 800639e:	2300      	movs	r3, #0
			pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 80063a0:	4d30      	ldr	r5, [pc, #192]	; (8006464 <bootloaderUpdateCommand+0x16c>)
 80063a2:	6028      	str	r0, [r5, #0]
			if (pcParameterString2[0] == '#') {
 80063a4:	6838      	ldr	r0, [r7, #0]
				result = BOS_ERR_WrongValue;				
 80063a6:	2768      	movs	r7, #104	; 0x68
			if (pcParameterString2[0] == '#') {
 80063a8:	56c3      	ldrsb	r3, [r0, r3]
 80063aa:	2b23      	cmp	r3, #35	; 0x23
 80063ac:	d105      	bne.n	80063ba <bootloaderUpdateCommand+0xc2>
				module = ( uint8_t ) atol( ( char * ) pcParameterString2+1 );
 80063ae:	3001      	adds	r0, #1
 80063b0:	f00d fed6 	bl	8014160 <atol>
	uint8_t module, port; BOS_Status result = BOS_OK;
 80063b4:	0037      	movs	r7, r6
				module = ( uint8_t ) atol( ( char * ) pcParameterString2+1 );
 80063b6:	b2c3      	uxtb	r3, r0
 80063b8:	9303      	str	r3, [sp, #12]
			if (pcParameterString3[0] == 'p') {
 80063ba:	2300      	movs	r3, #0
 80063bc:	6828      	ldr	r0, [r5, #0]
 80063be:	56c3      	ldrsb	r3, [r0, r3]
 80063c0:	2b70      	cmp	r3, #112	; 0x70
 80063c2:	d121      	bne.n	8006408 <bootloaderUpdateCommand+0x110>
				port = ( uint8_t ) atol( ( char * ) pcParameterString3+1 );
 80063c4:	3001      	adds	r0, #1
 80063c6:	f00d fecb 	bl	8014160 <atol>
 80063ca:	b2c3      	uxtb	r3, r0
 80063cc:	9302      	str	r3, [sp, #8]
			if (module != myID)
 80063ce:	4d17      	ldr	r5, [pc, #92]	; (800642c <bootloaderUpdateCommand+0x134>)
 80063d0:	9a03      	ldr	r2, [sp, #12]
 80063d2:	782b      	ldrb	r3, [r5, #0]
 80063d4:	4e18      	ldr	r6, [pc, #96]	; (8006438 <bootloaderUpdateCommand+0x140>)
 80063d6:	2100      	movs	r1, #0
 80063d8:	4293      	cmp	r3, r2
 80063da:	d017      	beq.n	800640c <bootloaderUpdateCommand+0x114>
				BOS.response = BOS_RESPONSE_NONE;							
 80063dc:	4b22      	ldr	r3, [pc, #136]	; (8006468 <bootloaderUpdateCommand+0x170>)
				messageParams[0] = port; SendMessageToModule(module, CODE_UPDATE_VIA_PORT, 1);
 80063de:	9a02      	ldr	r2, [sp, #8]
				BOS.response = BOS_RESPONSE_NONE;							
 80063e0:	7199      	strb	r1, [r3, #6]
				messageParams[0] = port; SendMessageToModule(module, CODE_UPDATE_VIA_PORT, 1);
 80063e2:	4b22      	ldr	r3, [pc, #136]	; (800646c <bootloaderUpdateCommand+0x174>)
 80063e4:	311a      	adds	r1, #26
 80063e6:	701a      	strb	r2, [r3, #0]
 80063e8:	9803      	ldr	r0, [sp, #12]
 80063ea:	2201      	movs	r2, #1
 80063ec:	f001 fd9e 	bl	8007f2c <SendMessageToModule>
				osDelay(100);			
 80063f0:	2064      	movs	r0, #100	; 0x64
 80063f2:	f009 f9b6 	bl	800f762 <osDelay>
				remoteBootloaderUpdate(myID, module, PcPort, port);	
 80063f6:	7832      	ldrb	r2, [r6, #0]
 80063f8:	7828      	ldrb	r0, [r5, #0]
 80063fa:	9b02      	ldr	r3, [sp, #8]
 80063fc:	9903      	ldr	r1, [sp, #12]
				remoteBootloaderUpdate(myID, myID, PcPort, port);							
 80063fe:	f7fd f9cd 	bl	800379c <remoteBootloaderUpdate>
	if (result == BOS_ERR_WrongValue) {
 8006402:	2f68      	cmp	r7, #104	; 0x68
 8006404:	d1bc      	bne.n	8006380 <bootloaderUpdateCommand+0x88>
 8006406:	e7b7      	b.n	8006378 <bootloaderUpdateCommand+0x80>
				result = BOS_ERR_WrongValue;		
 8006408:	2768      	movs	r7, #104	; 0x68
 800640a:	e7e0      	b.n	80063ce <bootloaderUpdateCommand+0xd6>
				SendMessageFromPort(port, 0, 0, CODE_UPDATE, 0);
 800640c:	000a      	movs	r2, r1
 800640e:	9100      	str	r1, [sp, #0]
 8006410:	2319      	movs	r3, #25
 8006412:	9802      	ldr	r0, [sp, #8]
 8006414:	f001 fbc0 	bl	8007b98 <SendMessageFromPort>
				osDelay(100);
 8006418:	2064      	movs	r0, #100	; 0x64
 800641a:	f009 f9a2 	bl	800f762 <osDelay>
				remoteBootloaderUpdate(myID, myID, PcPort, port);							
 800641e:	7828      	ldrb	r0, [r5, #0]
 8006420:	7832      	ldrb	r2, [r6, #0]
 8006422:	9b02      	ldr	r3, [sp, #8]
 8006424:	0001      	movs	r1, r0
 8006426:	e7ea      	b.n	80063fe <bootloaderUpdateCommand+0x106>
 8006428:	20001258 	.word	0x20001258
 800642c:	20001039 	.word	0x20001039
 8006430:	08019b1c 	.word	0x08019b1c
 8006434:	20000074 	.word	0x20000074
 8006438:	20000a9f 	.word	0x20000a9f
 800643c:	20007ff0 	.word	0x20007ff0
 8006440:	deadbeef 	.word	0xdeadbeef
 8006444:	20000ec6 	.word	0x20000ec6
 8006448:	e000ed00 	.word	0xe000ed00
 800644c:	05fa0004 	.word	0x05fa0004
 8006450:	08019b3c 	.word	0x08019b3c
 8006454:	08019bf8 	.word	0x08019bf8
 8006458:	20001264 	.word	0x20001264
 800645c:	2000123c 	.word	0x2000123c
 8006460:	20001268 	.word	0x20001268
 8006464:	20001244 	.word	0x20001244
 8006468:	20006f70 	.word	0x20006f70
 800646c:	20000f07 	.word	0x20000f07

08006470 <pingCommand>:
{
 8006470:	b510      	push	{r4, lr}
	configASSERT( pcWriteBuffer );
 8006472:	2800      	cmp	r0, #0
 8006474:	d101      	bne.n	800647a <pingCommand+0xa>
 8006476:	b672      	cpsid	i
 8006478:	e7fe      	b.n	8006478 <pingCommand+0x8>
	if (!moduleAlias[myID][0])
 800647a:	4b10      	ldr	r3, [pc, #64]	; (80064bc <pingCommand+0x4c>)
 800647c:	4910      	ldr	r1, [pc, #64]	; (80064c0 <pingCommand+0x50>)
 800647e:	781a      	ldrb	r2, [r3, #0]
 8006480:	230a      	movs	r3, #10
 8006482:	4353      	muls	r3, r2
 8006484:	5c5c      	ldrb	r4, [r3, r1]
 8006486:	2c00      	cmp	r4, #0
 8006488:	d113      	bne.n	80064b2 <pingCommand+0x42>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage1, myID);
 800648a:	490e      	ldr	r1, [pc, #56]	; (80064c4 <pingCommand+0x54>)
 800648c:	f00e fae6 	bl	8014a5c <sprintf>
	RTOS_IND_blink(200);	
 8006490:	2180      	movs	r1, #128	; 0x80
 8006492:	2201      	movs	r2, #1
 8006494:	01c9      	lsls	r1, r1, #7
 8006496:	480c      	ldr	r0, [pc, #48]	; (80064c8 <pingCommand+0x58>)
 8006498:	f00b ff42 	bl	8012320 <HAL_GPIO_WritePin>
 800649c:	20c8      	movs	r0, #200	; 0xc8
 800649e:	f009 f960 	bl	800f762 <osDelay>
 80064a2:	2180      	movs	r1, #128	; 0x80
 80064a4:	2200      	movs	r2, #0
 80064a6:	01c9      	lsls	r1, r1, #7
 80064a8:	4807      	ldr	r0, [pc, #28]	; (80064c8 <pingCommand+0x58>)
 80064aa:	f00b ff39 	bl	8012320 <HAL_GPIO_WritePin>
}
 80064ae:	2000      	movs	r0, #0
 80064b0:	bd10      	pop	{r4, pc}
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage2, myID, moduleAlias[myID]);
 80064b2:	185b      	adds	r3, r3, r1
 80064b4:	4905      	ldr	r1, [pc, #20]	; (80064cc <pingCommand+0x5c>)
 80064b6:	f00e fad1 	bl	8014a5c <sprintf>
 80064ba:	e7e9      	b.n	8006490 <pingCommand+0x20>
 80064bc:	20001039 	.word	0x20001039
 80064c0:	20000f35 	.word	0x20000f35
 80064c4:	0801a0b4 	.word	0x0801a0b4
 80064c8:	48000400 	.word	0x48000400
 80064cc:	0801a0c8 	.word	0x0801a0c8

080064d0 <prvRunTimeStatsCommand>:
{
 80064d0:	b510      	push	{r4, lr}
 80064d2:	1e04      	subs	r4, r0, #0
	configASSERT( pcWriteBuffer );
 80064d4:	d101      	bne.n	80064da <prvRunTimeStatsCommand+0xa>
 80064d6:	b672      	cpsid	i
 80064d8:	e7fe      	b.n	80064d8 <prvRunTimeStatsCommand+0x8>
	strcpy( ( char * ) pcWriteBuffer, ( char * ) pcStatsTableHeader );
 80064da:	4904      	ldr	r1, [pc, #16]	; (80064ec <prvRunTimeStatsCommand+0x1c>)
 80064dc:	f00e fafa 	bl	8014ad4 <strcpy>
	vTaskGetRunTimeStats( ((char*) pcWriteBuffer) + strlen( ( char * ) pcStatsTableHeader ) );
 80064e0:	0020      	movs	r0, r4
 80064e2:	3050      	adds	r0, #80	; 0x50
 80064e4:	f00a fbc6 	bl	8010c74 <vTaskGetRunTimeStats>
}
 80064e8:	2000      	movs	r0, #0
 80064ea:	bd10      	pop	{r4, pc}
 80064ec:	0801a0f4 	.word	0x0801a0f4

080064f0 <prvTaskStatsCommand>:
{
 80064f0:	b510      	push	{r4, lr}
 80064f2:	1e04      	subs	r4, r0, #0
	configASSERT( pcWriteBuffer );
 80064f4:	d101      	bne.n	80064fa <prvTaskStatsCommand+0xa>
 80064f6:	b672      	cpsid	i
 80064f8:	e7fe      	b.n	80064f8 <prvTaskStatsCommand+0x8>
	strcpy( ( char * ) pcWriteBuffer, ( char * ) pcTaskTableHeader );
 80064fa:	4904      	ldr	r1, [pc, #16]	; (800650c <prvTaskStatsCommand+0x1c>)
 80064fc:	f00e faea 	bl	8014ad4 <strcpy>
	vTaskList( ((char*) pcWriteBuffer) + strlen( ( char * ) pcTaskTableHeader ) );
 8006500:	0020      	movs	r0, r4
 8006502:	305a      	adds	r0, #90	; 0x5a
 8006504:	f00a fb66 	bl	8010bd4 <vTaskList>
}
 8006508:	2000      	movs	r0, #0
 800650a:	bd10      	pop	{r4, pc}
 800650c:	0801a158 	.word	0x0801a158

08006510 <uuidCommand>:
{
 8006510:	b570      	push	{r4, r5, r6, lr}
 8006512:	1e04      	subs	r4, r0, #0
	configASSERT( pcWriteBuffer );
 8006514:	d101      	bne.n	800651a <uuidCommand+0xa>
 8006516:	b672      	cpsid	i
 8006518:	e7fe      	b.n	8006518 <uuidCommand+0x8>
	sprintf( ( char * ) pcWriteBuffer, "%s", ( char * ) pcMessageUUID );
 800651a:	490f      	ldr	r1, [pc, #60]	; (8006558 <uuidCommand+0x48>)
 800651c:	f00e fada 	bl	8014ad4 <strcpy>
		sprintf( ( char * ) pcWriteBuffer, "%s%08X", ( char * ) pcWriteBuffer, *(uint32_t *) (MCU_F0_UUID_BASE+i*4) );
 8006520:	4d0e      	ldr	r5, [pc, #56]	; (800655c <uuidCommand+0x4c>)
 8006522:	4b0f      	ldr	r3, [pc, #60]	; (8006560 <uuidCommand+0x50>)
 8006524:	0029      	movs	r1, r5
 8006526:	0022      	movs	r2, r4
 8006528:	681b      	ldr	r3, [r3, #0]
 800652a:	0020      	movs	r0, r4
 800652c:	f00e fa96 	bl	8014a5c <sprintf>
 8006530:	4b0c      	ldr	r3, [pc, #48]	; (8006564 <uuidCommand+0x54>)
 8006532:	0029      	movs	r1, r5
 8006534:	0022      	movs	r2, r4
 8006536:	681b      	ldr	r3, [r3, #0]
 8006538:	0020      	movs	r0, r4
 800653a:	f00e fa8f 	bl	8014a5c <sprintf>
 800653e:	4b0a      	ldr	r3, [pc, #40]	; (8006568 <uuidCommand+0x58>)
 8006540:	0029      	movs	r1, r5
 8006542:	681b      	ldr	r3, [r3, #0]
 8006544:	0022      	movs	r2, r4
 8006546:	0020      	movs	r0, r4
 8006548:	f00e fa88 	bl	8014a5c <sprintf>
	strcat(( char * ) pcWriteBuffer, "\r\n");
 800654c:	4907      	ldr	r1, [pc, #28]	; (800656c <uuidCommand+0x5c>)
 800654e:	0020      	movs	r0, r4
 8006550:	f00e faa4 	bl	8014a9c <strcat>
}
 8006554:	2000      	movs	r0, #0
 8006556:	bd70      	pop	{r4, r5, r6, pc}
 8006558:	0801b4c0 	.word	0x0801b4c0
 800655c:	0801b4ce 	.word	0x0801b4ce
 8006560:	1ffff7ac 	.word	0x1ffff7ac
 8006564:	1ffff7b0 	.word	0x1ffff7b0
 8006568:	1ffff7b4 	.word	0x1ffff7b4
 800656c:	0801aae8 	.word	0x0801aae8

08006570 <timeCommand>:
{
 8006570:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8006572:	1e04      	subs	r4, r0, #0
	configASSERT( pcWriteBuffer );
 8006574:	d101      	bne.n	800657a <timeCommand+0xa>
 8006576:	b672      	cpsid	i
 8006578:	e7fe      	b.n	8006578 <timeCommand+0x8>
	GetTimeDate();
 800657a:	f006 f809 	bl	800c590 <GetTimeDate>
	if (BOS.hourformat == 24)
 800657e:	4914      	ldr	r1, [pc, #80]	; (80065d0 <timeCommand+0x60>)
 8006580:	7b4b      	ldrb	r3, [r1, #13]
 8006582:	2b18      	cmp	r3, #24
 8006584:	d10c      	bne.n	80065a0 <timeCommand+0x30>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage24, BOS.time.hours, BOS.time.minutes, BOS.time.seconds, BOS.time.msec );
 8006586:	89c8      	ldrh	r0, [r1, #14]
 8006588:	7c4b      	ldrb	r3, [r1, #17]
 800658a:	7c8a      	ldrb	r2, [r1, #18]
 800658c:	9001      	str	r0, [sp, #4]
 800658e:	7c09      	ldrb	r1, [r1, #16]
 8006590:	0020      	movs	r0, r4
 8006592:	9100      	str	r1, [sp, #0]
 8006594:	490f      	ldr	r1, [pc, #60]	; (80065d4 <timeCommand+0x64>)
 8006596:	f00e fa61 	bl	8014a5c <sprintf>
}
 800659a:	2000      	movs	r0, #0
 800659c:	b004      	add	sp, #16
 800659e:	bd10      	pop	{r4, pc}
	else if (BOS.hourformat == 12)
 80065a0:	2b0c      	cmp	r3, #12
 80065a2:	d1fa      	bne.n	800659a <timeCommand+0x2a>
		if (BOS.time.ampm == RTC_AM)
 80065a4:	7ccb      	ldrb	r3, [r1, #19]
 80065a6:	2b01      	cmp	r3, #1
 80065a8:	d10c      	bne.n	80065c4 <timeCommand+0x54>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage12, BOS.time.hours, BOS.time.minutes, BOS.time.seconds, BOS.time.msec, "AM" );
 80065aa:	7c4b      	ldrb	r3, [r1, #17]
 80065ac:	7c8a      	ldrb	r2, [r1, #18]
 80065ae:	480a      	ldr	r0, [pc, #40]	; (80065d8 <timeCommand+0x68>)
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage12, BOS.time.hours, BOS.time.minutes, BOS.time.seconds, BOS.time.msec, "PM" );
 80065b0:	9002      	str	r0, [sp, #8]
 80065b2:	89c8      	ldrh	r0, [r1, #14]
 80065b4:	9001      	str	r0, [sp, #4]
 80065b6:	7c09      	ldrb	r1, [r1, #16]
 80065b8:	0020      	movs	r0, r4
 80065ba:	9100      	str	r1, [sp, #0]
 80065bc:	4907      	ldr	r1, [pc, #28]	; (80065dc <timeCommand+0x6c>)
 80065be:	f00e fa4d 	bl	8014a5c <sprintf>
 80065c2:	e7ea      	b.n	800659a <timeCommand+0x2a>
		else if (BOS.time.ampm == RTC_PM)
 80065c4:	2b02      	cmp	r3, #2
 80065c6:	d1e8      	bne.n	800659a <timeCommand+0x2a>
			sprintf( ( char * ) pcWriteBuffer, ( char * ) pcMessage12, BOS.time.hours, BOS.time.minutes, BOS.time.seconds, BOS.time.msec, "PM" );
 80065c8:	7c4b      	ldrb	r3, [r1, #17]
 80065ca:	7c8a      	ldrb	r2, [r1, #18]
 80065cc:	4804      	ldr	r0, [pc, #16]	; (80065e0 <timeCommand+0x70>)
 80065ce:	e7ef      	b.n	80065b0 <timeCommand+0x40>
 80065d0:	20006f70 	.word	0x20006f70
 80065d4:	0801b410 	.word	0x0801b410
 80065d8:	0801b45f 	.word	0x0801b45f
 80065dc:	0801b436 	.word	0x0801b436
 80065e0:	0801b462 	.word	0x0801b462

080065e4 <resetCommand>:
	configASSERT( pcWriteBuffer );
 80065e4:	2800      	cmp	r0, #0
 80065e6:	d101      	bne.n	80065ec <resetCommand+0x8>
 80065e8:	b672      	cpsid	i
 80065ea:	e7fe      	b.n	80065ea <resetCommand+0x6>
  __ASM volatile ("dsb 0xF":::"memory");
 80065ec:	f3bf 8f4f 	dsb	sy
 80065f0:	4b03      	ldr	r3, [pc, #12]	; (8006600 <resetCommand+0x1c>)
 80065f2:	4a04      	ldr	r2, [pc, #16]	; (8006604 <resetCommand+0x20>)
 80065f4:	60da      	str	r2, [r3, #12]
 80065f6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 80065fa:	46c0      	nop			; (mov r8, r8)
 80065fc:	e7fd      	b.n	80065fa <resetCommand+0x16>
 80065fe:	46c0      	nop			; (mov r8, r8)
 8006600:	e000ed00 	.word	0xe000ed00
 8006604:	05fa0004 	.word	0x05fa0004

08006608 <RegisterUserCLICommands>:
}
 8006608:	4770      	bx	lr
	...

0800660c <vRegisterCLICommands>:
{
 800660c:	b510      	push	{r4, lr}
	FreeRTOS_CLIRegisterCommand( &prvTaskStatsCommandDefinition );
 800660e:	482f      	ldr	r0, [pc, #188]	; (80066cc <vRegisterCLICommands+0xc0>)
 8006610:	f009 f918 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &prvRunTimeStatsCommandDefinition );	
 8006614:	482e      	ldr	r0, [pc, #184]	; (80066d0 <vRegisterCLICommands+0xc4>)
 8006616:	f009 f915 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &pingCommandDefinition );
 800661a:	482e      	ldr	r0, [pc, #184]	; (80066d4 <vRegisterCLICommands+0xc8>)
 800661c:	f009 f912 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &bootloaderUpdateCommandDefinition );
 8006620:	482d      	ldr	r0, [pc, #180]	; (80066d8 <vRegisterCLICommands+0xcc>)
 8006622:	f009 f90f 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &exploreCommandDefinition );
 8006626:	482d      	ldr	r0, [pc, #180]	; (80066dc <vRegisterCLICommands+0xd0>)
 8006628:	f009 f90c 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &resetCommandDefinition );
 800662c:	482c      	ldr	r0, [pc, #176]	; (80066e0 <vRegisterCLICommands+0xd4>)
 800662e:	f009 f909 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &nameCommandDefinition );
 8006632:	482c      	ldr	r0, [pc, #176]	; (80066e4 <vRegisterCLICommands+0xd8>)
 8006634:	f009 f906 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &groupCommandDefinition );
 8006638:	482b      	ldr	r0, [pc, #172]	; (80066e8 <vRegisterCLICommands+0xdc>)
 800663a:	f009 f903 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &statusCommandDefinition );
 800663e:	482b      	ldr	r0, [pc, #172]	; (80066ec <vRegisterCLICommands+0xe0>)
 8006640:	f009 f900 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &infoCommandDefinition );
 8006644:	482a      	ldr	r0, [pc, #168]	; (80066f0 <vRegisterCLICommands+0xe4>)
 8006646:	f009 f8fd 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &scastCommandDefinition );
 800664a:	482a      	ldr	r0, [pc, #168]	; (80066f4 <vRegisterCLICommands+0xe8>)
 800664c:	f009 f8fa 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &addbuttonCommandDefinition );
 8006650:	4829      	ldr	r0, [pc, #164]	; (80066f8 <vRegisterCLICommands+0xec>)
 8006652:	f009 f8f7 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &removebuttonCommandDefinition );
 8006656:	4829      	ldr	r0, [pc, #164]	; (80066fc <vRegisterCLICommands+0xf0>)
 8006658:	f009 f8f4 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &setCommandDefinition );
 800665c:	4828      	ldr	r0, [pc, #160]	; (8006700 <vRegisterCLICommands+0xf4>)
 800665e:	f009 f8f1 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &getCommandDefinition );
 8006662:	4828      	ldr	r0, [pc, #160]	; (8006704 <vRegisterCLICommands+0xf8>)
 8006664:	f009 f8ee 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &defaultCommandDefinition );
 8006668:	4827      	ldr	r0, [pc, #156]	; (8006708 <vRegisterCLICommands+0xfc>)
 800666a:	f009 f8eb 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &timeCommandDefinition );
 800666e:	4827      	ldr	r0, [pc, #156]	; (800670c <vRegisterCLICommands+0x100>)
 8006670:	f009 f8e8 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &dateCommandDefinition );
 8006674:	4826      	ldr	r0, [pc, #152]	; (8006710 <vRegisterCLICommands+0x104>)
 8006676:	f009 f8e5 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &setBaudrateCommandDefinition);
 800667a:	4826      	ldr	r0, [pc, #152]	; (8006714 <vRegisterCLICommands+0x108>)
 800667c:	f009 f8e2 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &uuidCommandDefinition);
 8006680:	4825      	ldr	r0, [pc, #148]	; (8006718 <vRegisterCLICommands+0x10c>)
 8006682:	f009 f8df 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &idcodeCommandDefinition);
 8006686:	4825      	ldr	r0, [pc, #148]	; (800671c <vRegisterCLICommands+0x110>)
 8006688:	f009 f8dc 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &flashsizeCommandDefinition);
 800668c:	4824      	ldr	r0, [pc, #144]	; (8006720 <vRegisterCLICommands+0x114>)
 800668e:	f009 f8d9 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &snipCommandDefinition);
 8006692:	4824      	ldr	r0, [pc, #144]	; (8006724 <vRegisterCLICommands+0x118>)
 8006694:	f009 f8d6 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &actSnipCommandDefinition);
 8006698:	4823      	ldr	r0, [pc, #140]	; (8006728 <vRegisterCLICommands+0x11c>)
 800669a:	f009 f8d3 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &pauseSnipCommandDefinition);
 800669e:	4823      	ldr	r0, [pc, #140]	; (800672c <vRegisterCLICommands+0x120>)
 80066a0:	f009 f8d0 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &delSnipCommandDefinition);
 80066a4:	4822      	ldr	r0, [pc, #136]	; (8006730 <vRegisterCLICommands+0x124>)
 80066a6:	f009 f8cd 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &bridgeCommandDefinition);
 80066aa:	4822      	ldr	r0, [pc, #136]	; (8006734 <vRegisterCLICommands+0x128>)
 80066ac:	f009 f8ca 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &unbridgeCommandDefinition);
 80066b0:	4821      	ldr	r0, [pc, #132]	; (8006738 <vRegisterCLICommands+0x12c>)
 80066b2:	f009 f8c7 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &testportCommandDefinition);
 80066b6:	4821      	ldr	r0, [pc, #132]	; (800673c <vRegisterCLICommands+0x130>)
 80066b8:	f009 f8c4 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	numOfBosCommands = 29;
 80066bc:	221d      	movs	r2, #29
 80066be:	4b20      	ldr	r3, [pc, #128]	; (8006740 <vRegisterCLICommands+0x134>)
 80066c0:	701a      	strb	r2, [r3, #0]
	RegisterModuleCLICommands();
 80066c2:	f003 f99f 	bl	8009a04 <RegisterModuleCLICommands>
	RegisterUserCLICommands();
 80066c6:	f7ff ff9f 	bl	8006608 <RegisterUserCLICommands>
}
 80066ca:	bd10      	pop	{r4, pc}
 80066cc:	0801a1b4 	.word	0x0801a1b4
 80066d0:	0801a148 	.word	0x0801a148
 80066d4:	0801a0e4 	.word	0x0801a0e4
 80066d8:	08019b40 	.word	0x08019b40
 80066dc:	08019cc4 	.word	0x08019cc4
 80066e0:	0801a1fc 	.word	0x0801a1fc
 80066e4:	0801a05c 	.word	0x0801a05c
 80066e8:	08019f2c 	.word	0x08019f2c
 80066ec:	0801a644 	.word	0x0801a644
 80066f0:	0801a020 	.word	0x0801a020
 80066f4:	0801a2b4 	.word	0x0801a2b4
 80066f8:	08019b0c 	.word	0x08019b0c
 80066fc:	0801a1ec 	.word	0x0801a1ec
 8006700:	0801a4b8 	.word	0x0801a4b8
 8006704:	08019dd8 	.word	0x08019dd8
 8006708:	08019c48 	.word	0x08019c48
 800670c:	0801b468 	.word	0x0801b468
 8006710:	08019bb4 	.word	0x08019bb4
 8006714:	0801a300 	.word	0x0801a300
 8006718:	0801b4d8 	.word	0x0801b4d8
 800671c:	08019fa0 	.word	0x08019fa0
 8006720:	08019cf4 	.word	0x08019cf4
 8006724:	0801a634 	.word	0x0801a634
 8006728:	08019a9c 	.word	0x08019a9c
 800672c:	0801a0a4 	.word	0x0801a0a4
 8006730:	08019cb4 	.word	0x08019cb4
 8006734:	08019b8c 	.word	0x08019b8c
 8006738:	0801b4b0 	.word	0x0801b4b0
 800673c:	0801b400 	.word	0x0801b400
 8006740:	20006ef4 	.word	0x20006ef4

08006744 <StopMsgDMA>:


/* --- Stop a messaging DMA --- 
*/
void StopMsgDMA(uint8_t port)
{
 8006744:	b570      	push	{r4, r5, r6, lr}
	DMA_HandleTypeDef *hDMA;
	
	/* Select DMA struct */
	hDMA = &msgRxDMA[port-1];
 8006746:	2438      	movs	r4, #56	; 0x38
 8006748:	3801      	subs	r0, #1
 800674a:	4344      	muls	r4, r0
 800674c:	4d03      	ldr	r5, [pc, #12]	; (800675c <StopMsgDMA+0x18>)
 800674e:	1960      	adds	r0, r4, r5
	
	HAL_DMA_Abort(hDMA);
 8006750:	f00b f8c9 	bl	80118e6 <HAL_DMA_Abort>
	hDMA->Instance->CNDTR = 0;
 8006754:	2200      	movs	r2, #0
 8006756:	5963      	ldr	r3, [r4, r5]
 8006758:	605a      	str	r2, [r3, #4]
}
 800675a:	bd70      	pop	{r4, r5, r6, pc}
 800675c:	20001940 	.word	0x20001940

08006760 <StopStreamDMA>:
/*-----------------------------------------------------------*/

/* --- Stop a streaming DMA --- 
*/
void StopStreamDMA(uint8_t port)
{
 8006760:	b570      	push	{r4, r5, r6, lr}
	DMA_HandleTypeDef *hDMA;
	
	/* Select DMA struct */
	hDMA = &streamDMA[port-1];
 8006762:	2538      	movs	r5, #56	; 0x38
 8006764:	1e44      	subs	r4, r0, #1
 8006766:	4365      	muls	r5, r4
 8006768:	4e06      	ldr	r6, [pc, #24]	; (8006784 <StopStreamDMA+0x24>)
	
	HAL_DMA_Abort(hDMA);
	hDMA->Instance->CNDTR = 0;
	dmaStreamCount[port-1] = 0;
 800676a:	00a4      	lsls	r4, r4, #2
	hDMA = &streamDMA[port-1];
 800676c:	19a8      	adds	r0, r5, r6
	HAL_DMA_Abort(hDMA);
 800676e:	f00b f8ba 	bl	80118e6 <HAL_DMA_Abort>
	hDMA->Instance->CNDTR = 0;
 8006772:	2300      	movs	r3, #0
 8006774:	59aa      	ldr	r2, [r5, r6]
 8006776:	6053      	str	r3, [r2, #4]
	dmaStreamCount[port-1] = 0;
 8006778:	4a03      	ldr	r2, [pc, #12]	; (8006788 <StopStreamDMA+0x28>)
 800677a:	50a3      	str	r3, [r4, r2]
	dmaStreamTotal[port-1] = 0;
 800677c:	4a03      	ldr	r2, [pc, #12]	; (800678c <StopStreamDMA+0x2c>)
 800677e:	50a3      	str	r3, [r4, r2]

}
 8006780:	bd70      	pop	{r4, r5, r6, pc}
 8006782:	46c0      	nop			; (mov r8, r8)
 8006784:	20001b38 	.word	0x20001b38
 8006788:	200013f0 	.word	0x200013f0
 800678c:	20001418 	.word	0x20001418

08006790 <SwitchMsgDMAToStream>:
/*-----------------------------------------------------------*/

/* Switch messaging DMA channels to streaming 
*/
void SwitchMsgDMAToStream(uint8_t port)
{
 8006790:	b510      	push	{r4, lr}
 8006792:	0004      	movs	r4, r0
	// TODO - Make sure all messages in the RX buffer have been parsed?
	
	// Stop the messaging DMA
	StopMsgDMA(port);
 8006794:	f7ff ffd6 	bl	8006744 <StopMsgDMA>
	
	// Initialize a streaming DMA using same channel
	DMA_STREAM_CH_Init(&streamDMA[port-1], msgRxDMA[port-1].Instance);
 8006798:	2338      	movs	r3, #56	; 0x38
 800679a:	3c01      	subs	r4, #1
 800679c:	4363      	muls	r3, r4
 800679e:	4a03      	ldr	r2, [pc, #12]	; (80067ac <SwitchMsgDMAToStream+0x1c>)
 80067a0:	4803      	ldr	r0, [pc, #12]	; (80067b0 <SwitchMsgDMAToStream+0x20>)
 80067a2:	5899      	ldr	r1, [r3, r2]
 80067a4:	1818      	adds	r0, r3, r0
 80067a6:	f004 fde7 	bl	800b378 <DMA_STREAM_CH_Init>
}
 80067aa:	bd10      	pop	{r4, pc}
 80067ac:	20001940 	.word	0x20001940
 80067b0:	20001b38 	.word	0x20001b38

080067b4 <SwitchStreamDMAToMsg>:
/*-----------------------------------------------------------*/

/* Switch streaming DMA channel to messaging 
*/
void SwitchStreamDMAToMsg(uint8_t port)
{
 80067b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80067b6:	0006      	movs	r6, r0
	// Stop the streaming DMA
	StopStreamDMA(port);
	
	// Initialize a messaging DMA using same channels
	DMA_MSG_RX_CH_Init(&msgRxDMA[port-1], streamDMA[port-1].Instance);	
 80067b8:	2438      	movs	r4, #56	; 0x38
	StopStreamDMA(port);
 80067ba:	f7ff ffd1 	bl	8006760 <StopStreamDMA>
	DMA_MSG_RX_CH_Init(&msgRxDMA[port-1], streamDMA[port-1].Instance);	
 80067be:	1e73      	subs	r3, r6, #1
 80067c0:	435c      	muls	r4, r3
 80067c2:	4d0d      	ldr	r5, [pc, #52]	; (80067f8 <SwitchStreamDMAToMsg+0x44>)
 80067c4:	4f0d      	ldr	r7, [pc, #52]	; (80067fc <SwitchStreamDMAToMsg+0x48>)
 80067c6:	1965      	adds	r5, r4, r5
 80067c8:	59e1      	ldr	r1, [r4, r7]
 80067ca:	0028      	movs	r0, r5
 80067cc:	f004 fd5c 	bl	800b288 <DMA_MSG_RX_CH_Init>
	
	// Remove stream DMA and change port status
	portStatus[GetPort(streamDMA[port-1].Parent)] = FREE; 
 80067d0:	193b      	adds	r3, r7, r4
 80067d2:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80067d4:	f003 f940 	bl	8009a58 <GetPort>
 80067d8:	2200      	movs	r2, #0
 80067da:	4b09      	ldr	r3, [pc, #36]	; (8006800 <SwitchStreamDMAToMsg+0x4c>)
	streamDMA[port-1].Instance = 0;
	dmaStreamDst[port-1] = 0;
 80067dc:	4909      	ldr	r1, [pc, #36]	; (8006804 <SwitchStreamDMAToMsg+0x50>)
	portStatus[GetPort(streamDMA[port-1].Parent)] = FREE; 
 80067de:	541a      	strb	r2, [r3, r0]
	dmaStreamDst[port-1] = 0;
 80067e0:	1e73      	subs	r3, r6, #1
	streamDMA[port-1].Instance = 0;
 80067e2:	51e2      	str	r2, [r4, r7]
	dmaStreamDst[port-1] = 0;
 80067e4:	009b      	lsls	r3, r3, #2
	
	// Read this port again in messaging mode	
	DMA_MSG_RX_Setup(GetUart(port), &msgRxDMA[port-1]);
 80067e6:	0030      	movs	r0, r6
	dmaStreamDst[port-1] = 0;
 80067e8:	505a      	str	r2, [r3, r1]
	DMA_MSG_RX_Setup(GetUart(port), &msgRxDMA[port-1]);
 80067ea:	f006 fe09 	bl	800d400 <GetUart>
 80067ee:	0029      	movs	r1, r5
 80067f0:	f005 f8c0 	bl	800b974 <DMA_MSG_RX_Setup>
		
}
 80067f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80067f6:	46c0      	nop			; (mov r8, r8)
 80067f8:	20001940 	.word	0x20001940
 80067fc:	20001b38 	.word	0x20001b38
 8006800:	200010b2 	.word	0x200010b2
 8006804:	20001404 	.word	0x20001404

08006808 <StartDMAstream>:
/*-----------------------------------------------------------*/

/* Setup and start a streaming DMA (port-to-port) 
*/
BOS_Status StartDMAstream(UART_HandleTypeDef* huartSrc, UART_HandleTypeDef* huartDst, uint16_t num)
{	
 8006808:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800680a:	0005      	movs	r5, r0
 800680c:	000e      	movs	r6, r1
 800680e:	9201      	str	r2, [sp, #4]
	uint8_t srcPort = GetPort(huartSrc);
 8006810:	f003 f922 	bl	8009a58 <GetPort>
	
	// 1. Check if single- or multi-cast 
	// 1.a. If single-cast, switch the DMA channel to streaming if it's available 
	if (portStatus[srcPort] == FREE || portStatus[srcPort] == MSG || portStatus[srcPort] == CLI)		// This port is not streaming so it's single-cast
 8006814:	4f0d      	ldr	r7, [pc, #52]	; (800684c <StartDMAstream+0x44>)
	uint8_t srcPort = GetPort(huartSrc);
 8006816:	0004      	movs	r4, r0
	if (portStatus[srcPort] == FREE || portStatus[srcPort] == MSG || portStatus[srcPort] == CLI)		// This port is not streaming so it's single-cast
 8006818:	5c3b      	ldrb	r3, [r7, r0]
 800681a:	2b01      	cmp	r3, #1
 800681c:	d902      	bls.n	8006824 <StartDMAstream+0x1c>
		SwitchMsgDMAToStream(srcPort);
	}
	// 1.b. If multi-cast, do some stuff - TODO
	else if (portStatus[srcPort] == STREAM)
	{
		return BOS_ERR_PORT_BUSY;		// Multi-casting not implemented right now
 800681e:	2017      	movs	r0, #23
	if (portStatus[srcPort] == FREE || portStatus[srcPort] == MSG || portStatus[srcPort] == CLI)		// This port is not streaming so it's single-cast
 8006820:	2b03      	cmp	r3, #3
 8006822:	d111      	bne.n	8006848 <StartDMAstream+0x40>
		SwitchMsgDMAToStream(srcPort);
 8006824:	0020      	movs	r0, r4
 8006826:	f7ff ffb3 	bl	8006790 <SwitchMsgDMAToStream>
	}
	else
		return BOS_ERR_PORT_BUSY;

	// 2. Setup streaming destination
	dmaStreamDst[srcPort-1] = huartDst;
 800682a:	4a09      	ldr	r2, [pc, #36]	; (8006850 <StartDMAstream+0x48>)
 800682c:	1e63      	subs	r3, r4, #1
 800682e:	009b      	lsls	r3, r3, #2
 8006830:	509e      	str	r6, [r3, r2]
	
	// 3. Lock the ports 
	portStatus[srcPort] = STREAM;
 8006832:	2202      	movs	r2, #2
 8006834:	553a      	strb	r2, [r7, r4]
	
	// 4. Initialize stream counter 
	dmaStreamCount[srcPort-1] = 0;
 8006836:	2400      	movs	r4, #0
 8006838:	4a06      	ldr	r2, [pc, #24]	; (8006854 <StartDMAstream+0x4c>)
	
	// 5. Setup and start the DMA stream
	DMA_STREAM_Setup(huartSrc, huartDst, num);	
 800683a:	0028      	movs	r0, r5
	dmaStreamCount[srcPort-1] = 0;
 800683c:	509c      	str	r4, [r3, r2]
	DMA_STREAM_Setup(huartSrc, huartDst, num);	
 800683e:	0031      	movs	r1, r6
 8006840:	9a01      	ldr	r2, [sp, #4]
 8006842:	f005 f8eb 	bl	800ba1c <DMA_STREAM_Setup>
	
	return BOS_OK;
 8006846:	0020      	movs	r0, r4
}
 8006848:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800684a:	46c0      	nop			; (mov r8, r8)
 800684c:	200010b2 	.word	0x200010b2
 8006850:	20001404 	.word	0x20001404
 8006854:	200013f0 	.word	0x200013f0

08006858 <DMA_IRQHandler>:
/*-----------------------------------------------------------*/

/* DMA interrupt service routine 
*/
void DMA_IRQHandler(uint8_t port)
{
 8006858:	b570      	push	{r4, r5, r6, lr}
 800685a:	0005      	movs	r5, r0
 800685c:	1e44      	subs	r4, r0, #1
 800685e:	2038      	movs	r0, #56	; 0x38
	if (portStatus[port] != STREAM) {
 8006860:	4b0e      	ldr	r3, [pc, #56]	; (800689c <DMA_IRQHandler+0x44>)
 8006862:	4360      	muls	r0, r4
 8006864:	5d5b      	ldrb	r3, [r3, r5]
 8006866:	2b02      	cmp	r3, #2
 8006868:	d004      	beq.n	8006874 <DMA_IRQHandler+0x1c>
		HAL_DMA_IRQHandler(&msgRxDMA[port-1]);
 800686a:	4b0d      	ldr	r3, [pc, #52]	; (80068a0 <DMA_IRQHandler+0x48>)
 800686c:	18c0      	adds	r0, r0, r3
 800686e:	f00b f85f 	bl	8011930 <HAL_DMA_IRQHandler>
			++dmaStreamCount[port-1];
		if (dmaStreamCount[port-1] >= dmaStreamTotal[port-1]) {
			StopStreamDMA(port);
		}
	}
}
 8006872:	bd70      	pop	{r4, r5, r6, pc}
		HAL_DMA_IRQHandler(&streamDMA[port-1]);
 8006874:	4b0b      	ldr	r3, [pc, #44]	; (80068a4 <DMA_IRQHandler+0x4c>)
		if (dmaStreamTotal[port-1])
 8006876:	00a4      	lsls	r4, r4, #2
		HAL_DMA_IRQHandler(&streamDMA[port-1]);
 8006878:	18c0      	adds	r0, r0, r3
 800687a:	f00b f859 	bl	8011930 <HAL_DMA_IRQHandler>
		if (dmaStreamTotal[port-1])
 800687e:	4b0a      	ldr	r3, [pc, #40]	; (80068a8 <DMA_IRQHandler+0x50>)
 8006880:	58e1      	ldr	r1, [r4, r3]
 8006882:	4b0a      	ldr	r3, [pc, #40]	; (80068ac <DMA_IRQHandler+0x54>)
 8006884:	2900      	cmp	r1, #0
 8006886:	d002      	beq.n	800688e <DMA_IRQHandler+0x36>
			++dmaStreamCount[port-1];
 8006888:	591a      	ldr	r2, [r3, r4]
 800688a:	3201      	adds	r2, #1
 800688c:	511a      	str	r2, [r3, r4]
		if (dmaStreamCount[port-1] >= dmaStreamTotal[port-1]) {
 800688e:	591b      	ldr	r3, [r3, r4]
 8006890:	4299      	cmp	r1, r3
 8006892:	d8ee      	bhi.n	8006872 <DMA_IRQHandler+0x1a>
			StopStreamDMA(port);
 8006894:	0028      	movs	r0, r5
 8006896:	f7ff ff63 	bl	8006760 <StopStreamDMA>
}
 800689a:	e7ea      	b.n	8006872 <DMA_IRQHandler+0x1a>
 800689c:	200010b2 	.word	0x200010b2
 80068a0:	20001940 	.word	0x20001940
 80068a4:	20001b38 	.word	0x20001b38
 80068a8:	20001418 	.word	0x20001418
 80068ac:	200013f0 	.word	0x200013f0

080068b0 <ResetUartORE>:
/* Reset UART ORE (overrun) flag in case other modules were already transmitting on startup
*/
void ResetUartORE(void)
{
#ifdef _Usart1
	__HAL_UART_CLEAR_OREFLAG(&huart1);
 80068b0:	4b08      	ldr	r3, [pc, #32]	; (80068d4 <ResetUartORE+0x24>)
 80068b2:	681a      	ldr	r2, [r3, #0]
 80068b4:	2308      	movs	r3, #8
 80068b6:	6213      	str	r3, [r2, #32]
#endif
#ifdef _Usart2
	__HAL_UART_CLEAR_OREFLAG(&huart2);
 80068b8:	4a07      	ldr	r2, [pc, #28]	; (80068d8 <ResetUartORE+0x28>)
 80068ba:	6812      	ldr	r2, [r2, #0]
 80068bc:	6213      	str	r3, [r2, #32]
#endif
#ifdef _Usart3
	__HAL_UART_CLEAR_OREFLAG(&huart3);
 80068be:	4a07      	ldr	r2, [pc, #28]	; (80068dc <ResetUartORE+0x2c>)
 80068c0:	6812      	ldr	r2, [r2, #0]
 80068c2:	6213      	str	r3, [r2, #32]
#endif
#ifdef _Usart4
	__HAL_UART_CLEAR_OREFLAG(&huart4);
 80068c4:	4a06      	ldr	r2, [pc, #24]	; (80068e0 <ResetUartORE+0x30>)
 80068c6:	6812      	ldr	r2, [r2, #0]
 80068c8:	6213      	str	r3, [r2, #32]
#endif
#ifdef _Usart5
	__HAL_UART_CLEAR_OREFLAG(&huart5);
 80068ca:	4a06      	ldr	r2, [pc, #24]	; (80068e4 <ResetUartORE+0x34>)
 80068cc:	6812      	ldr	r2, [r2, #0]
 80068ce:	6213      	str	r3, [r2, #32]
#endif
#ifdef _Usart6
	__HAL_UART_CLEAR_OREFLAG(&huart6);
#endif
}
 80068d0:	4770      	bx	lr
 80068d2:	46c0      	nop			; (mov r8, r8)
 80068d4:	20007424 	.word	0x20007424
 80068d8:	200077d0 	.word	0x200077d0
 80068dc:	200070dc 	.word	0x200070dc
 80068e0:	20007758 	.word	0x20007758
 80068e4:	200073b0 	.word	0x200073b0

080068e8 <EE_VerifyPageFullWriteVariable>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 80068e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80068ea:	000d      	movs	r5, r1
 80068ec:	9001      	str	r0, [sp, #4]
  HAL_StatusTypeDef FlashStatus = HAL_OK;
  uint16_t ValidPage = PAGEA;
  uint32_t Address = 0, PageEndAddress = 0;
	
	HAL_FLASH_Unlock();
 80068ee:	f00b fb5f 	bl	8011fb0 <HAL_FLASH_Unlock>
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 80068f2:	4b24      	ldr	r3, [pc, #144]	; (8006984 <EE_VerifyPageFullWriteVariable+0x9c>)
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 80068f4:	4a24      	ldr	r2, [pc, #144]	; (8006988 <EE_VerifyPageFullWriteVariable+0xa0>)
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 80068f6:	881b      	ldrh	r3, [r3, #0]
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 80068f8:	8812      	ldrh	r2, [r2, #0]
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 80068fa:	b29b      	uxth	r3, r3
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 80068fc:	b292      	uxth	r2, r2
      if (PageStatusB == VALID_PAGE)
 80068fe:	2a00      	cmp	r2, #0
 8006900:	d110      	bne.n	8006924 <EE_VerifyPageFullWriteVariable+0x3c>
          return PAGEA;         /* PageA valid */
 8006902:	4a22      	ldr	r2, [pc, #136]	; (800698c <EE_VerifyPageFullWriteVariable+0xa4>)
 8006904:	189b      	adds	r3, r3, r2
 8006906:	1e5a      	subs	r2, r3, #1
 8006908:	4193      	sbcs	r3, r2
 800690a:	005b      	lsls	r3, r3, #1
  {
    return  NO_VALID_PAGE;
  }

  /* Get the valid Page start Address */
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 800690c:	4a20      	ldr	r2, [pc, #128]	; (8006990 <EE_VerifyPageFullWriteVariable+0xa8>)
 800690e:	189c      	adds	r4, r3, r2

  /* Get the valid Page end Address - Each page is twice pages size */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((2 + ValidPage) * PAGE_SIZE));
 8006910:	4a20      	ldr	r2, [pc, #128]	; (8006994 <EE_VerifyPageFullWriteVariable+0xac>)
 8006912:	02db      	lsls	r3, r3, #11
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8006914:	02e4      	lsls	r4, r4, #11
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((2 + ValidPage) * PAGE_SIZE));
 8006916:	189b      	adds	r3, r3, r2

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
 8006918:	429c      	cmp	r4, r3
 800691a:	d30b      	bcc.n	8006934 <EE_VerifyPageFullWriteVariable+0x4c>
      /* Next address location */
      Address = Address + 4;
    }
  }
	
	HAL_FLASH_Lock();
 800691c:	f00b fb5a 	bl	8011fd4 <HAL_FLASH_Lock>

  /* Return PAGE_FULL in case the valid page is full */
  return PAGE_FULL;
 8006920:	2080      	movs	r0, #128	; 0x80
 8006922:	e018      	b.n	8006956 <EE_VerifyPageFullWriteVariable+0x6e>
    return  NO_VALID_PAGE;
 8006924:	20ab      	movs	r0, #171	; 0xab
      else if (PageStatusA == VALID_PAGE)
 8006926:	2b00      	cmp	r3, #0
 8006928:	d115      	bne.n	8006956 <EE_VerifyPageFullWriteVariable+0x6e>
        if (PageStatusB == RECEIVE_DATA)
 800692a:	491b      	ldr	r1, [pc, #108]	; (8006998 <EE_VerifyPageFullWriteVariable+0xb0>)
 800692c:	428a      	cmp	r2, r1
 800692e:	d1ed      	bne.n	800690c <EE_VerifyPageFullWriteVariable+0x24>
          return PAGEB;         /* PageB valid */
 8006930:	3302      	adds	r3, #2
 8006932:	e7eb      	b.n	800690c <EE_VerifyPageFullWriteVariable+0x24>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 8006934:	6822      	ldr	r2, [r4, #0]
 8006936:	3201      	adds	r2, #1
 8006938:	d121      	bne.n	800697e <EE_VerifyPageFullWriteVariable+0x96>
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, Address, Data);
 800693a:	2300      	movs	r3, #0
 800693c:	002a      	movs	r2, r5
 800693e:	0021      	movs	r1, r4
 8006940:	2001      	movs	r0, #1
 8006942:	f00b fb7b 	bl	801203c <HAL_FLASH_Program>
			FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006946:	4815      	ldr	r0, [pc, #84]	; (800699c <EE_VerifyPageFullWriteVariable+0xb4>)
 8006948:	f00b fb4e 	bl	8011fe8 <FLASH_WaitForLastOperation>
 800694c:	4e14      	ldr	r6, [pc, #80]	; (80069a0 <EE_VerifyPageFullWriteVariable+0xb8>)
 800694e:	1e03      	subs	r3, r0, #0
      if (FlashStatus != HAL_OK)
 8006950:	d002      	beq.n	8006958 <EE_VerifyPageFullWriteVariable+0x70>
      return pFlash.ErrorCode;
 8006952:	69f0      	ldr	r0, [r6, #28]
 8006954:	b280      	uxth	r0, r0
}
 8006956:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006958:	2701      	movs	r7, #1
 800695a:	4d12      	ldr	r5, [pc, #72]	; (80069a4 <EE_VerifyPageFullWriteVariable+0xbc>)
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, Address + 2, VirtAddress);
 800695c:	1ca1      	adds	r1, r4, #2
				CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 800695e:	692a      	ldr	r2, [r5, #16]
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, Address + 2, VirtAddress);
 8006960:	0038      	movs	r0, r7
				CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006962:	43ba      	bics	r2, r7
 8006964:	612a      	str	r2, [r5, #16]
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, Address + 2, VirtAddress);
 8006966:	9a01      	ldr	r2, [sp, #4]
 8006968:	f00b fb68 	bl	801203c <HAL_FLASH_Program>
			FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 800696c:	480b      	ldr	r0, [pc, #44]	; (800699c <EE_VerifyPageFullWriteVariable+0xb4>)
 800696e:	f00b fb3b 	bl	8011fe8 <FLASH_WaitForLastOperation>
      if (FlashStatus != HAL_OK)
 8006972:	2800      	cmp	r0, #0
 8006974:	d1ed      	bne.n	8006952 <EE_VerifyPageFullWriteVariable+0x6a>
				CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006976:	692b      	ldr	r3, [r5, #16]
 8006978:	43bb      	bics	r3, r7
 800697a:	612b      	str	r3, [r5, #16]
 800697c:	e7e9      	b.n	8006952 <EE_VerifyPageFullWriteVariable+0x6a>
      Address = Address + 4;
 800697e:	3404      	adds	r4, #4
 8006980:	e7ca      	b.n	8006918 <EE_VerifyPageFullWriteVariable+0x30>
 8006982:	46c0      	nop			; (mov r8, r8)
 8006984:	0801e000 	.word	0x0801e000
 8006988:	0801f000 	.word	0x0801f000
 800698c:	ffff1112 	.word	0xffff1112
 8006990:	0001003c 	.word	0x0001003c
 8006994:	0801effe 	.word	0x0801effe
 8006998:	0000eeee 	.word	0x0000eeee
 800699c:	0000c350 	.word	0x0000c350
 80069a0:	20007ab8 	.word	0x20007ab8
 80069a4:	40022000 	.word	0x40022000

080069a8 <EE_ReadVariable>:
{
 80069a8:	b510      	push	{r4, lr}
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 80069aa:	4b10      	ldr	r3, [pc, #64]	; (80069ec <EE_ReadVariable+0x44>)
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 80069ac:	4a10      	ldr	r2, [pc, #64]	; (80069f0 <EE_ReadVariable+0x48>)
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 80069ae:	881b      	ldrh	r3, [r3, #0]
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 80069b0:	8812      	ldrh	r2, [r2, #0]
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 80069b2:	b29b      	uxth	r3, r3
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 80069b4:	b292      	uxth	r2, r2
      if (PageStatusA == VALID_PAGE)
 80069b6:	2b00      	cmp	r3, #0
 80069b8:	d003      	beq.n	80069c2 <EE_ReadVariable+0x1a>
    return  NO_VALID_PAGE;
 80069ba:	23ab      	movs	r3, #171	; 0xab
      else if (PageStatusB == VALID_PAGE)
 80069bc:	2a00      	cmp	r2, #0
 80069be:	d110      	bne.n	80069e2 <EE_ReadVariable+0x3a>
        return PAGEB;           /* PageB valid */
 80069c0:	3ba9      	subs	r3, #169	; 0xa9
  Address = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((2 + ValidPage) * PAGE_SIZE));
 80069c2:	4c0c      	ldr	r4, [pc, #48]	; (80069f4 <EE_ReadVariable+0x4c>)
  PageStartAddress = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80069c4:	02da      	lsls	r2, r3, #11
  Address = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((2 + ValidPage) * PAGE_SIZE));
 80069c6:	1913      	adds	r3, r2, r4
  while (Address > (PageStartAddress + 2))
 80069c8:	4c0b      	ldr	r4, [pc, #44]	; (80069f8 <EE_ReadVariable+0x50>)
 80069ca:	1912      	adds	r2, r2, r4
 80069cc:	429a      	cmp	r2, r3
 80069ce:	d301      	bcc.n	80069d4 <EE_ReadVariable+0x2c>
  uint16_t AddressValue = 0x5555, ReadStatus = 1;
 80069d0:	2301      	movs	r3, #1
 80069d2:	e006      	b.n	80069e2 <EE_ReadVariable+0x3a>
    AddressValue = (*(__IO uint16_t*)Address);
 80069d4:	881c      	ldrh	r4, [r3, #0]
    if (AddressValue == VirtAddress)
 80069d6:	4284      	cmp	r4, r0
 80069d8:	d105      	bne.n	80069e6 <EE_ReadVariable+0x3e>
      *Data = (*(__IO uint16_t*)(Address - 2));
 80069da:	3b02      	subs	r3, #2
 80069dc:	881b      	ldrh	r3, [r3, #0]
 80069de:	800b      	strh	r3, [r1, #0]
      ReadStatus = 0;
 80069e0:	2300      	movs	r3, #0
}
 80069e2:	0018      	movs	r0, r3
 80069e4:	bd10      	pop	{r4, pc}
      Address = Address - 4;
 80069e6:	3b04      	subs	r3, #4
 80069e8:	e7f0      	b.n	80069cc <EE_ReadVariable+0x24>
 80069ea:	46c0      	nop			; (mov r8, r8)
 80069ec:	0801e000 	.word	0x0801e000
 80069f0:	0801f000 	.word	0x0801f000
 80069f4:	0801effe 	.word	0x0801effe
 80069f8:	0801e002 	.word	0x0801e002

080069fc <EE_WriteVariable>:
{
 80069fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80069fe:	000d      	movs	r5, r1
 8006a00:	b085      	sub	sp, #20
 8006a02:	9003      	str	r0, [sp, #12]
	HAL_FLASH_Unlock();
 8006a04:	f00b fad4 	bl	8011fb0 <HAL_FLASH_Unlock>
  Status = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8006a08:	0029      	movs	r1, r5
 8006a0a:	9803      	ldr	r0, [sp, #12]
 8006a0c:	f7ff ff6c 	bl	80068e8 <EE_VerifyPageFullWriteVariable>
 8006a10:	0004      	movs	r4, r0
  if (Status == PAGE_FULL)
 8006a12:	2880      	cmp	r0, #128	; 0x80
 8006a14:	d11b      	bne.n	8006a4e <EE_WriteVariable+0x52>
  HAL_StatusTypeDef FlashStatus = HAL_OK;
  uint32_t NewPageAddress = 0, OldPageAddress = 0;
  uint16_t ValidPage = PAGEA, VarIdx = 0;
  uint16_t EepromStatus = 0, ReadStatus = 0;
	
	HAL_FLASH_Unlock();
 8006a16:	f00b facb 	bl	8011fb0 <HAL_FLASH_Unlock>
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 8006a1a:	4a38      	ldr	r2, [pc, #224]	; (8006afc <EE_WriteVariable+0x100>)
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 8006a1c:	4b38      	ldr	r3, [pc, #224]	; (8006b00 <EE_WriteVariable+0x104>)
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 8006a1e:	8810      	ldrh	r0, [r2, #0]
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 8006a20:	8819      	ldrh	r1, [r3, #0]
 8006a22:	b289      	uxth	r1, r1
      if (PageStatusA == VALID_PAGE)
 8006a24:	2800      	cmp	r0, #0
 8006a26:	d017      	beq.n	8006a58 <EE_WriteVariable+0x5c>
    /* Old page address where variable will be taken from */
    OldPageAddress = PAGEA1_BASE_ADDRESS;
  }
  else
  {
    return NO_VALID_PAGE;       /* No valid Page */
 8006a28:	342b      	adds	r4, #43	; 0x2b
      else if (PageStatusB == VALID_PAGE)
 8006a2a:	2900      	cmp	r1, #0
 8006a2c:	d10f      	bne.n	8006a4e <EE_WriteVariable+0x52>
    OldPageAddress = PAGEB1_BASE_ADDRESS;
 8006a2e:	9302      	str	r3, [sp, #8]
    NewPageAddress = PAGEA1_BASE_ADDRESS;
 8006a30:	9201      	str	r2, [sp, #4]
  }

  /* Set the new Page status to RECEIVE_DATA status */
	HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, NewPageAddress, RECEIVE_DATA);
 8006a32:	4a34      	ldr	r2, [pc, #208]	; (8006b04 <EE_WriteVariable+0x108>)
 8006a34:	2300      	movs	r3, #0
 8006a36:	9901      	ldr	r1, [sp, #4]
 8006a38:	2001      	movs	r0, #1
 8006a3a:	f00b faff 	bl	801203c <HAL_FLASH_Program>
	/* Wait for last operation to be completed */
	FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006a3e:	4832      	ldr	r0, [pc, #200]	; (8006b08 <EE_WriteVariable+0x10c>)
 8006a40:	f00b fad2 	bl	8011fe8 <FLASH_WaitForLastOperation>
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
 8006a44:	2800      	cmp	r0, #0
 8006a46:	d00a      	beq.n	8006a5e <EE_WriteVariable+0x62>
	/* Wait for last operation to be completed */
	FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
  {
    return pFlash.ErrorCode;
 8006a48:	4b30      	ldr	r3, [pc, #192]	; (8006b0c <EE_WriteVariable+0x110>)
 8006a4a:	69dc      	ldr	r4, [r3, #28]
 8006a4c:	b2a4      	uxth	r4, r4
	HAL_FLASH_Lock();
 8006a4e:	f00b fac1 	bl	8011fd4 <HAL_FLASH_Lock>
}
 8006a52:	0020      	movs	r0, r4
 8006a54:	b005      	add	sp, #20
 8006a56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    OldPageAddress = PAGEA1_BASE_ADDRESS;
 8006a58:	9202      	str	r2, [sp, #8]
    NewPageAddress = PAGEB1_BASE_ADDRESS;
 8006a5a:	9301      	str	r3, [sp, #4]
 8006a5c:	e7e9      	b.n	8006a32 <EE_WriteVariable+0x36>
		CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006a5e:	2701      	movs	r7, #1
 8006a60:	4e2b      	ldr	r6, [pc, #172]	; (8006b10 <EE_WriteVariable+0x114>)
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8006a62:	0029      	movs	r1, r5
		CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006a64:	6933      	ldr	r3, [r6, #16]
 8006a66:	43bb      	bics	r3, r7
 8006a68:	6133      	str	r3, [r6, #16]
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8006a6a:	9803      	ldr	r0, [sp, #12]
 8006a6c:	f7ff ff3c 	bl	80068e8 <EE_VerifyPageFullWriteVariable>
 8006a70:	1e04      	subs	r4, r0, #0
  if (EepromStatus != HAL_OK)
 8006a72:	d1ec      	bne.n	8006a4e <EE_WriteVariable+0x52>
  for (VarIdx = 1; VarIdx <= NumOfEEPROMvar; VarIdx++)
 8006a74:	003d      	movs	r5, r7
    if (VarIdx != VirtAddress)  /* Check each variable except the one passed as parameter */
 8006a76:	9b03      	ldr	r3, [sp, #12]
 8006a78:	42ab      	cmp	r3, r5
 8006a7a:	d12f      	bne.n	8006adc <EE_WriteVariable+0xe0>
  for (VarIdx = 1; VarIdx <= NumOfEEPROMvar; VarIdx++)
 8006a7c:	3501      	adds	r5, #1
 8006a7e:	4b25      	ldr	r3, [pc, #148]	; (8006b14 <EE_WriteVariable+0x118>)
 8006a80:	b2ad      	uxth	r5, r5
 8006a82:	429d      	cmp	r5, r3
 8006a84:	d1f7      	bne.n	8006a76 <EE_WriteVariable+0x7a>
  FLASH_PageErase(OldPageAddress);
 8006a86:	9802      	ldr	r0, [sp, #8]
 8006a88:	f00b fb2c 	bl	80120e4 <FLASH_PageErase>
	FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006a8c:	481e      	ldr	r0, [pc, #120]	; (8006b08 <EE_WriteVariable+0x10c>)
 8006a8e:	f00b faab 	bl	8011fe8 <FLASH_WaitForLastOperation>
  if (FlashStatus != HAL_OK)
 8006a92:	2800      	cmp	r0, #0
 8006a94:	d1d8      	bne.n	8006a48 <EE_WriteVariable+0x4c>
		FLASH_PageErase(OldPageAddress + PAGE_SIZE);
 8006a96:	2280      	movs	r2, #128	; 0x80
 8006a98:	0112      	lsls	r2, r2, #4
 8006a9a:	4694      	mov	ip, r2
 8006a9c:	9b02      	ldr	r3, [sp, #8]
 8006a9e:	4463      	add	r3, ip
 8006aa0:	0018      	movs	r0, r3
 8006aa2:	f00b fb1f 	bl	80120e4 <FLASH_PageErase>
		FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006aa6:	4818      	ldr	r0, [pc, #96]	; (8006b08 <EE_WriteVariable+0x10c>)
 8006aa8:	f00b fa9e 	bl	8011fe8 <FLASH_WaitForLastOperation>
		 if (FlashStatus != HAL_OK)
 8006aac:	2800      	cmp	r0, #0
 8006aae:	d1cb      	bne.n	8006a48 <EE_WriteVariable+0x4c>
			CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006ab0:	2202      	movs	r2, #2
 8006ab2:	6933      	ldr	r3, [r6, #16]
	HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, NewPageAddress, VALID_PAGE);
 8006ab4:	2001      	movs	r0, #1
			CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006ab6:	4393      	bics	r3, r2
 8006ab8:	6133      	str	r3, [r6, #16]
	HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, NewPageAddress, VALID_PAGE);
 8006aba:	2200      	movs	r2, #0
 8006abc:	2300      	movs	r3, #0
 8006abe:	9901      	ldr	r1, [sp, #4]
 8006ac0:	f00b fabc 	bl	801203c <HAL_FLASH_Program>
	FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006ac4:	4810      	ldr	r0, [pc, #64]	; (8006b08 <EE_WriteVariable+0x10c>)
 8006ac6:	f00b fa8f 	bl	8011fe8 <FLASH_WaitForLastOperation>
  if (FlashStatus != HAL_OK)
 8006aca:	2800      	cmp	r0, #0
 8006acc:	d1bc      	bne.n	8006a48 <EE_WriteVariable+0x4c>
  }
	else
	{
		/* If the program operation is completed, disable the PG Bit */
		CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006ace:	2201      	movs	r2, #1
 8006ad0:	6933      	ldr	r3, [r6, #16]
 8006ad2:	4393      	bics	r3, r2
 8006ad4:	6133      	str	r3, [r6, #16]
	}
			
	HAL_FLASH_Lock();
 8006ad6:	f00b fa7d 	bl	8011fd4 <HAL_FLASH_Lock>
 8006ada:	e7b8      	b.n	8006a4e <EE_WriteVariable+0x52>
      ReadStatus = EE_ReadVariable(VarIdx, &DataVar);
 8006adc:	4f0e      	ldr	r7, [pc, #56]	; (8006b18 <EE_WriteVariable+0x11c>)
 8006ade:	0028      	movs	r0, r5
 8006ae0:	0039      	movs	r1, r7
 8006ae2:	f7ff ff61 	bl	80069a8 <EE_ReadVariable>
      if (ReadStatus != 0x1)
 8006ae6:	2801      	cmp	r0, #1
 8006ae8:	d0c8      	beq.n	8006a7c <EE_WriteVariable+0x80>
        EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, DataVar);
 8006aea:	8839      	ldrh	r1, [r7, #0]
 8006aec:	0028      	movs	r0, r5
 8006aee:	f7ff fefb 	bl	80068e8 <EE_VerifyPageFullWriteVariable>
        if (EepromStatus != HAL_OK)
 8006af2:	2800      	cmp	r0, #0
 8006af4:	d0c2      	beq.n	8006a7c <EE_WriteVariable+0x80>
 8006af6:	0004      	movs	r4, r0
 8006af8:	e7a9      	b.n	8006a4e <EE_WriteVariable+0x52>
 8006afa:	46c0      	nop			; (mov r8, r8)
 8006afc:	0801e000 	.word	0x0801e000
 8006b00:	0801f000 	.word	0x0801f000
 8006b04:	0000eeee 	.word	0x0000eeee
 8006b08:	0000c350 	.word	0x0000c350
 8006b0c:	20007ab8 	.word	0x20007ab8
 8006b10:	40022000 	.word	0x40022000
 8006b14:	00000401 	.word	0x00000401
 8006b18:	2000142c 	.word	0x2000142c

08006b1c <EE_Format>:
{
 8006b1c:	b570      	push	{r4, r5, r6, lr}
	HAL_FLASH_Unlock();
 8006b1e:	f00b fa47 	bl	8011fb0 <HAL_FLASH_Unlock>
	FLASH_PageErase(PAGEA1_BASE_ADDRESS);	
 8006b22:	481f      	ldr	r0, [pc, #124]	; (8006ba0 <EE_Format+0x84>)
 8006b24:	f00b fade 	bl	80120e4 <FLASH_PageErase>
	FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006b28:	481e      	ldr	r0, [pc, #120]	; (8006ba4 <EE_Format+0x88>)
 8006b2a:	f00b fa5d 	bl	8011fe8 <FLASH_WaitForLastOperation>
	if (FlashStatus != HAL_OK)
 8006b2e:	2800      	cmp	r0, #0
 8006b30:	d003      	beq.n	8006b3a <EE_Format+0x1e>
			return pFlash.ErrorCode;
 8006b32:	4b1d      	ldr	r3, [pc, #116]	; (8006ba8 <EE_Format+0x8c>)
 8006b34:	69d8      	ldr	r0, [r3, #28]
 8006b36:	b280      	uxth	r0, r0
}
 8006b38:	bd70      	pop	{r4, r5, r6, pc}
		FLASH_PageErase(PAGEA2_BASE_ADDRESS);
 8006b3a:	481c      	ldr	r0, [pc, #112]	; (8006bac <EE_Format+0x90>)
 8006b3c:	f00b fad2 	bl	80120e4 <FLASH_PageErase>
		FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006b40:	4818      	ldr	r0, [pc, #96]	; (8006ba4 <EE_Format+0x88>)
 8006b42:	f00b fa51 	bl	8011fe8 <FLASH_WaitForLastOperation>
		if(FlashStatus != HAL_OK)
 8006b46:	2800      	cmp	r0, #0
 8006b48:	d1f3      	bne.n	8006b32 <EE_Format+0x16>
			CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006b4a:	2202      	movs	r2, #2
 8006b4c:	4d18      	ldr	r5, [pc, #96]	; (8006bb0 <EE_Format+0x94>)
	HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEA1_BASE_ADDRESS, VALID_PAGE);
 8006b4e:	4914      	ldr	r1, [pc, #80]	; (8006ba0 <EE_Format+0x84>)
			CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006b50:	692b      	ldr	r3, [r5, #16]
	HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEA1_BASE_ADDRESS, VALID_PAGE);
 8006b52:	2001      	movs	r0, #1
			CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006b54:	4393      	bics	r3, r2
 8006b56:	612b      	str	r3, [r5, #16]
	HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEA1_BASE_ADDRESS, VALID_PAGE);
 8006b58:	2200      	movs	r2, #0
 8006b5a:	2300      	movs	r3, #0
 8006b5c:	f00b fa6e 	bl	801203c <HAL_FLASH_Program>
	FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006b60:	4810      	ldr	r0, [pc, #64]	; (8006ba4 <EE_Format+0x88>)
 8006b62:	f00b fa41 	bl	8011fe8 <FLASH_WaitForLastOperation>
	if (FlashStatus != HAL_OK)
 8006b66:	2800      	cmp	r0, #0
 8006b68:	d1e3      	bne.n	8006b32 <EE_Format+0x16>
		CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006b6a:	2601      	movs	r6, #1
 8006b6c:	692b      	ldr	r3, [r5, #16]
	FLASH_PageErase(PAGEB1_BASE_ADDRESS);
 8006b6e:	4811      	ldr	r0, [pc, #68]	; (8006bb4 <EE_Format+0x98>)
		CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006b70:	43b3      	bics	r3, r6
 8006b72:	612b      	str	r3, [r5, #16]
	FLASH_PageErase(PAGEB1_BASE_ADDRESS);
 8006b74:	f00b fab6 	bl	80120e4 <FLASH_PageErase>
	FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006b78:	480a      	ldr	r0, [pc, #40]	; (8006ba4 <EE_Format+0x88>)
 8006b7a:	f00b fa35 	bl	8011fe8 <FLASH_WaitForLastOperation>
	if (FlashStatus != HAL_OK)
 8006b7e:	2800      	cmp	r0, #0
 8006b80:	d1d7      	bne.n	8006b32 <EE_Format+0x16>
		FLASH_PageErase(PAGEB2_BASE_ADDRESS);
 8006b82:	480d      	ldr	r0, [pc, #52]	; (8006bb8 <EE_Format+0x9c>)
 8006b84:	f00b faae 	bl	80120e4 <FLASH_PageErase>
		FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006b88:	4806      	ldr	r0, [pc, #24]	; (8006ba4 <EE_Format+0x88>)
 8006b8a:	f00b fa2d 	bl	8011fe8 <FLASH_WaitForLastOperation>
 8006b8e:	1e04      	subs	r4, r0, #0
		if(FlashStatus != HAL_OK)
 8006b90:	d1cf      	bne.n	8006b32 <EE_Format+0x16>
			CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006b92:	692b      	ldr	r3, [r5, #16]
 8006b94:	43b3      	bics	r3, r6
 8006b96:	612b      	str	r3, [r5, #16]
	HAL_FLASH_Lock();
 8006b98:	f00b fa1c 	bl	8011fd4 <HAL_FLASH_Lock>
  return FlashStatus;
 8006b9c:	0020      	movs	r0, r4
 8006b9e:	e7cb      	b.n	8006b38 <EE_Format+0x1c>
 8006ba0:	0801e000 	.word	0x0801e000
 8006ba4:	0000c350 	.word	0x0000c350
 8006ba8:	20007ab8 	.word	0x20007ab8
 8006bac:	0801e800 	.word	0x0801e800
 8006bb0:	40022000 	.word	0x40022000
 8006bb4:	0801f000 	.word	0x0801f000
 8006bb8:	0801f800 	.word	0x0801f800

08006bbc <EE_Init>:
{
 8006bbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 8006bbe:	4d94      	ldr	r5, [pc, #592]	; (8006e10 <EE_Init+0x254>)
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 8006bc0:	4c94      	ldr	r4, [pc, #592]	; (8006e14 <EE_Init+0x258>)
	HAL_FLASH_Unlock();
 8006bc2:	f00b f9f5 	bl	8011fb0 <HAL_FLASH_Unlock>
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 8006bc6:	882a      	ldrh	r2, [r5, #0]
  switch (PageStatusA)
 8006bc8:	4893      	ldr	r0, [pc, #588]	; (8006e18 <EE_Init+0x25c>)
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 8006bca:	8823      	ldrh	r3, [r4, #0]
  PageStatusA = (*(__IO uint16_t*)PAGEA1_BASE_ADDRESS);
 8006bcc:	b292      	uxth	r2, r2
  PageStatusB = (*(__IO uint16_t*)PAGEB1_BASE_ADDRESS);
 8006bce:	b29b      	uxth	r3, r3
  switch (PageStatusA)
 8006bd0:	4282      	cmp	r2, r0
 8006bd2:	d057      	beq.n	8006c84 <EE_Init+0xc8>
 8006bd4:	4991      	ldr	r1, [pc, #580]	; (8006e1c <EE_Init+0x260>)
 8006bd6:	428a      	cmp	r2, r1
 8006bd8:	d00d      	beq.n	8006bf6 <EE_Init+0x3a>
 8006bda:	2a00      	cmp	r2, #0
 8006bdc:	d102      	bne.n	8006be4 <EE_Init+0x28>
      if (PageStatusB == VALID_PAGE) /* Invalid state -> format eeprom */
 8006bde:	2b00      	cmp	r3, #0
 8006be0:	d000      	beq.n	8006be4 <EE_Init+0x28>
 8006be2:	e0ca      	b.n	8006d7a <EE_Init+0x1be>
      FlashStatus = EE_Format();
 8006be4:	f7ff ff9a 	bl	8006b1c <EE_Format>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006be8:	488d      	ldr	r0, [pc, #564]	; (8006e20 <EE_Init+0x264>)
 8006bea:	f00b f9fd 	bl	8011fe8 <FLASH_WaitForLastOperation>
 8006bee:	b284      	uxth	r4, r0
				if(FlashStatus != HAL_OK)
 8006bf0:	2c00      	cmp	r4, #0
 8006bf2:	d043      	beq.n	8006c7c <EE_Init+0xc0>
 8006bf4:	e08b      	b.n	8006d0e <EE_Init+0x152>
      if (PageStatusB == VALID_PAGE) /* PageA erased, PageB valid */
 8006bf6:	2b00      	cmp	r3, #0
 8006bf8:	d119      	bne.n	8006c2e <EE_Init+0x72>
        FLASH_PageErase(PAGEA1_BASE_ADDRESS);			
 8006bfa:	0028      	movs	r0, r5
 8006bfc:	f00b fa72 	bl	80120e4 <FLASH_PageErase>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006c00:	4887      	ldr	r0, [pc, #540]	; (8006e20 <EE_Init+0x264>)
 8006c02:	f00b f9f1 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006c06:	2800      	cmp	r0, #0
 8006c08:	d003      	beq.n	8006c12 <EE_Init+0x56>
						return pFlash.ErrorCode;
 8006c0a:	4b86      	ldr	r3, [pc, #536]	; (8006e24 <EE_Init+0x268>)
 8006c0c:	69dc      	ldr	r4, [r3, #28]
 8006c0e:	b2a4      	uxth	r4, r4
 8006c10:	e07d      	b.n	8006d0e <EE_Init+0x152>
					FLASH_PageErase(PAGEA2_BASE_ADDRESS);
 8006c12:	4885      	ldr	r0, [pc, #532]	; (8006e28 <EE_Init+0x26c>)
					FLASH_PageErase(PAGEB2_BASE_ADDRESS);
 8006c14:	f00b fa66 	bl	80120e4 <FLASH_PageErase>
					FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006c18:	4881      	ldr	r0, [pc, #516]	; (8006e20 <EE_Init+0x264>)
 8006c1a:	f00b f9e5 	bl	8011fe8 <FLASH_WaitForLastOperation>
					if(FlashStatus != HAL_OK)
 8006c1e:	2800      	cmp	r0, #0
 8006c20:	d1f3      	bne.n	8006c0a <EE_Init+0x4e>
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006c22:	2102      	movs	r1, #2
 8006c24:	4a81      	ldr	r2, [pc, #516]	; (8006e2c <EE_Init+0x270>)
 8006c26:	6913      	ldr	r3, [r2, #16]
 8006c28:	438b      	bics	r3, r1
 8006c2a:	6113      	str	r3, [r2, #16]
 8006c2c:	e026      	b.n	8006c7c <EE_Init+0xc0>
      else if (PageStatusB == RECEIVE_DATA) /* PageA erased, PageB receive */
 8006c2e:	4283      	cmp	r3, r0
 8006c30:	d000      	beq.n	8006c34 <EE_Init+0x78>
 8006c32:	e099      	b.n	8006d68 <EE_Init+0x1ac>
        FLASH_PageErase(PAGEA1_BASE_ADDRESS);
 8006c34:	0028      	movs	r0, r5
 8006c36:	f00b fa55 	bl	80120e4 <FLASH_PageErase>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006c3a:	4879      	ldr	r0, [pc, #484]	; (8006e20 <EE_Init+0x264>)
 8006c3c:	f00b f9d4 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006c40:	2800      	cmp	r0, #0
 8006c42:	d1e2      	bne.n	8006c0a <EE_Init+0x4e>
					FLASH_PageErase(PAGEA2_BASE_ADDRESS);
 8006c44:	4878      	ldr	r0, [pc, #480]	; (8006e28 <EE_Init+0x26c>)
 8006c46:	f00b fa4d 	bl	80120e4 <FLASH_PageErase>
					FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006c4a:	4875      	ldr	r0, [pc, #468]	; (8006e20 <EE_Init+0x264>)
 8006c4c:	f00b f9cc 	bl	8011fe8 <FLASH_WaitForLastOperation>
					if(FlashStatus != HAL_OK)
 8006c50:	2800      	cmp	r0, #0
 8006c52:	d1da      	bne.n	8006c0a <EE_Init+0x4e>
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006c54:	2202      	movs	r2, #2
 8006c56:	4d75      	ldr	r5, [pc, #468]	; (8006e2c <EE_Init+0x270>)
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEB1_BASE_ADDRESS, VALID_PAGE);
 8006c58:	0021      	movs	r1, r4
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006c5a:	692b      	ldr	r3, [r5, #16]
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEB1_BASE_ADDRESS, VALID_PAGE);
 8006c5c:	2001      	movs	r0, #1
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006c5e:	4393      	bics	r3, r2
 8006c60:	612b      	str	r3, [r5, #16]
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEB1_BASE_ADDRESS, VALID_PAGE);
 8006c62:	2200      	movs	r2, #0
 8006c64:	2300      	movs	r3, #0
 8006c66:	f00b f9e9 	bl	801203c <HAL_FLASH_Program>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006c6a:	486d      	ldr	r0, [pc, #436]	; (8006e20 <EE_Init+0x264>)
 8006c6c:	f00b f9bc 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006c70:	2800      	cmp	r0, #0
 8006c72:	d1ca      	bne.n	8006c0a <EE_Init+0x4e>
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006c74:	2201      	movs	r2, #1
 8006c76:	692b      	ldr	r3, [r5, #16]
 8006c78:	4393      	bics	r3, r2
 8006c7a:	612b      	str	r3, [r5, #16]
	HAL_FLASH_Lock();
 8006c7c:	f00b f9aa 	bl	8011fd4 <HAL_FLASH_Lock>
  return HAL_OK;
 8006c80:	2400      	movs	r4, #0
 8006c82:	e044      	b.n	8006d0e <EE_Init+0x152>
      if (PageStatusB == VALID_PAGE) /* PageA receive, PageB valid */
 8006c84:	2b00      	cmp	r3, #0
 8006c86:	d144      	bne.n	8006d12 <EE_Init+0x156>
  int16_t x = -1;
 8006c88:	2601      	movs	r6, #1
 8006c8a:	2501      	movs	r5, #1
 8006c8c:	4276      	negs	r6, r6
          if (( *(__IO uint16_t*)(PAGEA1_BASE_ADDRESS + 6)) == VarIdx)
 8006c8e:	4b68      	ldr	r3, [pc, #416]	; (8006e30 <EE_Init+0x274>)
 8006c90:	b2ac      	uxth	r4, r5
 8006c92:	881b      	ldrh	r3, [r3, #0]
 8006c94:	42a3      	cmp	r3, r4
 8006c96:	d100      	bne.n	8006c9a <EE_Init+0xde>
            x = VarIdx;
 8006c98:	b22e      	sxth	r6, r5
          if (VarIdx != x)
 8006c9a:	42b5      	cmp	r5, r6
 8006c9c:	d126      	bne.n	8006cec <EE_Init+0x130>
        for (VarIdx = 1; VarIdx <= NumOfEEPROMvar; VarIdx++)
 8006c9e:	4b65      	ldr	r3, [pc, #404]	; (8006e34 <EE_Init+0x278>)
 8006ca0:	3501      	adds	r5, #1
 8006ca2:	429d      	cmp	r5, r3
 8006ca4:	d1f3      	bne.n	8006c8e <EE_Init+0xd2>
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEA1_BASE_ADDRESS, VALID_PAGE);
 8006ca6:	2200      	movs	r2, #0
 8006ca8:	2300      	movs	r3, #0
 8006caa:	4959      	ldr	r1, [pc, #356]	; (8006e10 <EE_Init+0x254>)
 8006cac:	2001      	movs	r0, #1
 8006cae:	f00b f9c5 	bl	801203c <HAL_FLASH_Program>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006cb2:	485b      	ldr	r0, [pc, #364]	; (8006e20 <EE_Init+0x264>)
 8006cb4:	f00b f998 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006cb8:	2800      	cmp	r0, #0
 8006cba:	d1a6      	bne.n	8006c0a <EE_Init+0x4e>
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006cbc:	2201      	movs	r2, #1
 8006cbe:	4c5b      	ldr	r4, [pc, #364]	; (8006e2c <EE_Init+0x270>)
        FLASH_PageErase(PAGEB1_BASE_ADDRESS);
 8006cc0:	4854      	ldr	r0, [pc, #336]	; (8006e14 <EE_Init+0x258>)
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006cc2:	6923      	ldr	r3, [r4, #16]
 8006cc4:	4393      	bics	r3, r2
 8006cc6:	6123      	str	r3, [r4, #16]
        FLASH_PageErase(PAGEB1_BASE_ADDRESS);
 8006cc8:	f00b fa0c 	bl	80120e4 <FLASH_PageErase>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006ccc:	4854      	ldr	r0, [pc, #336]	; (8006e20 <EE_Init+0x264>)
 8006cce:	f00b f98b 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006cd2:	2800      	cmp	r0, #0
 8006cd4:	d199      	bne.n	8006c0a <EE_Init+0x4e>
					FLASH_PageErase(PAGEB2_BASE_ADDRESS);
 8006cd6:	4858      	ldr	r0, [pc, #352]	; (8006e38 <EE_Init+0x27c>)
					FLASH_PageErase(PAGEA2_BASE_ADDRESS);
 8006cd8:	f00b fa04 	bl	80120e4 <FLASH_PageErase>
					FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006cdc:	4850      	ldr	r0, [pc, #320]	; (8006e20 <EE_Init+0x264>)
 8006cde:	f00b f983 	bl	8011fe8 <FLASH_WaitForLastOperation>
					if(FlashStatus != HAL_OK)
 8006ce2:	2800      	cmp	r0, #0
 8006ce4:	d191      	bne.n	8006c0a <EE_Init+0x4e>
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006ce6:	6923      	ldr	r3, [r4, #16]
 8006ce8:	2202      	movs	r2, #2
 8006cea:	e03a      	b.n	8006d62 <EE_Init+0x1a6>
            ReadStatus = EE_ReadVariable(VarIdx, &DataVar);
 8006cec:	4f53      	ldr	r7, [pc, #332]	; (8006e3c <EE_Init+0x280>)
 8006cee:	0020      	movs	r0, r4
 8006cf0:	0039      	movs	r1, r7
 8006cf2:	f7ff fe59 	bl	80069a8 <EE_ReadVariable>
            if (ReadStatus != 0x1)
 8006cf6:	2801      	cmp	r0, #1
 8006cf8:	d0d1      	beq.n	8006c9e <EE_Init+0xe2>
              EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, DataVar);
 8006cfa:	0020      	movs	r0, r4
 8006cfc:	8839      	ldrh	r1, [r7, #0]
 8006cfe:	f7ff fdf3 	bl	80068e8 <EE_VerifyPageFullWriteVariable>
 8006d02:	0004      	movs	r4, r0
							FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006d04:	4846      	ldr	r0, [pc, #280]	; (8006e20 <EE_Init+0x264>)
 8006d06:	f00b f96f 	bl	8011fe8 <FLASH_WaitForLastOperation>
							if(FlashStatus != HAL_OK)
 8006d0a:	2800      	cmp	r0, #0
 8006d0c:	d0c7      	beq.n	8006c9e <EE_Init+0xe2>
}
 8006d0e:	0020      	movs	r0, r4
 8006d10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      else if (PageStatusB == ERASED) /* PageA receive, PageB erased */
 8006d12:	4a42      	ldr	r2, [pc, #264]	; (8006e1c <EE_Init+0x260>)
 8006d14:	4293      	cmp	r3, r2
 8006d16:	d127      	bne.n	8006d68 <EE_Init+0x1ac>
        FLASH_PageErase(PAGEB1_BASE_ADDRESS);
 8006d18:	0020      	movs	r0, r4
 8006d1a:	f00b f9e3 	bl	80120e4 <FLASH_PageErase>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006d1e:	4840      	ldr	r0, [pc, #256]	; (8006e20 <EE_Init+0x264>)
 8006d20:	f00b f962 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006d24:	2800      	cmp	r0, #0
 8006d26:	d000      	beq.n	8006d2a <EE_Init+0x16e>
 8006d28:	e76f      	b.n	8006c0a <EE_Init+0x4e>
					FLASH_PageErase(PAGEB2_BASE_ADDRESS);
 8006d2a:	4843      	ldr	r0, [pc, #268]	; (8006e38 <EE_Init+0x27c>)
 8006d2c:	f00b f9da 	bl	80120e4 <FLASH_PageErase>
					FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006d30:	483b      	ldr	r0, [pc, #236]	; (8006e20 <EE_Init+0x264>)
 8006d32:	f00b f959 	bl	8011fe8 <FLASH_WaitForLastOperation>
					if(FlashStatus != HAL_OK)
 8006d36:	2800      	cmp	r0, #0
 8006d38:	d000      	beq.n	8006d3c <EE_Init+0x180>
 8006d3a:	e766      	b.n	8006c0a <EE_Init+0x4e>
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006d3c:	2202      	movs	r2, #2
 8006d3e:	4c3b      	ldr	r4, [pc, #236]	; (8006e2c <EE_Init+0x270>)
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEA1_BASE_ADDRESS, VALID_PAGE);
 8006d40:	0029      	movs	r1, r5
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006d42:	6923      	ldr	r3, [r4, #16]
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEA1_BASE_ADDRESS, VALID_PAGE);
 8006d44:	2001      	movs	r0, #1
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006d46:	4393      	bics	r3, r2
 8006d48:	6123      	str	r3, [r4, #16]
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEA1_BASE_ADDRESS, VALID_PAGE);
 8006d4a:	2200      	movs	r2, #0
 8006d4c:	2300      	movs	r3, #0
 8006d4e:	f00b f975 	bl	801203c <HAL_FLASH_Program>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006d52:	4833      	ldr	r0, [pc, #204]	; (8006e20 <EE_Init+0x264>)
 8006d54:	f00b f948 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006d58:	2800      	cmp	r0, #0
 8006d5a:	d000      	beq.n	8006d5e <EE_Init+0x1a2>
 8006d5c:	e755      	b.n	8006c0a <EE_Init+0x4e>
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006d5e:	2201      	movs	r2, #1
 8006d60:	6923      	ldr	r3, [r4, #16]
						CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8006d62:	4393      	bics	r3, r2
 8006d64:	6123      	str	r3, [r4, #16]
 8006d66:	e789      	b.n	8006c7c <EE_Init+0xc0>
        FlashStatus = EE_Format();
 8006d68:	f7ff fed8 	bl	8006b1c <EE_Format>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006d6c:	482c      	ldr	r0, [pc, #176]	; (8006e20 <EE_Init+0x264>)
 8006d6e:	f00b f93b 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006d72:	2800      	cmp	r0, #0
 8006d74:	d100      	bne.n	8006d78 <EE_Init+0x1bc>
 8006d76:	e781      	b.n	8006c7c <EE_Init+0xc0>
 8006d78:	e747      	b.n	8006c0a <EE_Init+0x4e>
      else if (PageStatusB == ERASED) /* PageA valid, PageB erased */
 8006d7a:	428b      	cmp	r3, r1
 8006d7c:	d10a      	bne.n	8006d94 <EE_Init+0x1d8>
        FLASH_PageErase(PAGEB1_BASE_ADDRESS);
 8006d7e:	0020      	movs	r0, r4
 8006d80:	f00b f9b0 	bl	80120e4 <FLASH_PageErase>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006d84:	4826      	ldr	r0, [pc, #152]	; (8006e20 <EE_Init+0x264>)
 8006d86:	f00b f92f 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006d8a:	2800      	cmp	r0, #0
 8006d8c:	d000      	beq.n	8006d90 <EE_Init+0x1d4>
 8006d8e:	e73c      	b.n	8006c0a <EE_Init+0x4e>
					FLASH_PageErase(PAGEB2_BASE_ADDRESS);
 8006d90:	4829      	ldr	r0, [pc, #164]	; (8006e38 <EE_Init+0x27c>)
 8006d92:	e73f      	b.n	8006c14 <EE_Init+0x58>
  int16_t x = -1;
 8006d94:	2601      	movs	r6, #1
 8006d96:	2501      	movs	r5, #1
 8006d98:	4276      	negs	r6, r6
          if ((*(__IO uint16_t*)(PAGEB1_BASE_ADDRESS + 6)) == VarIdx)
 8006d9a:	4b29      	ldr	r3, [pc, #164]	; (8006e40 <EE_Init+0x284>)
 8006d9c:	b2ac      	uxth	r4, r5
 8006d9e:	881b      	ldrh	r3, [r3, #0]
 8006da0:	42a3      	cmp	r3, r4
 8006da2:	d100      	bne.n	8006da6 <EE_Init+0x1ea>
            x = VarIdx;
 8006da4:	b22e      	sxth	r6, r5
          if (VarIdx != x)
 8006da6:	42b5      	cmp	r5, r6
 8006da8:	d11f      	bne.n	8006dea <EE_Init+0x22e>
        for (VarIdx = 1; VarIdx <= NumOfEEPROMvar; VarIdx++)
 8006daa:	4b22      	ldr	r3, [pc, #136]	; (8006e34 <EE_Init+0x278>)
 8006dac:	3501      	adds	r5, #1
 8006dae:	429d      	cmp	r5, r3
 8006db0:	d1f3      	bne.n	8006d9a <EE_Init+0x1de>
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, PAGEB1_BASE_ADDRESS, VALID_PAGE);
 8006db2:	2200      	movs	r2, #0
 8006db4:	2300      	movs	r3, #0
 8006db6:	4917      	ldr	r1, [pc, #92]	; (8006e14 <EE_Init+0x258>)
 8006db8:	2001      	movs	r0, #1
 8006dba:	f00b f93f 	bl	801203c <HAL_FLASH_Program>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006dbe:	4818      	ldr	r0, [pc, #96]	; (8006e20 <EE_Init+0x264>)
 8006dc0:	f00b f912 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006dc4:	2800      	cmp	r0, #0
 8006dc6:	d000      	beq.n	8006dca <EE_Init+0x20e>
 8006dc8:	e71f      	b.n	8006c0a <EE_Init+0x4e>
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006dca:	2201      	movs	r2, #1
 8006dcc:	4c17      	ldr	r4, [pc, #92]	; (8006e2c <EE_Init+0x270>)
        FLASH_PageErase(PAGEA1_BASE_ADDRESS);
 8006dce:	4810      	ldr	r0, [pc, #64]	; (8006e10 <EE_Init+0x254>)
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8006dd0:	6923      	ldr	r3, [r4, #16]
 8006dd2:	4393      	bics	r3, r2
 8006dd4:	6123      	str	r3, [r4, #16]
        FLASH_PageErase(PAGEA1_BASE_ADDRESS);
 8006dd6:	f00b f985 	bl	80120e4 <FLASH_PageErase>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006dda:	4811      	ldr	r0, [pc, #68]	; (8006e20 <EE_Init+0x264>)
 8006ddc:	f00b f904 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if(FlashStatus != HAL_OK)
 8006de0:	2800      	cmp	r0, #0
 8006de2:	d000      	beq.n	8006de6 <EE_Init+0x22a>
 8006de4:	e711      	b.n	8006c0a <EE_Init+0x4e>
					FLASH_PageErase(PAGEA2_BASE_ADDRESS);
 8006de6:	4810      	ldr	r0, [pc, #64]	; (8006e28 <EE_Init+0x26c>)
 8006de8:	e776      	b.n	8006cd8 <EE_Init+0x11c>
            ReadStatus = EE_ReadVariable(VarIdx, &DataVar);
 8006dea:	4f14      	ldr	r7, [pc, #80]	; (8006e3c <EE_Init+0x280>)
 8006dec:	0020      	movs	r0, r4
 8006dee:	0039      	movs	r1, r7
 8006df0:	f7ff fdda 	bl	80069a8 <EE_ReadVariable>
            if (ReadStatus != 0x1)
 8006df4:	2801      	cmp	r0, #1
 8006df6:	d0d8      	beq.n	8006daa <EE_Init+0x1ee>
              EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, DataVar);
 8006df8:	0020      	movs	r0, r4
 8006dfa:	8839      	ldrh	r1, [r7, #0]
 8006dfc:	f7ff fd74 	bl	80068e8 <EE_VerifyPageFullWriteVariable>
 8006e00:	0004      	movs	r4, r0
							FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8006e02:	4807      	ldr	r0, [pc, #28]	; (8006e20 <EE_Init+0x264>)
 8006e04:	f00b f8f0 	bl	8011fe8 <FLASH_WaitForLastOperation>
							if(FlashStatus != HAL_OK)
 8006e08:	2800      	cmp	r0, #0
 8006e0a:	d0ce      	beq.n	8006daa <EE_Init+0x1ee>
 8006e0c:	e77f      	b.n	8006d0e <EE_Init+0x152>
 8006e0e:	46c0      	nop			; (mov r8, r8)
 8006e10:	0801e000 	.word	0x0801e000
 8006e14:	0801f000 	.word	0x0801f000
 8006e18:	0000eeee 	.word	0x0000eeee
 8006e1c:	0000ffff 	.word	0x0000ffff
 8006e20:	0000c350 	.word	0x0000c350
 8006e24:	20007ab8 	.word	0x20007ab8
 8006e28:	0801e800 	.word	0x0801e800
 8006e2c:	40022000 	.word	0x40022000
 8006e30:	0801e006 	.word	0x0801e006
 8006e34:	00000401 	.word	0x00000401
 8006e38:	0801f800 	.word	0x0801f800
 8006e3c:	2000142c 	.word	0x2000142c
 8006e40:	0801f006 	.word	0x0801f006

08006e44 <StartDefaultTask>:

/*-----------------------------------------------------------*/

/* StartDefaultTask function */
void StartDefaultTask(void * argument)
{
 8006e44:	b570      	push	{r4, r5, r6, lr}
				RTOS_IND_blink(200);
				indMode = IND_OFF;
				break;
			
			case IND_TOPOLOGY :
				RTOS_IND_blink(100);
 8006e46:	2480      	movs	r4, #128	; 0x80
 8006e48:	01e4      	lsls	r4, r4, #7
		switch (indMode)
 8006e4a:	4d18      	ldr	r5, [pc, #96]	; (8006eac <StartDefaultTask+0x68>)
 8006e4c:	782a      	ldrb	r2, [r5, #0]
 8006e4e:	2a02      	cmp	r2, #2
 8006e50:	d01e      	beq.n	8006e90 <StartDefaultTask+0x4c>
 8006e52:	2a03      	cmp	r2, #3
 8006e54:	d023      	beq.n	8006e9e <StartDefaultTask+0x5a>
 8006e56:	2a01      	cmp	r2, #1
 8006e58:	d10d      	bne.n	8006e76 <StartDefaultTask+0x32>
				RTOS_IND_blink(200);
 8006e5a:	4815      	ldr	r0, [pc, #84]	; (8006eb0 <StartDefaultTask+0x6c>)
 8006e5c:	0021      	movs	r1, r4
 8006e5e:	f00b fa5f 	bl	8012320 <HAL_GPIO_WritePin>
 8006e62:	20c8      	movs	r0, #200	; 0xc8
				indMode = IND_OFF;
				break;
			
			case IND_SHORT_BLINK :
				RTOS_IND_blink(30);
 8006e64:	f008 fc7d 	bl	800f762 <osDelay>
 8006e68:	2200      	movs	r2, #0
 8006e6a:	0021      	movs	r1, r4
 8006e6c:	4810      	ldr	r0, [pc, #64]	; (8006eb0 <StartDefaultTask+0x6c>)
 8006e6e:	f00b fa57 	bl	8012320 <HAL_GPIO_WritePin>
				indMode = IND_OFF;
 8006e72:	2300      	movs	r3, #0
 8006e74:	702b      	strb	r3, [r5, #0]
			default:
				break;
		}
		
		/* Read button state */
		CheckAttachedButtons();
 8006e76:	f000 f97f 	bl	8007178 <CheckAttachedButtons>
		
		/* Execute activated Command Snippets */
		ExecuteSnippet();
 8006e7a:	f7fd ff27 	bl	8004ccc <ExecuteSnippet>
		
		/* Reset button state if no delay is needed by this module */
		if(needToDelayButtonStateReset != true)	delayButtonStateReset = false;
 8006e7e:	4b0d      	ldr	r3, [pc, #52]	; (8006eb4 <StartDefaultTask+0x70>)
 8006e80:	781b      	ldrb	r3, [r3, #0]
 8006e82:	2b00      	cmp	r3, #0
 8006e84:	d101      	bne.n	8006e8a <StartDefaultTask+0x46>
 8006e86:	4a0c      	ldr	r2, [pc, #48]	; (8006eb8 <StartDefaultTask+0x74>)
 8006e88:	7013      	strb	r3, [r2, #0]
				
		taskYIELD();
 8006e8a:	f00a f9e3 	bl	8011254 <vPortYield>
		switch (indMode)
 8006e8e:	e7dc      	b.n	8006e4a <StartDefaultTask+0x6>
				RTOS_IND_blink(100);
 8006e90:	4807      	ldr	r0, [pc, #28]	; (8006eb0 <StartDefaultTask+0x6c>)
 8006e92:	2201      	movs	r2, #1
 8006e94:	0021      	movs	r1, r4
 8006e96:	f00b fa43 	bl	8012320 <HAL_GPIO_WritePin>
 8006e9a:	2064      	movs	r0, #100	; 0x64
 8006e9c:	e7e2      	b.n	8006e64 <StartDefaultTask+0x20>
				RTOS_IND_blink(30);
 8006e9e:	4804      	ldr	r0, [pc, #16]	; (8006eb0 <StartDefaultTask+0x6c>)
 8006ea0:	2201      	movs	r2, #1
 8006ea2:	0021      	movs	r1, r4
 8006ea4:	f00b fa3c 	bl	8012320 <HAL_GPIO_WritePin>
 8006ea8:	201e      	movs	r0, #30
 8006eaa:	e7db      	b.n	8006e64 <StartDefaultTask+0x20>
 8006eac:	20000ec6 	.word	0x20000ec6
 8006eb0:	48000400 	.word	0x48000400
 8006eb4:	20001496 	.word	0x20001496
 8006eb8:	20001495 	.word	0x20001495

08006ebc <MX_FREERTOS_Init>:
{
 8006ebc:	b5f0      	push	{r4, r5, r6, r7, lr}
  xTaskCreate(StartDefaultTask, (const char *) "DefaultTask", (configMINIMAL_STACK_SIZE), NULL, osPriorityNormal-osPriorityIdle, &defaultTaskHandle);
 8006ebe:	25a0      	movs	r5, #160	; 0xa0
 8006ec0:	2400      	movs	r4, #0
 8006ec2:	2703      	movs	r7, #3
  xTaskCreate(PxMessagingTask, (const char *) "P1MsgTask", configMINIMAL_STACK_SIZE, (void *) P1, osPriorityAboveNormal-osPriorityIdle, &P1MsgTaskHandle);
 8006ec4:	2604      	movs	r6, #4
  xTaskCreate(StartDefaultTask, (const char *) "DefaultTask", (configMINIMAL_STACK_SIZE), NULL, osPriorityNormal-osPriorityIdle, &defaultTaskHandle);
 8006ec6:	4b53      	ldr	r3, [pc, #332]	; (8007014 <MX_FREERTOS_Init+0x158>)
{
 8006ec8:	b08f      	sub	sp, #60	; 0x3c
  xTaskCreate(StartDefaultTask, (const char *) "DefaultTask", (configMINIMAL_STACK_SIZE), NULL, osPriorityNormal-osPriorityIdle, &defaultTaskHandle);
 8006eca:	006d      	lsls	r5, r5, #1
 8006ecc:	9301      	str	r3, [sp, #4]
 8006ece:	002a      	movs	r2, r5
 8006ed0:	0023      	movs	r3, r4
 8006ed2:	9403      	str	r4, [sp, #12]
 8006ed4:	9402      	str	r4, [sp, #8]
 8006ed6:	9700      	str	r7, [sp, #0]
 8006ed8:	494f      	ldr	r1, [pc, #316]	; (8007018 <MX_FREERTOS_Init+0x15c>)
 8006eda:	4850      	ldr	r0, [pc, #320]	; (800701c <MX_FREERTOS_Init+0x160>)
 8006edc:	f009 fab7 	bl	801044e <xTaskGenericCreate>
	xTaskCreate(BackEndTask, (const char *) "BackEndTask", (configMINIMAL_STACK_SIZE), NULL, osPriorityNormal-osPriorityIdle, &BackEndTaskHandle);
 8006ee0:	4b4f      	ldr	r3, [pc, #316]	; (8007020 <MX_FREERTOS_Init+0x164>)
 8006ee2:	002a      	movs	r2, r5
 8006ee4:	9301      	str	r3, [sp, #4]
 8006ee6:	9403      	str	r4, [sp, #12]
 8006ee8:	0023      	movs	r3, r4
 8006eea:	9402      	str	r4, [sp, #8]
 8006eec:	9700      	str	r7, [sp, #0]
 8006eee:	494d      	ldr	r1, [pc, #308]	; (8007024 <MX_FREERTOS_Init+0x168>)
 8006ef0:	484d      	ldr	r0, [pc, #308]	; (8007028 <MX_FREERTOS_Init+0x16c>)
 8006ef2:	f009 faac 	bl	801044e <xTaskGenericCreate>
	xTaskCreate(UserTask, (const char *) "UserTask", (configMINIMAL_STACK_SIZE), NULL, osPriorityNormal-osPriorityIdle, &UserTaskHandle);
 8006ef6:	4b4d      	ldr	r3, [pc, #308]	; (800702c <MX_FREERTOS_Init+0x170>)
 8006ef8:	002a      	movs	r2, r5
 8006efa:	9301      	str	r3, [sp, #4]
 8006efc:	494c      	ldr	r1, [pc, #304]	; (8007030 <MX_FREERTOS_Init+0x174>)
 8006efe:	0023      	movs	r3, r4
 8006f00:	9403      	str	r4, [sp, #12]
 8006f02:	9402      	str	r4, [sp, #8]
 8006f04:	9700      	str	r7, [sp, #0]
 8006f06:	484b      	ldr	r0, [pc, #300]	; (8007034 <MX_FREERTOS_Init+0x178>)
 8006f08:	f009 faa1 	bl	801044e <xTaskGenericCreate>
	vRegisterCLICommands();
 8006f0c:	f7ff fb7e 	bl	800660c <vRegisterCLICommands>
	xTaskCreate(prvCLITask, "CliTask",	(configMINIMAL_STACK_SIZE),	NULL,	osPriorityNormal-osPriorityIdle, &xCommandConsoleTaskHandle);
 8006f10:	4b49      	ldr	r3, [pc, #292]	; (8007038 <MX_FREERTOS_Init+0x17c>)
 8006f12:	002a      	movs	r2, r5
 8006f14:	9301      	str	r3, [sp, #4]
 8006f16:	9403      	str	r4, [sp, #12]
 8006f18:	0023      	movs	r3, r4
 8006f1a:	9402      	str	r4, [sp, #8]
 8006f1c:	9700      	str	r7, [sp, #0]
 8006f1e:	4947      	ldr	r1, [pc, #284]	; (800703c <MX_FREERTOS_Init+0x180>)
 8006f20:	4847      	ldr	r0, [pc, #284]	; (8007040 <MX_FREERTOS_Init+0x184>)
 8006f22:	f009 fa94 	bl	801044e <xTaskGenericCreate>
  xTaskCreate(PxMessagingTask, (const char *) "P1MsgTask", configMINIMAL_STACK_SIZE, (void *) P1, osPriorityAboveNormal-osPriorityIdle, &P1MsgTaskHandle);
 8006f26:	4b47      	ldr	r3, [pc, #284]	; (8007044 <MX_FREERTOS_Init+0x188>)
 8006f28:	9600      	str	r6, [sp, #0]
 8006f2a:	9301      	str	r3, [sp, #4]
 8006f2c:	002a      	movs	r2, r5
 8006f2e:	9403      	str	r4, [sp, #12]
 8006f30:	9402      	str	r4, [sp, #8]
 8006f32:	2301      	movs	r3, #1
 8006f34:	4944      	ldr	r1, [pc, #272]	; (8007048 <MX_FREERTOS_Init+0x18c>)
 8006f36:	4845      	ldr	r0, [pc, #276]	; (800704c <MX_FREERTOS_Init+0x190>)
 8006f38:	f009 fa89 	bl	801044e <xTaskGenericCreate>
	xTaskCreate(PxMessagingTask, (const char *) "P2MsgTask", configMINIMAL_STACK_SIZE, (void *) P2, osPriorityAboveNormal-osPriorityIdle, &P2MsgTaskHandle);
 8006f3c:	4b44      	ldr	r3, [pc, #272]	; (8007050 <MX_FREERTOS_Init+0x194>)
 8006f3e:	9600      	str	r6, [sp, #0]
 8006f40:	9301      	str	r3, [sp, #4]
 8006f42:	002a      	movs	r2, r5
 8006f44:	9403      	str	r4, [sp, #12]
 8006f46:	9402      	str	r4, [sp, #8]
 8006f48:	2302      	movs	r3, #2
 8006f4a:	4942      	ldr	r1, [pc, #264]	; (8007054 <MX_FREERTOS_Init+0x198>)
 8006f4c:	483f      	ldr	r0, [pc, #252]	; (800704c <MX_FREERTOS_Init+0x190>)
 8006f4e:	f009 fa7e 	bl	801044e <xTaskGenericCreate>
	xTaskCreate(PxMessagingTask, (const char *) "P3MsgTask", configMINIMAL_STACK_SIZE, (void *) P3, osPriorityAboveNormal-osPriorityIdle, &P3MsgTaskHandle);
 8006f52:	4b41      	ldr	r3, [pc, #260]	; (8007058 <MX_FREERTOS_Init+0x19c>)
 8006f54:	9600      	str	r6, [sp, #0]
 8006f56:	9301      	str	r3, [sp, #4]
 8006f58:	002a      	movs	r2, r5
 8006f5a:	003b      	movs	r3, r7
 8006f5c:	9403      	str	r4, [sp, #12]
 8006f5e:	9402      	str	r4, [sp, #8]
 8006f60:	493e      	ldr	r1, [pc, #248]	; (800705c <MX_FREERTOS_Init+0x1a0>)
 8006f62:	483a      	ldr	r0, [pc, #232]	; (800704c <MX_FREERTOS_Init+0x190>)
 8006f64:	f009 fa73 	bl	801044e <xTaskGenericCreate>
	xTaskCreate(PxMessagingTask, (const char *) "P4MsgTask", configMINIMAL_STACK_SIZE, (void *) P4, osPriorityAboveNormal-osPriorityIdle, &P4MsgTaskHandle);
 8006f68:	4b3d      	ldr	r3, [pc, #244]	; (8007060 <MX_FREERTOS_Init+0x1a4>)
 8006f6a:	9600      	str	r6, [sp, #0]
 8006f6c:	9301      	str	r3, [sp, #4]
 8006f6e:	002a      	movs	r2, r5
 8006f70:	0033      	movs	r3, r6
 8006f72:	9403      	str	r4, [sp, #12]
 8006f74:	9402      	str	r4, [sp, #8]
 8006f76:	493b      	ldr	r1, [pc, #236]	; (8007064 <MX_FREERTOS_Init+0x1a8>)
 8006f78:	4834      	ldr	r0, [pc, #208]	; (800704c <MX_FREERTOS_Init+0x190>)
 8006f7a:	f009 fa68 	bl	801044e <xTaskGenericCreate>
	xTaskCreate(PxMessagingTask, (const char *) "P5MsgTask", configMINIMAL_STACK_SIZE, (void *) P5, osPriorityAboveNormal-osPriorityIdle, &P5MsgTaskHandle);
 8006f7e:	4b3a      	ldr	r3, [pc, #232]	; (8007068 <MX_FREERTOS_Init+0x1ac>)
 8006f80:	002a      	movs	r2, r5
 8006f82:	9301      	str	r3, [sp, #4]
 8006f84:	9600      	str	r6, [sp, #0]
 8006f86:	2305      	movs	r3, #5
 8006f88:	9403      	str	r4, [sp, #12]
 8006f8a:	9402      	str	r4, [sp, #8]
 8006f8c:	4937      	ldr	r1, [pc, #220]	; (800706c <MX_FREERTOS_Init+0x1b0>)
 8006f8e:	482f      	ldr	r0, [pc, #188]	; (800704c <MX_FREERTOS_Init+0x190>)
 8006f90:	f009 fa5d 	bl	801044e <xTaskGenericCreate>
	osSemaphoreDef(SemaphoreP1); PxRxSemaphoreHandle[P1] = osSemaphoreCreate(osSemaphore(SemaphoreP1), 1);
 8006f94:	2101      	movs	r1, #1
 8006f96:	a804      	add	r0, sp, #16
 8006f98:	9404      	str	r4, [sp, #16]
 8006f9a:	f008 fc0b 	bl	800f7b4 <osSemaphoreCreate>
 8006f9e:	4e34      	ldr	r6, [pc, #208]	; (8007070 <MX_FREERTOS_Init+0x1b4>)
	osSemaphoreDef(SemaphoreP2); PxTxSemaphoreHandle[P1] = osSemaphoreCreate(osSemaphore(SemaphoreP2), 1);
 8006fa0:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP1); PxRxSemaphoreHandle[P1] = osSemaphoreCreate(osSemaphore(SemaphoreP1), 1);
 8006fa2:	6070      	str	r0, [r6, #4]
	osSemaphoreDef(SemaphoreP2); PxTxSemaphoreHandle[P1] = osSemaphoreCreate(osSemaphore(SemaphoreP2), 1);
 8006fa4:	a805      	add	r0, sp, #20
 8006fa6:	9405      	str	r4, [sp, #20]
 8006fa8:	f008 fc04 	bl	800f7b4 <osSemaphoreCreate>
 8006fac:	4d31      	ldr	r5, [pc, #196]	; (8007074 <MX_FREERTOS_Init+0x1b8>)
	osSemaphoreDef(SemaphoreP3); PxRxSemaphoreHandle[P2] = osSemaphoreCreate(osSemaphore(SemaphoreP3), 1);
 8006fae:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP2); PxTxSemaphoreHandle[P1] = osSemaphoreCreate(osSemaphore(SemaphoreP2), 1);
 8006fb0:	6068      	str	r0, [r5, #4]
	osSemaphoreDef(SemaphoreP3); PxRxSemaphoreHandle[P2] = osSemaphoreCreate(osSemaphore(SemaphoreP3), 1);
 8006fb2:	a806      	add	r0, sp, #24
 8006fb4:	9406      	str	r4, [sp, #24]
 8006fb6:	f008 fbfd 	bl	800f7b4 <osSemaphoreCreate>
	osSemaphoreDef(SemaphoreP4); PxTxSemaphoreHandle[P2] = osSemaphoreCreate(osSemaphore(SemaphoreP4), 1);
 8006fba:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP3); PxRxSemaphoreHandle[P2] = osSemaphoreCreate(osSemaphore(SemaphoreP3), 1);
 8006fbc:	60b0      	str	r0, [r6, #8]
	osSemaphoreDef(SemaphoreP4); PxTxSemaphoreHandle[P2] = osSemaphoreCreate(osSemaphore(SemaphoreP4), 1);
 8006fbe:	a807      	add	r0, sp, #28
 8006fc0:	9407      	str	r4, [sp, #28]
 8006fc2:	f008 fbf7 	bl	800f7b4 <osSemaphoreCreate>
	osSemaphoreDef(SemaphoreP5); PxRxSemaphoreHandle[P3] = osSemaphoreCreate(osSemaphore(SemaphoreP5), 1);
 8006fc6:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP4); PxTxSemaphoreHandle[P2] = osSemaphoreCreate(osSemaphore(SemaphoreP4), 1);
 8006fc8:	60a8      	str	r0, [r5, #8]
	osSemaphoreDef(SemaphoreP5); PxRxSemaphoreHandle[P3] = osSemaphoreCreate(osSemaphore(SemaphoreP5), 1);
 8006fca:	a808      	add	r0, sp, #32
 8006fcc:	9408      	str	r4, [sp, #32]
 8006fce:	f008 fbf1 	bl	800f7b4 <osSemaphoreCreate>
	osSemaphoreDef(SemaphoreP6); PxTxSemaphoreHandle[P3] = osSemaphoreCreate(osSemaphore(SemaphoreP6), 1);
 8006fd2:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP5); PxRxSemaphoreHandle[P3] = osSemaphoreCreate(osSemaphore(SemaphoreP5), 1);
 8006fd4:	60f0      	str	r0, [r6, #12]
	osSemaphoreDef(SemaphoreP6); PxTxSemaphoreHandle[P3] = osSemaphoreCreate(osSemaphore(SemaphoreP6), 1);
 8006fd6:	a809      	add	r0, sp, #36	; 0x24
 8006fd8:	9409      	str	r4, [sp, #36]	; 0x24
 8006fda:	f008 fbeb 	bl	800f7b4 <osSemaphoreCreate>
	osSemaphoreDef(SemaphoreP7); PxRxSemaphoreHandle[P4] = osSemaphoreCreate(osSemaphore(SemaphoreP7), 1);
 8006fde:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP6); PxTxSemaphoreHandle[P3] = osSemaphoreCreate(osSemaphore(SemaphoreP6), 1);
 8006fe0:	60e8      	str	r0, [r5, #12]
	osSemaphoreDef(SemaphoreP7); PxRxSemaphoreHandle[P4] = osSemaphoreCreate(osSemaphore(SemaphoreP7), 1);
 8006fe2:	a80a      	add	r0, sp, #40	; 0x28
 8006fe4:	940a      	str	r4, [sp, #40]	; 0x28
 8006fe6:	f008 fbe5 	bl	800f7b4 <osSemaphoreCreate>
	osSemaphoreDef(SemaphoreP8); PxTxSemaphoreHandle[P4] = osSemaphoreCreate(osSemaphore(SemaphoreP8), 1);
 8006fea:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP7); PxRxSemaphoreHandle[P4] = osSemaphoreCreate(osSemaphore(SemaphoreP7), 1);
 8006fec:	6130      	str	r0, [r6, #16]
	osSemaphoreDef(SemaphoreP8); PxTxSemaphoreHandle[P4] = osSemaphoreCreate(osSemaphore(SemaphoreP8), 1);
 8006fee:	a80b      	add	r0, sp, #44	; 0x2c
 8006ff0:	940b      	str	r4, [sp, #44]	; 0x2c
 8006ff2:	f008 fbdf 	bl	800f7b4 <osSemaphoreCreate>
	osSemaphoreDef(SemaphoreP9); PxRxSemaphoreHandle[P5] = osSemaphoreCreate(osSemaphore(SemaphoreP9), 1);
 8006ff6:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP8); PxTxSemaphoreHandle[P4] = osSemaphoreCreate(osSemaphore(SemaphoreP8), 1);
 8006ff8:	6128      	str	r0, [r5, #16]
	osSemaphoreDef(SemaphoreP9); PxRxSemaphoreHandle[P5] = osSemaphoreCreate(osSemaphore(SemaphoreP9), 1);
 8006ffa:	a80c      	add	r0, sp, #48	; 0x30
 8006ffc:	940c      	str	r4, [sp, #48]	; 0x30
 8006ffe:	f008 fbd9 	bl	800f7b4 <osSemaphoreCreate>
	osSemaphoreDef(SemaphoreP10); PxTxSemaphoreHandle[P5] = osSemaphoreCreate(osSemaphore(SemaphoreP10), 1);
 8007002:	2101      	movs	r1, #1
	osSemaphoreDef(SemaphoreP9); PxRxSemaphoreHandle[P5] = osSemaphoreCreate(osSemaphore(SemaphoreP9), 1);
 8007004:	6170      	str	r0, [r6, #20]
	osSemaphoreDef(SemaphoreP10); PxTxSemaphoreHandle[P5] = osSemaphoreCreate(osSemaphore(SemaphoreP10), 1);
 8007006:	a80d      	add	r0, sp, #52	; 0x34
 8007008:	940d      	str	r4, [sp, #52]	; 0x34
 800700a:	f008 fbd3 	bl	800f7b4 <osSemaphoreCreate>
 800700e:	6168      	str	r0, [r5, #20]
}
 8007010:	b00f      	add	sp, #60	; 0x3c
 8007012:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007014:	2000144c 	.word	0x2000144c
 8007018:	0801b4e8 	.word	0x0801b4e8
 800701c:	08006e45 	.word	0x08006e45
 8007020:	20001430 	.word	0x20001430
 8007024:	0801b4f4 	.word	0x0801b4f4
 8007028:	080080e1 	.word	0x080080e1
 800702c:	20001448 	.word	0x20001448
 8007030:	0801b500 	.word	0x0801b500
 8007034:	08014149 	.word	0x08014149
 8007038:	20001454 	.word	0x20001454
 800703c:	0801b509 	.word	0x0801b509
 8007040:	08004a19 	.word	0x08004a19
 8007044:	20001434 	.word	0x20001434
 8007048:	0801b511 	.word	0x0801b511
 800704c:	080083d5 	.word	0x080083d5
 8007050:	20001438 	.word	0x20001438
 8007054:	0801b51b 	.word	0x0801b51b
 8007058:	2000143c 	.word	0x2000143c
 800705c:	0801b525 	.word	0x0801b525
 8007060:	20001440 	.word	0x20001440
 8007064:	0801b52f 	.word	0x0801b52f
 8007068:	20001444 	.word	0x20001444
 800706c:	0801b539 	.word	0x0801b539
 8007070:	2000700c 	.word	0x2000700c
 8007074:	20006ff0 	.word	0x20006ff0

08007078 <vMainConfigureTimerForRunTimeStats>:
}

/*-----------------------------------------------------------*/

void vMainConfigureTimerForRunTimeStats( void )
{
 8007078:	b510      	push	{r4, lr}
	/* How many clocks are there per tenth of a millisecond? */
	ulClocksPer10thOfAMilliSecond = configCPU_CLOCK_HZ / 10000UL;
 800707a:	4b04      	ldr	r3, [pc, #16]	; (800708c <vMainConfigureTimerForRunTimeStats+0x14>)
 800707c:	4904      	ldr	r1, [pc, #16]	; (8007090 <vMainConfigureTimerForRunTimeStats+0x18>)
 800707e:	6818      	ldr	r0, [r3, #0]
 8007080:	f7f9 f87a 	bl	8000178 <__udivsi3>
 8007084:	4b03      	ldr	r3, [pc, #12]	; (8007094 <vMainConfigureTimerForRunTimeStats+0x1c>)
 8007086:	6018      	str	r0, [r3, #0]
}
 8007088:	bd10      	pop	{r4, pc}
 800708a:	46c0      	nop			; (mov r8, r8)
 800708c:	200000a0 	.word	0x200000a0
 8007090:	00002710 	.word	0x00002710
 8007094:	20001450 	.word	0x20001450

08007098 <ulMainGetRunTimeCounterValue>:
/*-----------------------------------------------------------*/

uint32_t ulMainGetRunTimeCounterValue( void )
{
uint32_t ulSysTickCounts, ulTickCount, ulReturn;
const uint32_t ulSysTickReloadValue = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8007098:	21fa      	movs	r1, #250	; 0xfa
{
 800709a:	b570      	push	{r4, r5, r6, lr}
const uint32_t ulSysTickReloadValue = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800709c:	4b0d      	ldr	r3, [pc, #52]	; (80070d4 <ulMainGetRunTimeCounterValue+0x3c>)
 800709e:	0089      	lsls	r1, r1, #2
 80070a0:	6818      	ldr	r0, [r3, #0]
 80070a2:	f7f9 f869 	bl	8000178 <__udivsi3>
	timer peripheral. */


	/* The SysTick is a down counter.  How many clocks have passed since it was
	last reloaded? */
	ulSysTickCounts = ulSysTickReloadValue - *pulCurrentSysTickCount;
 80070a6:	4d0c      	ldr	r5, [pc, #48]	; (80070d8 <ulMainGetRunTimeCounterValue+0x40>)
const uint32_t ulSysTickReloadValue = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80070a8:	1e44      	subs	r4, r0, #1
	ulSysTickCounts = ulSysTickReloadValue - *pulCurrentSysTickCount;
 80070aa:	682e      	ldr	r6, [r5, #0]

	/* How many times has it overflowed? */
	ulTickCount = xTaskGetTickCountFromISR();
 80070ac:	f009 fa7a 	bl	80105a4 <xTaskGetTickCountFromISR>

	/* Is there a SysTick interrupt pending? */
	if( ( *pulInterruptCTRLState & ulSysTickPendingBit ) != 0UL )
 80070b0:	4b0a      	ldr	r3, [pc, #40]	; (80070dc <ulMainGetRunTimeCounterValue+0x44>)
 80070b2:	681b      	ldr	r3, [r3, #0]
 80070b4:	015b      	lsls	r3, r3, #5
 80070b6:	d409      	bmi.n	80070cc <ulMainGetRunTimeCounterValue+0x34>
	ulSysTickCounts = ulSysTickReloadValue - *pulCurrentSysTickCount;
 80070b8:	1ba4      	subs	r4, r4, r6
		ulSysTickCounts = ulSysTickReloadValue - *pulCurrentSysTickCount;
	}

	/* Convert the tick count into tenths of a millisecond.  THIS ASSUMES
	configTICK_RATE_HZ is 1000! */
	ulReturn = ( ulTickCount * 10UL ) ;
 80070ba:	250a      	movs	r5, #10

	/* Add on the number of tenths of a millisecond that have passed since the
	tick count last got updated. */
	ulReturn += ( ulSysTickCounts / ulClocksPer10thOfAMilliSecond );
 80070bc:	4b08      	ldr	r3, [pc, #32]	; (80070e0 <ulMainGetRunTimeCounterValue+0x48>)
	ulReturn = ( ulTickCount * 10UL ) ;
 80070be:	4345      	muls	r5, r0
	ulReturn += ( ulSysTickCounts / ulClocksPer10thOfAMilliSecond );
 80070c0:	6819      	ldr	r1, [r3, #0]
 80070c2:	0020      	movs	r0, r4
 80070c4:	f7f9 f858 	bl	8000178 <__udivsi3>
 80070c8:	1940      	adds	r0, r0, r5

	return ulReturn;
}
 80070ca:	bd70      	pop	{r4, r5, r6, pc}
		ulSysTickCounts = ulSysTickReloadValue - *pulCurrentSysTickCount;
 80070cc:	682b      	ldr	r3, [r5, #0]
		ulTickCount++;
 80070ce:	3001      	adds	r0, #1
		ulSysTickCounts = ulSysTickReloadValue - *pulCurrentSysTickCount;
 80070d0:	1ae4      	subs	r4, r4, r3
 80070d2:	e7f2      	b.n	80070ba <ulMainGetRunTimeCounterValue+0x22>
 80070d4:	200000a0 	.word	0x200000a0
 80070d8:	e000e018 	.word	0xe000e018
 80070dc:	e000ed04 	.word	0xe000ed04
 80070e0:	20001450 	.word	0x20001450

080070e4 <buttonPressedCallback>:
/* --- Button press callback. DO NOT MODIFY THIS CALLBACK. 
		This function is declared as __weak to be overwritten by other implementations in user file.
*/
__weak void buttonPressedCallback(uint8_t port)
{	
}
 80070e4:	4770      	bx	lr

080070e6 <buttonReleasedCallback>:
 80070e6:	4770      	bx	lr

080070e8 <buttonClickedCallback>:
 80070e8:	4770      	bx	lr

080070ea <buttonDblClickedCallback>:
 80070ea:	4770      	bx	lr

080070ec <buttonPressedForXCallback>:
/* --- Button pressed_for_x callbacks. DO NOT MODIFY THIS CALLBACK. 
		This function is declared as __weak to be overwritten by other implementations in user file.
*/
__weak void buttonPressedForXCallback(uint8_t port, uint8_t eventType)
{	
}
 80070ec:	4770      	bx	lr

080070ee <buttonReleasedForYCallback>:
 80070ee:	4770      	bx	lr

080070f0 <CheckForTimedButtonPress>:
/*-----------------------------------------------------------*/	

/* --- Check for timed press button events
*/
BOS_Status CheckForTimedButtonPress(uint8_t port)
{
 80070f0:	b570      	push	{r4, r5, r6, lr}
	BOS_Status result = BOS_OK;
	uint32_t t1 = button[port].pressedX1Sec, t2 = button[port].pressedX2Sec, t3 = button[port].pressedX3Sec;
 80070f2:	2609      	movs	r6, #9
 80070f4:	0031      	movs	r1, r6
	
	/* Convert to ms */
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
	
	if (pressCounter[port] == t1)	
 80070f6:	4b0d      	ldr	r3, [pc, #52]	; (800712c <CheckForTimedButtonPress+0x3c>)
	uint32_t t1 = button[port].pressedX1Sec, t2 = button[port].pressedX2Sec, t3 = button[port].pressedX3Sec;
 80070f8:	4341      	muls	r1, r0
	if (pressCounter[port] == t1)	
 80070fa:	0080      	lsls	r0, r0, #2
 80070fc:	58c0      	ldr	r0, [r0, r3]
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 80070fe:	23fa      	movs	r3, #250	; 0xfa
	uint32_t t1 = button[port].pressedX1Sec, t2 = button[port].pressedX2Sec, t3 = button[port].pressedX3Sec;
 8007100:	4a0b      	ldr	r2, [pc, #44]	; (8007130 <CheckForTimedButtonPress+0x40>)
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 8007102:	009b      	lsls	r3, r3, #2
	uint32_t t1 = button[port].pressedX1Sec, t2 = button[port].pressedX2Sec, t3 = button[port].pressedX3Sec;
 8007104:	1854      	adds	r4, r2, r1
 8007106:	78a5      	ldrb	r5, [r4, #2]
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 8007108:	435d      	muls	r5, r3
	if (pressCounter[port] == t1)	
 800710a:	42a8      	cmp	r0, r5
 800710c:	d102      	bne.n	8007114 <CheckForTimedButtonPress+0x24>
	{	
		button[port].state = PRESSED_FOR_X1_SEC;
 800710e:	548e      	strb	r6, [r1, r2]
	{	
		button[port].state = PRESSED_FOR_X2_SEC;
	}	

	return result;	
}
 8007110:	2000      	movs	r0, #0
 8007112:	bd70      	pop	{r4, r5, r6, pc}
	uint32_t t1 = button[port].pressedX1Sec, t2 = button[port].pressedX2Sec, t3 = button[port].pressedX3Sec;
 8007114:	78e5      	ldrb	r5, [r4, #3]
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 8007116:	435d      	muls	r5, r3
	else if (pressCounter[port] == t2)	
 8007118:	42a8      	cmp	r0, r5
 800711a:	d102      	bne.n	8007122 <CheckForTimedButtonPress+0x32>
		button[port].state = PRESSED_FOR_X2_SEC;
 800711c:	230a      	movs	r3, #10
 800711e:	548b      	strb	r3, [r1, r2]
 8007120:	e7f6      	b.n	8007110 <CheckForTimedButtonPress+0x20>
	uint32_t t1 = button[port].pressedX1Sec, t2 = button[port].pressedX2Sec, t3 = button[port].pressedX3Sec;
 8007122:	7924      	ldrb	r4, [r4, #4]
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 8007124:	4363      	muls	r3, r4
	else if (pressCounter[port] == t3)	
 8007126:	4298      	cmp	r0, r3
 8007128:	d1f2      	bne.n	8007110 <CheckForTimedButtonPress+0x20>
 800712a:	e7f7      	b.n	800711c <CheckForTimedButtonPress+0x2c>
 800712c:	20001498 	.word	0x20001498
 8007130:	20001458 	.word	0x20001458

08007134 <CheckForTimedButtonRelease>:
/* --- Check for timed release button events
*/
BOS_Status CheckForTimedButtonRelease(uint8_t port)
{
	BOS_Status result = BOS_OK;
	uint32_t t1 = button[port].releasedY1Sec, t2 = button[port].releasedY2Sec, t3 = button[port].releasedY3Sec;
 8007134:	2309      	movs	r3, #9
{
 8007136:	b530      	push	{r4, r5, lr}

	/* Convert to ms */
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
	
	if (releaseCounter[port] == t1)	
 8007138:	4a0d      	ldr	r2, [pc, #52]	; (8007170 <CheckForTimedButtonRelease+0x3c>)
	uint32_t t1 = button[port].releasedY1Sec, t2 = button[port].releasedY2Sec, t3 = button[port].releasedY3Sec;
 800713a:	4343      	muls	r3, r0
	if (releaseCounter[port] == t1)	
 800713c:	0080      	lsls	r0, r0, #2
 800713e:	5880      	ldr	r0, [r0, r2]
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 8007140:	22fa      	movs	r2, #250	; 0xfa
	uint32_t t1 = button[port].releasedY1Sec, t2 = button[port].releasedY2Sec, t3 = button[port].releasedY3Sec;
 8007142:	490c      	ldr	r1, [pc, #48]	; (8007174 <CheckForTimedButtonRelease+0x40>)
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 8007144:	0092      	lsls	r2, r2, #2
	uint32_t t1 = button[port].releasedY1Sec, t2 = button[port].releasedY2Sec, t3 = button[port].releasedY3Sec;
 8007146:	18cc      	adds	r4, r1, r3
 8007148:	7965      	ldrb	r5, [r4, #5]
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 800714a:	4355      	muls	r5, r2
	if (releaseCounter[port] == t1)	
 800714c:	42a8      	cmp	r0, r5
 800714e:	d102      	bne.n	8007156 <CheckForTimedButtonRelease+0x22>
	{	
		button[port].state = RELEASED_FOR_Y1_SEC;
 8007150:	220c      	movs	r2, #12
	{	
		button[port].state = RELEASED_FOR_Y2_SEC;
	}		
	else if (releaseCounter[port] == t3)	
	{	
		button[port].state = RELEASED_FOR_Y2_SEC;
 8007152:	545a      	strb	r2, [r3, r1]
 8007154:	e009      	b.n	800716a <CheckForTimedButtonRelease+0x36>
	uint32_t t1 = button[port].releasedY1Sec, t2 = button[port].releasedY2Sec, t3 = button[port].releasedY3Sec;
 8007156:	79a5      	ldrb	r5, [r4, #6]
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 8007158:	4355      	muls	r5, r2
	else if (releaseCounter[port] == t2)	
 800715a:	42a8      	cmp	r0, r5
 800715c:	d101      	bne.n	8007162 <CheckForTimedButtonRelease+0x2e>
		button[port].state = RELEASED_FOR_Y2_SEC;
 800715e:	220d      	movs	r2, #13
 8007160:	e7f7      	b.n	8007152 <CheckForTimedButtonRelease+0x1e>
	uint32_t t1 = button[port].releasedY1Sec, t2 = button[port].releasedY2Sec, t3 = button[port].releasedY3Sec;
 8007162:	79e4      	ldrb	r4, [r4, #7]
	t1 *= 1000; t2 *= 1000; t3 *= 1000;
 8007164:	4362      	muls	r2, r4
	else if (releaseCounter[port] == t3)	
 8007166:	4290      	cmp	r0, r2
 8007168:	d0f9      	beq.n	800715e <CheckForTimedButtonRelease+0x2a>
	}	

	return result;	
}
 800716a:	2000      	movs	r0, #0
 800716c:	bd30      	pop	{r4, r5, pc}
 800716e:	46c0      	nop			; (mov r8, r8)
 8007170:	200014b0 	.word	0x200014b0
 8007174:	20001458 	.word	0x20001458

08007178 <CheckAttachedButtons>:
{
 8007178:	b5f0      	push	{r4, r5, r6, r7, lr}
 800717a:	2701      	movs	r7, #1
	uint8_t connected = GPIO_PIN_RESET, state = 0;
 800717c:	2300      	movs	r3, #0
						delayButtonStateReset = true;
 800717e:	003c      	movs	r4, r7
{
 8007180:	b08b      	sub	sp, #44	; 0x2c
	uint8_t connected = GPIO_PIN_RESET, state = 0;
 8007182:	9302      	str	r3, [sp, #8]
 8007184:	9304      	str	r3, [sp, #16]
 8007186:	2309      	movs	r3, #9
 8007188:	437b      	muls	r3, r7
 800718a:	9305      	str	r3, [sp, #20]
 800718c:	9a05      	ldr	r2, [sp, #20]
 800718e:	4ba8      	ldr	r3, [pc, #672]	; (8007430 <CheckAttachedButtons+0x2b8>)
 8007190:	b2fd      	uxtb	r5, r7
 8007192:	189a      	adds	r2, r3, r2
 8007194:	9203      	str	r2, [sp, #12]
		if (button[i].type)			// Only check defined butons
 8007196:	7852      	ldrb	r2, [r2, #1]
 8007198:	2a00      	cmp	r2, #0
 800719a:	d100      	bne.n	800719e <CheckAttachedButtons+0x26>
 800719c:	e116      	b.n	80073cc <CheckAttachedButtons+0x254>
			if (delayButtonStateReset == false)	button[i].state = NONE;		
 800719e:	4aa5      	ldr	r2, [pc, #660]	; (8007434 <CheckAttachedButtons+0x2bc>)
 80071a0:	7812      	ldrb	r2, [r2, #0]
 80071a2:	2a00      	cmp	r2, #0
 80071a4:	d101      	bne.n	80071aa <CheckAttachedButtons+0x32>
 80071a6:	9905      	ldr	r1, [sp, #20]
 80071a8:	54ca      	strb	r2, [r1, r3]
			GetPortGPIOs(i, &TX_Port, &TX_Pin, &RX_Port, &RX_Pin);
 80071aa:	260e      	movs	r6, #14
 80071ac:	ab04      	add	r3, sp, #16
 80071ae:	18f6      	adds	r6, r6, r3
 80071b0:	aa07      	add	r2, sp, #28
 80071b2:	ab09      	add	r3, sp, #36	; 0x24
 80071b4:	a908      	add	r1, sp, #32
 80071b6:	9600      	str	r6, [sp, #0]
 80071b8:	0028      	movs	r0, r5
 80071ba:	f004 ff3b 	bl	800c034 <GetPortGPIOs>
			HAL_GPIO_WritePin((GPIO_TypeDef *)TX_Port, TX_Pin, GPIO_PIN_RESET); Delay_us(10);
 80071be:	ab04      	add	r3, sp, #16
 80071c0:	8999      	ldrh	r1, [r3, #12]
 80071c2:	2200      	movs	r2, #0
 80071c4:	9808      	ldr	r0, [sp, #32]
 80071c6:	f00b f8ab 	bl	8012320 <HAL_GPIO_WritePin>
 80071ca:	200a      	movs	r0, #10
 80071cc:	f005 ff9c 	bl	800d108 <StartMicroDelay>
			if (HAL_GPIO_ReadPin((GPIO_TypeDef *)RX_Port, RX_Pin) == GPIO_PIN_RESET) 
 80071d0:	8831      	ldrh	r1, [r6, #0]
 80071d2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80071d4:	f00b f89e 	bl	8012314 <HAL_GPIO_ReadPin>
 80071d8:	2800      	cmp	r0, #0
 80071da:	d10d      	bne.n	80071f8 <CheckAttachedButtons+0x80>
				HAL_GPIO_WritePin((GPIO_TypeDef *)TX_Port, TX_Pin, GPIO_PIN_SET); Delay_us(10);
 80071dc:	ab04      	add	r3, sp, #16
 80071de:	8999      	ldrh	r1, [r3, #12]
 80071e0:	0022      	movs	r2, r4
 80071e2:	9808      	ldr	r0, [sp, #32]
 80071e4:	f00b f89c 	bl	8012320 <HAL_GPIO_WritePin>
 80071e8:	200a      	movs	r0, #10
 80071ea:	f005 ff8d 	bl	800d108 <StartMicroDelay>
				connected = HAL_GPIO_ReadPin((GPIO_TypeDef *)RX_Port, RX_Pin); 
 80071ee:	8831      	ldrh	r1, [r6, #0]
 80071f0:	9809      	ldr	r0, [sp, #36]	; 0x24
 80071f2:	f00b f88f 	bl	8012314 <HAL_GPIO_ReadPin>
 80071f6:	9004      	str	r0, [sp, #16]
			HAL_GPIO_WritePin((GPIO_TypeDef *)TX_Port, TX_Pin, GPIO_PIN_RESET);
 80071f8:	ab07      	add	r3, sp, #28
 80071fa:	8819      	ldrh	r1, [r3, #0]
 80071fc:	9808      	ldr	r0, [sp, #32]
 80071fe:	2200      	movs	r2, #0
 8007200:	f00b f88e 	bl	8012320 <HAL_GPIO_WritePin>
			switch (button[i].type)
 8007204:	9b03      	ldr	r3, [sp, #12]
 8007206:	7858      	ldrb	r0, [r3, #1]
 8007208:	00bb      	lsls	r3, r7, #2
 800720a:	3801      	subs	r0, #1
 800720c:	2803      	cmp	r0, #3
 800720e:	d809      	bhi.n	8007224 <CheckAttachedButtons+0xac>
					if (connected == GPIO_PIN_SET)	
 8007210:	9a04      	ldr	r2, [sp, #16]
			switch (button[i].type)
 8007212:	f7f8 ff93 	bl	800013c <__gnu_thumb1_case_uqi>
 8007216:	0202      	.short	0x0202
 8007218:	7670      	.short	0x7670
					if (connected == GPIO_PIN_SET)	
 800721a:	2a01      	cmp	r2, #1
 800721c:	d077      	beq.n	800730e <CheckAttachedButtons+0x196>
					else if (connected == GPIO_PIN_RESET) 
 800721e:	2a00      	cmp	r2, #0
 8007220:	d100      	bne.n	8007224 <CheckAttachedButtons+0xac>
 8007222:	e092      	b.n	800734a <CheckAttachedButtons+0x1d2>
			if (state == CLOSED || state == ON)												
 8007224:	9a02      	ldr	r2, [sp, #8]
 8007226:	2a04      	cmp	r2, #4
 8007228:	d001      	beq.n	800722e <CheckAttachedButtons+0xb6>
 800722a:	2a02      	cmp	r2, #2
 800722c:	d174      	bne.n	8007318 <CheckAttachedButtons+0x1a0>
				if (pressCounter[i] < 0xFFFF)	
 800722e:	4982      	ldr	r1, [pc, #520]	; (8007438 <CheckAttachedButtons+0x2c0>)
 8007230:	4882      	ldr	r0, [pc, #520]	; (800743c <CheckAttachedButtons+0x2c4>)
 8007232:	58ca      	ldr	r2, [r1, r3]
 8007234:	4282      	cmp	r2, r0
 8007236:	d86d      	bhi.n	8007314 <CheckAttachedButtons+0x19c>
					++pressCounter[i];																			// Advance the debounce counter
 8007238:	3201      	adds	r2, #1
					pressCounter[i] = 0;																		// Reset debounce counter					
 800723a:	50ca      	str	r2, [r1, r3]
			if (pressCounter[i] < BOS.buttons.debounce) 									
 800723c:	4b7e      	ldr	r3, [pc, #504]	; (8007438 <CheckAttachedButtons+0x2c0>)
 800723e:	00be      	lsls	r6, r7, #2
 8007240:	469c      	mov	ip, r3
 8007242:	58f1      	ldr	r1, [r6, r3]
 8007244:	4b7e      	ldr	r3, [pc, #504]	; (8007440 <CheckAttachedButtons+0x2c8>)
 8007246:	881b      	ldrh	r3, [r3, #0]
 8007248:	4299      	cmp	r1, r3
 800724a:	d31e      	bcc.n	800728a <CheckAttachedButtons+0x112>
				if (pressCounter[i] == BOS.buttons.debounce)
 800724c:	d106      	bne.n	800725c <CheckAttachedButtons+0xe4>
					button[i].state = PRESSED;															// Record a PRESSED event. This event is always reset on next tick.
 800724e:	2007      	movs	r0, #7
 8007250:	4977      	ldr	r1, [pc, #476]	; (8007430 <CheckAttachedButtons+0x2b8>)
 8007252:	9a05      	ldr	r2, [sp, #20]
 8007254:	5450      	strb	r0, [r2, r1]
					++pressCounter[i];
 8007256:	4662      	mov	r2, ip
 8007258:	1c59      	adds	r1, r3, #1
 800725a:	50b1      	str	r1, [r6, r2]
				if (releaseCounter[i] > BOS.buttons.debounce)							// Reset releaseCounter if needed - to avoid masking pressCounter on NO switches
 800725c:	4a79      	ldr	r2, [pc, #484]	; (8007444 <CheckAttachedButtons+0x2cc>)
 800725e:	58b1      	ldr	r1, [r6, r2]
 8007260:	428b      	cmp	r3, r1
 8007262:	d201      	bcs.n	8007268 <CheckAttachedButtons+0xf0>
					releaseCounter[i] = 0;					
 8007264:	2300      	movs	r3, #0
 8007266:	50b3      	str	r3, [r6, r2]
				if (pressCounter[i] > BOS.buttons.singleClickTime && pressCounter[i] < 500)	
 8007268:	4b73      	ldr	r3, [pc, #460]	; (8007438 <CheckAttachedButtons+0x2c0>)
 800726a:	4a75      	ldr	r2, [pc, #468]	; (8007440 <CheckAttachedButtons+0x2c8>)
 800726c:	58f3      	ldr	r3, [r6, r3]
 800726e:	8851      	ldrh	r1, [r2, #2]
 8007270:	428b      	cmp	r3, r1
 8007272:	d800      	bhi.n	8007276 <CheckAttachedButtons+0xfe>
 8007274:	e084      	b.n	8007380 <CheckAttachedButtons+0x208>
 8007276:	21f4      	movs	r1, #244	; 0xf4
 8007278:	31ff      	adds	r1, #255	; 0xff
 800727a:	428b      	cmp	r3, r1
 800727c:	d900      	bls.n	8007280 <CheckAttachedButtons+0x108>
 800727e:	e07f      	b.n	8007380 <CheckAttachedButtons+0x208>
					if (clicked == 0)
 8007280:	4b71      	ldr	r3, [pc, #452]	; (8007448 <CheckAttachedButtons+0x2d0>)
 8007282:	7819      	ldrb	r1, [r3, #0]
 8007284:	2900      	cmp	r1, #0
 8007286:	d16b      	bne.n	8007360 <CheckAttachedButtons+0x1e8>
						clicked = 1;																					// Record a possible single click 
 8007288:	701c      	strb	r4, [r3, #0]
			if (releaseCounter[i] < BOS.buttons.debounce) 							
 800728a:	4b6e      	ldr	r3, [pc, #440]	; (8007444 <CheckAttachedButtons+0x2cc>)
 800728c:	469c      	mov	ip, r3
 800728e:	58f1      	ldr	r1, [r6, r3]
 8007290:	4b6b      	ldr	r3, [pc, #428]	; (8007440 <CheckAttachedButtons+0x2c8>)
 8007292:	881b      	ldrh	r3, [r3, #0]
 8007294:	4299      	cmp	r1, r3
 8007296:	d321      	bcc.n	80072dc <CheckAttachedButtons+0x164>
				if (releaseCounter[i] == BOS.buttons.debounce)
 8007298:	d106      	bne.n	80072a8 <CheckAttachedButtons+0x130>
					button[i].state = RELEASED;															// Record a RELEASED event. This event is always reset on next tick.
 800729a:	2008      	movs	r0, #8
 800729c:	4964      	ldr	r1, [pc, #400]	; (8007430 <CheckAttachedButtons+0x2b8>)
 800729e:	9a05      	ldr	r2, [sp, #20]
 80072a0:	5450      	strb	r0, [r2, r1]
					++releaseCounter[i];
 80072a2:	4662      	mov	r2, ip
 80072a4:	1c59      	adds	r1, r3, #1
 80072a6:	50b1      	str	r1, [r6, r2]
				if (pressCounter[i] > BOS.buttons.debounce)								// Reset pressCounter if needed - to avoid masking releaseCounter on NC switches
 80072a8:	4963      	ldr	r1, [pc, #396]	; (8007438 <CheckAttachedButtons+0x2c0>)
 80072aa:	5872      	ldr	r2, [r6, r1]
 80072ac:	4293      	cmp	r3, r2
 80072ae:	d201      	bcs.n	80072b4 <CheckAttachedButtons+0x13c>
					pressCounter[i] = 0;				
 80072b0:	2300      	movs	r3, #0
 80072b2:	5073      	str	r3, [r6, r1]
				if (releaseCounter[i] > BOS.buttons.singleClickTime && releaseCounter[i] < 500)	
 80072b4:	4663      	mov	r3, ip
 80072b6:	4a62      	ldr	r2, [pc, #392]	; (8007440 <CheckAttachedButtons+0x2c8>)
 80072b8:	599b      	ldr	r3, [r3, r6]
 80072ba:	8852      	ldrh	r2, [r2, #2]
 80072bc:	4293      	cmp	r3, r2
 80072be:	d976      	bls.n	80073ae <CheckAttachedButtons+0x236>
 80072c0:	22f4      	movs	r2, #244	; 0xf4
 80072c2:	32ff      	adds	r2, #255	; 0xff
 80072c4:	4293      	cmp	r3, r2
 80072c6:	d872      	bhi.n	80073ae <CheckAttachedButtons+0x236>
					if (clicked == 1)
 80072c8:	4b5f      	ldr	r3, [pc, #380]	; (8007448 <CheckAttachedButtons+0x2d0>)
 80072ca:	4a59      	ldr	r2, [pc, #356]	; (8007430 <CheckAttachedButtons+0x2b8>)
 80072cc:	7819      	ldrb	r1, [r3, #0]
 80072ce:	2901      	cmp	r1, #1
 80072d0:	d166      	bne.n	80073a0 <CheckAttachedButtons+0x228>
						button[i].state = CLICKED;														// Record a single button click event
 80072d2:	9805      	ldr	r0, [sp, #20]
 80072d4:	3104      	adds	r1, #4
 80072d6:	5411      	strb	r1, [r2, r0]
						clicked = 2;																					// Prepare for a double click
 80072d8:	2202      	movs	r2, #2
						clicked = 0;																					// Prepare for a single click					
 80072da:	701a      	strb	r2, [r3, #0]
			switch (button[i].state)
 80072dc:	4e54      	ldr	r6, [pc, #336]	; (8007430 <CheckAttachedButtons+0x2b8>)
 80072de:	9b05      	ldr	r3, [sp, #20]
 80072e0:	5d98      	ldrb	r0, [r3, r6]
 80072e2:	3805      	subs	r0, #5
 80072e4:	2809      	cmp	r0, #9
 80072e6:	d871      	bhi.n	80073cc <CheckAttachedButtons+0x254>
 80072e8:	f7f8 ff28 	bl	800013c <__gnu_thumb1_case_uqi>
 80072ec:	766a877a 	.word	0x766a877a
 80072f0:	cabfb494 	.word	0xcabfb494
 80072f4:	e5d8      	.short	0xe5d8
					if (connected == GPIO_PIN_SET)	
 80072f6:	2a01      	cmp	r2, #1
 80072f8:	d007      	beq.n	800730a <CheckAttachedButtons+0x192>
					else if (connected == GPIO_PIN_RESET) 
 80072fa:	2a00      	cmp	r2, #0
 80072fc:	d192      	bne.n	8007224 <CheckAttachedButtons+0xac>
 80072fe:	9402      	str	r4, [sp, #8]
 8007300:	e00f      	b.n	8007322 <CheckAttachedButtons+0x1aa>
					if (connected == GPIO_PIN_SET)	
 8007302:	2a01      	cmp	r2, #1
 8007304:	d0fb      	beq.n	80072fe <CheckAttachedButtons+0x186>
					else if (connected == GPIO_PIN_RESET) 
 8007306:	2a00      	cmp	r2, #0
 8007308:	d18c      	bne.n	8007224 <CheckAttachedButtons+0xac>
						state = ON;
 800730a:	2202      	movs	r2, #2
 800730c:	e000      	b.n	8007310 <CheckAttachedButtons+0x198>
						state = CLOSED;
 800730e:	2204      	movs	r2, #4
						state = ON;
 8007310:	9202      	str	r2, [sp, #8]
 8007312:	e78c      	b.n	800722e <CheckAttachedButtons+0xb6>
					pressCounter[i] = 0;																		// Reset debounce counter					
 8007314:	2200      	movs	r2, #0
 8007316:	e790      	b.n	800723a <CheckAttachedButtons+0xc2>
			if (state == OPEN || state == OFF)												
 8007318:	9a02      	ldr	r2, [sp, #8]
 800731a:	2a03      	cmp	r2, #3
 800731c:	d001      	beq.n	8007322 <CheckAttachedButtons+0x1aa>
 800731e:	2a01      	cmp	r2, #1
 8007320:	d18c      	bne.n	800723c <CheckAttachedButtons+0xc4>
				if (releaseCounter[i] < 0xFFFF)
 8007322:	4948      	ldr	r1, [pc, #288]	; (8007444 <CheckAttachedButtons+0x2cc>)
 8007324:	4845      	ldr	r0, [pc, #276]	; (800743c <CheckAttachedButtons+0x2c4>)
 8007326:	58ca      	ldr	r2, [r1, r3]
 8007328:	4282      	cmp	r2, r0
 800732a:	d811      	bhi.n	8007350 <CheckAttachedButtons+0x1d8>
					++releaseCounter[i];																		// Advance the debounce counter
 800732c:	3201      	adds	r2, #1
				if (clicked == 2 && dblCounter[i] <= BOS.buttons.maxInterClickTime)				// Advance the inter-click counter		
 800732e:	4846      	ldr	r0, [pc, #280]	; (8007448 <CheckAttachedButtons+0x2d0>)
					releaseCounter[i] = 0;																	// Reset debounce counter		
 8007330:	50ca      	str	r2, [r1, r3]
				if (clicked == 2 && dblCounter[i] <= BOS.buttons.maxInterClickTime)				// Advance the inter-click counter		
 8007332:	7806      	ldrb	r6, [r0, #0]
 8007334:	4945      	ldr	r1, [pc, #276]	; (800744c <CheckAttachedButtons+0x2d4>)
 8007336:	4a42      	ldr	r2, [pc, #264]	; (8007440 <CheckAttachedButtons+0x2c8>)
 8007338:	5c7b      	ldrb	r3, [r7, r1]
 800733a:	7952      	ldrb	r2, [r2, #5]
 800733c:	2e02      	cmp	r6, #2
 800733e:	d109      	bne.n	8007354 <CheckAttachedButtons+0x1dc>
 8007340:	4293      	cmp	r3, r2
 8007342:	d80a      	bhi.n	800735a <CheckAttachedButtons+0x1e2>
					++dblCounter[i];			
 8007344:	3301      	adds	r3, #1
					dblCounter[i] = 0;																			// Reset the inter-click counter
 8007346:	55cb      	strb	r3, [r1, r7]
 8007348:	e778      	b.n	800723c <CheckAttachedButtons+0xc4>
 800734a:	2203      	movs	r2, #3
 800734c:	9202      	str	r2, [sp, #8]
 800734e:	e7e8      	b.n	8007322 <CheckAttachedButtons+0x1aa>
					releaseCounter[i] = 0;																	// Reset debounce counter		
 8007350:	2200      	movs	r2, #0
 8007352:	e7ec      	b.n	800732e <CheckAttachedButtons+0x1b6>
				else if (dblCounter[i] > BOS.buttons.maxInterClickTime)	{
 8007354:	4293      	cmp	r3, r2
 8007356:	d800      	bhi.n	800735a <CheckAttachedButtons+0x1e2>
 8007358:	e770      	b.n	800723c <CheckAttachedButtons+0xc4>
					clicked = 0;
 800735a:	2300      	movs	r3, #0
 800735c:	7003      	strb	r3, [r0, #0]
 800735e:	e7f2      	b.n	8007346 <CheckAttachedButtons+0x1ce>
					else if (clicked == 2) {
 8007360:	2902      	cmp	r1, #2
 8007362:	d192      	bne.n	800728a <CheckAttachedButtons+0x112>
						if (dblCounter[i] > BOS.buttons.minInterClickTime && dblCounter[i] < BOS.buttons.maxInterClickTime) {
 8007364:	4939      	ldr	r1, [pc, #228]	; (800744c <CheckAttachedButtons+0x2d4>)
 8007366:	5c78      	ldrb	r0, [r7, r1]
 8007368:	7911      	ldrb	r1, [r2, #4]
 800736a:	4281      	cmp	r1, r0
 800736c:	d28d      	bcs.n	800728a <CheckAttachedButtons+0x112>
 800736e:	7952      	ldrb	r2, [r2, #5]
 8007370:	4282      	cmp	r2, r0
 8007372:	d98a      	bls.n	800728a <CheckAttachedButtons+0x112>
							clicked = 3;																				// Record a possible double click 
 8007374:	2203      	movs	r2, #3
 8007376:	701a      	strb	r2, [r3, #0]
							dblCounter[i] = 0;																	// Reset the inter-click counter
 8007378:	2300      	movs	r3, #0
 800737a:	4a34      	ldr	r2, [pc, #208]	; (800744c <CheckAttachedButtons+0x2d4>)
 800737c:	54bb      	strb	r3, [r7, r2]
 800737e:	e784      	b.n	800728a <CheckAttachedButtons+0x112>
				else if (pressCounter[i] >= 500 && pressCounter[i] < 0xFFFF)	
 8007380:	3bf5      	subs	r3, #245	; 0xf5
 8007382:	4a33      	ldr	r2, [pc, #204]	; (8007450 <CheckAttachedButtons+0x2d8>)
 8007384:	3bff      	subs	r3, #255	; 0xff
 8007386:	4293      	cmp	r3, r2
 8007388:	d900      	bls.n	800738c <CheckAttachedButtons+0x214>
 800738a:	e77e      	b.n	800728a <CheckAttachedButtons+0x112>
					if (clicked)	clicked = 0;															// Cannot be a click
 800738c:	4b2e      	ldr	r3, [pc, #184]	; (8007448 <CheckAttachedButtons+0x2d0>)
 800738e:	781a      	ldrb	r2, [r3, #0]
 8007390:	2a00      	cmp	r2, #0
 8007392:	d001      	beq.n	8007398 <CheckAttachedButtons+0x220>
 8007394:	2200      	movs	r2, #0
 8007396:	701a      	strb	r2, [r3, #0]
					CheckForTimedButtonPress(i);
 8007398:	0028      	movs	r0, r5
 800739a:	f7ff fea9 	bl	80070f0 <CheckForTimedButtonPress>
 800739e:	e774      	b.n	800728a <CheckAttachedButtons+0x112>
					else if (clicked == 3)
 80073a0:	2903      	cmp	r1, #3
 80073a2:	d19b      	bne.n	80072dc <CheckAttachedButtons+0x164>
						button[i].state = DBL_CLICKED;												// Record a double button click event
 80073a4:	9805      	ldr	r0, [sp, #20]
 80073a6:	3103      	adds	r1, #3
 80073a8:	5411      	strb	r1, [r2, r0]
						clicked = 0;																					// Prepare for a single click					
 80073aa:	2200      	movs	r2, #0
 80073ac:	e795      	b.n	80072da <CheckAttachedButtons+0x162>
				else if (releaseCounter[i] >= 500 && releaseCounter[i] < 0xFFFF)	
 80073ae:	3bf5      	subs	r3, #245	; 0xf5
 80073b0:	4a27      	ldr	r2, [pc, #156]	; (8007450 <CheckAttachedButtons+0x2d8>)
 80073b2:	3bff      	subs	r3, #255	; 0xff
 80073b4:	4293      	cmp	r3, r2
 80073b6:	d891      	bhi.n	80072dc <CheckAttachedButtons+0x164>
					CheckForTimedButtonRelease(i);
 80073b8:	0028      	movs	r0, r5
 80073ba:	f7ff febb 	bl	8007134 <CheckForTimedButtonRelease>
 80073be:	e78d      	b.n	80072dc <CheckAttachedButtons+0x164>
					buttonPressedCallback(i);
 80073c0:	0028      	movs	r0, r5
 80073c2:	f7ff fe8f 	bl	80070e4 <buttonPressedCallback>
					button[i].state = NONE;
 80073c6:	2300      	movs	r3, #0
 80073c8:	9a05      	ldr	r2, [sp, #20]
 80073ca:	54b3      	strb	r3, [r6, r2]
 80073cc:	3701      	adds	r7, #1
	for(uint8_t i=1 ; i<=NumOfPorts ; i++)
 80073ce:	2f06      	cmp	r7, #6
 80073d0:	d000      	beq.n	80073d4 <CheckAttachedButtons+0x25c>
 80073d2:	e6d8      	b.n	8007186 <CheckAttachedButtons+0xe>
}
 80073d4:	b00b      	add	sp, #44	; 0x2c
 80073d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
					buttonReleasedCallback(i);
 80073d8:	0028      	movs	r0, r5
 80073da:	f7ff fe84 	bl	80070e6 <buttonReleasedCallback>
 80073de:	e7f2      	b.n	80073c6 <CheckAttachedButtons+0x24e>
					if (!delayButtonStateReset && (button[i].events & BUTTON_EVENT_CLICKED)) 
 80073e0:	4b14      	ldr	r3, [pc, #80]	; (8007434 <CheckAttachedButtons+0x2bc>)
 80073e2:	781a      	ldrb	r2, [r3, #0]
 80073e4:	2a00      	cmp	r2, #0
 80073e6:	d1f1      	bne.n	80073cc <CheckAttachedButtons+0x254>
 80073e8:	9a03      	ldr	r2, [sp, #12]
 80073ea:	7a12      	ldrb	r2, [r2, #8]
 80073ec:	4222      	tst	r2, r4
 80073ee:	d0ed      	beq.n	80073cc <CheckAttachedButtons+0x254>
						buttonClickedCallback(i);
 80073f0:	0028      	movs	r0, r5
						delayButtonStateReset = true;
 80073f2:	701c      	strb	r4, [r3, #0]
						buttonClickedCallback(i);
 80073f4:	f7ff fe78 	bl	80070e8 <buttonClickedCallback>
 80073f8:	e7e8      	b.n	80073cc <CheckAttachedButtons+0x254>
					if (!delayButtonStateReset && (button[i].events & BUTTON_EVENT_DBL_CLICKED)) 
 80073fa:	4b0e      	ldr	r3, [pc, #56]	; (8007434 <CheckAttachedButtons+0x2bc>)
 80073fc:	781a      	ldrb	r2, [r3, #0]
 80073fe:	2a00      	cmp	r2, #0
 8007400:	d1e4      	bne.n	80073cc <CheckAttachedButtons+0x254>
 8007402:	9a03      	ldr	r2, [sp, #12]
 8007404:	7a12      	ldrb	r2, [r2, #8]
 8007406:	0792      	lsls	r2, r2, #30
 8007408:	d5e0      	bpl.n	80073cc <CheckAttachedButtons+0x254>
						buttonDblClickedCallback(i);
 800740a:	0028      	movs	r0, r5
						delayButtonStateReset = true;
 800740c:	701c      	strb	r4, [r3, #0]
						buttonDblClickedCallback(i);
 800740e:	f7ff fe6c 	bl	80070ea <buttonDblClickedCallback>
 8007412:	e7db      	b.n	80073cc <CheckAttachedButtons+0x254>
					if (!delayButtonStateReset && (button[i].events & BUTTON_EVENT_PRESSED_FOR_X1_SEC)) 
 8007414:	4b07      	ldr	r3, [pc, #28]	; (8007434 <CheckAttachedButtons+0x2bc>)
 8007416:	781a      	ldrb	r2, [r3, #0]
 8007418:	2a00      	cmp	r2, #0
 800741a:	d1d7      	bne.n	80073cc <CheckAttachedButtons+0x254>
 800741c:	9a03      	ldr	r2, [sp, #12]
 800741e:	7a12      	ldrb	r2, [r2, #8]
 8007420:	0752      	lsls	r2, r2, #29
 8007422:	d5d3      	bpl.n	80073cc <CheckAttachedButtons+0x254>
						buttonPressedForXCallback(i, PRESSED_FOR_X1_SEC-8);
 8007424:	2101      	movs	r1, #1
						delayButtonStateReset = true;
 8007426:	701c      	strb	r4, [r3, #0]
						buttonPressedForXCallback(i, PRESSED_FOR_X2_SEC-8);
 8007428:	0028      	movs	r0, r5
 800742a:	f7ff fe5f 	bl	80070ec <buttonPressedForXCallback>
 800742e:	e7cd      	b.n	80073cc <CheckAttachedButtons+0x254>
 8007430:	20001458 	.word	0x20001458
 8007434:	20001495 	.word	0x20001495
 8007438:	20001498 	.word	0x20001498
 800743c:	0000fffe 	.word	0x0000fffe
 8007440:	20006f70 	.word	0x20006f70
 8007444:	200014b0 	.word	0x200014b0
 8007448:	2000148e 	.word	0x2000148e
 800744c:	2000148f 	.word	0x2000148f
 8007450:	0000fe0a 	.word	0x0000fe0a
					if (!delayButtonStateReset && (button[i].events & BUTTON_EVENT_PRESSED_FOR_X2_SEC)) 
 8007454:	4b1e      	ldr	r3, [pc, #120]	; (80074d0 <CheckAttachedButtons+0x358>)
 8007456:	781a      	ldrb	r2, [r3, #0]
 8007458:	2a00      	cmp	r2, #0
 800745a:	d1b7      	bne.n	80073cc <CheckAttachedButtons+0x254>
 800745c:	9a03      	ldr	r2, [sp, #12]
 800745e:	7a12      	ldrb	r2, [r2, #8]
 8007460:	0712      	lsls	r2, r2, #28
 8007462:	d5b3      	bpl.n	80073cc <CheckAttachedButtons+0x254>
						delayButtonStateReset = true;
 8007464:	701c      	strb	r4, [r3, #0]
						buttonPressedForXCallback(i, PRESSED_FOR_X2_SEC-8);
 8007466:	2102      	movs	r1, #2
 8007468:	e7de      	b.n	8007428 <CheckAttachedButtons+0x2b0>
					if (!delayButtonStateReset && (button[i].events & BUTTON_EVENT_PRESSED_FOR_X3_SEC)) 
 800746a:	4b19      	ldr	r3, [pc, #100]	; (80074d0 <CheckAttachedButtons+0x358>)
 800746c:	781a      	ldrb	r2, [r3, #0]
 800746e:	2a00      	cmp	r2, #0
 8007470:	d1ac      	bne.n	80073cc <CheckAttachedButtons+0x254>
 8007472:	9a03      	ldr	r2, [sp, #12]
 8007474:	7a12      	ldrb	r2, [r2, #8]
 8007476:	06d2      	lsls	r2, r2, #27
 8007478:	d5a8      	bpl.n	80073cc <CheckAttachedButtons+0x254>
						delayButtonStateReset = true;
 800747a:	701c      	strb	r4, [r3, #0]
						buttonPressedForXCallback(i, PRESSED_FOR_X3_SEC-8);
 800747c:	2103      	movs	r1, #3
 800747e:	e7d3      	b.n	8007428 <CheckAttachedButtons+0x2b0>
					if (!delayButtonStateReset && (button[i].events & BUTTON_EVENT_RELEASED_FOR_Y1_SEC)) 
 8007480:	4b13      	ldr	r3, [pc, #76]	; (80074d0 <CheckAttachedButtons+0x358>)
 8007482:	781a      	ldrb	r2, [r3, #0]
 8007484:	2a00      	cmp	r2, #0
 8007486:	d1a1      	bne.n	80073cc <CheckAttachedButtons+0x254>
 8007488:	9a03      	ldr	r2, [sp, #12]
 800748a:	7a12      	ldrb	r2, [r2, #8]
 800748c:	0692      	lsls	r2, r2, #26
 800748e:	d59d      	bpl.n	80073cc <CheckAttachedButtons+0x254>
						buttonReleasedForYCallback(i, RELEASED_FOR_Y1_SEC-11);
 8007490:	2101      	movs	r1, #1
						delayButtonStateReset = true;
 8007492:	701c      	strb	r4, [r3, #0]
						buttonReleasedForYCallback(i, RELEASED_FOR_Y3_SEC-11);
 8007494:	0028      	movs	r0, r5
 8007496:	f7ff fe2a 	bl	80070ee <buttonReleasedForYCallback>
 800749a:	e797      	b.n	80073cc <CheckAttachedButtons+0x254>
					if (!delayButtonStateReset && (button[i].events & BUTTON_EVENT_RELEASED_FOR_Y2_SEC)) 
 800749c:	4b0c      	ldr	r3, [pc, #48]	; (80074d0 <CheckAttachedButtons+0x358>)
 800749e:	781a      	ldrb	r2, [r3, #0]
 80074a0:	2a00      	cmp	r2, #0
 80074a2:	d000      	beq.n	80074a6 <CheckAttachedButtons+0x32e>
 80074a4:	e792      	b.n	80073cc <CheckAttachedButtons+0x254>
 80074a6:	9a03      	ldr	r2, [sp, #12]
 80074a8:	7a12      	ldrb	r2, [r2, #8]
 80074aa:	0652      	lsls	r2, r2, #25
 80074ac:	d400      	bmi.n	80074b0 <CheckAttachedButtons+0x338>
 80074ae:	e78d      	b.n	80073cc <CheckAttachedButtons+0x254>
						delayButtonStateReset = true;
 80074b0:	701c      	strb	r4, [r3, #0]
						buttonReleasedForYCallback(i, RELEASED_FOR_Y2_SEC-11);
 80074b2:	2102      	movs	r1, #2
 80074b4:	e7ee      	b.n	8007494 <CheckAttachedButtons+0x31c>
					if (!delayButtonStateReset && (button[i].events & BUTTON_EVENT_RELEASED_FOR_Y3_SEC)) 
 80074b6:	4b06      	ldr	r3, [pc, #24]	; (80074d0 <CheckAttachedButtons+0x358>)
 80074b8:	781a      	ldrb	r2, [r3, #0]
 80074ba:	2a00      	cmp	r2, #0
 80074bc:	d000      	beq.n	80074c0 <CheckAttachedButtons+0x348>
 80074be:	e785      	b.n	80073cc <CheckAttachedButtons+0x254>
 80074c0:	9a03      	ldr	r2, [sp, #12]
 80074c2:	7a12      	ldrb	r2, [r2, #8]
 80074c4:	2a7f      	cmp	r2, #127	; 0x7f
 80074c6:	d800      	bhi.n	80074ca <CheckAttachedButtons+0x352>
 80074c8:	e780      	b.n	80073cc <CheckAttachedButtons+0x254>
						delayButtonStateReset = true;
 80074ca:	701c      	strb	r4, [r3, #0]
						buttonReleasedForYCallback(i, RELEASED_FOR_Y3_SEC-11);
 80074cc:	2103      	movs	r1, #3
 80074ce:	e7e1      	b.n	8007494 <CheckAttachedButtons+0x31c>
 80074d0:	20001495 	.word	0x20001495

080074d4 <AddPortButton>:
/* --- Define a new button attached to one of array ports
					buttonType: MOMENTARY_NO, MOMENTARY_NC, ONOFF_NO, ONOFF_NC
					port: array port (P1 - Px)
*/
BOS_Status AddPortButton(uint8_t buttonType, uint8_t port)
{
 80074d4:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t TX_Port, RX_Port; 
	uint16_t TX_Pin, RX_Pin, temp16, res;
	uint8_t temp8 = 0;
	
	/* 1. Stop communication at this port (only if the scheduler is running) - TODO update*/
	if (BOS_initialized) {
 80074d6:	4d41      	ldr	r5, [pc, #260]	; (80075dc <AddPortButton+0x108>)
{
 80074d8:	b08f      	sub	sp, #60	; 0x3c
	if (BOS_initialized) {
 80074da:	782b      	ldrb	r3, [r5, #0]
{
 80074dc:	9003      	str	r0, [sp, #12]
 80074de:	000c      	movs	r4, r1
	if (BOS_initialized) {
 80074e0:	2b00      	cmp	r3, #0
 80074e2:	d008      	beq.n	80074f6 <AddPortButton+0x22>
		osSemaphoreRelease(PxRxSemaphoreHandle[port]);		/* Give back the semaphore if it was taken */
 80074e4:	4b3e      	ldr	r3, [pc, #248]	; (80075e0 <AddPortButton+0x10c>)
 80074e6:	008e      	lsls	r6, r1, #2
 80074e8:	58f0      	ldr	r0, [r6, r3]
 80074ea:	f008 f99f 	bl	800f82c <osSemaphoreRelease>
		osSemaphoreRelease(PxTxSemaphoreHandle[port]);
 80074ee:	4b3d      	ldr	r3, [pc, #244]	; (80075e4 <AddPortButton+0x110>)
 80074f0:	58f0      	ldr	r0, [r6, r3]
 80074f2:	f008 f99b 	bl	800f82c <osSemaphoreRelease>
	}
	portStatus[port] = PORTBUTTON;	
 80074f6:	2204      	movs	r2, #4
 80074f8:	4b3b      	ldr	r3, [pc, #236]	; (80075e8 <AddPortButton+0x114>)
 80074fa:	551a      	strb	r2, [r3, r4]
	
	/* 2. Deinitialize UART (only if module is initialized) */
	if (BOS_initialized) {
 80074fc:	782b      	ldrb	r3, [r5, #0]
 80074fe:	2b00      	cmp	r3, #0
 8007500:	d004      	beq.n	800750c <AddPortButton+0x38>
		HAL_UART_DeInit(GetUart(port));
 8007502:	0020      	movs	r0, r4
 8007504:	f005 ff7c 	bl	800d400 <GetUart>
 8007508:	f00c f910 	bl	801372c <HAL_UART_DeInit>
	}
	
	/* 3. Initialize GPIOs */
	GetPortGPIOs(port, &TX_Port, &TX_Pin, &RX_Port, &RX_Pin);		
 800750c:	260e      	movs	r6, #14
 800750e:	ab02      	add	r3, sp, #8
 8007510:	18f6      	adds	r6, r6, r3
 8007512:	ad06      	add	r5, sp, #24
 8007514:	0032      	movs	r2, r6
 8007516:	9500      	str	r5, [sp, #0]
 8007518:	ab08      	add	r3, sp, #32
 800751a:	a907      	add	r1, sp, #28
 800751c:	0020      	movs	r0, r4
 800751e:	f004 fd89 	bl	800c034 <GetPortGPIOs>
	/* Ouput (TXD) */
	GPIO_InitStruct.Pin = TX_Pin;
 8007522:	8833      	ldrh	r3, [r6, #0]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007524:	2600      	movs	r6, #0
	GPIO_InitStruct.Pin = TX_Pin;
 8007526:	9309      	str	r3, [sp, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8007528:	2301      	movs	r3, #1
	GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
	HAL_GPIO_Init((GPIO_TypeDef *)TX_Port, &GPIO_InitStruct);
 800752a:	a909      	add	r1, sp, #36	; 0x24
 800752c:	9807      	ldr	r0, [sp, #28]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800752e:	930a      	str	r3, [sp, #40]	; 0x28
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007530:	960b      	str	r6, [sp, #44]	; 0x2c
	GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8007532:	960c      	str	r6, [sp, #48]	; 0x30
	HAL_GPIO_Init((GPIO_TypeDef *)TX_Port, &GPIO_InitStruct);
 8007534:	f00a fe32 	bl	801219c <HAL_GPIO_Init>
	/* Input (RXD) */
	GPIO_InitStruct.Pin = RX_Pin;
 8007538:	882b      	ldrh	r3, [r5, #0]
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init((GPIO_TypeDef *)RX_Port, &GPIO_InitStruct);
 800753a:	a909      	add	r1, sp, #36	; 0x24
	GPIO_InitStruct.Pin = RX_Pin;
 800753c:	9309      	str	r3, [sp, #36]	; 0x24
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 800753e:	2302      	movs	r3, #2
	HAL_GPIO_Init((GPIO_TypeDef *)RX_Port, &GPIO_InitStruct);
 8007540:	9808      	ldr	r0, [sp, #32]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8007542:	930b      	str	r3, [sp, #44]	; 0x2c
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8007544:	960a      	str	r6, [sp, #40]	; 0x28
	HAL_GPIO_Init((GPIO_TypeDef *)RX_Port, &GPIO_InitStruct);
 8007546:	f00a fe29 	bl	801219c <HAL_GPIO_Init>

	/* 4. Update button struct */
	button[port].type = buttonType;	
 800754a:	2209      	movs	r2, #9
	
	/* 5. Add to EEPROM if not already there */
	res = EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1), &temp16);
 800754c:	0025      	movs	r5, r4
 800754e:	2712      	movs	r7, #18
	button[port].type = buttonType;	
 8007550:	4362      	muls	r2, r4
 8007552:	4b26      	ldr	r3, [pc, #152]	; (80075ec <AddPortButton+0x118>)
	res = EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1), &temp16);
 8007554:	353a      	adds	r5, #58	; 0x3a
	button[port].type = buttonType;	
 8007556:	189b      	adds	r3, r3, r2
 8007558:	9a03      	ldr	r2, [sp, #12]
	res = EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1), &temp16);
 800755a:	00ad      	lsls	r5, r5, #2
	button[port].type = buttonType;	
 800755c:	705a      	strb	r2, [r3, #1]
	res = EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1), &temp16);
 800755e:	ab02      	add	r3, sp, #8
 8007560:	18ff      	adds	r7, r7, r3
 8007562:	0039      	movs	r1, r7
 8007564:	0028      	movs	r0, r5
 8007566:	f7ff fa1f 	bl	80069a8 <EE_ReadVariable>
	if(!res)																														// This variable exists
 800756a:	42b0      	cmp	r0, r6
 800756c:	d121      	bne.n	80075b2 <AddPortButton+0xde>
	{
		temp8 = (uint8_t)(temp16 >> 8);
 800756e:	883b      	ldrh	r3, [r7, #0]
 8007570:	0a1b      	lsrs	r3, r3, #8
		if ( ((temp8 >> 4) == port) && ((temp8 & 0x0F) == buttonType) )		// This is same port and same type, do not update
 8007572:	091a      	lsrs	r2, r3, #4
 8007574:	42a2      	cmp	r2, r4
 8007576:	d104      	bne.n	8007582 <AddPortButton+0xae>
 8007578:	220f      	movs	r2, #15
 800757a:	4013      	ands	r3, r2
 800757c:	9a03      	ldr	r2, [sp, #12]
 800757e:	4293      	cmp	r3, r2
 8007580:	d014      	beq.n	80075ac <AddPortButton+0xd8>
			return BOS_OK;
		else 																															// Update the variable
		{																														
			temp16 = ((uint16_t)port << 12) | ((uint16_t)buttonType << 8);
 8007582:	9b03      	ldr	r3, [sp, #12]
 8007584:	0324      	lsls	r4, r4, #12
 8007586:	0219      	lsls	r1, r3, #8
 8007588:	4321      	orrs	r1, r4
 800758a:	b289      	uxth	r1, r1
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1), temp16);
 800758c:	0028      	movs	r0, r5
			temp16 = ((uint16_t)port << 12) | ((uint16_t)buttonType << 8);
 800758e:	8039      	strh	r1, [r7, #0]
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1), temp16);
 8007590:	f7ff fa34 	bl	80069fc <EE_WriteVariable>
			/* Reset times */
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+1, 0);
 8007594:	2100      	movs	r1, #0
 8007596:	1c68      	adds	r0, r5, #1
 8007598:	f7ff fa30 	bl	80069fc <EE_WriteVariable>
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+2, 0);
 800759c:	2100      	movs	r1, #0
 800759e:	1ca8      	adds	r0, r5, #2
 80075a0:	f7ff fa2c 	bl	80069fc <EE_WriteVariable>
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+3, 0);
 80075a4:	2100      	movs	r1, #0
 80075a6:	1ce8      	adds	r0, r5, #3
	  	temp16 = ((uint16_t)port << 12) | ((uint16_t)buttonType << 8);
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1), temp16);		
	  	/* Reset times */
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+1, 0);
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+2, 0);
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+3, 0);
 80075a8:	f7ff fa28 	bl	80069fc <EE_WriteVariable>
	}
	
	return result;
}
 80075ac:	2000      	movs	r0, #0
 80075ae:	b00f      	add	sp, #60	; 0x3c
 80075b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	  	temp16 = ((uint16_t)port << 12) | ((uint16_t)buttonType << 8);
 80075b2:	9b03      	ldr	r3, [sp, #12]
 80075b4:	0324      	lsls	r4, r4, #12
 80075b6:	0219      	lsls	r1, r3, #8
 80075b8:	4321      	orrs	r1, r4
 80075ba:	b289      	uxth	r1, r1
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1), temp16);		
 80075bc:	0028      	movs	r0, r5
	  	temp16 = ((uint16_t)port << 12) | ((uint16_t)buttonType << 8);
 80075be:	8039      	strh	r1, [r7, #0]
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1), temp16);		
 80075c0:	f7ff fa1c 	bl	80069fc <EE_WriteVariable>
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+1, 0);
 80075c4:	0031      	movs	r1, r6
 80075c6:	1c68      	adds	r0, r5, #1
 80075c8:	f7ff fa18 	bl	80069fc <EE_WriteVariable>
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+2, 0);
 80075cc:	0031      	movs	r1, r6
 80075ce:	1ca8      	adds	r0, r5, #2
 80075d0:	f7ff fa14 	bl	80069fc <EE_WriteVariable>
	  	EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+3, 0);
 80075d4:	1ce8      	adds	r0, r5, #3
 80075d6:	0031      	movs	r1, r6
 80075d8:	e7e6      	b.n	80075a8 <AddPortButton+0xd4>
 80075da:	46c0      	nop			; (mov r8, r8)
 80075dc:	20000a9d 	.word	0x20000a9d
 80075e0:	2000700c 	.word	0x2000700c
 80075e4:	20006ff0 	.word	0x20006ff0
 80075e8:	200010b2 	.word	0x200010b2
 80075ec:	20001458 	.word	0x20001458

080075f0 <RemovePortButton>:

/* --- Undefine a button attached to one of array ports and restore the port to default state
					port: array port (P1 - Px)
*/
BOS_Status RemovePortButton(uint8_t port)
{
 80075f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80075f2:	0004      	movs	r4, r0
	BOS_Status result = BOS_OK;
	uint16_t res, temp16;
	
	/* 1. Remove from button struct */
	button[port].type = NONE;
 80075f4:	2109      	movs	r1, #9
 80075f6:	2300      	movs	r3, #0
 80075f8:	4361      	muls	r1, r4
 80075fa:	4830      	ldr	r0, [pc, #192]	; (80076bc <RemovePortButton+0xcc>)
	button[port].events = 0;
	button[port].pressedX1Sec = 0; button[port].pressedX2Sec = 0; button[port].pressedX3Sec = 0;
	button[port].releasedY1Sec = 0; button[port].releasedY2Sec = 0; button[port].releasedY3Sec = 0;
	
	/* 2. Remove from EEPROM if it's already there */
	res = EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1), &temp16);
 80075fc:	0025      	movs	r5, r4
	button[port].type = NONE;
 80075fe:	1842      	adds	r2, r0, r1
	button[port].state = NONE;
 8007600:	540b      	strb	r3, [r1, r0]
	button[port].type = NONE;
 8007602:	7053      	strb	r3, [r2, #1]
	button[port].events = 0;
 8007604:	7213      	strb	r3, [r2, #8]
	button[port].pressedX1Sec = 0; button[port].pressedX2Sec = 0; button[port].pressedX3Sec = 0;
 8007606:	7093      	strb	r3, [r2, #2]
 8007608:	70d3      	strb	r3, [r2, #3]
 800760a:	7113      	strb	r3, [r2, #4]
	button[port].releasedY1Sec = 0; button[port].releasedY2Sec = 0; button[port].releasedY3Sec = 0;
 800760c:	7153      	strb	r3, [r2, #5]
 800760e:	7193      	strb	r3, [r2, #6]
 8007610:	71d3      	strb	r3, [r2, #7]
	res = EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1), &temp16);
 8007612:	466b      	mov	r3, sp
 8007614:	353a      	adds	r5, #58	; 0x3a
 8007616:	00ad      	lsls	r5, r5, #2
 8007618:	1d99      	adds	r1, r3, #6
 800761a:	0028      	movs	r0, r5
 800761c:	f7ff f9c4 	bl	80069a8 <EE_ReadVariable>
 8007620:	1e06      	subs	r6, r0, #0
	if(!res)																														// This variable exists, reset all to zeros
 8007622:	d10f      	bne.n	8007644 <RemovePortButton+0x54>
	{
		EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1), 0);
 8007624:	0001      	movs	r1, r0
 8007626:	0028      	movs	r0, r5
 8007628:	f7ff f9e8 	bl	80069fc <EE_WriteVariable>
		/* Reset times */
		EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+1, 0);
 800762c:	0031      	movs	r1, r6
 800762e:	1c68      	adds	r0, r5, #1
 8007630:	f7ff f9e4 	bl	80069fc <EE_WriteVariable>
		EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+2, 0);
 8007634:	0031      	movs	r1, r6
 8007636:	1ca8      	adds	r0, r5, #2
 8007638:	f7ff f9e0 	bl	80069fc <EE_WriteVariable>
		EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+3, 0);		
 800763c:	1ce8      	adds	r0, r5, #3
 800763e:	0031      	movs	r1, r6
 8007640:	f7ff f9dc 	bl	80069fc <EE_WriteVariable>
	}
	
	/* 3. Initialize UART at this port */
	UART_HandleTypeDef* huart = GetUart(port);
 8007644:	0020      	movs	r0, r4
 8007646:	f005 fedb 	bl	800d400 <GetUart>
	
	if (huart->Instance == USART1) 
 800764a:	4a1d      	ldr	r2, [pc, #116]	; (80076c0 <RemovePortButton+0xd0>)
 800764c:	6803      	ldr	r3, [r0, #0]
	UART_HandleTypeDef* huart = GetUart(port);
 800764e:	0005      	movs	r5, r0
	if (huart->Instance == USART1) 
 8007650:	4293      	cmp	r3, r2
 8007652:	d10c      	bne.n	800766e <RemovePortButton+0x7e>
	{	
#ifdef _Usart1		
		MX_USART1_UART_Init();
 8007654:	f005 fd7c 	bl	800d150 <MX_USART1_UART_Init>
	BOS_Status result = BOS_OK;
 8007658:	2600      	movs	r6, #0
	} 
	else
		result = BOS_ERROR;			
	
	/* 4. Start scanning this port */
	portStatus[port] = FREE;
 800765a:	2200      	movs	r2, #0
 800765c:	4b19      	ldr	r3, [pc, #100]	; (80076c4 <RemovePortButton+0xd4>)
	/* Read this port again */
	HAL_UART_Receive_IT(huart, (uint8_t *)&cRxedChar, 1);	
 800765e:	0028      	movs	r0, r5
	portStatus[port] = FREE;
 8007660:	551a      	strb	r2, [r3, r4]
	HAL_UART_Receive_IT(huart, (uint8_t *)&cRxedChar, 1);	
 8007662:	4919      	ldr	r1, [pc, #100]	; (80076c8 <RemovePortButton+0xd8>)
 8007664:	3201      	adds	r2, #1
 8007666:	f00c f8b3 	bl	80137d0 <HAL_UART_Receive_IT>
	
	return result;
}
 800766a:	0030      	movs	r0, r6
 800766c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
	else if (huart->Instance == USART2) 
 800766e:	4a17      	ldr	r2, [pc, #92]	; (80076cc <RemovePortButton+0xdc>)
 8007670:	4293      	cmp	r3, r2
 8007672:	d102      	bne.n	800767a <RemovePortButton+0x8a>
		MX_USART2_UART_Init();
 8007674:	f005 fd84 	bl	800d180 <MX_USART2_UART_Init>
 8007678:	e7ee      	b.n	8007658 <RemovePortButton+0x68>
	else if (huart->Instance == USART3) 
 800767a:	4a15      	ldr	r2, [pc, #84]	; (80076d0 <RemovePortButton+0xe0>)
 800767c:	4293      	cmp	r3, r2
 800767e:	d102      	bne.n	8007686 <RemovePortButton+0x96>
		MX_USART3_UART_Init();
 8007680:	f005 fd96 	bl	800d1b0 <MX_USART3_UART_Init>
 8007684:	e7e8      	b.n	8007658 <RemovePortButton+0x68>
	else if (huart->Instance == USART4) 
 8007686:	4a13      	ldr	r2, [pc, #76]	; (80076d4 <RemovePortButton+0xe4>)
 8007688:	4293      	cmp	r3, r2
 800768a:	d102      	bne.n	8007692 <RemovePortButton+0xa2>
		MX_USART4_UART_Init();
 800768c:	f005 fda8 	bl	800d1e0 <MX_USART4_UART_Init>
 8007690:	e7e2      	b.n	8007658 <RemovePortButton+0x68>
	else if (huart->Instance == USART5) 
 8007692:	4a11      	ldr	r2, [pc, #68]	; (80076d8 <RemovePortButton+0xe8>)
 8007694:	4293      	cmp	r3, r2
 8007696:	d102      	bne.n	800769e <RemovePortButton+0xae>
		MX_USART5_UART_Init();
 8007698:	f005 fdba 	bl	800d210 <MX_USART5_UART_Init>
 800769c:	e7dc      	b.n	8007658 <RemovePortButton+0x68>
	else if (huart->Instance == USART6) 
 800769e:	4a0f      	ldr	r2, [pc, #60]	; (80076dc <RemovePortButton+0xec>)
	BOS_Status result = BOS_OK;
 80076a0:	2600      	movs	r6, #0
	else if (huart->Instance == USART6) 
 80076a2:	4293      	cmp	r3, r2
 80076a4:	d0d9      	beq.n	800765a <RemovePortButton+0x6a>
	else if (huart->Instance == USART7) 
 80076a6:	4a0e      	ldr	r2, [pc, #56]	; (80076e0 <RemovePortButton+0xf0>)
 80076a8:	4293      	cmp	r3, r2
 80076aa:	d0d6      	beq.n	800765a <RemovePortButton+0x6a>
	else if (huart->Instance == USART8) 
 80076ac:	4a0d      	ldr	r2, [pc, #52]	; (80076e4 <RemovePortButton+0xf4>)
 80076ae:	189b      	adds	r3, r3, r2
 80076b0:	1e5a      	subs	r2, r3, #1
 80076b2:	4193      	sbcs	r3, r2
 80076b4:	425b      	negs	r3, r3
 80076b6:	b2de      	uxtb	r6, r3
 80076b8:	e7cf      	b.n	800765a <RemovePortButton+0x6a>
 80076ba:	46c0      	nop			; (mov r8, r8)
 80076bc:	20001458 	.word	0x20001458
 80076c0:	40013800 	.word	0x40013800
 80076c4:	200010b2 	.word	0x200010b2
 80076c8:	20000e2b 	.word	0x20000e2b
 80076cc:	40004400 	.word	0x40004400
 80076d0:	40004800 	.word	0x40004800
 80076d4:	40004c00 	.word	0x40004c00
 80076d8:	40005000 	.word	0x40005000
 80076dc:	40011400 	.word	0x40011400
 80076e0:	40011800 	.word	0x40011800
 80076e4:	bffee400 	.word	0xbffee400

080076e8 <SetButtonEvents>:
					released_x1sec, released_x1sec, released_x1sec: Release time for events Y1, Y2 and Y3 in seconds. Use 0 to disable the event. 
					mode: BUTTON_EVENT_MODE_CLEAR to clear events marked with 0, BUTTON_EVENT_MODE_OR to OR events marked with 1 with existing events.
*/
BOS_Status SetButtonEvents(uint8_t port, uint8_t clicked, uint8_t dbl_clicked, uint8_t pressed_x1sec, uint8_t pressed_x2sec, uint8_t pressed_x3sec,\
													uint8_t released_y1sec, uint8_t released_y2sec, uint8_t released_y3sec, uint8_t mode)
{
 80076e8:	b5f0      	push	{r4, r5, r6, r7, lr}
	BOS_Status result = BOS_OK;	
	uint16_t res, temp16; uint8_t temp8;
	
	if (button[port].type == NONE)
 80076ea:	2509      	movs	r5, #9
{
 80076ec:	b089      	sub	sp, #36	; 0x24
 80076ee:	9302      	str	r3, [sp, #8]
 80076f0:	ab0e      	add	r3, sp, #56	; 0x38
 80076f2:	781b      	ldrb	r3, [r3, #0]
	if (button[port].type == NONE)
 80076f4:	4345      	muls	r5, r0
{
 80076f6:	9303      	str	r3, [sp, #12]
 80076f8:	ab0f      	add	r3, sp, #60	; 0x3c
 80076fa:	781b      	ldrb	r3, [r3, #0]
 80076fc:	0004      	movs	r4, r0
 80076fe:	9304      	str	r3, [sp, #16]
 8007700:	ab10      	add	r3, sp, #64	; 0x40
 8007702:	781e      	ldrb	r6, [r3, #0]
 8007704:	ab11      	add	r3, sp, #68	; 0x44
 8007706:	781b      	ldrb	r3, [r3, #0]
	if (button[port].type == NONE)
 8007708:	48ad      	ldr	r0, [pc, #692]	; (80079c0 <SetButtonEvents+0x2d8>)
{
 800770a:	9301      	str	r3, [sp, #4]
 800770c:	ab12      	add	r3, sp, #72	; 0x48
 800770e:	781b      	ldrb	r3, [r3, #0]
	if (button[port].type == NONE)
 8007710:	1940      	adds	r0, r0, r5
 8007712:	7845      	ldrb	r5, [r0, #1]
{
 8007714:	9305      	str	r3, [sp, #20]
 8007716:	ab13      	add	r3, sp, #76	; 0x4c
 8007718:	781b      	ldrb	r3, [r3, #0]
	if (button[port].type == NONE)
 800771a:	2d00      	cmp	r5, #0
 800771c:	d103      	bne.n	8007726 <SetButtonEvents+0x3e>
		return BOS_ERR_BUTTON_NOT_DEFINED;
 800771e:	240b      	movs	r4, #11
	else																																// Variable does not exist. Return error
		return BOS_ERR_BUTTON_NOT_DEFINED;	
		
	
	return result;
}
 8007720:	0020      	movs	r0, r4
 8007722:	b009      	add	sp, #36	; 0x24
 8007724:	bdf0      	pop	{r4, r5, r6, r7, pc}
	button[port].pressedX1Sec = pressed_x1sec; button[port].pressedX2Sec = pressed_x2sec; button[port].pressedX3Sec = pressed_x3sec;
 8007726:	9d02      	ldr	r5, [sp, #8]
	button[port].releasedY1Sec = released_y1sec; button[port].releasedY2Sec = released_y2sec; button[port].releasedY3Sec = released_y3sec;
 8007728:	7146      	strb	r6, [r0, #5]
	button[port].pressedX1Sec = pressed_x1sec; button[port].pressedX2Sec = pressed_x2sec; button[port].pressedX3Sec = pressed_x3sec;
 800772a:	7085      	strb	r5, [r0, #2]
 800772c:	9d03      	ldr	r5, [sp, #12]
 800772e:	70c5      	strb	r5, [r0, #3]
 8007730:	9d04      	ldr	r5, [sp, #16]
 8007732:	7105      	strb	r5, [r0, #4]
	button[port].releasedY1Sec = released_y1sec; button[port].releasedY2Sec = released_y2sec; button[port].releasedY3Sec = released_y3sec;
 8007734:	9d01      	ldr	r5, [sp, #4]
 8007736:	7185      	strb	r5, [r0, #6]
 8007738:	9d05      	ldr	r5, [sp, #20]
 800773a:	71c5      	strb	r5, [r0, #7]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && clicked)) {				
 800773c:	2b01      	cmp	r3, #1
 800773e:	d005      	beq.n	800774c <SetButtonEvents+0x64>
 8007740:	2b00      	cmp	r3, #0
 8007742:	d000      	beq.n	8007746 <SetButtonEvents+0x5e>
 8007744:	e0be      	b.n	80078c4 <SetButtonEvents+0x1dc>
 8007746:	2900      	cmp	r1, #0
 8007748:	d100      	bne.n	800774c <SetButtonEvents+0x64>
 800774a:	e0bb      	b.n	80078c4 <SetButtonEvents+0x1dc>
		button[port].events |= BUTTON_EVENT_CLICKED;
 800774c:	2109      	movs	r1, #9
 800774e:	4361      	muls	r1, r4
 8007750:	489b      	ldr	r0, [pc, #620]	; (80079c0 <SetButtonEvents+0x2d8>)
 8007752:	1841      	adds	r1, r0, r1
 8007754:	2001      	movs	r0, #1
 8007756:	7a0d      	ldrb	r5, [r1, #8]
 8007758:	4328      	orrs	r0, r5
 800775a:	7208      	strb	r0, [r1, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && dbl_clicked)) {		
 800775c:	2b01      	cmp	r3, #1
 800775e:	d000      	beq.n	8007762 <SetButtonEvents+0x7a>
 8007760:	e0be      	b.n	80078e0 <SetButtonEvents+0x1f8>
		button[port].events |= BUTTON_EVENT_DBL_CLICKED;
 8007762:	2109      	movs	r1, #9
 8007764:	4361      	muls	r1, r4
 8007766:	4a96      	ldr	r2, [pc, #600]	; (80079c0 <SetButtonEvents+0x2d8>)
 8007768:	1852      	adds	r2, r2, r1
 800776a:	2102      	movs	r1, #2
 800776c:	7a10      	ldrb	r0, [r2, #8]
 800776e:	4301      	orrs	r1, r0
 8007770:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && pressed_x1sec)) {			
 8007772:	2b01      	cmp	r3, #1
 8007774:	d100      	bne.n	8007778 <SetButtonEvents+0x90>
 8007776:	e0c4      	b.n	8007902 <SetButtonEvents+0x21a>
 8007778:	2b00      	cmp	r3, #0
 800777a:	d100      	bne.n	800777e <SetButtonEvents+0x96>
 800777c:	e0bd      	b.n	80078fa <SetButtonEvents+0x212>
	} else if (mode == BUTTON_EVENT_MODE_CLEAR && !pressed_x1sec) {
 800777e:	9a02      	ldr	r2, [sp, #8]
 8007780:	431a      	orrs	r2, r3
 8007782:	d000      	beq.n	8007786 <SetButtonEvents+0x9e>
 8007784:	e0c7      	b.n	8007916 <SetButtonEvents+0x22e>
		button[port].events &= ~BUTTON_EVENT_PRESSED_FOR_X1_SEC;		
 8007786:	2109      	movs	r1, #9
 8007788:	2004      	movs	r0, #4
 800778a:	4361      	muls	r1, r4
 800778c:	4a8c      	ldr	r2, [pc, #560]	; (80079c0 <SetButtonEvents+0x2d8>)
 800778e:	1852      	adds	r2, r2, r1
 8007790:	7a11      	ldrb	r1, [r2, #8]
 8007792:	4381      	bics	r1, r0
 8007794:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && pressed_x2sec)) {		
 8007796:	9a03      	ldr	r2, [sp, #12]
 8007798:	2a00      	cmp	r2, #0
 800779a:	d100      	bne.n	800779e <SetButtonEvents+0xb6>
 800779c:	e0be      	b.n	800791c <SetButtonEvents+0x234>
		button[port].events |= BUTTON_EVENT_PRESSED_FOR_X2_SEC;
 800779e:	2109      	movs	r1, #9
 80077a0:	4361      	muls	r1, r4
 80077a2:	4a87      	ldr	r2, [pc, #540]	; (80079c0 <SetButtonEvents+0x2d8>)
 80077a4:	1852      	adds	r2, r2, r1
 80077a6:	2108      	movs	r1, #8
 80077a8:	7a10      	ldrb	r0, [r2, #8]
 80077aa:	4301      	orrs	r1, r0
 80077ac:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && pressed_x3sec)) {		
 80077ae:	2b00      	cmp	r3, #0
 80077b0:	d100      	bne.n	80077b4 <SetButtonEvents+0xcc>
 80077b2:	e0bf      	b.n	8007934 <SetButtonEvents+0x24c>
	} else if (mode == BUTTON_EVENT_MODE_CLEAR && !pressed_x3sec) {
 80077b4:	9a04      	ldr	r2, [sp, #16]
 80077b6:	431a      	orrs	r2, r3
 80077b8:	d000      	beq.n	80077bc <SetButtonEvents+0xd4>
 80077ba:	e0c7      	b.n	800794c <SetButtonEvents+0x264>
		button[port].events &= ~BUTTON_EVENT_PRESSED_FOR_X3_SEC;		
 80077bc:	2010      	movs	r0, #16
 80077be:	3209      	adds	r2, #9
 80077c0:	4362      	muls	r2, r4
 80077c2:	497f      	ldr	r1, [pc, #508]	; (80079c0 <SetButtonEvents+0x2d8>)
 80077c4:	188a      	adds	r2, r1, r2
 80077c6:	7a11      	ldrb	r1, [r2, #8]
 80077c8:	4381      	bics	r1, r0
 80077ca:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && released_y1sec)) {		
 80077cc:	2e00      	cmp	r6, #0
 80077ce:	d000      	beq.n	80077d2 <SetButtonEvents+0xea>
 80077d0:	e0f1      	b.n	80079b6 <SetButtonEvents+0x2ce>
	} else if (mode == BUTTON_EVENT_MODE_CLEAR && !released_y1sec) {
 80077d2:	0032      	movs	r2, r6
 80077d4:	431a      	orrs	r2, r3
 80077d6:	d000      	beq.n	80077da <SetButtonEvents+0xf2>
 80077d8:	e0cc      	b.n	8007974 <SetButtonEvents+0x28c>
		button[port].events &= ~BUTTON_EVENT_RELEASED_FOR_Y1_SEC;		
 80077da:	2109      	movs	r1, #9
 80077dc:	2020      	movs	r0, #32
 80077de:	4361      	muls	r1, r4
 80077e0:	4a77      	ldr	r2, [pc, #476]	; (80079c0 <SetButtonEvents+0x2d8>)
 80077e2:	1852      	adds	r2, r2, r1
 80077e4:	7a11      	ldrb	r1, [r2, #8]
 80077e6:	4381      	bics	r1, r0
 80077e8:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && released_y2sec)) {		
 80077ea:	9a01      	ldr	r2, [sp, #4]
 80077ec:	2a00      	cmp	r2, #0
 80077ee:	d000      	beq.n	80077f2 <SetButtonEvents+0x10a>
 80077f0:	e0c7      	b.n	8007982 <SetButtonEvents+0x29a>
	} else if (mode == BUTTON_EVENT_MODE_CLEAR && !released_y2sec) {
 80077f2:	9a01      	ldr	r2, [sp, #4]
 80077f4:	431a      	orrs	r2, r3
 80077f6:	d000      	beq.n	80077fa <SetButtonEvents+0x112>
 80077f8:	e0ce      	b.n	8007998 <SetButtonEvents+0x2b0>
		button[port].events &= ~BUTTON_EVENT_RELEASED_FOR_Y2_SEC;		
 80077fa:	2209      	movs	r2, #9
 80077fc:	2140      	movs	r1, #64	; 0x40
 80077fe:	4362      	muls	r2, r4
 8007800:	4b6f      	ldr	r3, [pc, #444]	; (80079c0 <SetButtonEvents+0x2d8>)
 8007802:	189b      	adds	r3, r3, r2
 8007804:	7a1a      	ldrb	r2, [r3, #8]
 8007806:	438a      	bics	r2, r1
 8007808:	721a      	strb	r2, [r3, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && released_y3sec)) {		
 800780a:	9b05      	ldr	r3, [sp, #20]
 800780c:	2b00      	cmp	r3, #0
 800780e:	d100      	bne.n	8007812 <SetButtonEvents+0x12a>
 8007810:	e0c9      	b.n	80079a6 <SetButtonEvents+0x2be>
		button[port].events |= BUTTON_EVENT_RELEASED_FOR_Y3_SEC;	
 8007812:	2209      	movs	r2, #9
 8007814:	4362      	muls	r2, r4
 8007816:	4b6a      	ldr	r3, [pc, #424]	; (80079c0 <SetButtonEvents+0x2d8>)
 8007818:	189b      	adds	r3, r3, r2
 800781a:	2280      	movs	r2, #128	; 0x80
 800781c:	7a19      	ldrb	r1, [r3, #8]
 800781e:	4252      	negs	r2, r2
 8007820:	430a      	orrs	r2, r1
		button[port].events &= ~BUTTON_EVENT_RELEASED_FOR_Y3_SEC;		
 8007822:	721a      	strb	r2, [r3, #8]
	res = EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1), &temp16);
 8007824:	0025      	movs	r5, r4
 8007826:	ab06      	add	r3, sp, #24
 8007828:	353a      	adds	r5, #58	; 0x3a
 800782a:	00ad      	lsls	r5, r5, #2
 800782c:	1d9f      	adds	r7, r3, #6
 800782e:	0039      	movs	r1, r7
 8007830:	0028      	movs	r0, r5
 8007832:	f7ff f8b9 	bl	80069a8 <EE_ReadVariable>
	if(!res)																														// This variable exists
 8007836:	2800      	cmp	r0, #0
 8007838:	d000      	beq.n	800783c <SetButtonEvents+0x154>
 800783a:	e770      	b.n	800771e <SetButtonEvents+0x36>
		if ((uint8_t)(temp16) != button[port].events) {										// Update only if different
 800783c:	2209      	movs	r2, #9
 800783e:	4362      	muls	r2, r4
 8007840:	4c5f      	ldr	r4, [pc, #380]	; (80079c0 <SetButtonEvents+0x2d8>)
		temp8 = (uint8_t)(temp16 >> 8);																		// Keep upper byte
 8007842:	883b      	ldrh	r3, [r7, #0]
		if ((uint8_t)(temp16) != button[port].events) {										// Update only if different
 8007844:	18a4      	adds	r4, r4, r2
 8007846:	7a22      	ldrb	r2, [r4, #8]
 8007848:	b2d9      	uxtb	r1, r3
 800784a:	4291      	cmp	r1, r2
 800784c:	d006      	beq.n	800785c <SetButtonEvents+0x174>
			temp16 = ((uint16_t)temp8 << 8) | (uint16_t)button[port].events;
 800784e:	0a19      	lsrs	r1, r3, #8
 8007850:	0209      	lsls	r1, r1, #8
 8007852:	4311      	orrs	r1, r2
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1), temp16);
 8007854:	0028      	movs	r0, r5
			temp16 = ((uint16_t)temp8 << 8) | (uint16_t)button[port].events;
 8007856:	8039      	strh	r1, [r7, #0]
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1), temp16);
 8007858:	f7ff f8d0 	bl	80069fc <EE_WriteVariable>
		EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1)+1, &temp16);
 800785c:	ab06      	add	r3, sp, #24
 800785e:	1d9c      	adds	r4, r3, #6
 8007860:	1c6f      	adds	r7, r5, #1
 8007862:	0021      	movs	r1, r4
 8007864:	0038      	movs	r0, r7
 8007866:	f7ff f89f 	bl	80069a8 <EE_ReadVariable>
		if ( temp16 != (((uint16_t)pressed_x1sec << 8) | (uint16_t) released_y1sec) )
 800786a:	9b02      	ldr	r3, [sp, #8]
 800786c:	0219      	lsls	r1, r3, #8
 800786e:	8823      	ldrh	r3, [r4, #0]
 8007870:	4331      	orrs	r1, r6
 8007872:	428b      	cmp	r3, r1
 8007874:	d003      	beq.n	800787e <SetButtonEvents+0x196>
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+1, ((uint16_t)pressed_x1sec << 8) | (uint16_t) released_y1sec);
 8007876:	b289      	uxth	r1, r1
 8007878:	0038      	movs	r0, r7
 800787a:	f7ff f8bf 	bl	80069fc <EE_WriteVariable>
		EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1)+2, &temp16);
 800787e:	1cae      	adds	r6, r5, #2
 8007880:	0021      	movs	r1, r4
 8007882:	0030      	movs	r0, r6
 8007884:	f7ff f890 	bl	80069a8 <EE_ReadVariable>
		if ( temp16 != (((uint16_t)pressed_x2sec << 8) | (uint16_t) released_y2sec) )
 8007888:	9b03      	ldr	r3, [sp, #12]
 800788a:	9a01      	ldr	r2, [sp, #4]
 800788c:	0219      	lsls	r1, r3, #8
 800788e:	8823      	ldrh	r3, [r4, #0]
 8007890:	430a      	orrs	r2, r1
 8007892:	4293      	cmp	r3, r2
 8007894:	d003      	beq.n	800789e <SetButtonEvents+0x1b6>
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+2, ((uint16_t)pressed_x2sec << 8) | (uint16_t) released_y2sec);
 8007896:	b291      	uxth	r1, r2
 8007898:	0030      	movs	r0, r6
 800789a:	f7ff f8af 	bl	80069fc <EE_WriteVariable>
		EE_ReadVariable(_EE_BUTTON_BASE+4*(port-1)+3, &temp16);
 800789e:	3503      	adds	r5, #3
 80078a0:	0021      	movs	r1, r4
 80078a2:	0028      	movs	r0, r5
 80078a4:	f7ff f880 	bl	80069a8 <EE_ReadVariable>
		if ( temp16 != (((uint16_t)pressed_x3sec << 8) | (uint16_t) released_y3sec) )
 80078a8:	9b04      	ldr	r3, [sp, #16]
 80078aa:	9a05      	ldr	r2, [sp, #20]
 80078ac:	0219      	lsls	r1, r3, #8
 80078ae:	8823      	ldrh	r3, [r4, #0]
 80078b0:	430a      	orrs	r2, r1
	return result;
 80078b2:	2400      	movs	r4, #0
		if ( temp16 != (((uint16_t)pressed_x3sec << 8) | (uint16_t) released_y3sec) )
 80078b4:	4293      	cmp	r3, r2
 80078b6:	d100      	bne.n	80078ba <SetButtonEvents+0x1d2>
 80078b8:	e732      	b.n	8007720 <SetButtonEvents+0x38>
			EE_WriteVariable(_EE_BUTTON_BASE+4*(port-1)+3, ((uint16_t)pressed_x3sec << 8) | (uint16_t) released_y3sec);
 80078ba:	b291      	uxth	r1, r2
 80078bc:	0028      	movs	r0, r5
 80078be:	f7ff f89d 	bl	80069fc <EE_WriteVariable>
 80078c2:	e72d      	b.n	8007720 <SetButtonEvents+0x38>
	} else if (mode == BUTTON_EVENT_MODE_CLEAR && !clicked) {
 80078c4:	4319      	orrs	r1, r3
 80078c6:	d10b      	bne.n	80078e0 <SetButtonEvents+0x1f8>
		button[port].events &= ~BUTTON_EVENT_CLICKED;		
 80078c8:	2501      	movs	r5, #1
 80078ca:	3109      	adds	r1, #9
 80078cc:	4361      	muls	r1, r4
 80078ce:	483c      	ldr	r0, [pc, #240]	; (80079c0 <SetButtonEvents+0x2d8>)
 80078d0:	1841      	adds	r1, r0, r1
 80078d2:	7a08      	ldrb	r0, [r1, #8]
 80078d4:	43a8      	bics	r0, r5
 80078d6:	7208      	strb	r0, [r1, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && dbl_clicked)) {		
 80078d8:	2a00      	cmp	r2, #0
 80078da:	d000      	beq.n	80078de <SetButtonEvents+0x1f6>
 80078dc:	e741      	b.n	8007762 <SetButtonEvents+0x7a>
 80078de:	e001      	b.n	80078e4 <SetButtonEvents+0x1fc>
 80078e0:	2b00      	cmp	r3, #0
 80078e2:	d0f9      	beq.n	80078d8 <SetButtonEvents+0x1f0>
	} else if (mode == BUTTON_EVENT_MODE_CLEAR && !dbl_clicked) {
 80078e4:	431a      	orrs	r2, r3
 80078e6:	d000      	beq.n	80078ea <SetButtonEvents+0x202>
 80078e8:	e746      	b.n	8007778 <SetButtonEvents+0x90>
		button[port].events &= ~BUTTON_EVENT_DBL_CLICKED;		
 80078ea:	2109      	movs	r1, #9
 80078ec:	2002      	movs	r0, #2
 80078ee:	4361      	muls	r1, r4
 80078f0:	4a33      	ldr	r2, [pc, #204]	; (80079c0 <SetButtonEvents+0x2d8>)
 80078f2:	1852      	adds	r2, r2, r1
 80078f4:	7a11      	ldrb	r1, [r2, #8]
 80078f6:	4381      	bics	r1, r0
 80078f8:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && pressed_x1sec)) {			
 80078fa:	9a02      	ldr	r2, [sp, #8]
 80078fc:	2a00      	cmp	r2, #0
 80078fe:	d100      	bne.n	8007902 <SetButtonEvents+0x21a>
 8007900:	e73d      	b.n	800777e <SetButtonEvents+0x96>
		button[port].events |= BUTTON_EVENT_PRESSED_FOR_X1_SEC;
 8007902:	2209      	movs	r2, #9
 8007904:	4362      	muls	r2, r4
 8007906:	492e      	ldr	r1, [pc, #184]	; (80079c0 <SetButtonEvents+0x2d8>)
 8007908:	188a      	adds	r2, r1, r2
 800790a:	2104      	movs	r1, #4
 800790c:	7a10      	ldrb	r0, [r2, #8]
 800790e:	4301      	orrs	r1, r0
 8007910:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && pressed_x2sec)) {		
 8007912:	2b01      	cmp	r3, #1
 8007914:	d020      	beq.n	8007958 <SetButtonEvents+0x270>
 8007916:	2b00      	cmp	r3, #0
 8007918:	d100      	bne.n	800791c <SetButtonEvents+0x234>
 800791a:	e73c      	b.n	8007796 <SetButtonEvents+0xae>
	} else if (mode == BUTTON_EVENT_MODE_CLEAR && !pressed_x2sec) {
 800791c:	9a03      	ldr	r2, [sp, #12]
 800791e:	431a      	orrs	r2, r3
 8007920:	d000      	beq.n	8007924 <SetButtonEvents+0x23c>
 8007922:	e744      	b.n	80077ae <SetButtonEvents+0xc6>
		button[port].events &= ~BUTTON_EVENT_PRESSED_FOR_X2_SEC;		
 8007924:	2109      	movs	r1, #9
 8007926:	2008      	movs	r0, #8
 8007928:	4361      	muls	r1, r4
 800792a:	4a25      	ldr	r2, [pc, #148]	; (80079c0 <SetButtonEvents+0x2d8>)
 800792c:	1852      	adds	r2, r2, r1
 800792e:	7a11      	ldrb	r1, [r2, #8]
 8007930:	4381      	bics	r1, r0
 8007932:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && pressed_x3sec)) {		
 8007934:	9a04      	ldr	r2, [sp, #16]
 8007936:	2a00      	cmp	r2, #0
 8007938:	d100      	bne.n	800793c <SetButtonEvents+0x254>
 800793a:	e73b      	b.n	80077b4 <SetButtonEvents+0xcc>
		button[port].events |= BUTTON_EVENT_PRESSED_FOR_X3_SEC;
 800793c:	2109      	movs	r1, #9
 800793e:	4361      	muls	r1, r4
 8007940:	4a1f      	ldr	r2, [pc, #124]	; (80079c0 <SetButtonEvents+0x2d8>)
 8007942:	1852      	adds	r2, r2, r1
 8007944:	2110      	movs	r1, #16
 8007946:	7a10      	ldrb	r0, [r2, #8]
 8007948:	4301      	orrs	r1, r0
 800794a:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && released_y1sec)) {		
 800794c:	2b00      	cmp	r3, #0
 800794e:	d000      	beq.n	8007952 <SetButtonEvents+0x26a>
 8007950:	e73f      	b.n	80077d2 <SetButtonEvents+0xea>
 8007952:	2e00      	cmp	r6, #0
 8007954:	d104      	bne.n	8007960 <SetButtonEvents+0x278>
 8007956:	e73c      	b.n	80077d2 <SetButtonEvents+0xea>
		button[port].events |= BUTTON_EVENT_PRESSED_FOR_X3_SEC;
 8007958:	2018      	movs	r0, #24
		button[port].events |= BUTTON_EVENT_PRESSED_FOR_X2_SEC;
 800795a:	7a11      	ldrb	r1, [r2, #8]
		button[port].events |= BUTTON_EVENT_PRESSED_FOR_X3_SEC;
 800795c:	4301      	orrs	r1, r0
 800795e:	7211      	strb	r1, [r2, #8]
		button[port].events |= BUTTON_EVENT_RELEASED_FOR_Y1_SEC;
 8007960:	2109      	movs	r1, #9
 8007962:	4361      	muls	r1, r4
 8007964:	4a16      	ldr	r2, [pc, #88]	; (80079c0 <SetButtonEvents+0x2d8>)
 8007966:	1852      	adds	r2, r2, r1
 8007968:	2120      	movs	r1, #32
 800796a:	7a10      	ldrb	r0, [r2, #8]
 800796c:	4301      	orrs	r1, r0
 800796e:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && released_y2sec)) {		
 8007970:	2b01      	cmp	r3, #1
 8007972:	d006      	beq.n	8007982 <SetButtonEvents+0x29a>
 8007974:	2b00      	cmp	r3, #0
 8007976:	d000      	beq.n	800797a <SetButtonEvents+0x292>
 8007978:	e73b      	b.n	80077f2 <SetButtonEvents+0x10a>
 800797a:	9a01      	ldr	r2, [sp, #4]
 800797c:	2a00      	cmp	r2, #0
 800797e:	d100      	bne.n	8007982 <SetButtonEvents+0x29a>
 8007980:	e73b      	b.n	80077fa <SetButtonEvents+0x112>
		button[port].events |= BUTTON_EVENT_RELEASED_FOR_Y2_SEC;
 8007982:	2109      	movs	r1, #9
 8007984:	4361      	muls	r1, r4
 8007986:	4a0e      	ldr	r2, [pc, #56]	; (80079c0 <SetButtonEvents+0x2d8>)
 8007988:	1852      	adds	r2, r2, r1
 800798a:	2140      	movs	r1, #64	; 0x40
 800798c:	7a10      	ldrb	r0, [r2, #8]
 800798e:	4301      	orrs	r1, r0
 8007990:	7211      	strb	r1, [r2, #8]
	if (mode == BUTTON_EVENT_MODE_OR || (mode == BUTTON_EVENT_MODE_CLEAR && released_y3sec)) {		
 8007992:	2b01      	cmp	r3, #1
 8007994:	d100      	bne.n	8007998 <SetButtonEvents+0x2b0>
 8007996:	e73c      	b.n	8007812 <SetButtonEvents+0x12a>
 8007998:	2b00      	cmp	r3, #0
 800799a:	d100      	bne.n	800799e <SetButtonEvents+0x2b6>
 800799c:	e735      	b.n	800780a <SetButtonEvents+0x122>
	} else if (mode == BUTTON_EVENT_MODE_CLEAR && !released_y3sec) {
 800799e:	9a05      	ldr	r2, [sp, #20]
 80079a0:	4313      	orrs	r3, r2
 80079a2:	d000      	beq.n	80079a6 <SetButtonEvents+0x2be>
 80079a4:	e73e      	b.n	8007824 <SetButtonEvents+0x13c>
		button[port].events &= ~BUTTON_EVENT_RELEASED_FOR_Y3_SEC;		
 80079a6:	2209      	movs	r2, #9
 80079a8:	217f      	movs	r1, #127	; 0x7f
 80079aa:	4362      	muls	r2, r4
 80079ac:	4b04      	ldr	r3, [pc, #16]	; (80079c0 <SetButtonEvents+0x2d8>)
 80079ae:	189b      	adds	r3, r3, r2
 80079b0:	7a1a      	ldrb	r2, [r3, #8]
 80079b2:	400a      	ands	r2, r1
 80079b4:	e735      	b.n	8007822 <SetButtonEvents+0x13a>
		button[port].events |= BUTTON_EVENT_RELEASED_FOR_Y1_SEC;
 80079b6:	2120      	movs	r1, #32
 80079b8:	7a10      	ldrb	r0, [r2, #8]
 80079ba:	4301      	orrs	r1, r0
 80079bc:	7211      	strb	r1, [r2, #8]
 80079be:	e7dc      	b.n	800797a <SetButtonEvents+0x292>
 80079c0:	20001458 	.word	0x20001458

080079c4 <StreamTimerCallback>:
/*-----------------------------------------------------------*/

/* --- DMA stream timer callback --- 
*/
void StreamTimerCallback( TimerHandle_t xTimerStream )
{
 80079c4:	b510      	push	{r4, lr}
	uint32_t tid = 0;
	
	tid = ( uint32_t ) pvTimerGetTimerID( xTimerStream );
 80079c6:	f009 fbe3 	bl	8011190 <pvTimerGetTimerID>
	
	StopStreamDMA(tid);
 80079ca:	b2c4      	uxtb	r4, r0
 80079cc:	0020      	movs	r0, r4
 80079ce:	f7fe fec7 	bl	8006760 <StopStreamDMA>
	
	SwitchStreamDMAToMsg(tid);
 80079d2:	0020      	movs	r0, r4
 80079d4:	f7fe feee 	bl	80067b4 <SwitchStreamDMAToMsg>
}
 80079d8:	bd10      	pop	{r4, pc}
	...

080079dc <SetupDMAStreams>:
{
 80079dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80079de:	250f      	movs	r5, #15
 80079e0:	b087      	sub	sp, #28
 80079e2:	0014      	movs	r4, r2
 80079e4:	aa02      	add	r2, sp, #8
 80079e6:	18ad      	adds	r5, r5, r2
 80079e8:	0007      	movs	r7, r0
 80079ea:	702b      	strb	r3, [r5, #0]
	if (src == dst) {							// Streaming inside destination module. Lock this port to streaming but no need to setup DMA
 80079ec:	0018      	movs	r0, r3
 80079ee:	ab0c      	add	r3, sp, #48	; 0x30
 80079f0:	781b      	ldrb	r3, [r3, #0]
{
 80079f2:	9103      	str	r1, [sp, #12]
	if (src == dst) {							// Streaming inside destination module. Lock this port to streaming but no need to setup DMA
 80079f4:	4298      	cmp	r0, r3
 80079f6:	d106      	bne.n	8007a06 <SetupDMAStreams+0x2a>
		portStatus[src] = STREAM;
 80079f8:	2202      	movs	r2, #2
		return BOS_ERR_WrongParam;
 80079fa:	2667      	movs	r6, #103	; 0x67
		portStatus[src] = STREAM;
 80079fc:	4b50      	ldr	r3, [pc, #320]	; (8007b40 <SetupDMAStreams+0x164>)
 80079fe:	541a      	strb	r2, [r3, r0]
}
 8007a00:	0030      	movs	r0, r6
 8007a02:	b007      	add	sp, #28
 8007a04:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BOS_ERR_WrongParam;
 8007a06:	2667      	movs	r6, #103	; 0x67
	} else if (src == 0 || dst == 0) 			// Streaming outside source module or inside destination module without defining ports. Do not lock the port and do not setup DMA
 8007a08:	2800      	cmp	r0, #0
 8007a0a:	d0f9      	beq.n	8007a00 <SetupDMAStreams+0x24>
 8007a0c:	2b00      	cmp	r3, #0
 8007a0e:	d0f7      	beq.n	8007a00 <SetupDMAStreams+0x24>
	if (direction == FORWARD) 
 8007a10:	2f00      	cmp	r7, #0
 8007a12:	d133      	bne.n	8007a7c <SetupDMAStreams+0xa0>
		if (StartDMAstream(GetUart(src), GetUart(dst), 1) == BOS_ERR_PORT_BUSY)	return BOS_ERR_PORT_BUSY; 
 8007a14:	f005 fcf4 	bl	800d400 <GetUart>
 8007a18:	ab0c      	add	r3, sp, #48	; 0x30
 8007a1a:	0006      	movs	r6, r0
 8007a1c:	7818      	ldrb	r0, [r3, #0]
 8007a1e:	f005 fcef 	bl	800d400 <GetUart>
 8007a22:	2201      	movs	r2, #1
 8007a24:	0001      	movs	r1, r0
 8007a26:	0030      	movs	r0, r6
 8007a28:	f7fe feee 	bl	8006808 <StartDMAstream>
 8007a2c:	2817      	cmp	r0, #23
 8007a2e:	d101      	bne.n	8007a34 <SetupDMAStreams+0x58>
 8007a30:	2617      	movs	r6, #23
 8007a32:	e7e5      	b.n	8007a00 <SetupDMAStreams+0x24>
		xTimerStream = xTimerCreate( "StreamTimer", pdMS_TO_TICKS(timeout), pdFALSE, ( void * )&src, StreamTimerCallback );
 8007a34:	21fa      	movs	r1, #250	; 0xfa
 8007a36:	0020      	movs	r0, r4
 8007a38:	0089      	lsls	r1, r1, #2
 8007a3a:	4348      	muls	r0, r1
 8007a3c:	f7f8 fb9c 	bl	8000178 <__udivsi3>
 8007a40:	4b40      	ldr	r3, [pc, #256]	; (8007b44 <SetupDMAStreams+0x168>)
 8007a42:	0001      	movs	r1, r0
 8007a44:	9300      	str	r3, [sp, #0]
 8007a46:	002b      	movs	r3, r5
		xTimerStream = xTimerCreate( "StreamTimer", pdMS_TO_TICKS(timeout), pdFALSE, ( void * )&dst, StreamTimerCallback );
 8007a48:	2200      	movs	r2, #0
 8007a4a:	483f      	ldr	r0, [pc, #252]	; (8007b48 <SetupDMAStreams+0x16c>)
 8007a4c:	f009 fa78 	bl	8010f40 <xTimerCreate>
 8007a50:	0004      	movs	r4, r0
		dmaStreamTotal[src-1] = count;
 8007a52:	782b      	ldrb	r3, [r5, #0]
 8007a54:	4a3d      	ldr	r2, [pc, #244]	; (8007b4c <SetupDMAStreams+0x170>)
 8007a56:	3b01      	subs	r3, #1
 8007a58:	9903      	ldr	r1, [sp, #12]
 8007a5a:	009b      	lsls	r3, r3, #2
 8007a5c:	5099      	str	r1, [r3, r2]
	return BOS_OK;
 8007a5e:	2600      	movs	r6, #0
	if (xTimerStream != NULL)
 8007a60:	42b4      	cmp	r4, r6
 8007a62:	d0cd      	beq.n	8007a00 <SetupDMAStreams+0x24>
		xTimerStart( xTimerStream, portMAX_DELAY );
 8007a64:	f008 fd98 	bl	8010598 <xTaskGetTickCount>
 8007a68:	2301      	movs	r3, #1
 8007a6a:	425b      	negs	r3, r3
 8007a6c:	0002      	movs	r2, r0
 8007a6e:	9300      	str	r3, [sp, #0]
 8007a70:	2101      	movs	r1, #1
 8007a72:	0033      	movs	r3, r6
 8007a74:	0020      	movs	r0, r4
 8007a76:	f009 fa7f 	bl	8010f78 <xTimerGenericCommand>
 8007a7a:	e7c1      	b.n	8007a00 <SetupDMAStreams+0x24>
	else if (direction == BACKWARD) 
 8007a7c:	2f01      	cmp	r7, #1
 8007a7e:	d118      	bne.n	8007ab2 <SetupDMAStreams+0xd6>
		if (StartDMAstream(GetUart(dst), GetUart(src), 1) == BOS_ERR_PORT_BUSY)	return BOS_ERR_PORT_BUSY; 
 8007a80:	0018      	movs	r0, r3
 8007a82:	f005 fcbd 	bl	800d400 <GetUart>
 8007a86:	0006      	movs	r6, r0
 8007a88:	7828      	ldrb	r0, [r5, #0]
 8007a8a:	f005 fcb9 	bl	800d400 <GetUart>
 8007a8e:	003a      	movs	r2, r7
 8007a90:	0001      	movs	r1, r0
 8007a92:	0030      	movs	r0, r6
 8007a94:	f7fe feb8 	bl	8006808 <StartDMAstream>
 8007a98:	2817      	cmp	r0, #23
 8007a9a:	d0c9      	beq.n	8007a30 <SetupDMAStreams+0x54>
		xTimerStream = xTimerCreate( "StreamTimer", pdMS_TO_TICKS(timeout), pdFALSE, ( void * )&dst, StreamTimerCallback );
 8007a9c:	21fa      	movs	r1, #250	; 0xfa
 8007a9e:	0020      	movs	r0, r4
 8007aa0:	0089      	lsls	r1, r1, #2
 8007aa2:	4348      	muls	r0, r1
 8007aa4:	f7f8 fb68 	bl	8000178 <__udivsi3>
 8007aa8:	4b26      	ldr	r3, [pc, #152]	; (8007b44 <SetupDMAStreams+0x168>)
 8007aaa:	0001      	movs	r1, r0
 8007aac:	9300      	str	r3, [sp, #0]
 8007aae:	ab0c      	add	r3, sp, #48	; 0x30
 8007ab0:	e7ca      	b.n	8007a48 <SetupDMAStreams+0x6c>
		return BOS_ERR_WrongParam;
 8007ab2:	2667      	movs	r6, #103	; 0x67
	else if (direction == BIDIRECTIONAL) 
 8007ab4:	2f02      	cmp	r7, #2
 8007ab6:	d1a3      	bne.n	8007a00 <SetupDMAStreams+0x24>
		if (StartDMAstream(GetUart(src), GetUart(dst), 1) == BOS_ERR_PORT_BUSY)	return BOS_ERR_PORT_BUSY;
 8007ab8:	f005 fca2 	bl	800d400 <GetUart>
 8007abc:	ab0c      	add	r3, sp, #48	; 0x30
 8007abe:	0006      	movs	r6, r0
 8007ac0:	7818      	ldrb	r0, [r3, #0]
 8007ac2:	f005 fc9d 	bl	800d400 <GetUart>
 8007ac6:	2201      	movs	r2, #1
 8007ac8:	0001      	movs	r1, r0
 8007aca:	0030      	movs	r0, r6
 8007acc:	f7fe fe9c 	bl	8006808 <StartDMAstream>
 8007ad0:	2817      	cmp	r0, #23
 8007ad2:	d0ad      	beq.n	8007a30 <SetupDMAStreams+0x54>
		xTimerStream = xTimerCreate( "StreamTimer", pdMS_TO_TICKS(timeout), pdFALSE, ( void * )&src, StreamTimerCallback );
 8007ad4:	21fa      	movs	r1, #250	; 0xfa
 8007ad6:	0020      	movs	r0, r4
 8007ad8:	0089      	lsls	r1, r1, #2
 8007ada:	4348      	muls	r0, r1
 8007adc:	f7f8 fb4c 	bl	8000178 <__udivsi3>
 8007ae0:	4b18      	ldr	r3, [pc, #96]	; (8007b44 <SetupDMAStreams+0x168>)
 8007ae2:	4c19      	ldr	r4, [pc, #100]	; (8007b48 <SetupDMAStreams+0x16c>)
 8007ae4:	0001      	movs	r1, r0
 8007ae6:	9300      	str	r3, [sp, #0]
 8007ae8:	2200      	movs	r2, #0
 8007aea:	002b      	movs	r3, r5
 8007aec:	0007      	movs	r7, r0
 8007aee:	0020      	movs	r0, r4
 8007af0:	f009 fa26 	bl	8010f40 <xTimerCreate>
		dmaStreamTotal[src-1] = count;
 8007af4:	782b      	ldrb	r3, [r5, #0]
 8007af6:	9a03      	ldr	r2, [sp, #12]
 8007af8:	4e14      	ldr	r6, [pc, #80]	; (8007b4c <SetupDMAStreams+0x170>)
 8007afa:	3b01      	subs	r3, #1
 8007afc:	009b      	lsls	r3, r3, #2
 8007afe:	519a      	str	r2, [r3, r6]
		if (StartDMAstream(GetUart(dst), GetUart(src), 1) == BOS_ERR_PORT_BUSY)	return BOS_ERR_PORT_BUSY; 
 8007b00:	ab0c      	add	r3, sp, #48	; 0x30
 8007b02:	7818      	ldrb	r0, [r3, #0]
 8007b04:	f005 fc7c 	bl	800d400 <GetUart>
 8007b08:	9004      	str	r0, [sp, #16]
 8007b0a:	7828      	ldrb	r0, [r5, #0]
 8007b0c:	f005 fc78 	bl	800d400 <GetUart>
 8007b10:	2201      	movs	r2, #1
 8007b12:	0001      	movs	r1, r0
 8007b14:	9804      	ldr	r0, [sp, #16]
 8007b16:	f7fe fe77 	bl	8006808 <StartDMAstream>
 8007b1a:	2817      	cmp	r0, #23
 8007b1c:	d088      	beq.n	8007a30 <SetupDMAStreams+0x54>
		xTimerStream = xTimerCreate( "StreamTimer", pdMS_TO_TICKS(timeout), pdFALSE, ( void * )&dst, StreamTimerCallback );
 8007b1e:	4b09      	ldr	r3, [pc, #36]	; (8007b44 <SetupDMAStreams+0x168>)
 8007b20:	2200      	movs	r2, #0
 8007b22:	9300      	str	r3, [sp, #0]
 8007b24:	0020      	movs	r0, r4
 8007b26:	ab0c      	add	r3, sp, #48	; 0x30
 8007b28:	0039      	movs	r1, r7
 8007b2a:	f009 fa09 	bl	8010f40 <xTimerCreate>
		dmaStreamTotal[dst-1] = count;
 8007b2e:	ab0c      	add	r3, sp, #48	; 0x30
 8007b30:	781b      	ldrb	r3, [r3, #0]
 8007b32:	9a03      	ldr	r2, [sp, #12]
 8007b34:	3b01      	subs	r3, #1
 8007b36:	009b      	lsls	r3, r3, #2
		xTimerStream = xTimerCreate( "StreamTimer", pdMS_TO_TICKS(timeout), pdFALSE, ( void * )&dst, StreamTimerCallback );
 8007b38:	0004      	movs	r4, r0
		dmaStreamTotal[dst-1] = count;
 8007b3a:	519a      	str	r2, [r3, r6]
 8007b3c:	e78f      	b.n	8007a5e <SetupDMAStreams+0x82>
 8007b3e:	46c0      	nop			; (mov r8, r8)
 8007b40:	200010b2 	.word	0x200010b2
 8007b44:	080079c5 	.word	0x080079c5
 8007b48:	0801b543 	.word	0x0801b543
 8007b4c:	20001418 	.word	0x20001418

08007b50 <NotifyMessagingTask>:

/* --- Activate Messaging Tasks
*/
void NotifyMessagingTask(uint8_t port)
{
	switch (port)
 8007b50:	3801      	subs	r0, #1
{
 8007b52:	b510      	push	{r4, lr}
	switch (port)
 8007b54:	2804      	cmp	r0, #4
 8007b56:	d80b      	bhi.n	8007b70 <NotifyMessagingTask+0x20>
		case P4 :
			xTaskNotifyGive(P4MsgTaskHandle);	break;
	#endif
	#ifdef _P5
		case P5 :
			xTaskNotifyGive(P5MsgTaskHandle);	break;
 8007b58:	2300      	movs	r3, #0
 8007b5a:	2202      	movs	r2, #2
 8007b5c:	0019      	movs	r1, r3
	switch (port)
 8007b5e:	f7f8 faed 	bl	800013c <__gnu_thumb1_case_uqi>
 8007b62:	0803      	.short	0x0803
 8007b64:	0c0a      	.short	0x0c0a
 8007b66:	0e          	.byte	0x0e
 8007b67:	00          	.byte	0x00
			xTaskNotifyGive(P1MsgTaskHandle);	break;
 8007b68:	4806      	ldr	r0, [pc, #24]	; (8007b84 <NotifyMessagingTask+0x34>)
			xTaskNotifyGive(P5MsgTaskHandle);	break;
 8007b6a:	6800      	ldr	r0, [r0, #0]
 8007b6c:	f009 f926 	bl	8010dbc <xTaskGenericNotify>
		case P6 :
			xTaskNotifyGive(P6MsgTaskHandle);	break;
	#endif
		default: break;
	}		
}
 8007b70:	bd10      	pop	{r4, pc}
			xTaskNotifyGive(P2MsgTaskHandle);	break;
 8007b72:	4805      	ldr	r0, [pc, #20]	; (8007b88 <NotifyMessagingTask+0x38>)
 8007b74:	e7f9      	b.n	8007b6a <NotifyMessagingTask+0x1a>
			xTaskNotifyGive(P3MsgTaskHandle);	break;
 8007b76:	4805      	ldr	r0, [pc, #20]	; (8007b8c <NotifyMessagingTask+0x3c>)
 8007b78:	e7f7      	b.n	8007b6a <NotifyMessagingTask+0x1a>
			xTaskNotifyGive(P4MsgTaskHandle);	break;
 8007b7a:	4805      	ldr	r0, [pc, #20]	; (8007b90 <NotifyMessagingTask+0x40>)
 8007b7c:	e7f5      	b.n	8007b6a <NotifyMessagingTask+0x1a>
			xTaskNotifyGive(P5MsgTaskHandle);	break;
 8007b7e:	4805      	ldr	r0, [pc, #20]	; (8007b94 <NotifyMessagingTask+0x44>)
 8007b80:	e7f3      	b.n	8007b6a <NotifyMessagingTask+0x1a>
 8007b82:	46c0      	nop			; (mov r8, r8)
 8007b84:	20001434 	.word	0x20001434
 8007b88:	20001438 	.word	0x20001438
 8007b8c:	2000143c 	.word	0x2000143c
 8007b90:	20001440 	.word	0x20001440
 8007b94:	20001444 	.word	0x20001444

08007b98 <SendMessageFromPort>:
																								 single-cast message forwarded from another port (which is passed to the API thru numberOfParams).
        7   !0        !0				0								Not allowed.
        8   !0        0					0								Message sent to adjacent neighbor (e.g., if ID is unknown) with myID as source module.
*/
BOS_Status SendMessageFromPort(uint8_t port, uint8_t src, uint8_t dst, uint16_t code, uint16_t numberOfParams)
{
 8007b98:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007b9a:	b089      	sub	sp, #36	; 0x24
 8007b9c:	9303      	str	r3, [sp, #12]
 8007b9e:	ab0e      	add	r3, sp, #56	; 0x38
 8007ba0:	881c      	ldrh	r4, [r3, #0]
	uint8_t length = 0, shift = 0; static uint16_t totalNumberOfParams = 0; static uint16_t ptrShift = 0;
	bool extendOptions = false, extendCode = false;
	UBaseType_t TaskPriority;
	
	/* Sanity check broadcast/multi-cast and not allowed cases */
	if ((port == 0 && dst == 0) ||																												// cases 3 & 4
 8007ba2:	0003      	movs	r3, r0
{
 8007ba4:	9005      	str	r0, [sp, #20]
 8007ba6:	9102      	str	r1, [sp, #8]
 8007ba8:	9204      	str	r2, [sp, #16]
	if ((port == 0 && dst == 0) ||																												// cases 3 & 4
 8007baa:	4313      	orrs	r3, r2
			(port == 0 && dst != BOS_BROADCAST && dst != BOS_MULTICAST) || 										// cases 1 & 2
			(port != 0 && src != 0 && dst == 0)) {																						// case 7
		return BOS_ERR_WrongParam; 
 8007bac:	2067      	movs	r0, #103	; 0x67
	if ((port == 0 && dst == 0) ||																												// cases 3 & 4
 8007bae:	2b00      	cmp	r3, #0
 8007bb0:	d007      	beq.n	8007bc2 <SendMessageFromPort+0x2a>
 8007bb2:	9b05      	ldr	r3, [sp, #20]
 8007bb4:	2b00      	cmp	r3, #0
 8007bb6:	d106      	bne.n	8007bc6 <SendMessageFromPort+0x2e>
			(port == 0 && dst != BOS_BROADCAST && dst != BOS_MULTICAST) || 										// cases 1 & 2
 8007bb8:	0013      	movs	r3, r2
 8007bba:	3302      	adds	r3, #2
 8007bbc:	b2db      	uxtb	r3, r3
 8007bbe:	2b01      	cmp	r3, #1
 8007bc0:	d908      	bls.n	8007bd4 <SendMessageFromPort+0x3c>
	
	/* Reset responseStatus in case response is expected - TODO should be tailored for each port */
	responseStatus = BOS_ERR_NoResponse;
	
	return result;
}
 8007bc2:	b009      	add	sp, #36	; 0x24
 8007bc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			(port != 0 && src != 0 && dst == 0)) {																						// case 7
 8007bc6:	9b02      	ldr	r3, [sp, #8]
 8007bc8:	2b00      	cmp	r3, #0
 8007bca:	d003      	beq.n	8007bd4 <SendMessageFromPort+0x3c>
 8007bcc:	9b04      	ldr	r3, [sp, #16]
		return BOS_ERR_WrongParam; 
 8007bce:	2067      	movs	r0, #103	; 0x67
			(port != 0 && src != 0 && dst == 0)) {																						// case 7
 8007bd0:	2b00      	cmp	r3, #0
 8007bd2:	d0f6      	beq.n	8007bc2 <SendMessageFromPort+0x2a>
	TaskPriority = uxTaskPriorityGet( NULL );
 8007bd4:	2000      	movs	r0, #0
 8007bd6:	f008 fc4f 	bl	8010478 <uxTaskPriorityGet>
	vTaskPrioritySet( NULL, osPriorityHigh-osPriorityIdle );
 8007bda:	2105      	movs	r1, #5
	TaskPriority = uxTaskPriorityGet( NULL );
 8007bdc:	9007      	str	r0, [sp, #28]
	vTaskPrioritySet( NULL, osPriorityHigh-osPriorityIdle );
 8007bde:	2000      	movs	r0, #0
 8007be0:	f008 fc5a 	bl	8010498 <vTaskPrioritySet>
	message[0] = 'H';						
 8007be4:	2348      	movs	r3, #72	; 0x48
 8007be6:	4a96      	ldr	r2, [pc, #600]	; (8007e40 <SendMessageFromPort+0x2a8>)
	if ((port == 0 && src == 0 && (dst == BOS_BROADCAST || dst == BOS_MULTICAST)) || code == 0)					// case 2 and part of case 6
 8007be8:	9902      	ldr	r1, [sp, #8]
	message[0] = 'H';						
 8007bea:	7013      	strb	r3, [r2, #0]
	message[1] = 'Z';
 8007bec:	3312      	adds	r3, #18
 8007bee:	7053      	strb	r3, [r2, #1]
	if ((port == 0 && src == 0 && (dst == BOS_BROADCAST || dst == BOS_MULTICAST)) || code == 0)					// case 2 and part of case 6
 8007bf0:	9b05      	ldr	r3, [sp, #20]
 8007bf2:	430b      	orrs	r3, r1
 8007bf4:	d13c      	bne.n	8007c70 <SendMessageFromPort+0xd8>
 8007bf6:	9b04      	ldr	r3, [sp, #16]
 8007bf8:	3302      	adds	r3, #2
 8007bfa:	b2db      	uxtb	r3, r3
 8007bfc:	2b01      	cmp	r3, #1
 8007bfe:	d900      	bls.n	8007c02 <SendMessageFromPort+0x6a>
 8007c00:	e10b      	b.n	8007e1a <SendMessageFromPort+0x282>
		memcpy(&message[3], &cMessage[numberOfParams-1][0], (size_t) length);
 8007c02:	2138      	movs	r1, #56	; 0x38
		length = messageLength[numberOfParams-1];
 8007c04:	3c01      	subs	r4, #1
		memcpy(&message[3], &cMessage[numberOfParams-1][0], (size_t) length);
 8007c06:	4361      	muls	r1, r4
		length = messageLength[numberOfParams-1];
 8007c08:	4b8e      	ldr	r3, [pc, #568]	; (8007e44 <SendMessageFromPort+0x2ac>)
		memcpy(&message[3], &cMessage[numberOfParams-1][0], (size_t) length);
 8007c0a:	488f      	ldr	r0, [pc, #572]	; (8007e48 <SendMessageFromPort+0x2b0>)
		length = messageLength[numberOfParams-1];
 8007c0c:	5d1f      	ldrb	r7, [r3, r4]
		memcpy(&message[3], &cMessage[numberOfParams-1][0], (size_t) length);
 8007c0e:	4c8f      	ldr	r4, [pc, #572]	; (8007e4c <SendMessageFromPort+0x2b4>)
 8007c10:	003a      	movs	r2, r7
 8007c12:	1909      	adds	r1, r1, r4
 8007c14:	f00c fd1e 	bl	8014654 <memcpy>
	message[2] = length;
 8007c18:	4d89      	ldr	r5, [pc, #548]	; (8007e40 <SendMessageFromPort+0x2a8>)
	memcpy(crcBuffer, &message[0], length + 3);
 8007c1a:	4e8d      	ldr	r6, [pc, #564]	; (8007e50 <SendMessageFromPort+0x2b8>)
 8007c1c:	1cfb      	adds	r3, r7, #3
 8007c1e:	001a      	movs	r2, r3
 8007c20:	0029      	movs	r1, r5
 8007c22:	0030      	movs	r0, r6
 8007c24:	9306      	str	r3, [sp, #24]
	message[2] = length;
 8007c26:	70af      	strb	r7, [r5, #2]
	memcpy(crcBuffer, &message[0], length + 3);
 8007c28:	f00c fd14 	bl	8014654 <memcpy>
	message[length+3] = CalculateCRC8((uint32_t *)&crcBuffer, (length + 3));
 8007c2c:	1cf9      	adds	r1, r7, #3
 8007c2e:	0030      	movs	r0, r6
 8007c30:	f004 f99c 	bl	800bf6c <CalculateCRC8>
 8007c34:	9b06      	ldr	r3, [sp, #24]
	memset(crcBuffer, 0, sizeof(crcBuffer));
 8007c36:	2238      	movs	r2, #56	; 0x38
	message[length+3] = CalculateCRC8((uint32_t *)&crcBuffer, (length + 3));
 8007c38:	54e8      	strb	r0, [r5, r3]
	memset(crcBuffer, 0, sizeof(crcBuffer));
 8007c3a:	2100      	movs	r1, #0
 8007c3c:	0030      	movs	r0, r6
 8007c3e:	f00c fd12 	bl	8014666 <memset>
	if (dst != BOS_BROADCAST && dst != BOS_MULTICAST) 
 8007c42:	9b04      	ldr	r3, [sp, #16]
	message[length+3] = CalculateCRC8((uint32_t *)&crcBuffer, (length + 3));
 8007c44:	b2bc      	uxth	r4, r7
	if (dst != BOS_BROADCAST && dst != BOS_MULTICAST) 
 8007c46:	3302      	adds	r3, #2
 8007c48:	b2db      	uxtb	r3, r3
 8007c4a:	2b01      	cmp	r3, #1
 8007c4c:	d800      	bhi.n	8007c50 <SendMessageFromPort+0xb8>
 8007c4e:	e0bf      	b.n	8007dd0 <SendMessageFromPort+0x238>
		writePxDMAMutex(port, message, length+4, cmd50ms);
 8007c50:	1d22      	adds	r2, r4, #4
 8007c52:	b292      	uxth	r2, r2
 8007c54:	2332      	movs	r3, #50	; 0x32
 8007c56:	0029      	movs	r1, r5
 8007c58:	9805      	ldr	r0, [sp, #20]
 8007c5a:	f005 fc1f 	bl	800d49c <writePxDMAMutex>
	vTaskPrioritySet( NULL, TaskPriority );
 8007c5e:	2000      	movs	r0, #0
 8007c60:	9907      	ldr	r1, [sp, #28]
 8007c62:	f008 fc19 	bl	8010498 <vTaskPrioritySet>
	responseStatus = BOS_ERR_NoResponse;
 8007c66:	2202      	movs	r2, #2
 8007c68:	4b7a      	ldr	r3, [pc, #488]	; (8007e54 <SendMessageFromPort+0x2bc>)
	return result;
 8007c6a:	2000      	movs	r0, #0
	responseStatus = BOS_ERR_NoResponse;
 8007c6c:	701a      	strb	r2, [r3, #0]
 8007c6e:	e7a8      	b.n	8007bc2 <SendMessageFromPort+0x2a>
	if ((port == 0 && src == 0 && (dst == BOS_BROADCAST || dst == BOS_MULTICAST)) || code == 0)					// case 2 and part of case 6
 8007c70:	9b03      	ldr	r3, [sp, #12]
 8007c72:	2b00      	cmp	r3, #0
 8007c74:	d0c5      	beq.n	8007c02 <SendMessageFromPort+0x6a>
		if (src == 0)		src = myID;
 8007c76:	9b02      	ldr	r3, [sp, #8]
 8007c78:	2b00      	cmp	r3, #0
 8007c7a:	d102      	bne.n	8007c82 <SendMessageFromPort+0xea>
 8007c7c:	4b76      	ldr	r3, [pc, #472]	; (8007e58 <SendMessageFromPort+0x2c0>)
 8007c7e:	781b      	ldrb	r3, [r3, #0]
 8007c80:	9302      	str	r3, [sp, #8]
		message[2] = length;	
 8007c82:	2600      	movs	r6, #0
		message[3] = dst;						
 8007c84:	9b04      	ldr	r3, [sp, #16]
		message[5] = (BOS.response) | (BOS.trace<<2) | (extendCode<<1) | (extendOptions);
 8007c86:	4975      	ldr	r1, [pc, #468]	; (8007e5c <SendMessageFromPort+0x2c4>)
		message[3] = dst;						
 8007c88:	70d3      	strb	r3, [r2, #3]
		message[4] = src;
 8007c8a:	9b02      	ldr	r3, [sp, #8]
		message[2] = length;	
 8007c8c:	7096      	strb	r6, [r2, #2]
		message[4] = src;
 8007c8e:	7113      	strb	r3, [r2, #4]
		message[5] = (BOS.response) | (BOS.trace<<2) | (extendCode<<1) | (extendOptions);
 8007c90:	79cb      	ldrb	r3, [r1, #7]
 8007c92:	7989      	ldrb	r1, [r1, #6]
 8007c94:	009b      	lsls	r3, r3, #2
 8007c96:	430b      	orrs	r3, r1
		if (code > 0xFF)	extendCode = true;
 8007c98:	21ff      	movs	r1, #255	; 0xff
 8007c9a:	9803      	ldr	r0, [sp, #12]
 8007c9c:	4281      	cmp	r1, r0
 8007c9e:	4189      	sbcs	r1, r1
 8007ca0:	4249      	negs	r1, r1
		message[5] = (BOS.response) | (BOS.trace<<2) | (extendCode<<1) | (extendOptions);
 8007ca2:	0049      	lsls	r1, r1, #1
 8007ca4:	430b      	orrs	r3, r1
 8007ca6:	b2db      	uxtb	r3, r3
 8007ca8:	7153      	strb	r3, [r2, #5]
		message[6+shift] = (uint8_t) code;
 8007caa:	7190      	strb	r0, [r2, #6]
		if (extendCode == true) {
 8007cac:	28ff      	cmp	r0, #255	; 0xff
 8007cae:	d902      	bls.n	8007cb6 <SendMessageFromPort+0x11e>
			message[6+shift] = (uint8_t) (code >> 8);		
 8007cb0:	0a01      	lsrs	r1, r0, #8
 8007cb2:	71d1      	strb	r1, [r2, #7]
			++shift;
 8007cb4:	3601      	adds	r6, #1
 8007cb6:	4862      	ldr	r0, [pc, #392]	; (8007e40 <SendMessageFromPort+0x2a8>)
		if (numberOfParams <= MAX_PARAMS_PER_MESSAGE ) {				
 8007cb8:	2c2e      	cmp	r4, #46	; 0x2e
 8007cba:	d835      	bhi.n	8007d28 <SendMessageFromPort+0x190>
			memcpy((char*)&message[7+shift], (&messageParams[0]+ptrShift), numberOfParams);
 8007cbc:	1df3      	adds	r3, r6, #7
 8007cbe:	18c0      	adds	r0, r0, r3
 8007cc0:	4b67      	ldr	r3, [pc, #412]	; (8007e60 <SendMessageFromPort+0x2c8>)
 8007cc2:	0022      	movs	r2, r4
 8007cc4:	8819      	ldrh	r1, [r3, #0]
 8007cc6:	4b67      	ldr	r3, [pc, #412]	; (8007e64 <SendMessageFromPort+0x2cc>)
 8007cc8:	18c9      	adds	r1, r1, r3
 8007cca:	f00c fcc3 	bl	8014654 <memcpy>
			length = numberOfParams + shift + 4;
 8007cce:	1d21      	adds	r1, r4, #4
 8007cd0:	1871      	adds	r1, r6, r1
 8007cd2:	b2cf      	uxtb	r7, r1
		if(AddBcastPayload == true)
 8007cd4:	4b64      	ldr	r3, [pc, #400]	; (8007e68 <SendMessageFromPort+0x2d0>)
 8007cd6:	781b      	ldrb	r3, [r3, #0]
 8007cd8:	2b00      	cmp	r3, #0
 8007cda:	d09d      	beq.n	8007c18 <SendMessageFromPort+0x80>
			if (dstGroupID < BOS_BROADCAST)
 8007cdc:	4b63      	ldr	r3, [pc, #396]	; (8007e6c <SendMessageFromPort+0x2d4>)
 8007cde:	781b      	ldrb	r3, [r3, #0]
 8007ce0:	2bff      	cmp	r3, #255	; 0xff
 8007ce2:	d100      	bne.n	8007ce6 <SendMessageFromPort+0x14e>
 8007ce4:	e09e      	b.n	8007e24 <SendMessageFromPort+0x28c>
				for(uint16_t i=1 ; i<=N ; i++)						// N modules
 8007ce6:	4a62      	ldr	r2, [pc, #392]	; (8007e70 <SendMessageFromPort+0x2d8>)
							message[7+shift+numberOfParams+groupMembers-1] = i;
 8007ce8:	4855      	ldr	r0, [pc, #340]	; (8007e40 <SendMessageFromPort+0x2a8>)
				for(uint16_t i=1 ; i<=N ; i++)						// N modules
 8007cea:	7812      	ldrb	r2, [r2, #0]
 8007cec:	4694      	mov	ip, r2
 8007cee:	2201      	movs	r2, #1
 8007cf0:	0011      	movs	r1, r2
 8007cf2:	4099      	lsls	r1, r3
			uint8_t groupMembers = 0;
 8007cf4:	2300      	movs	r3, #0
 8007cf6:	000d      	movs	r5, r1
							message[7+shift+numberOfParams+groupMembers-1] = i;
 8007cf8:	1981      	adds	r1, r0, r6
 8007cfa:	9106      	str	r1, [sp, #24]
				for(uint16_t i=1 ; i<=N ; i++)						// N modules
 8007cfc:	b291      	uxth	r1, r2
 8007cfe:	458c      	cmp	ip, r1
 8007d00:	d253      	bcs.n	8007daa <SendMessageFromPort+0x212>
				message[7+shift+numberOfParams+groupMembers] = groupMembers;
 8007d02:	1df0      	adds	r0, r6, #7
 8007d04:	1900      	adds	r0, r0, r4
 8007d06:	4d4e      	ldr	r5, [pc, #312]	; (8007e40 <SendMessageFromPort+0x2a8>)
 8007d08:	18c0      	adds	r0, r0, r3
			else if ( (dstGroupID < BOS_BROADCAST) && ((numberOfParams+groupMembers+2) < MAX_PARAMS_PER_MESSAGE) )		// Multicast
 8007d0a:	191c      	adds	r4, r3, r4
				message[7+shift+numberOfParams+groupMembers] = groupMembers;
 8007d0c:	542b      	strb	r3, [r5, r0]
			else if ( (dstGroupID < BOS_BROADCAST) && ((numberOfParams+groupMembers+2) < MAX_PARAMS_PER_MESSAGE) )		// Multicast
 8007d0e:	2c2b      	cmp	r4, #43	; 0x2b
 8007d10:	dc56      	bgt.n	8007dc0 <SendMessageFromPort+0x228>
				message[7+shift+numberOfParams+groupMembers+1] = ++bcastID;
 8007d12:	4958      	ldr	r1, [pc, #352]	; (8007e74 <SendMessageFromPort+0x2dc>)
 8007d14:	3702      	adds	r7, #2
 8007d16:	780a      	ldrb	r2, [r1, #0]
 8007d18:	1828      	adds	r0, r5, r0
 8007d1a:	3201      	adds	r2, #1
 8007d1c:	b2d2      	uxtb	r2, r2
				length += groupMembers + 2;		// + bcastID + number of group member + group members IDs 
 8007d1e:	18fb      	adds	r3, r7, r3
				message[7+shift+numberOfParams+groupMembers+1] = ++bcastID;
 8007d20:	700a      	strb	r2, [r1, #0]
 8007d22:	7042      	strb	r2, [r0, #1]
				length += groupMembers + 2;		// + bcastID + number of group member + group members IDs 
 8007d24:	b2df      	uxtb	r7, r3
 8007d26:	e777      	b.n	8007c18 <SendMessageFromPort+0x80>
			message[5] |= 0x80;		
 8007d28:	2180      	movs	r1, #128	; 0x80
 8007d2a:	4249      	negs	r1, r1
 8007d2c:	430b      	orrs	r3, r1
 8007d2e:	7143      	strb	r3, [r0, #5]
			totalNumberOfParams = numberOfParams;
 8007d30:	4b51      	ldr	r3, [pc, #324]	; (8007e78 <SendMessageFromPort+0x2e0>)
	uint8_t length = 0, shift = 0; static uint16_t totalNumberOfParams = 0; static uint16_t ptrShift = 0;
 8007d32:	2700      	movs	r7, #0
			totalNumberOfParams = numberOfParams;
 8007d34:	801c      	strh	r4, [r3, #0]
			numberOfParams = MAX_PARAMS_PER_MESSAGE;
 8007d36:	242e      	movs	r4, #46	; 0x2e
			while (totalNumberOfParams != 0)
 8007d38:	4b4f      	ldr	r3, [pc, #316]	; (8007e78 <SendMessageFromPort+0x2e0>)
 8007d3a:	881d      	ldrh	r5, [r3, #0]
 8007d3c:	2d00      	cmp	r5, #0
 8007d3e:	d0c9      	beq.n	8007cd4 <SendMessageFromPort+0x13c>
				if ( (totalNumberOfParams/numberOfParams) >= 1) 
 8007d40:	0021      	movs	r1, r4
 8007d42:	0028      	movs	r0, r5
 8007d44:	f7f8 fa18 	bl	8000178 <__udivsi3>
 8007d48:	b283      	uxth	r3, r0
 8007d4a:	9306      	str	r3, [sp, #24]
 8007d4c:	2b00      	cmp	r3, #0
 8007d4e:	d015      	beq.n	8007d7c <SendMessageFromPort+0x1e4>
					ptrShift += numberOfParams;
 8007d50:	0025      	movs	r5, r4
					SendMessageFromPort(port, src, dst, code, numberOfParams);
 8007d52:	9b03      	ldr	r3, [sp, #12]
 8007d54:	9a04      	ldr	r2, [sp, #16]
 8007d56:	9902      	ldr	r1, [sp, #8]
 8007d58:	9400      	str	r4, [sp, #0]
 8007d5a:	9805      	ldr	r0, [sp, #20]
 8007d5c:	f7ff ff1c 	bl	8007b98 <SendMessageFromPort>
					osDelay(10);
 8007d60:	200a      	movs	r0, #10
 8007d62:	f007 fcfe 	bl	800f762 <osDelay>
					totalNumberOfParams -= numberOfParams;
 8007d66:	4b44      	ldr	r3, [pc, #272]	; (8007e78 <SendMessageFromPort+0x2e0>)
 8007d68:	4a43      	ldr	r2, [pc, #268]	; (8007e78 <SendMessageFromPort+0x2e0>)
 8007d6a:	881b      	ldrh	r3, [r3, #0]
 8007d6c:	1b1b      	subs	r3, r3, r4
 8007d6e:	8013      	strh	r3, [r2, #0]
					ptrShift += numberOfParams;
 8007d70:	4a3b      	ldr	r2, [pc, #236]	; (8007e60 <SendMessageFromPort+0x2c8>)
 8007d72:	8813      	ldrh	r3, [r2, #0]
 8007d74:	18e3      	adds	r3, r4, r3
 8007d76:	8013      	strh	r3, [r2, #0]
 8007d78:	002c      	movs	r4, r5
 8007d7a:	e7dd      	b.n	8007d38 <SendMessageFromPort+0x1a0>
					message[5] &= 0x7F;		/* Last message. Reset long message flag */
 8007d7c:	227f      	movs	r2, #127	; 0x7f
 8007d7e:	4830      	ldr	r0, [pc, #192]	; (8007e40 <SendMessageFromPort+0x2a8>)
					memcpy((char*)&message[7+shift], (&messageParams[0]+ptrShift), numberOfParams);
 8007d80:	4c37      	ldr	r4, [pc, #220]	; (8007e60 <SendMessageFromPort+0x2c8>)
					message[5] &= 0x7F;		/* Last message. Reset long message flag */
 8007d82:	7943      	ldrb	r3, [r0, #5]
					memcpy((char*)&message[7+shift], (&messageParams[0]+ptrShift), numberOfParams);
 8007d84:	8821      	ldrh	r1, [r4, #0]
					message[5] &= 0x7F;		/* Last message. Reset long message flag */
 8007d86:	4013      	ands	r3, r2
 8007d88:	7143      	strb	r3, [r0, #5]
					memcpy((char*)&message[7+shift], (&messageParams[0]+ptrShift), numberOfParams);
 8007d8a:	1df3      	adds	r3, r6, #7
 8007d8c:	1818      	adds	r0, r3, r0
 8007d8e:	4b35      	ldr	r3, [pc, #212]	; (8007e64 <SendMessageFromPort+0x2cc>)
 8007d90:	002a      	movs	r2, r5
 8007d92:	18c9      	adds	r1, r1, r3
 8007d94:	f00c fc5e 	bl	8014654 <memcpy>
					ptrShift = 0; totalNumberOfParams = 0;
 8007d98:	9b06      	ldr	r3, [sp, #24]
 8007d9a:	9a06      	ldr	r2, [sp, #24]
 8007d9c:	8023      	strh	r3, [r4, #0]
					length = numberOfParams + shift + 4;
 8007d9e:	1d29      	adds	r1, r5, #4
					ptrShift = 0; totalNumberOfParams = 0;
 8007da0:	4b35      	ldr	r3, [pc, #212]	; (8007e78 <SendMessageFromPort+0x2e0>)
					length = numberOfParams + shift + 4;
 8007da2:	1871      	adds	r1, r6, r1
					ptrShift = 0; totalNumberOfParams = 0;
 8007da4:	801a      	strh	r2, [r3, #0]
					length = numberOfParams + shift + 4;
 8007da6:	b2cf      	uxtb	r7, r1
 8007da8:	e7e6      	b.n	8007d78 <SendMessageFromPort+0x1e0>
					if (InGroup(i, dstGroupID))
 8007daa:	0051      	lsls	r1, r2, #1
 8007dac:	4833      	ldr	r0, [pc, #204]	; (8007e7c <SendMessageFromPort+0x2e4>)
 8007dae:	3902      	subs	r1, #2
 8007db0:	5a41      	ldrh	r1, [r0, r1]
 8007db2:	420d      	tst	r5, r1
 8007db4:	d00a      	beq.n	8007dcc <SendMessageFromPort+0x234>
						++groupMembers;							// Add this member
 8007db6:	3301      	adds	r3, #1
 8007db8:	b2db      	uxtb	r3, r3
						if ((numberOfParams+groupMembers+1) < MAX_PARAMS_PER_MESSAGE)
 8007dba:	1919      	adds	r1, r3, r4
 8007dbc:	292c      	cmp	r1, #44	; 0x2c
 8007dbe:	dd01      	ble.n	8007dc4 <SendMessageFromPort+0x22c>
							return BOS_ERR_MSG_DOES_NOT_FIT;
 8007dc0:	2069      	movs	r0, #105	; 0x69
 8007dc2:	e6fe      	b.n	8007bc2 <SendMessageFromPort+0x2a>
							message[7+shift+numberOfParams+groupMembers-1] = i;
 8007dc4:	9906      	ldr	r1, [sp, #24]
 8007dc6:	18c9      	adds	r1, r1, r3
 8007dc8:	1909      	adds	r1, r1, r4
 8007dca:	718a      	strb	r2, [r1, #6]
 8007dcc:	3201      	adds	r2, #1
 8007dce:	e795      	b.n	8007cfc <SendMessageFromPort+0x164>
		if (code == 0 && src == 0) {					// Forwarded broadcast or multicast. Update with original source.
 8007dd0:	9b03      	ldr	r3, [sp, #12]
 8007dd2:	2b00      	cmp	r3, #0
 8007dd4:	d104      	bne.n	8007de0 <SendMessageFromPort+0x248>
 8007dd6:	9b02      	ldr	r3, [sp, #8]
 8007dd8:	2b00      	cmp	r3, #0
 8007dda:	d101      	bne.n	8007de0 <SendMessageFromPort+0x248>
			src = message[4];
 8007ddc:	792b      	ldrb	r3, [r5, #4]
 8007dde:	9302      	str	r3, [sp, #8]
		FindBroadcastRoutes(src);
 8007de0:	9802      	ldr	r0, [sp, #8]
 8007de2:	f7fb fbb5 	bl	8003550 <FindBroadcastRoutes>
			if ( (bcastRoutes[myID-1] >> (p-1)) & 0x01 ) 		
 8007de6:	2701      	movs	r7, #1
		FindBroadcastRoutes(src);
 8007de8:	2200      	movs	r2, #0
			if ( (bcastRoutes[myID-1] >> (p-1)) & 0x01 ) 		
 8007dea:	4b1b      	ldr	r3, [pc, #108]	; (8007e58 <SendMessageFromPort+0x2c0>)
 8007dec:	4924      	ldr	r1, [pc, #144]	; (8007e80 <SendMessageFromPort+0x2e8>)
 8007dee:	781b      	ldrb	r3, [r3, #0]
 8007df0:	1c56      	adds	r6, r2, #1
 8007df2:	3b01      	subs	r3, #1
 8007df4:	005b      	lsls	r3, r3, #1
 8007df6:	5a5b      	ldrh	r3, [r3, r1]
 8007df8:	b2f0      	uxtb	r0, r6
 8007dfa:	4113      	asrs	r3, r2
 8007dfc:	423b      	tst	r3, r7
 8007dfe:	d008      	beq.n	8007e12 <SendMessageFromPort+0x27a>
				writePxDMAMutex(p, message, length+4, cmd50ms);
 8007e00:	1d22      	adds	r2, r4, #4
 8007e02:	b292      	uxth	r2, r2
 8007e04:	2332      	movs	r3, #50	; 0x32
 8007e06:	0029      	movs	r1, r5
 8007e08:	f005 fb48 	bl	800d49c <writePxDMAMutex>
				Delay_ms(1);
 8007e0c:	0038      	movs	r0, r7
 8007e0e:	f009 fb7d 	bl	801150c <HAL_Delay>
 8007e12:	0032      	movs	r2, r6
		for (uint8_t p=1 ; p<=NumOfPorts ; p++) 
 8007e14:	2e05      	cmp	r6, #5
 8007e16:	d1e8      	bne.n	8007dea <SendMessageFromPort+0x252>
 8007e18:	e721      	b.n	8007c5e <SendMessageFromPort+0xc6>
	if ((port == 0 && src == 0 && (dst == BOS_BROADCAST || dst == BOS_MULTICAST)) || code == 0)					// case 2 and part of case 6
 8007e1a:	9b03      	ldr	r3, [sp, #12]
 8007e1c:	2b00      	cmp	r3, #0
 8007e1e:	d100      	bne.n	8007e22 <SendMessageFromPort+0x28a>
 8007e20:	e6ef      	b.n	8007c02 <SendMessageFromPort+0x6a>
 8007e22:	e72b      	b.n	8007c7c <SendMessageFromPort+0xe4>
			if ( (dstGroupID == BOS_BROADCAST) && ((numberOfParams+1) < MAX_PARAMS_PER_MESSAGE) )
 8007e24:	2c2c      	cmp	r4, #44	; 0x2c
 8007e26:	d8cb      	bhi.n	8007dc0 <SendMessageFromPort+0x228>
				message[7+shift+numberOfParams] = ++bcastID;
 8007e28:	4a12      	ldr	r2, [pc, #72]	; (8007e74 <SendMessageFromPort+0x2dc>)
 8007e2a:	4905      	ldr	r1, [pc, #20]	; (8007e40 <SendMessageFromPort+0x2a8>)
 8007e2c:	7813      	ldrb	r3, [r2, #0]
 8007e2e:	1989      	adds	r1, r1, r6
 8007e30:	3301      	adds	r3, #1
 8007e32:	b2db      	uxtb	r3, r3
 8007e34:	190c      	adds	r4, r1, r4
				length += 1;		// + bcastID
 8007e36:	3701      	adds	r7, #1
				message[7+shift+numberOfParams] = ++bcastID;
 8007e38:	7013      	strb	r3, [r2, #0]
 8007e3a:	71e3      	strb	r3, [r4, #7]
				length += 1;		// + bcastID
 8007e3c:	b2ff      	uxtb	r7, r7
 8007e3e:	e6eb      	b.n	8007c18 <SendMessageFromPort+0x80>
 8007e40:	20000eca 	.word	0x20000eca
 8007e44:	20000f02 	.word	0x20000f02
 8007e48:	20000ecd 	.word	0x20000ecd
 8007e4c:	20000d13 	.word	0x20000d13
 8007e50:	200013b6 	.word	0x200013b6
 8007e54:	200010c8 	.word	0x200010c8
 8007e58:	20001039 	.word	0x20001039
 8007e5c:	20006f70 	.word	0x20006f70
 8007e60:	200014c8 	.word	0x200014c8
 8007e64:	20000f07 	.word	0x20000f07
 8007e68:	20000a9c 	.word	0x20000a9c
 8007e6c:	2000001d 	.word	0x2000001d
 8007e70:	2000001c 	.word	0x2000001c
 8007e74:	20000cc6 	.word	0x20000cc6
 8007e78:	200014ca 	.word	0x200014ca
 8007e7c:	20000e94 	.word	0x20000e94
 8007e80:	20000cc8 	.word	0x20000cc8

08007e84 <ForwardReceivedMessage>:
{
 8007e84:	b573      	push	{r0, r1, r4, r5, r6, lr}
	AddBcastPayload = false; 	
 8007e86:	2400      	movs	r4, #0
 8007e88:	4b0a      	ldr	r3, [pc, #40]	; (8007eb4 <ForwardReceivedMessage+0x30>)
{
 8007e8a:	0005      	movs	r5, r0
	AddBcastPayload = false; 	
 8007e8c:	701c      	strb	r4, [r3, #0]
	dst = cMessage[incomingPort-1][0];
 8007e8e:	2338      	movs	r3, #56	; 0x38
 8007e90:	1e42      	subs	r2, r0, #1
 8007e92:	4353      	muls	r3, r2
 8007e94:	4a08      	ldr	r2, [pc, #32]	; (8007eb8 <ForwardReceivedMessage+0x34>)
 8007e96:	5c9e      	ldrb	r6, [r3, r2]
	port = FindRoute(myID, dst); 
 8007e98:	4b08      	ldr	r3, [pc, #32]	; (8007ebc <ForwardReceivedMessage+0x38>)
 8007e9a:	0031      	movs	r1, r6
 8007e9c:	7818      	ldrb	r0, [r3, #0]
 8007e9e:	f7fb fbd9 	bl	8003654 <FindRoute>
	SendMessageFromPort(port, 0, dst, 0, incomingPort);
 8007ea2:	9500      	str	r5, [sp, #0]
 8007ea4:	0032      	movs	r2, r6
 8007ea6:	0023      	movs	r3, r4
 8007ea8:	0021      	movs	r1, r4
 8007eaa:	f7ff fe75 	bl	8007b98 <SendMessageFromPort>
}
 8007eae:	0020      	movs	r0, r4
 8007eb0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007eb2:	46c0      	nop			; (mov r8, r8)
 8007eb4:	20000a9c 	.word	0x20000a9c
 8007eb8:	20000d13 	.word	0x20000d13
 8007ebc:	20001039 	.word	0x20001039

08007ec0 <BroadcastReceivedMessage>:
{
 8007ec0:	b507      	push	{r0, r1, r2, lr}
 8007ec2:	0002      	movs	r2, r0
	AddBcastPayload = false; dstGroupID = dstGroup;	
 8007ec4:	2000      	movs	r0, #0
 8007ec6:	4b08      	ldr	r3, [pc, #32]	; (8007ee8 <BroadcastReceivedMessage+0x28>)
 8007ec8:	b289      	uxth	r1, r1
 8007eca:	7018      	strb	r0, [r3, #0]
 8007ecc:	4b07      	ldr	r3, [pc, #28]	; (8007eec <BroadcastReceivedMessage+0x2c>)
 8007ece:	701a      	strb	r2, [r3, #0]
		SendMessageFromPort(0, 0, BOS_BROADCAST, 0, incomingPort);
 8007ed0:	9100      	str	r1, [sp, #0]
 8007ed2:	0003      	movs	r3, r0
	if (dstGroup == BOS_BROADCAST)
 8007ed4:	2aff      	cmp	r2, #255	; 0xff
 8007ed6:	d104      	bne.n	8007ee2 <BroadcastReceivedMessage+0x22>
		SendMessageFromPort(0, 0, BOS_MULTICAST, 0, incomingPort);
 8007ed8:	0001      	movs	r1, r0
 8007eda:	f7ff fe5d 	bl	8007b98 <SendMessageFromPort>
}
 8007ede:	2000      	movs	r0, #0
 8007ee0:	bd0e      	pop	{r1, r2, r3, pc}
		SendMessageFromPort(0, 0, BOS_MULTICAST, 0, incomingPort);
 8007ee2:	22fe      	movs	r2, #254	; 0xfe
 8007ee4:	e7f8      	b.n	8007ed8 <BroadcastReceivedMessage+0x18>
 8007ee6:	46c0      	nop			; (mov r8, r8)
 8007ee8:	20000a9c 	.word	0x20000a9c
 8007eec:	2000001d 	.word	0x2000001d

08007ef0 <BroadcastMessage>:
{
 8007ef0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	AddBcastPayload = true; dstGroupID = dstGroup;
 8007ef2:	2501      	movs	r5, #1
{
 8007ef4:	001c      	movs	r4, r3
	AddBcastPayload = true; dstGroupID = dstGroup;
 8007ef6:	4b0a      	ldr	r3, [pc, #40]	; (8007f20 <BroadcastMessage+0x30>)
 8007ef8:	701d      	strb	r5, [r3, #0]
 8007efa:	4b0a      	ldr	r3, [pc, #40]	; (8007f24 <BroadcastMessage+0x34>)
 8007efc:	7019      	strb	r1, [r3, #0]
		SendMessageFromPort(0, src, BOS_BROADCAST, code, numberOfParams);
 8007efe:	0013      	movs	r3, r2
 8007f00:	9400      	str	r4, [sp, #0]
 8007f02:	000a      	movs	r2, r1
	if (dstGroup == BOS_BROADCAST)
 8007f04:	29ff      	cmp	r1, #255	; 0xff
 8007f06:	d000      	beq.n	8007f0a <BroadcastMessage+0x1a>
		SendMessageFromPort(0, src, BOS_MULTICAST, code, numberOfParams);
 8007f08:	22fe      	movs	r2, #254	; 0xfe
 8007f0a:	0001      	movs	r1, r0
 8007f0c:	2000      	movs	r0, #0
 8007f0e:	f7ff fe43 	bl	8007b98 <SendMessageFromPort>
	memset( messageParams, 0, numberOfParams );
 8007f12:	0022      	movs	r2, r4
 8007f14:	2100      	movs	r1, #0
 8007f16:	4804      	ldr	r0, [pc, #16]	; (8007f28 <BroadcastMessage+0x38>)
 8007f18:	f00c fba5 	bl	8014666 <memset>
}
 8007f1c:	2000      	movs	r0, #0
 8007f1e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8007f20:	20000a9c 	.word	0x20000a9c
 8007f24:	2000001d 	.word	0x2000001d
 8007f28:	20000f07 	.word	0x20000f07

08007f2c <SendMessageToModule>:
{
 8007f2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007f2e:	4f0e      	ldr	r7, [pc, #56]	; (8007f68 <SendMessageToModule+0x3c>)
 8007f30:	0004      	movs	r4, r0
 8007f32:	000e      	movs	r6, r1
 8007f34:	0015      	movs	r5, r2
 8007f36:	7838      	ldrb	r0, [r7, #0]
	if (dst != BOS_BROADCAST)
 8007f38:	2cff      	cmp	r4, #255	; 0xff
 8007f3a:	d00f      	beq.n	8007f5c <SendMessageToModule+0x30>
		port = FindRoute(myID, dst); 
 8007f3c:	0021      	movs	r1, r4
 8007f3e:	f7fb fb89 	bl	8003654 <FindRoute>
		SendMessageFromPort(port, myID, dst, code, numberOfParams);	
 8007f42:	7839      	ldrb	r1, [r7, #0]
 8007f44:	0022      	movs	r2, r4
 8007f46:	9500      	str	r5, [sp, #0]
 8007f48:	0033      	movs	r3, r6
 8007f4a:	f7ff fe25 	bl	8007b98 <SendMessageFromPort>
		memset( messageParams, 0, numberOfParams );
 8007f4e:	002a      	movs	r2, r5
 8007f50:	2100      	movs	r1, #0
 8007f52:	4806      	ldr	r0, [pc, #24]	; (8007f6c <SendMessageToModule+0x40>)
 8007f54:	f00c fb87 	bl	8014666 <memset>
}
 8007f58:	2000      	movs	r0, #0
 8007f5a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		BroadcastMessage(myID, BOS_BROADCAST, code, numberOfParams);
 8007f5c:	0013      	movs	r3, r2
 8007f5e:	000a      	movs	r2, r1
 8007f60:	0021      	movs	r1, r4
 8007f62:	f7ff ffc5 	bl	8007ef0 <BroadcastMessage>
 8007f66:	e7f7      	b.n	8007f58 <SendMessageToModule+0x2c>
 8007f68:	20001039 	.word	0x20001039
 8007f6c:	20000f07 	.word	0x20000f07

08007f70 <StartScastDMAStream>:

/* --- Start a single-cast DMA stream across the array. Transfer ends after (count) bytes are transferred 
			or timeout (ms), whichever comes first. If stored = true, the stream is stored in emulated eeprom --- 
*/
BOS_Status StartScastDMAStream(uint8_t srcP, uint8_t srcM, uint8_t dstP, uint8_t dstM, uint8_t direction, uint32_t count, uint32_t timeout, bool stored)
{
 8007f70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007f72:	b093      	sub	sp, #76	; 0x4c
 8007f74:	0017      	movs	r7, r2
 8007f76:	001d      	movs	r5, r3
 8007f78:	2201      	movs	r2, #1
 8007f7a:	ab18      	add	r3, sp, #96	; 0x60
 8007f7c:	781b      	ldrb	r3, [r3, #0]
 8007f7e:	9008      	str	r0, [sp, #32]
 8007f80:	9307      	str	r3, [sp, #28]
 8007f82:	ab1b      	add	r3, sp, #108	; 0x6c
 8007f84:	781b      	ldrb	r3, [r3, #0]
 8007f86:	000c      	movs	r4, r1
 8007f88:	9309      	str	r3, [sp, #36]	; 0x24
 8007f8a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8007f8c:	9206      	str	r2, [sp, #24]
 8007f8e:	0e1b      	lsrs	r3, r3, #24
 8007f90:	930b      	str	r3, [sp, #44]	; 0x2c
 8007f92:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8007f94:	0c1b      	lsrs	r3, r3, #16
 8007f96:	b2db      	uxtb	r3, r3
 8007f98:	930c      	str	r3, [sp, #48]	; 0x30
 8007f9a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8007f9c:	0a1b      	lsrs	r3, r3, #8
 8007f9e:	b2db      	uxtb	r3, r3
 8007fa0:	9310      	str	r3, [sp, #64]	; 0x40
 8007fa2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8007fa4:	0e1b      	lsrs	r3, r3, #24
 8007fa6:	930e      	str	r3, [sp, #56]	; 0x38
 8007fa8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8007faa:	0c1b      	lsrs	r3, r3, #16
 8007fac:	b2db      	uxtb	r3, r3
 8007fae:	930d      	str	r3, [sp, #52]	; 0x34
 8007fb0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8007fb2:	0a1b      	lsrs	r3, r3, #8
 8007fb4:	b2db      	uxtb	r3, r3
 8007fb6:	930f      	str	r3, [sp, #60]	; 0x3c
	BOS_Status result = BOS_OK;
	uint8_t port = 0, temp1 = 0, temp2 = 0;
	
	/* Is the source a different module? */
	if (srcM != myID) {
 8007fb8:	4b46      	ldr	r3, [pc, #280]	; (80080d4 <StartScastDMAStream+0x164>)
 8007fba:	781b      	ldrb	r3, [r3, #0]
 8007fbc:	428b      	cmp	r3, r1
 8007fbe:	d01f      	beq.n	8008000 <StartScastDMAStream+0x90>
		/* Forward this task to the source module */
		messageParams[0] = (uint8_t) (count >> 24);			/* Count */
 8007fc0:	4b45      	ldr	r3, [pc, #276]	; (80080d8 <StartScastDMAStream+0x168>)
 8007fc2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
		messageParams[4] = (uint8_t) (timeout >> 24);		/* Timeout */
		messageParams[5] = (uint8_t) (timeout >> 16);
		messageParams[6] = (uint8_t) (timeout >> 8);
		messageParams[7] = (uint8_t) timeout;
		messageParams[8] = direction;										/* Stream direction */
		messageParams[9] = srcP;												/* Source port */
 8007fc4:	7258      	strb	r0, [r3, #9]
		messageParams[0] = (uint8_t) (count >> 24);			/* Count */
 8007fc6:	701a      	strb	r2, [r3, #0]
		messageParams[1] = (uint8_t) (count >> 16);
 8007fc8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		messageParams[10] = dstM;												/* destination module */
		messageParams[11] = dstP;												/* destination port */
		messageParams[12] = stored;											/* EEPROM storage */
		SendMessageToModule(srcM, CODE_DMA_SCAST_STREAM, 13);		
 8007fca:	211c      	movs	r1, #28
		messageParams[1] = (uint8_t) (count >> 16);
 8007fcc:	705a      	strb	r2, [r3, #1]
		messageParams[2] = (uint8_t) (count >> 8);
 8007fce:	9a10      	ldr	r2, [sp, #64]	; 0x40
		SendMessageToModule(srcM, CODE_DMA_SCAST_STREAM, 13);		
 8007fd0:	0020      	movs	r0, r4
		messageParams[2] = (uint8_t) (count >> 8);
 8007fd2:	709a      	strb	r2, [r3, #2]
		messageParams[3] = (uint8_t) count;
 8007fd4:	9a19      	ldr	r2, [sp, #100]	; 0x64
		messageParams[10] = dstM;												/* destination module */
 8007fd6:	729d      	strb	r5, [r3, #10]
		messageParams[3] = (uint8_t) count;
 8007fd8:	70da      	strb	r2, [r3, #3]
		messageParams[4] = (uint8_t) (timeout >> 24);		/* Timeout */
 8007fda:	9a0e      	ldr	r2, [sp, #56]	; 0x38
		messageParams[11] = dstP;												/* destination port */
 8007fdc:	72df      	strb	r7, [r3, #11]
		messageParams[4] = (uint8_t) (timeout >> 24);		/* Timeout */
 8007fde:	711a      	strb	r2, [r3, #4]
		messageParams[5] = (uint8_t) (timeout >> 16);
 8007fe0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8007fe2:	715a      	strb	r2, [r3, #5]
		messageParams[6] = (uint8_t) (timeout >> 8);
 8007fe4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007fe6:	719a      	strb	r2, [r3, #6]
		messageParams[7] = (uint8_t) timeout;
 8007fe8:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8007fea:	71da      	strb	r2, [r3, #7]
		messageParams[8] = direction;										/* Stream direction */
 8007fec:	9a07      	ldr	r2, [sp, #28]
 8007fee:	721a      	strb	r2, [r3, #8]
		messageParams[12] = stored;											/* EEPROM storage */
 8007ff0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007ff2:	731a      	strb	r2, [r3, #12]
		SendMessageToModule(srcM, CODE_DMA_SCAST_STREAM, 13);		
 8007ff4:	220d      	movs	r2, #13
 8007ff6:	f7ff ff99 	bl	8007f2c <SendMessageToModule>
		SaveEEstreams(direction, count, timeout, srcP, port, 0, 0, 0, 0);
	}
	
	
	return result;
}
 8007ffa:	2000      	movs	r0, #0
 8007ffc:	b013      	add	sp, #76	; 0x4c
 8007ffe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		FindRoute(srcM, dstM);
 8008000:	0029      	movs	r1, r5
 8008002:	0020      	movs	r0, r4
 8008004:	f7fb fb26 	bl	8003654 <FindRoute>
 8008008:	9b06      	ldr	r3, [sp, #24]
 800800a:	4e34      	ldr	r6, [pc, #208]	; (80080dc <StartScastDMAStream+0x16c>)
 800800c:	199e      	adds	r6, r3, r6
 800800e:	1e73      	subs	r3, r6, #1
		if (route[i]) 
 8008010:	7818      	ldrb	r0, [r3, #0]
 8008012:	9311      	str	r3, [sp, #68]	; 0x44
 8008014:	2800      	cmp	r0, #0
 8008016:	d038      	beq.n	800808a <StartScastDMAStream+0x11a>
			if (route[i+1]) {
 8008018:	7831      	ldrb	r1, [r6, #0]
 800801a:	2900      	cmp	r1, #0
 800801c:	d058      	beq.n	80080d0 <StartScastDMAStream+0x160>
				temp1 = FindRoute(route[i], srcM);
 800801e:	f7fb fb19 	bl	8003654 <FindRoute>
			FindRoute(srcM, dstM);
 8008022:	0029      	movs	r1, r5
				temp1 = FindRoute(route[i], srcM);
 8008024:	900a      	str	r0, [sp, #40]	; 0x28
			FindRoute(srcM, dstM);
 8008026:	0020      	movs	r0, r4
 8008028:	f7fb fb14 	bl	8003654 <FindRoute>
			if (route[i] == dstM) {
 800802c:	1e73      	subs	r3, r6, #1
 800802e:	7818      	ldrb	r0, [r3, #0]
				temp2 = dstP;
 8008030:	003a      	movs	r2, r7
			if (route[i] == dstM) {
 8008032:	42a8      	cmp	r0, r5
 8008034:	d004      	beq.n	8008040 <StartScastDMAStream+0xd0>
				temp2 = FindRoute(route[i], route[i-1]);
 8008036:	3e02      	subs	r6, #2
 8008038:	7831      	ldrb	r1, [r6, #0]
 800803a:	f7fb fb0b 	bl	8003654 <FindRoute>
 800803e:	0002      	movs	r2, r0
			messageParams[0] = (uint8_t) (count >> 24);			/* Count */
 8008040:	4b25      	ldr	r3, [pc, #148]	; (80080d8 <StartScastDMAStream+0x168>)
 8008042:	990b      	ldr	r1, [sp, #44]	; 0x2c
			messageParams[10] = temp2;											/* destination port */
 8008044:	729a      	strb	r2, [r3, #10]
			messageParams[0] = (uint8_t) (count >> 24);			/* Count */
 8008046:	7019      	strb	r1, [r3, #0]
			messageParams[1] = (uint8_t) (count >> 16);
 8008048:	990c      	ldr	r1, [sp, #48]	; 0x30
			messageParams[11] = stored;											/* EEPROM storage */
 800804a:	9a09      	ldr	r2, [sp, #36]	; 0x24
			messageParams[1] = (uint8_t) (count >> 16);
 800804c:	7059      	strb	r1, [r3, #1]
			messageParams[2] = (uint8_t) (count >> 8);
 800804e:	9910      	ldr	r1, [sp, #64]	; 0x40
			FindRoute(srcM, dstM);
 8008050:	0020      	movs	r0, r4
			messageParams[2] = (uint8_t) (count >> 8);
 8008052:	7099      	strb	r1, [r3, #2]
			messageParams[3] = (uint8_t) count;
 8008054:	9919      	ldr	r1, [sp, #100]	; 0x64
			messageParams[11] = stored;											/* EEPROM storage */
 8008056:	72da      	strb	r2, [r3, #11]
			messageParams[3] = (uint8_t) count;
 8008058:	70d9      	strb	r1, [r3, #3]
			messageParams[4] = (uint8_t) (timeout >> 24);		/* Timeout */
 800805a:	990e      	ldr	r1, [sp, #56]	; 0x38
 800805c:	7119      	strb	r1, [r3, #4]
			messageParams[5] = (uint8_t) (timeout >> 16);
 800805e:	990d      	ldr	r1, [sp, #52]	; 0x34
 8008060:	7159      	strb	r1, [r3, #5]
			messageParams[6] = (uint8_t) (timeout >> 8);
 8008062:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8008064:	7199      	strb	r1, [r3, #6]
			messageParams[7] = (uint8_t) timeout;
 8008066:	991a      	ldr	r1, [sp, #104]	; 0x68
 8008068:	71d9      	strb	r1, [r3, #7]
			messageParams[8] = direction;										/* Stream direction */
 800806a:	9907      	ldr	r1, [sp, #28]
 800806c:	7219      	strb	r1, [r3, #8]
			messageParams[9] = temp1;												/* Source port */
 800806e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008070:	7259      	strb	r1, [r3, #9]
			FindRoute(srcM, dstM);
 8008072:	0029      	movs	r1, r5
 8008074:	f7fb faee 	bl	8003654 <FindRoute>
			SendMessageToModule(route[i], CODE_DMA_CHANNEL, 12);
 8008078:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800807a:	220c      	movs	r2, #12
 800807c:	7818      	ldrb	r0, [r3, #0]
 800807e:	211b      	movs	r1, #27
 8008080:	f7ff ff54 	bl	8007f2c <SendMessageToModule>
			osDelay(10);
 8008084:	200a      	movs	r0, #10
 8008086:	f007 fb6c 	bl	800f762 <osDelay>
 800808a:	9b06      	ldr	r3, [sp, #24]
 800808c:	3301      	adds	r3, #1
 800808e:	9306      	str	r3, [sp, #24]
	for(uint8_t i=0 ; i<sizeof(route) ; i++)
 8008090:	2b1a      	cmp	r3, #26
 8008092:	d1b5      	bne.n	8008000 <StartScastDMAStream+0x90>
	if (srcM == dstM)
 8008094:	42ac      	cmp	r4, r5
 8008096:	d004      	beq.n	80080a2 <StartScastDMAStream+0x132>
		port = FindRoute(srcM, dstM);
 8008098:	0029      	movs	r1, r5
 800809a:	0020      	movs	r0, r4
 800809c:	f7fb fada 	bl	8003654 <FindRoute>
 80080a0:	0007      	movs	r7, r0
	SetupDMAStreams(direction, count, timeout, srcP, port);
 80080a2:	9b08      	ldr	r3, [sp, #32]
 80080a4:	9700      	str	r7, [sp, #0]
 80080a6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80080a8:	9919      	ldr	r1, [sp, #100]	; 0x64
 80080aa:	9807      	ldr	r0, [sp, #28]
 80080ac:	f7ff fc96 	bl	80079dc <SetupDMAStreams>
	if (stored) {		
 80080b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80080b2:	2b00      	cmp	r3, #0
 80080b4:	d0a1      	beq.n	8007ffa <StartScastDMAStream+0x8a>
		SaveEEstreams(direction, count, timeout, srcP, port, 0, 0, 0, 0);
 80080b6:	2300      	movs	r3, #0
 80080b8:	9700      	str	r7, [sp, #0]
 80080ba:	9304      	str	r3, [sp, #16]
 80080bc:	9303      	str	r3, [sp, #12]
 80080be:	9302      	str	r3, [sp, #8]
 80080c0:	9301      	str	r3, [sp, #4]
 80080c2:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80080c4:	9b08      	ldr	r3, [sp, #32]
 80080c6:	9919      	ldr	r1, [sp, #100]	; 0x64
 80080c8:	9807      	ldr	r0, [sp, #28]
 80080ca:	f7fa ffed 	bl	80030a8 <SaveEEstreams>
 80080ce:	e794      	b.n	8007ffa <StartScastDMAStream+0x8a>
				temp1 = FindRoute(route[i], srcM);
 80080d0:	0021      	movs	r1, r4
 80080d2:	e7a4      	b.n	800801e <StartScastDMAStream+0xae>
 80080d4:	20001039 	.word	0x20001039
 80080d8:	20000f07 	.word	0x20000f07
 80080dc:	20007028 	.word	0x20007028

080080e0 <BackEndTask>:

/*-----------------------------------------------------------*/

/* BackEndTask function */
void BackEndTask(void * argument)
{
 80080e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	int packetStart = 0, packetEnd = 0, packetLength = 0, parseStart = 0;
 80080e2:	2400      	movs	r4, #0
{
 80080e4:	b08d      	sub	sp, #52	; 0x34
 80080e6:	2301      	movs	r3, #1
 80080e8:	0025      	movs	r5, r4
 80080ea:	4fac      	ldr	r7, [pc, #688]	; (800839c <BackEndTask+0x2bc>)
 80080ec:	9301      	str	r3, [sp, #4]
 80080ee:	466b      	mov	r3, sp
 80080f0:	791b      	ldrb	r3, [r3, #4]
  {
		/* Search the circular receive buffers for any complete packets */	
		for (port=1 ; port <= NumOfPorts; port++)
		{
			/* A. Check for BOS messages */	
			if (portStatus[port] == MSG || portStatus[port] == FREE) 
 80080f2:	9a01      	ldr	r2, [sp, #4]
 80080f4:	9309      	str	r3, [sp, #36]	; 0x24
 80080f6:	9b01      	ldr	r3, [sp, #4]
 80080f8:	3b01      	subs	r3, #1
 80080fa:	9307      	str	r3, [sp, #28]
 80080fc:	4ba8      	ldr	r3, [pc, #672]	; (80083a0 <BackEndTask+0x2c0>)
 80080fe:	5c9b      	ldrb	r3, [r3, r2]
 8008100:	2b01      	cmp	r3, #1
 8008102:	d900      	bls.n	8008106 <BackEndTask+0x26>
 8008104:	e120      	b.n	8008348 <BackEndTask+0x268>
			{	
				/* A.1. Look for HZ delimiter and determine packet start */
				/* Note this parses only a single packet on each pass TODO update to parse all */

				for (int i=UARTRxBufIndex[port-1]; i<MSG_RX_BUF_SIZE ; i++)
 8008106:	2600      	movs	r6, #0
 8008108:	4ba6      	ldr	r3, [pc, #664]	; (80083a4 <BackEndTask+0x2c4>)
 800810a:	9a07      	ldr	r2, [sp, #28]
 800810c:	18d3      	adds	r3, r2, r3
 800810e:	781c      	ldrb	r4, [r3, #0]
 8008110:	9306      	str	r3, [sp, #24]
 8008112:	2c3f      	cmp	r4, #63	; 0x3f
 8008114:	dd03      	ble.n	800811e <BackEndTask+0x3e>
 8008116:	002c      	movs	r4, r5
 8008118:	e00d      	b.n	8008136 <BackEndTask+0x56>
 800811a:	0025      	movs	r5, r4
 800811c:	e7e7      	b.n	80080ee <BackEndTask+0xe>
				{
					if (i < (MSG_RX_BUF_SIZE-1) && UARTRxBuf[port-1][i] == 'H' && UARTRxBuf[port-1][i+1] == 'Z')	
 800811e:	2c3f      	cmp	r4, #63	; 0x3f
 8008120:	d100      	bne.n	8008124 <BackEndTask+0x44>
 8008122:	e08a      	b.n	800823a <BackEndTask+0x15a>
 8008124:	5d3b      	ldrb	r3, [r7, r4]
 8008126:	2b48      	cmp	r3, #72	; 0x48
 8008128:	d000      	beq.n	800812c <BackEndTask+0x4c>
 800812a:	e0ba      	b.n	80082a2 <BackEndTask+0x1c2>
 800812c:	193b      	adds	r3, r7, r4
 800812e:	785b      	ldrb	r3, [r3, #1]
 8008130:	2b5a      	cmp	r3, #90	; 0x5a
 8008132:	d000      	beq.n	8008136 <BackEndTask+0x56>
 8008134:	e0b5      	b.n	80082a2 <BackEndTask+0x1c2>
						}
					}						
				}
						
				/* Check parse status */
				if (emptyBuffer) {	
 8008136:	2e00      	cmp	r6, #0
 8008138:	d175      	bne.n	8008226 <BackEndTask+0x146>
					emptyBuffer = false;
					continue;
				}
				
				/* A.2. Parse the length byte */
				if (packetStart == MSG_RX_BUF_SIZE-3) {
 800813a:	2c3d      	cmp	r4, #61	; 0x3d
 800813c:	d000      	beq.n	8008140 <BackEndTask+0x60>
 800813e:	e0b6      	b.n	80082ae <BackEndTask+0x1ce>
					packetLength = UARTRxBuf[port-1][MSG_RX_BUF_SIZE-1];
 8008140:	003b      	movs	r3, r7
 8008142:	333f      	adds	r3, #63	; 0x3f
 8008144:	781b      	ldrb	r3, [r3, #0]
					parseStart = 0;				
 8008146:	9604      	str	r6, [sp, #16]
					packetLength = UARTRxBuf[port-1][MSG_RX_BUF_SIZE-1];
 8008148:	9302      	str	r3, [sp, #8]
					packetLength = UARTRxBuf[port-1][packetStart+2];
					parseStart = packetStart+3;
				}
				
				/* A.3. Set packet end from packet start and length */			
						packetEnd = packetStart + (packetLength + 3);			// Packet length is counted from Dst to before CRC
 800814a:	9b02      	ldr	r3, [sp, #8]
 800814c:	1cde      	adds	r6, r3, #3
 800814e:	1933      	adds	r3, r6, r4
 8008150:	9303      	str	r3, [sp, #12]
				if (packetEnd > MSG_RX_BUF_SIZE-1)												// wrap-around
 8008152:	2b3f      	cmp	r3, #63	; 0x3f
 8008154:	dd01      	ble.n	800815a <BackEndTask+0x7a>
					packetEnd -= MSG_RX_BUF_SIZE;
 8008156:	3b40      	subs	r3, #64	; 0x40
 8008158:	9303      	str	r3, [sp, #12]
 800815a:	9b01      	ldr	r3, [sp, #4]
 800815c:	4a92      	ldr	r2, [pc, #584]	; (80083a8 <BackEndTask+0x2c8>)
 800815e:	1899      	adds	r1, r3, r2
 8008160:	018b      	lsls	r3, r1, #6
 8008162:	18e2      	adds	r2, r4, r3
 8008164:	930a      	str	r3, [sp, #40]	; 0x28
 8008166:	4b8d      	ldr	r3, [pc, #564]	; (800839c <BackEndTask+0x2bc>)
 8008168:	18d3      	adds	r3, r2, r3
 800816a:	9305      	str	r3, [sp, #20]
			
				if (packetStart != packetEnd)										// Non-empty packet
 800816c:	9b03      	ldr	r3, [sp, #12]
 800816e:	42a3      	cmp	r3, r4
 8008170:	d100      	bne.n	8008174 <BackEndTask+0x94>
 8008172:	e102      	b.n	800837a <BackEndTask+0x29a>
				{				
					Delay_ms(1);
 8008174:	2001      	movs	r0, #1
 8008176:	f009 f9c9 	bl	801150c <HAL_Delay>
					/* A.4. Calculate packet CRC */				
					if (packetStart < packetEnd) {
 800817a:	9b03      	ldr	r3, [sp, #12]
 800817c:	4d8b      	ldr	r5, [pc, #556]	; (80083ac <BackEndTask+0x2cc>)
 800817e:	42a3      	cmp	r3, r4
 8008180:	dc00      	bgt.n	8008184 <BackEndTask+0xa4>
 8008182:	e0ab      	b.n	80082dc <BackEndTask+0x1fc>
						memcpy(crcBuffer, &UARTRxBuf[port-1][packetStart], packetLength + 3);						
 8008184:	0032      	movs	r2, r6
 8008186:	0028      	movs	r0, r5
 8008188:	9905      	ldr	r1, [sp, #20]
					} else {				// wrap around
						memcpy(crcBuffer, &UARTRxBuf[port-1][packetStart], MSG_RX_BUF_SIZE-packetStart);
						memcpy(&crcBuffer[MSG_RX_BUF_SIZE-packetStart], &UARTRxBuf[port-1][0], (packetLength + 3) - (MSG_RX_BUF_SIZE-packetStart));
 800818a:	f00c fa63 	bl	8014654 <memcpy>
					}

					/* crc8 calculation */
					crc8 = CalculateCRC8((uint32_t *)&crcBuffer, (packetLength + 3));						
 800818e:	9b02      	ldr	r3, [sp, #8]
 8008190:	4e86      	ldr	r6, [pc, #536]	; (80083ac <BackEndTask+0x2cc>)
 8008192:	1cd9      	adds	r1, r3, #3
 8008194:	0030      	movs	r0, r6
 8008196:	f003 fee9 	bl	800bf6c <CalculateCRC8>
					memset(crcBuffer, 0, sizeof(crcBuffer));
 800819a:	2538      	movs	r5, #56	; 0x38
					crc8 = CalculateCRC8((uint32_t *)&crcBuffer, (packetLength + 3));						
 800819c:	900b      	str	r0, [sp, #44]	; 0x2c
					memset(crcBuffer, 0, sizeof(crcBuffer));
 800819e:	002a      	movs	r2, r5
 80081a0:	2100      	movs	r1, #0
 80081a2:	0030      	movs	r0, r6
 80081a4:	f00c fa5f 	bl	8014666 <memset>
 80081a8:	9b02      	ldr	r3, [sp, #8]
					
					//if(!crc8){crc8=1;} /*Making sure CRC Value Is not Zero*/
					
					/* A.5. Compare CRC. If matched, accept the packet as a BOS message and notify the appropriate message parser task */
					if (crc8 == UARTRxBuf[port-1][packetEnd])
 80081aa:	4a7c      	ldr	r2, [pc, #496]	; (800839c <BackEndTask+0x2bc>)
 80081ac:	3304      	adds	r3, #4
 80081ae:	9308      	str	r3, [sp, #32]
 80081b0:	9b07      	ldr	r3, [sp, #28]
 80081b2:	9903      	ldr	r1, [sp, #12]
 80081b4:	019b      	lsls	r3, r3, #6
 80081b6:	18d3      	adds	r3, r2, r3
 80081b8:	5c5b      	ldrb	r3, [r3, r1]
 80081ba:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80081bc:	428b      	cmp	r3, r1
 80081be:	d000      	beq.n	80081c2 <BackEndTask+0xe2>
 80081c0:	e0b2      	b.n	8008328 <BackEndTask+0x248>
					{	
						portStatus[port] = MSG;
 80081c2:	2001      	movs	r0, #1
 80081c4:	9901      	ldr	r1, [sp, #4]
 80081c6:	4b76      	ldr	r3, [pc, #472]	; (80083a0 <BackEndTask+0x2c0>)
 80081c8:	9e04      	ldr	r6, [sp, #16]
 80081ca:	5458      	strb	r0, [r3, r1]
						messageLength[port-1] = packetLength;	
 80081cc:	000b      	movs	r3, r1
 80081ce:	9802      	ldr	r0, [sp, #8]
 80081d0:	4977      	ldr	r1, [pc, #476]	; (80083b0 <BackEndTask+0x2d0>)
 80081d2:	3b01      	subs	r3, #1
 80081d4:	54c8      	strb	r0, [r1, r3]
 80081d6:	9801      	ldr	r0, [sp, #4]
 80081d8:	46b4      	mov	ip, r6
 80081da:	4368      	muls	r0, r5
 80081dc:	0003      	movs	r3, r0
 80081de:	4d75      	ldr	r5, [pc, #468]	; (80083b4 <BackEndTask+0x2d4>)
 80081e0:	3b38      	subs	r3, #56	; 0x38
 80081e2:	9307      	str	r3, [sp, #28]
 80081e4:	002b      	movs	r3, r5
 80081e6:	3b38      	subs	r3, #56	; 0x38
 80081e8:	1818      	adds	r0, r3, r0
 80081ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80081ec:	4463      	add	r3, ip
 80081ee:	1899      	adds	r1, r3, r2

						/* A.5.1. Copy the packet to message buffer */	
						if ((packetLength) <= (MSG_RX_BUF_SIZE-parseStart-1)) {
 80081f0:	233f      	movs	r3, #63	; 0x3f
 80081f2:	9a02      	ldr	r2, [sp, #8]
 80081f4:	1b9b      	subs	r3, r3, r6
 80081f6:	4293      	cmp	r3, r2
 80081f8:	db7d      	blt.n	80082f6 <BackEndTask+0x216>
							memcpy(&cMessage[port-1][0], &UARTRxBuf[port-1][parseStart], packetLength);	
						} else {				// Message wraps around
							memcpy(&cMessage[port-1][0], &UARTRxBuf[port-1][parseStart], MSG_RX_BUF_SIZE-parseStart);
							memcpy(&cMessage[port-1][MSG_RX_BUF_SIZE-parseStart], &UARTRxBuf[port-1][0], (packetLength)-(MSG_RX_BUF_SIZE-parseStart));	// wrap-around
 80081fa:	f00c fa2b 	bl	8014654 <memcpy>
						}
						
						/* A.5.2 Clear packet location in the circular buffer */                
						if (packetStart < packetEnd) {
 80081fe:	9b03      	ldr	r3, [sp, #12]
 8008200:	42a3      	cmp	r3, r4
 8008202:	dc00      	bgt.n	8008206 <BackEndTask+0x126>
 8008204:	e084      	b.n	8008310 <BackEndTask+0x230>
								memset(&UARTRxBuf[port-1][packetStart], 0, (packetLength) + 4);                        
 8008206:	2100      	movs	r1, #0
 8008208:	9a08      	ldr	r2, [sp, #32]
 800820a:	9805      	ldr	r0, [sp, #20]
						} else {                // wrap around
								memset(&UARTRxBuf[port-1][packetStart], 0, MSG_RX_BUF_SIZE-packetStart);
								memset(&UARTRxBuf[port-1][0], 0, ((packetLength) + 4) - (MSG_RX_BUF_SIZE-packetStart));
 800820c:	f00c fa2b 	bl	8014666 <memset>
						}                                            
							
						/* A.5.3 Advance buffer index */													
						UARTRxBufIndex[port-1] = (packetEnd+1);			// Set buffer pointer after the CRC byte 
 8008210:	9b03      	ldr	r3, [sp, #12]
 8008212:	9a06      	ldr	r2, [sp, #24]
 8008214:	3301      	adds	r3, #1
 8008216:	7013      	strb	r3, [r2, #0]
						++acceptedMsg;
 8008218:	4a67      	ldr	r2, [pc, #412]	; (80083b8 <BackEndTask+0x2d8>)
				
						/* A.5.4. Notify messaging tasks */
						NotifyMessagingTask(port);	
 800821a:	9809      	ldr	r0, [sp, #36]	; 0x24
						++acceptedMsg;
 800821c:	8813      	ldrh	r3, [r2, #0]
 800821e:	3301      	adds	r3, #1
 8008220:	8013      	strh	r3, [r2, #0]
						NotifyMessagingTask(port);	
 8008222:	f7ff fc95 	bl	8007b50 <NotifyMessagingTask>
 8008226:	9b01      	ldr	r3, [sp, #4]
 8008228:	3740      	adds	r7, #64	; 0x40
 800822a:	3301      	adds	r3, #1
 800822c:	9301      	str	r3, [sp, #4]
		for (port=1 ; port <= NumOfPorts; port++)
 800822e:	2b06      	cmp	r3, #6
 8008230:	d000      	beq.n	8008234 <BackEndTask+0x154>
 8008232:	e772      	b.n	800811a <BackEndTask+0x3a>
				if (portStatus[port] == OVERRUN)	portStatus[port] = FREE;
				HAL_UART_Receive_DMA(GetUart(port), (uint8_t *)&UARTRxBuf[port-1], MSG_RX_BUF_SIZE);
			}				
		}
		
		taskYIELD();
 8008234:	f009 f80e 	bl	8011254 <vPortYield>
		for (port=1 ; port <= NumOfPorts; port++)
 8008238:	e755      	b.n	80080e6 <BackEndTask+0x6>
					else if (i == (MSG_RX_BUF_SIZE-1) && UARTRxBuf[port-1][MSG_RX_BUF_SIZE-1] == 'H' && UARTRxBuf[port-1][0] == 'Z')	// HZ wrap around
 800823a:	003b      	movs	r3, r7
 800823c:	333f      	adds	r3, #63	; 0x3f
 800823e:	781b      	ldrb	r3, [r3, #0]
 8008240:	2b48      	cmp	r3, #72	; 0x48
 8008242:	d103      	bne.n	800824c <BackEndTask+0x16c>
 8008244:	783b      	ldrb	r3, [r7, #0]
 8008246:	2b5a      	cmp	r3, #90	; 0x5a
 8008248:	d100      	bne.n	800824c <BackEndTask+0x16c>
 800824a:	e0a3      	b.n	8008394 <BackEndTask+0x2b4>
							if (BOS.disableCLI == false)
 800824c:	4b5b      	ldr	r3, [pc, #364]	; (80083bc <BackEndTask+0x2dc>)
							emptyBuffer = true;
 800824e:	2601      	movs	r6, #1
							if (BOS.disableCLI == false)
 8008250:	7edb      	ldrb	r3, [r3, #27]
 8008252:	2b00      	cmp	r3, #0
 8008254:	d125      	bne.n	80082a2 <BackEndTask+0x1c2>
								for (int j=UARTRxBufIndex[port-1] ; j<MSG_RX_BUF_SIZE ; j++)
 8008256:	9b06      	ldr	r3, [sp, #24]
 8008258:	781b      	ldrb	r3, [r3, #0]
 800825a:	2b3f      	cmp	r3, #63	; 0x3f
 800825c:	dc20      	bgt.n	80082a0 <BackEndTask+0x1c0>
									if (UARTRxBuf[port-1][j] == 0xD && ((j < MSG_RX_BUF_SIZE-1 && UARTRxBuf[port-1][j+1] == 0) || (j == MSG_RX_BUF_SIZE-1 && UARTRxBuf[port-1][0] == 0) ) ) 
 800825e:	5cfa      	ldrb	r2, [r7, r3]
 8008260:	2a0d      	cmp	r2, #13
 8008262:	d122      	bne.n	80082aa <BackEndTask+0x1ca>
 8008264:	2b3f      	cmp	r3, #63	; 0x3f
 8008266:	d01e      	beq.n	80082a6 <BackEndTask+0x1c6>
 8008268:	18fa      	adds	r2, r7, r3
 800826a:	7852      	ldrb	r2, [r2, #1]
 800826c:	2a00      	cmp	r2, #0
 800826e:	d11c      	bne.n	80082aa <BackEndTask+0x1ca>
										UARTRxBuf[port-1][j] = 0;
 8008270:	9a07      	ldr	r2, [sp, #28]
										portStatus[port] = CLI;					// Continue the CLI session on this port
 8008272:	2603      	movs	r6, #3
										UARTRxBuf[port-1][j] = 0;
 8008274:	0191      	lsls	r1, r2, #6
 8008276:	4a49      	ldr	r2, [pc, #292]	; (800839c <BackEndTask+0x2bc>)
 8008278:	1852      	adds	r2, r2, r1
 800827a:	2100      	movs	r1, #0
 800827c:	54d1      	strb	r1, [r2, r3]
										UARTRxBufIndex[port-1] = j+1;		// Advance buffer index
 800827e:	9a06      	ldr	r2, [sp, #24]
 8008280:	3301      	adds	r3, #1
 8008282:	7013      	strb	r3, [r2, #0]
										portStatus[PcPort] = FREE;			// Free the previous CLI port 
 8008284:	4b4e      	ldr	r3, [pc, #312]	; (80083c0 <BackEndTask+0x2e0>)
 8008286:	4a46      	ldr	r2, [pc, #280]	; (80083a0 <BackEndTask+0x2c0>)
 8008288:	7818      	ldrb	r0, [r3, #0]
 800828a:	5411      	strb	r1, [r2, r0]
										portStatus[port] = CLI;					// Continue the CLI session on this port
 800828c:	9801      	ldr	r0, [sp, #4]
 800828e:	5416      	strb	r6, [r2, r0]
										PcPort = port;
 8008290:	9a09      	ldr	r2, [sp, #36]	; 0x24
										xTaskNotifyGive(xCommandConsoleTaskHandle);		
 8008292:	484c      	ldr	r0, [pc, #304]	; (80083c4 <BackEndTask+0x2e4>)
										PcPort = port;
 8008294:	701a      	strb	r2, [r3, #0]
										xTaskNotifyGive(xCommandConsoleTaskHandle);		
 8008296:	6800      	ldr	r0, [r0, #0]
 8008298:	000b      	movs	r3, r1
 800829a:	2202      	movs	r2, #2
 800829c:	f008 fd8e 	bl	8010dbc <xTaskGenericNotify>
							emptyBuffer = true;
 80082a0:	2601      	movs	r6, #1
				for (int i=UARTRxBufIndex[port-1]; i<MSG_RX_BUF_SIZE ; i++)
 80082a2:	3401      	adds	r4, #1
 80082a4:	e735      	b.n	8008112 <BackEndTask+0x32>
									if (UARTRxBuf[port-1][j] == 0xD && ((j < MSG_RX_BUF_SIZE-1 && UARTRxBuf[port-1][j+1] == 0) || (j == MSG_RX_BUF_SIZE-1 && UARTRxBuf[port-1][0] == 0) ) ) 
 80082a6:	783a      	ldrb	r2, [r7, #0]
 80082a8:	e7e0      	b.n	800826c <BackEndTask+0x18c>
								for (int j=UARTRxBufIndex[port-1] ; j<MSG_RX_BUF_SIZE ; j++)
 80082aa:	3301      	adds	r3, #1
 80082ac:	e7d5      	b.n	800825a <BackEndTask+0x17a>
				} else if (packetStart == MSG_RX_BUF_SIZE-2) {
 80082ae:	2c3e      	cmp	r4, #62	; 0x3e
 80082b0:	d104      	bne.n	80082bc <BackEndTask+0x1dc>
					packetLength = UARTRxBuf[port-1][0];
 80082b2:	783b      	ldrb	r3, [r7, #0]
 80082b4:	9302      	str	r3, [sp, #8]
					parseStart = 1;
 80082b6:	2301      	movs	r3, #1
					parseStart = packetStart+3;
 80082b8:	9304      	str	r3, [sp, #16]
 80082ba:	e746      	b.n	800814a <BackEndTask+0x6a>
				} else if (packetStart == MSG_RX_BUF_SIZE-1) {
 80082bc:	2c3f      	cmp	r4, #63	; 0x3f
 80082be:	d104      	bne.n	80082ca <BackEndTask+0x1ea>
					packetLength = UARTRxBuf[port-1][1];
 80082c0:	787b      	ldrb	r3, [r7, #1]
 80082c2:	243f      	movs	r4, #63	; 0x3f
 80082c4:	9302      	str	r3, [sp, #8]
					parseStart = 2;
 80082c6:	2302      	movs	r3, #2
 80082c8:	e7f6      	b.n	80082b8 <BackEndTask+0x1d8>
					packetLength = UARTRxBuf[port-1][packetStart+2];
 80082ca:	9b07      	ldr	r3, [sp, #28]
 80082cc:	019a      	lsls	r2, r3, #6
 80082ce:	4b33      	ldr	r3, [pc, #204]	; (800839c <BackEndTask+0x2bc>)
 80082d0:	189b      	adds	r3, r3, r2
 80082d2:	191b      	adds	r3, r3, r4
 80082d4:	789b      	ldrb	r3, [r3, #2]
 80082d6:	9302      	str	r3, [sp, #8]
					parseStart = packetStart+3;
 80082d8:	1ce3      	adds	r3, r4, #3
 80082da:	e7ed      	b.n	80082b8 <BackEndTask+0x1d8>
						memcpy(crcBuffer, &UARTRxBuf[port-1][packetStart], MSG_RX_BUF_SIZE-packetStart);
 80082dc:	2340      	movs	r3, #64	; 0x40
 80082de:	1b1b      	subs	r3, r3, r4
 80082e0:	001a      	movs	r2, r3
 80082e2:	9905      	ldr	r1, [sp, #20]
 80082e4:	0028      	movs	r0, r5
 80082e6:	9308      	str	r3, [sp, #32]
 80082e8:	f00c f9b4 	bl	8014654 <memcpy>
						memcpy(&crcBuffer[MSG_RX_BUF_SIZE-packetStart], &UARTRxBuf[port-1][0], (packetLength + 3) - (MSG_RX_BUF_SIZE-packetStart));
 80082ec:	9b08      	ldr	r3, [sp, #32]
 80082ee:	0039      	movs	r1, r7
 80082f0:	18e8      	adds	r0, r5, r3
 80082f2:	1af2      	subs	r2, r6, r3
 80082f4:	e749      	b.n	800818a <BackEndTask+0xaa>
							memcpy(&cMessage[port-1][0], &UARTRxBuf[port-1][parseStart], MSG_RX_BUF_SIZE-parseStart);
 80082f6:	2640      	movs	r6, #64	; 0x40
 80082f8:	9b04      	ldr	r3, [sp, #16]
 80082fa:	1af6      	subs	r6, r6, r3
 80082fc:	0032      	movs	r2, r6
 80082fe:	f00c f9a9 	bl	8014654 <memcpy>
							memcpy(&cMessage[port-1][MSG_RX_BUF_SIZE-parseStart], &UARTRxBuf[port-1][0], (packetLength)-(MSG_RX_BUF_SIZE-parseStart));	// wrap-around
 8008302:	9b07      	ldr	r3, [sp, #28]
 8008304:	0039      	movs	r1, r7
 8008306:	1998      	adds	r0, r3, r6
 8008308:	9b02      	ldr	r3, [sp, #8]
 800830a:	1940      	adds	r0, r0, r5
 800830c:	1b9a      	subs	r2, r3, r6
 800830e:	e774      	b.n	80081fa <BackEndTask+0x11a>
								memset(&UARTRxBuf[port-1][packetStart], 0, MSG_RX_BUF_SIZE-packetStart);
 8008310:	2540      	movs	r5, #64	; 0x40
 8008312:	1b2d      	subs	r5, r5, r4
 8008314:	002a      	movs	r2, r5
 8008316:	2100      	movs	r1, #0
 8008318:	9805      	ldr	r0, [sp, #20]
 800831a:	f00c f9a4 	bl	8014666 <memset>
								memset(&UARTRxBuf[port-1][0], 0, ((packetLength) + 4) - (MSG_RX_BUF_SIZE-packetStart));
 800831e:	9b08      	ldr	r3, [sp, #32]
 8008320:	2100      	movs	r1, #0
 8008322:	1b5a      	subs	r2, r3, r5
 8008324:	0038      	movs	r0, r7
 8008326:	e771      	b.n	800820c <BackEndTask+0x12c>
				if (packetStart < packetEnd) {
 8008328:	9b03      	ldr	r3, [sp, #12]
 800832a:	42a3      	cmp	r3, r4
 800832c:	dd25      	ble.n	800837a <BackEndTask+0x29a>
						memset(&UARTRxBuf[port-1][packetStart], 0, (packetLength) + 4);                        
 800832e:	2100      	movs	r1, #0
 8008330:	9a08      	ldr	r2, [sp, #32]
 8008332:	9805      	ldr	r0, [sp, #20]
						memset(&UARTRxBuf[port-1][0], 0, ((packetLength) + 4) - (MSG_RX_BUF_SIZE-packetStart));
 8008334:	f00c f997 	bl	8014666 <memset>
				UARTRxBufIndex[port-1] = (packetEnd+1);			// Set buffer pointer after the CRC byte 
 8008338:	9b03      	ldr	r3, [sp, #12]
 800833a:	9a06      	ldr	r2, [sp, #24]
 800833c:	3301      	adds	r3, #1
 800833e:	7013      	strb	r3, [r2, #0]
				++rejectedMsg;							
 8008340:	4a21      	ldr	r2, [pc, #132]	; (80083c8 <BackEndTask+0x2e8>)
 8008342:	8813      	ldrh	r3, [r2, #0]
 8008344:	3301      	adds	r3, #1
 8008346:	8013      	strh	r3, [r2, #0]
 8008348:	9b01      	ldr	r3, [sp, #4]
 800834a:	4a20      	ldr	r2, [pc, #128]	; (80083cc <BackEndTask+0x2ec>)
 800834c:	3b01      	subs	r3, #1
 800834e:	189b      	adds	r3, r3, r2
			if (MsgDMAStopped[port-1] == true) {
 8008350:	781a      	ldrb	r2, [r3, #0]
 8008352:	2a00      	cmp	r2, #0
 8008354:	d100      	bne.n	8008358 <BackEndTask+0x278>
 8008356:	e766      	b.n	8008226 <BackEndTask+0x146>
				MsgDMAStopped[port-1] = false;
 8008358:	2200      	movs	r2, #0
				if (portStatus[port] == OVERRUN)	portStatus[port] = FREE;
 800835a:	9901      	ldr	r1, [sp, #4]
				MsgDMAStopped[port-1] = false;
 800835c:	701a      	strb	r2, [r3, #0]
				if (portStatus[port] == OVERRUN)	portStatus[port] = FREE;
 800835e:	4b10      	ldr	r3, [pc, #64]	; (80083a0 <BackEndTask+0x2c0>)
 8008360:	18cb      	adds	r3, r1, r3
 8008362:	7819      	ldrb	r1, [r3, #0]
 8008364:	2905      	cmp	r1, #5
 8008366:	d100      	bne.n	800836a <BackEndTask+0x28a>
 8008368:	701a      	strb	r2, [r3, #0]
				HAL_UART_Receive_DMA(GetUart(port), (uint8_t *)&UARTRxBuf[port-1], MSG_RX_BUF_SIZE);
 800836a:	9809      	ldr	r0, [sp, #36]	; 0x24
 800836c:	f005 f848 	bl	800d400 <GetUart>
 8008370:	2240      	movs	r2, #64	; 0x40
 8008372:	0039      	movs	r1, r7
 8008374:	f00b facc 	bl	8013910 <HAL_UART_Receive_DMA>
 8008378:	e755      	b.n	8008226 <BackEndTask+0x146>
						memset(&UARTRxBuf[port-1][packetStart], 0, MSG_RX_BUF_SIZE-packetStart);
 800837a:	2540      	movs	r5, #64	; 0x40
 800837c:	1b2d      	subs	r5, r5, r4
 800837e:	002a      	movs	r2, r5
 8008380:	2100      	movs	r1, #0
 8008382:	9805      	ldr	r0, [sp, #20]
 8008384:	f00c f96f 	bl	8014666 <memset>
						memset(&UARTRxBuf[port-1][0], 0, ((packetLength) + 4) - (MSG_RX_BUF_SIZE-packetStart));
 8008388:	9a02      	ldr	r2, [sp, #8]
 800838a:	2100      	movs	r1, #0
 800838c:	3204      	adds	r2, #4
 800838e:	1b52      	subs	r2, r2, r5
 8008390:	0038      	movs	r0, r7
 8008392:	e7cf      	b.n	8008334 <BackEndTask+0x254>
				if (emptyBuffer) {	
 8008394:	2e00      	cmp	r6, #0
 8008396:	d093      	beq.n	80082c0 <BackEndTask+0x1e0>
 8008398:	e745      	b.n	8008226 <BackEndTask+0x146>
 800839a:	46c0      	nop			; (mov r8, r8)
 800839c:	20001271 	.word	0x20001271
 80083a0:	200010b2 	.word	0x200010b2
 80083a4:	200013b1 	.word	0x200013b1
 80083a8:	03ffffff 	.word	0x03ffffff
 80083ac:	200013b6 	.word	0x200013b6
 80083b0:	20000f02 	.word	0x20000f02
 80083b4:	20000d13 	.word	0x20000d13
 80083b8:	200014cc 	.word	0x200014cc
 80083bc:	20006f70 	.word	0x20006f70
 80083c0:	20000a9f 	.word	0x20000a9f
 80083c4:	20001454 	.word	0x20001454
 80083c8:	20001664 	.word	0x20001664
 80083cc:	2000126c 	.word	0x2000126c

080083d0 <User_MessagingParser>:

{
	BOS_Status result = BOS_ERR_UnknownMessage;
	
	return result;
}
 80083d0:	2001      	movs	r0, #1
 80083d2:	4770      	bx	lr

080083d4 <PxMessagingTask>:
{
 80083d4:	b5f0      	push	{r4, r5, r6, r7, lr}
	port = (int8_t)(unsigned) argument;
 80083d6:	b2c3      	uxtb	r3, r0
{
 80083d8:	b099      	sub	sp, #100	; 0x64
	port = (int8_t)(unsigned) argument;
 80083da:	9306      	str	r3, [sp, #24]
 80083dc:	930c      	str	r3, [sp, #48]	; 0x30
		if (messageLength[port-1])
 80083de:	3b01      	subs	r3, #1
 80083e0:	9304      	str	r3, [sp, #16]
 80083e2:	2338      	movs	r3, #56	; 0x38
 80083e4:	9a04      	ldr	r2, [sp, #16]
 80083e6:	435a      	muls	r2, r3
		memset(cMessage[port-1], 0, (size_t) messageLength[port-1]);
 80083e8:	4bcc      	ldr	r3, [pc, #816]	; (800871c <PxMessagingTask+0x348>)
 80083ea:	9207      	str	r2, [sp, #28]
 80083ec:	18d3      	adds	r3, r2, r3
 80083ee:	9313      	str	r3, [sp, #76]	; 0x4c
	BOS_Status result = BOS_OK; HAL_StatusTypeDef status = HAL_OK;
 80083f0:	2300      	movs	r3, #0
 80083f2:	001c      	movs	r4, r3
 80083f4:	930a      	str	r3, [sp, #40]	; 0x28
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
 80083f6:	2101      	movs	r1, #1
 80083f8:	2001      	movs	r0, #1
 80083fa:	4249      	negs	r1, r1
 80083fc:	f008 fc9a 	bl	8010d34 <ulTaskNotifyTake>
		if (messageLength[port-1])
 8008400:	4bc7      	ldr	r3, [pc, #796]	; (8008720 <PxMessagingTask+0x34c>)
 8008402:	9a04      	ldr	r2, [sp, #16]
 8008404:	5c9b      	ldrb	r3, [r3, r2]
 8008406:	2b00      	cmp	r3, #0
 8008408:	d100      	bne.n	800840c <PxMessagingTask+0x38>
 800840a:	e0b2      	b.n	8008572 <PxMessagingTask+0x19e>
			if (cMessage[port-1][2]>>7) {
 800840c:	2138      	movs	r1, #56	; 0x38
 800840e:	4351      	muls	r1, r2
 8008410:	48c2      	ldr	r0, [pc, #776]	; (800871c <PxMessagingTask+0x348>)
 8008412:	4ac4      	ldr	r2, [pc, #784]	; (8008724 <PxMessagingTask+0x350>)
 8008414:	1841      	adds	r1, r0, r1
 8008416:	788d      	ldrb	r5, [r1, #2]
 8008418:	b269      	sxtb	r1, r5
 800841a:	2900      	cmp	r1, #0
 800841c:	da4a      	bge.n	80084b4 <PxMessagingTask+0xe0>
				longMessage = 1;
 800841e:	2101      	movs	r1, #1
				longMessage = 0;
 8008420:	7011      	strb	r1, [r2, #0]
			dst = cMessage[port-1][0]; 
 8008422:	2238      	movs	r2, #56	; 0x38
 8008424:	9904      	ldr	r1, [sp, #16]
 8008426:	434a      	muls	r2, r1
 8008428:	5c81      	ldrb	r1, [r0, r2]
			src = cMessage[port-1][1];	
 800842a:	1882      	adds	r2, r0, r2
			dst = cMessage[port-1][0]; 
 800842c:	9108      	str	r1, [sp, #32]
 800842e:	2101      	movs	r1, #1
 8008430:	4029      	ands	r1, r5
 8008432:	910b      	str	r1, [sp, #44]	; 0x2c
			BOS.trace = (traceOptions_t)((cMessage[port-1][2]>>2)&0x03);	// 3rd-4th bits Trace 
 8008434:	48bc      	ldr	r0, [pc, #752]	; (8008728 <PxMessagingTask+0x354>)
 8008436:	0729      	lsls	r1, r5, #28
 8008438:	0f89      	lsrs	r1, r1, #30
 800843a:	71c1      	strb	r1, [r0, #7]
			BOS.response = (cMessage[port-1][2])&0x60;									// 6th-7th bits Response mode
 800843c:	2160      	movs	r1, #96	; 0x60
 800843e:	4029      	ands	r1, r5
 8008440:	7181      	strb	r1, [r0, #6]
 8008442:	990b      	ldr	r1, [sp, #44]	; 0x2c
			src = cMessage[port-1][1];	
 8008444:	7856      	ldrb	r6, [r2, #1]
 8008446:	1852      	adds	r2, r2, r1
 8008448:	78d1      	ldrb	r1, [r2, #3]
 800844a:	9109      	str	r1, [sp, #36]	; 0x24
			if (extendCode == true) {		
 800844c:	07a9      	lsls	r1, r5, #30
 800844e:	d508      	bpl.n	8008462 <PxMessagingTask+0x8e>
				code = ( ( (uint16_t) cMessage[port-1][4+shift] << 8 ) + cMessage[port-1][3+shift] );	
 8008450:	7912      	ldrb	r2, [r2, #4]
 8008452:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008454:	0212      	lsls	r2, r2, #8
 8008456:	188a      	adds	r2, r1, r2
 8008458:	b292      	uxth	r2, r2
 800845a:	9209      	str	r2, [sp, #36]	; 0x24
				++shift;
 800845c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800845e:	3201      	adds	r2, #1
 8008460:	920b      	str	r2, [sp, #44]	; 0x2c
			if ( ( dst && (dst < BOS_MULTICAST) && (dst != myID) && (myID != 1) ) || 
 8008462:	9a08      	ldr	r2, [sp, #32]
 8008464:	3a01      	subs	r2, #1
 8008466:	b2d2      	uxtb	r2, r2
 8008468:	2afc      	cmp	r2, #252	; 0xfc
 800846a:	d833      	bhi.n	80084d4 <PxMessagingTask+0x100>
 800846c:	4baf      	ldr	r3, [pc, #700]	; (800872c <PxMessagingTask+0x358>)
 800846e:	9a08      	ldr	r2, [sp, #32]
 8008470:	781b      	ldrb	r3, [r3, #0]
 8008472:	4293      	cmp	r3, r2
 8008474:	d04d      	beq.n	8008512 <PxMessagingTask+0x13e>
 8008476:	2b01      	cmp	r3, #1
 8008478:	d105      	bne.n	8008486 <PxMessagingTask+0xb2>
					 ( dst && (dst < BOS_MULTICAST) && (dst != myID) && (myID == 1) && (code != CODE_MODULE_ID) ) )
 800847a:	9b08      	ldr	r3, [sp, #32]
 800847c:	2b01      	cmp	r3, #1
 800847e:	d048      	beq.n	8008512 <PxMessagingTask+0x13e>
 8008480:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008482:	2b10      	cmp	r3, #16
 8008484:	d045      	beq.n	8008512 <PxMessagingTask+0x13e>
				ForwardReceivedMessage(port);
 8008486:	9806      	ldr	r0, [sp, #24]
 8008488:	f7ff fcfc 	bl	8007e84 <ForwardReceivedMessage>
				if (BOS.trace)
 800848c:	4ba6      	ldr	r3, [pc, #664]	; (8008728 <PxMessagingTask+0x354>)
 800848e:	79db      	ldrb	r3, [r3, #7]
 8008490:	2b00      	cmp	r3, #0
 8008492:	d002      	beq.n	800849a <PxMessagingTask+0xc6>
					indMode = IND_SHORT_BLINK;
 8008494:	2203      	movs	r2, #3
 8008496:	4ba6      	ldr	r3, [pc, #664]	; (8008730 <PxMessagingTask+0x35c>)
 8008498:	701a      	strb	r2, [r3, #0]
					if (code == CODE_UPDATE) {		// Remote bootloader update
 800849a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800849c:	2b19      	cmp	r3, #25
 800849e:	d10b      	bne.n	80084b8 <PxMessagingTask+0xe4>
						Delay_ms(100); remoteBootloaderUpdate(src, dst, port, 0);								
 80084a0:	2064      	movs	r0, #100	; 0x64
 80084a2:	f009 f833 	bl	801150c <HAL_Delay>
 80084a6:	2300      	movs	r3, #0
						Delay_ms(100); remoteBootloaderUpdate(src, dst, port, cMessage[port-1][shift]);								
 80084a8:	9a06      	ldr	r2, [sp, #24]
 80084aa:	9908      	ldr	r1, [sp, #32]
								remoteBootloaderUpdate(src, myID, port, cMessage[port-1][shift]);
 80084ac:	0030      	movs	r0, r6
 80084ae:	f7fb f975 	bl	800379c <remoteBootloaderUpdate>
								break;
 80084b2:	e05e      	b.n	8008572 <PxMessagingTask+0x19e>
				longMessage = 0;
 80084b4:	2100      	movs	r1, #0
 80084b6:	e7b3      	b.n	8008420 <PxMessagingTask+0x4c>
					} else if (code == CODE_UPDATE_VIA_PORT) {		// Remote 'via port' bootloader update
 80084b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80084ba:	2b1a      	cmp	r3, #26
 80084bc:	d159      	bne.n	8008572 <PxMessagingTask+0x19e>
						Delay_ms(100); remoteBootloaderUpdate(src, dst, port, cMessage[port-1][shift]);								
 80084be:	2064      	movs	r0, #100	; 0x64
 80084c0:	f009 f824 	bl	801150c <HAL_Delay>
 80084c4:	2238      	movs	r2, #56	; 0x38
 80084c6:	9b04      	ldr	r3, [sp, #16]
 80084c8:	435a      	muls	r2, r3
 80084ca:	4b94      	ldr	r3, [pc, #592]	; (800871c <PxMessagingTask+0x348>)
 80084cc:	189b      	adds	r3, r3, r2
 80084ce:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80084d0:	5c9b      	ldrb	r3, [r3, r2]
 80084d2:	e7e9      	b.n	80084a8 <PxMessagingTask+0xd4>
				if (dst == BOS_BROADCAST && cMessage[port-1][messageLength[port-1]-1] != bcastLastID) 
 80084d4:	9a08      	ldr	r2, [sp, #32]
 80084d6:	2aff      	cmp	r2, #255	; 0xff
 80084d8:	d11e      	bne.n	8008518 <PxMessagingTask+0x144>
 80084da:	2538      	movs	r5, #56	; 0x38
 80084dc:	9a04      	ldr	r2, [sp, #16]
 80084de:	4355      	muls	r5, r2
 80084e0:	4a8e      	ldr	r2, [pc, #568]	; (800871c <PxMessagingTask+0x348>)
 80084e2:	1955      	adds	r5, r2, r5
 80084e4:	18eb      	adds	r3, r5, r3
 80084e6:	4a93      	ldr	r2, [pc, #588]	; (8008734 <PxMessagingTask+0x360>)
 80084e8:	3b01      	subs	r3, #1
 80084ea:	781b      	ldrb	r3, [r3, #0]
 80084ec:	7811      	ldrb	r1, [r2, #0]
 80084ee:	4299      	cmp	r1, r3
 80084f0:	d101      	bne.n	80084f6 <PxMessagingTask+0x122>
 80084f2:	f001 f80a 	bl	800950a <PxMessagingTask+0x1136>
					bcastID = bcastLastID = cMessage[port-1][messageLength[port-1]-1];			// Store bcastID 		
 80084f6:	7013      	strb	r3, [r2, #0]
 80084f8:	4a8f      	ldr	r2, [pc, #572]	; (8008738 <PxMessagingTask+0x364>)
					BroadcastReceivedMessage(BOS_BROADCAST, port);
 80084fa:	9906      	ldr	r1, [sp, #24]
 80084fc:	9808      	ldr	r0, [sp, #32]
					bcastID = bcastLastID = cMessage[port-1][messageLength[port-1]-1];			// Store bcastID 		
 80084fe:	7013      	strb	r3, [r2, #0]
					BroadcastReceivedMessage(BOS_BROADCAST, port);
 8008500:	f7ff fcde 	bl	8007ec0 <BroadcastReceivedMessage>
					cMessage[port-1][messageLength[port-1]-1] = 0;								// Reset bcastID location 
 8008504:	4b86      	ldr	r3, [pc, #536]	; (8008720 <PxMessagingTask+0x34c>)
 8008506:	9a04      	ldr	r2, [sp, #16]
 8008508:	5c9b      	ldrb	r3, [r3, r2]
 800850a:	18ed      	adds	r5, r5, r3
 800850c:	2300      	movs	r3, #0
 800850e:	3d01      	subs	r5, #1
 8008510:	702b      	strb	r3, [r5, #0]
				if (result == BOS_OK)
 8008512:	2c00      	cmp	r4, #0
 8008514:	d048      	beq.n	80085a8 <PxMessagingTask+0x1d4>
				}
 8008516:	e02c      	b.n	8008572 <PxMessagingTask+0x19e>
				if (dst == BOS_MULTICAST && cMessage[port-1][messageLength[port-1]-1] != bcastLastID) 
 8008518:	9a08      	ldr	r2, [sp, #32]
 800851a:	2afe      	cmp	r2, #254	; 0xfe
 800851c:	d1f9      	bne.n	8008512 <PxMessagingTask+0x13e>
 800851e:	2538      	movs	r5, #56	; 0x38
 8008520:	9a04      	ldr	r2, [sp, #16]
 8008522:	4f7e      	ldr	r7, [pc, #504]	; (800871c <PxMessagingTask+0x348>)
 8008524:	4355      	muls	r5, r2
 8008526:	197d      	adds	r5, r7, r5
 8008528:	18eb      	adds	r3, r5, r3
 800852a:	4a82      	ldr	r2, [pc, #520]	; (8008734 <PxMessagingTask+0x360>)
 800852c:	3b01      	subs	r3, #1
 800852e:	781b      	ldrb	r3, [r3, #0]
 8008530:	7811      	ldrb	r1, [r2, #0]
					result = BOS_ERR_MSG_Reflection;
 8008532:	2403      	movs	r4, #3
				if (dst == BOS_MULTICAST && cMessage[port-1][messageLength[port-1]-1] != bcastLastID) 
 8008534:	4299      	cmp	r1, r3
 8008536:	d01c      	beq.n	8008572 <PxMessagingTask+0x19e>
					bcastID = bcastLastID = cMessage[port-1][messageLength[port-1]-1];			// Store bcastID 		
 8008538:	7013      	strb	r3, [r2, #0]
 800853a:	4a7f      	ldr	r2, [pc, #508]	; (8008738 <PxMessagingTask+0x364>)
					BroadcastReceivedMessage(BOS_MULTICAST, port);
 800853c:	9906      	ldr	r1, [sp, #24]
 800853e:	9808      	ldr	r0, [sp, #32]
					bcastID = bcastLastID = cMessage[port-1][messageLength[port-1]-1];			// Store bcastID 		
 8008540:	7013      	strb	r3, [r2, #0]
					BroadcastReceivedMessage(BOS_MULTICAST, port);
 8008542:	f7ff fcbd 	bl	8007ec0 <BroadcastReceivedMessage>
					cMessage[port-1][messageLength[port-1]-1] = 0;								// Reset bcastID location 
 8008546:	9a04      	ldr	r2, [sp, #16]
 8008548:	4b75      	ldr	r3, [pc, #468]	; (8008720 <PxMessagingTask+0x34c>)
						if (myID == cMessage[port-1][messageLength[port-1]-2-temp+i]) {
 800854a:	003c      	movs	r4, r7
					cMessage[port-1][messageLength[port-1]-1] = 0;								// Reset bcastID location 
 800854c:	5c9b      	ldrb	r3, [r3, r2]
 800854e:	2200      	movs	r2, #0
 8008550:	18ed      	adds	r5, r5, r3
 8008552:	1e69      	subs	r1, r5, #1
 8008554:	700a      	strb	r2, [r1, #0]
					temp = cMessage[port-1][messageLength[port-1]-2];							// Number of members in this multicast group - TODO breaks when message is 14 length and padded
 8008556:	3d02      	subs	r5, #2
 8008558:	7829      	ldrb	r1, [r5, #0]
 800855a:	9807      	ldr	r0, [sp, #28]
 800855c:	9105      	str	r1, [sp, #20]
						if (myID == cMessage[port-1][messageLength[port-1]-2-temp+i]) {
 800855e:	4973      	ldr	r1, [pc, #460]	; (800872c <PxMessagingTask+0x358>)
 8008560:	181b      	adds	r3, r3, r0
 8008562:	9805      	ldr	r0, [sp, #20]
 8008564:	7809      	ldrb	r1, [r1, #0]
 8008566:	1a1b      	subs	r3, r3, r0
					for(i=0 ; i<temp ; i++)
 8008568:	9d05      	ldr	r5, [sp, #20]
 800856a:	b2d0      	uxtb	r0, r2
 800856c:	4285      	cmp	r5, r0
 800856e:	d815      	bhi.n	800859c <PxMessagingTask+0x1c8>
					result = BOS_ERR_WrongID;
 8008570:	2466      	movs	r4, #102	; 0x66
		memset(cMessage[port-1], 0, (size_t) messageLength[port-1]);
 8008572:	4d6b      	ldr	r5, [pc, #428]	; (8008720 <PxMessagingTask+0x34c>)
 8008574:	9b04      	ldr	r3, [sp, #16]
 8008576:	2100      	movs	r1, #0
 8008578:	5cea      	ldrb	r2, [r5, r3]
 800857a:	9813      	ldr	r0, [sp, #76]	; 0x4c
 800857c:	f00c f873 	bl	8014666 <memset>
		messageLength[port-1] = 0;
 8008580:	2100      	movs	r1, #0
 8008582:	9b04      	ldr	r3, [sp, #16]
		if (portStatus[port] != STREAM && portStatus[port] != CLI && portStatus[port] != PORTBUTTON) {
 8008584:	4a6d      	ldr	r2, [pc, #436]	; (800873c <PxMessagingTask+0x368>)
		messageLength[port-1] = 0;
 8008586:	54e9      	strb	r1, [r5, r3]
		if (portStatus[port] != STREAM && portStatus[port] != CLI && portStatus[port] != PORTBUTTON) {
 8008588:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800858a:	5cd3      	ldrb	r3, [r2, r3]
 800858c:	3b02      	subs	r3, #2
 800858e:	2b02      	cmp	r3, #2
 8008590:	d901      	bls.n	8008596 <PxMessagingTask+0x1c2>
			portStatus[port] = FREE;
 8008592:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008594:	54d1      	strb	r1, [r2, r3]
		taskYIELD();
 8008596:	f008 fe5d 	bl	8011254 <vPortYield>
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
 800859a:	e72c      	b.n	80083f6 <PxMessagingTask+0x22>
 800859c:	3201      	adds	r2, #1
						if (myID == cMessage[port-1][messageLength[port-1]-2-temp+i]) {
 800859e:	1898      	adds	r0, r3, r2
 80085a0:	3803      	subs	r0, #3
 80085a2:	5c20      	ldrb	r0, [r4, r0]
 80085a4:	4288      	cmp	r0, r1
 80085a6:	d1df      	bne.n	8008568 <PxMessagingTask+0x194>
				numOfParams = messageLength[port-1] - shift;
 80085a8:	9a04      	ldr	r2, [sp, #16]
 80085aa:	4b5d      	ldr	r3, [pc, #372]	; (8008720 <PxMessagingTask+0x34c>)
				shift += 4;
 80085ac:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
				numOfParams = messageLength[port-1] - shift;
 80085ae:	5c9b      	ldrb	r3, [r3, r2]
				shift += 4;
 80085b0:	3704      	adds	r7, #4
					switch (code)
 80085b2:	9a09      	ldr	r2, [sp, #36]	; 0x24
				numOfParams = messageLength[port-1] - shift;
 80085b4:	1bdd      	subs	r5, r3, r7
 80085b6:	b2ed      	uxtb	r5, r5
					switch (code)
 80085b8:	2a23      	cmp	r2, #35	; 0x23
 80085ba:	d901      	bls.n	80085c0 <PxMessagingTask+0x1ec>
 80085bc:	f000 ff89 	bl	80094d2 <PxMessagingTask+0x10fe>
 80085c0:	0010      	movs	r0, r2
 80085c2:	f7f7 fdcf 	bl	8000164 <__gnu_thumb1_case_uhi>
 80085c6:	007a      	.short	0x007a
 80085c8:	004e003b 	.word	0x004e003b
 80085cc:	007c0074 	.word	0x007c0074
 80085d0:	0786007e 	.word	0x0786007e
 80085d4:	07860786 	.word	0x07860786
 80085d8:	00840786 	.word	0x00840786
 80085dc:	00e700d3 	.word	0x00e700d3
 80085e0:	01310113 	.word	0x01310113
 80085e4:	015001ae 	.word	0x015001ae
 80085e8:	07860170 	.word	0x07860170
 80085ec:	00240194 	.word	0x00240194
 80085f0:	01ed01e5 	.word	0x01ed01e5
 80085f4:	023b01f7 	.word	0x023b01f7
 80085f8:	02760264 	.word	0x02760264
 80085fc:	038402b3 	.word	0x038402b3
 8008600:	03b30786 	.word	0x03b30786
 8008604:	051f049c 	.word	0x051f049c
 8008608:	051f076b 	.word	0x051f076b
 800860c:	0774      	.short	0x0774
 800860e:	9b07      	ldr	r3, [sp, #28]
								arrayPortsDir[src-1] |= (0x8000>>((cMessage[port-1][shift+p])-1));								
 8008610:	1e72      	subs	r2, r6, #1
 8008612:	18f9      	adds	r1, r7, r3
 8008614:	4b41      	ldr	r3, [pc, #260]	; (800871c <PxMessagingTask+0x348>)
 8008616:	2680      	movs	r6, #128	; 0x80
 8008618:	18c9      	adds	r1, r1, r3
					switch (code)
 800861a:	2300      	movs	r3, #0
								arrayPortsDir[src-1] |= (0x8000>>((cMessage[port-1][shift+p])-1));								
 800861c:	4c48      	ldr	r4, [pc, #288]	; (8008740 <PxMessagingTask+0x36c>)
 800861e:	0052      	lsls	r2, r2, #1
 8008620:	0236      	lsls	r6, r6, #8
							for (p=0 ; p<numOfParams ; p++) 
 8008622:	b2d8      	uxtb	r0, r3
 8008624:	4285      	cmp	r5, r0
 8008626:	d937      	bls.n	8008698 <PxMessagingTask+0x2c4>
								arrayPortsDir[src-1] |= (0x8000>>((cMessage[port-1][shift+p])-1));								
 8008628:	0037      	movs	r7, r6
 800862a:	5cc8      	ldrb	r0, [r1, r3]
 800862c:	3301      	adds	r3, #1
 800862e:	3801      	subs	r0, #1
 8008630:	4107      	asrs	r7, r0
 8008632:	0038      	movs	r0, r7
 8008634:	5b17      	ldrh	r7, [r2, r4]
 8008636:	4338      	orrs	r0, r7
 8008638:	5310      	strh	r0, [r2, r4]
 800863a:	e7f2      	b.n	8008622 <PxMessagingTask+0x24e>
							indMode = IND_PING;	osDelay(10);
 800863c:	2201      	movs	r2, #1
 800863e:	4b3c      	ldr	r3, [pc, #240]	; (8008730 <PxMessagingTask+0x35c>)
 8008640:	200a      	movs	r0, #10
 8008642:	701a      	strb	r2, [r3, #0]
 8008644:	f007 f88d 	bl	800f762 <osDelay>
							if (BOS.response == BOS_RESPONSE_ALL || BOS.response == BOS_RESPONSE_MSG)
 8008648:	2240      	movs	r2, #64	; 0x40
 800864a:	4b37      	ldr	r3, [pc, #220]	; (8008728 <PxMessagingTask+0x354>)
 800864c:	2400      	movs	r4, #0
 800864e:	799b      	ldrb	r3, [r3, #6]
 8008650:	4393      	bics	r3, r2
 8008652:	2b20      	cmp	r3, #32
 8008654:	d18d      	bne.n	8008572 <PxMessagingTask+0x19e>
								SendMessageToModule(src, CODE_PING_RESPONSE, 0);	
 8008656:	0022      	movs	r2, r4
 8008658:	2102      	movs	r1, #2
								SendMessageToModule(src, CODE_WRITE_REMOTE_RESPONSE, 1);											
 800865a:	0030      	movs	r0, r6
 800865c:	f7ff fc66 	bl	8007f2c <SendMessageToModule>
 8008660:	e787      	b.n	8008572 <PxMessagingTask+0x19e>
							if (!moduleAlias[myID][0])
 8008662:	4a32      	ldr	r2, [pc, #200]	; (800872c <PxMessagingTask+0x358>)
 8008664:	4b37      	ldr	r3, [pc, #220]	; (8008744 <PxMessagingTask+0x370>)
 8008666:	7811      	ldrb	r1, [r2, #0]
 8008668:	220a      	movs	r2, #10
 800866a:	4351      	muls	r1, r2
 800866c:	5cc9      	ldrb	r1, [r1, r3]
 800866e:	4836      	ldr	r0, [pc, #216]	; (8008748 <PxMessagingTask+0x374>)
 8008670:	2900      	cmp	r1, #0
 8008672:	d115      	bne.n	80086a0 <PxMessagingTask+0x2cc>
								sprintf( ( char * ) pcUserMessage, "Hi from module %d\r\n", src);
 8008674:	0032      	movs	r2, r6
 8008676:	4935      	ldr	r1, [pc, #212]	; (800874c <PxMessagingTask+0x378>)
 8008678:	f00c f9f0 	bl	8014a5c <sprintf>
							writePxMutex(PcPort, pcUserMessage, strlen(pcUserMessage), cmd50ms, HAL_MAX_DELAY);
 800867c:	4c32      	ldr	r4, [pc, #200]	; (8008748 <PxMessagingTask+0x374>)
 800867e:	0020      	movs	r0, r4
 8008680:	f7f7 fd4a 	bl	8000118 <strlen>
 8008684:	4b32      	ldr	r3, [pc, #200]	; (8008750 <PxMessagingTask+0x37c>)
 8008686:	b282      	uxth	r2, r0
 8008688:	7818      	ldrb	r0, [r3, #0]
 800868a:	2301      	movs	r3, #1
 800868c:	425b      	negs	r3, r3
 800868e:	9300      	str	r3, [sp, #0]
 8008690:	0021      	movs	r1, r4
 8008692:	3333      	adds	r3, #51	; 0x33
 8008694:	f004 fec0 	bl	800d418 <writePxMutex>
							responseStatus = BOS_OK;
 8008698:	2400      	movs	r4, #0
 800869a:	4b2e      	ldr	r3, [pc, #184]	; (8008754 <PxMessagingTask+0x380>)
 800869c:	701c      	strb	r4, [r3, #0]
							break;
 800869e:	e768      	b.n	8008572 <PxMessagingTask+0x19e>
								sprintf( ( char * ) pcUserMessage, "Hi from module %d (%s)\r\n", src, moduleAlias[src]);
 80086a0:	4372      	muls	r2, r6
 80086a2:	492d      	ldr	r1, [pc, #180]	; (8008758 <PxMessagingTask+0x384>)
 80086a4:	18d3      	adds	r3, r2, r3
 80086a6:	0032      	movs	r2, r6
 80086a8:	f00c f9d8 	bl	8014a5c <sprintf>
 80086ac:	e7e6      	b.n	800867c <PxMessagingTask+0x2a8>
							IND_ON();
 80086ae:	2201      	movs	r2, #1
							IND_OFF();
 80086b0:	2180      	movs	r1, #128	; 0x80
 80086b2:	482a      	ldr	r0, [pc, #168]	; (800875c <PxMessagingTask+0x388>)
 80086b4:	01c9      	lsls	r1, r1, #7
 80086b6:	f009 fe33 	bl	8012320 <HAL_GPIO_WritePin>
					switch (code)
 80086ba:	2400      	movs	r4, #0
 80086bc:	e759      	b.n	8008572 <PxMessagingTask+0x19e>
							IND_OFF();
 80086be:	2200      	movs	r2, #0
 80086c0:	e7f6      	b.n	80086b0 <PxMessagingTask+0x2dc>
							IND_toggle();
 80086c2:	2180      	movs	r1, #128	; 0x80
 80086c4:	4825      	ldr	r0, [pc, #148]	; (800875c <PxMessagingTask+0x388>)
 80086c6:	01c9      	lsls	r1, r1, #7
 80086c8:	f009 fe30 	bl	801232c <HAL_GPIO_TogglePin>
 80086cc:	e7f5      	b.n	80086ba <PxMessagingTask+0x2e6>
							neighbors[port-1][0] = ( (uint16_t) src << 8 ) + cMessage[port-1][2+shift];			/* Neighbor ID + Neighbor own port */
 80086ce:	2238      	movs	r2, #56	; 0x38
 80086d0:	9904      	ldr	r1, [sp, #16]
 80086d2:	9b04      	ldr	r3, [sp, #16]
 80086d4:	434a      	muls	r2, r1
 80086d6:	4911      	ldr	r1, [pc, #68]	; (800871c <PxMessagingTask+0x348>)
 80086d8:	4c21      	ldr	r4, [pc, #132]	; (8008760 <PxMessagingTask+0x38c>)
 80086da:	188a      	adds	r2, r1, r2
 80086dc:	19d0      	adds	r0, r2, r7
 80086de:	7881      	ldrb	r1, [r0, #2]
 80086e0:	0236      	lsls	r6, r6, #8
 80086e2:	1989      	adds	r1, r1, r6
 80086e4:	009b      	lsls	r3, r3, #2
 80086e6:	5319      	strh	r1, [r3, r4]
							neighbors[port-1][1] = ( (uint16_t) cMessage[port-1][shift] << 8 ) + cMessage[port-1][1+shift];		/* Neighbor PN */
 80086e8:	5dd1      	ldrb	r1, [r2, r7]
 80086ea:	7842      	ldrb	r2, [r0, #1]
 80086ec:	0209      	lsls	r1, r1, #8
 80086ee:	1852      	adds	r2, r2, r1
 80086f0:	18e3      	adds	r3, r4, r3
 80086f2:	805a      	strh	r2, [r3, #2]
							messageParams[1] = (uint8_t) myPN;
 80086f4:	4b1b      	ldr	r3, [pc, #108]	; (8008764 <PxMessagingTask+0x390>)
 80086f6:	4a1c      	ldr	r2, [pc, #112]	; (8008768 <PxMessagingTask+0x394>)
 80086f8:	881b      	ldrh	r3, [r3, #0]
							osDelay(2);
 80086fa:	2002      	movs	r0, #2
							messageParams[1] = (uint8_t) myPN;
 80086fc:	7053      	strb	r3, [r2, #1]
							messageParams[0] = (uint8_t) (myPN >> 8);	
 80086fe:	0a1b      	lsrs	r3, r3, #8
 8008700:	7013      	strb	r3, [r2, #0]
							messageParams[2] = port;
 8008702:	9b06      	ldr	r3, [sp, #24]
 8008704:	7093      	strb	r3, [r2, #2]
							osDelay(2);
 8008706:	f007 f82c 	bl	800f762 <osDelay>
							SendMessageFromPort(port, 0, 0, CODE_HI_RESPONSE, 3);
 800870a:	2303      	movs	r3, #3
 800870c:	2200      	movs	r2, #0
 800870e:	9300      	str	r3, [sp, #0]
 8008710:	0011      	movs	r1, r2
 8008712:	3308      	adds	r3, #8
 8008714:	9806      	ldr	r0, [sp, #24]
 8008716:	f7ff fa3f 	bl	8007b98 <SendMessageFromPort>
 800871a:	e7ce      	b.n	80086ba <PxMessagingTask+0x2e6>
 800871c:	20000d13 	.word	0x20000d13
 8008720:	20000f02 	.word	0x20000f02
 8008724:	20000ec7 	.word	0x20000ec7
 8008728:	20006f70 	.word	0x20006f70
 800872c:	20001039 	.word	0x20001039
 8008730:	20000ec6 	.word	0x20000ec6
 8008734:	200014ce 	.word	0x200014ce
 8008738:	20000cc6 	.word	0x20000cc6
 800873c:	200010b2 	.word	0x200010b2
 8008740:	20007a44 	.word	0x20007a44
 8008744:	20000f35 	.word	0x20000f35
 8008748:	20001614 	.word	0x20001614
 800874c:	0801a0b4 	.word	0x0801a0b4
 8008750:	20000a9f 	.word	0x20000a9f
 8008754:	200010c8 	.word	0x200010c8
 8008758:	0801a0c8 	.word	0x0801a0c8
 800875c:	48000400 	.word	0x48000400
 8008760:	2000103a 	.word	0x2000103a
 8008764:	20000050 	.word	0x20000050
 8008768:	20000f07 	.word	0x20000f07
							neighbors[port-1][0] = ( (uint16_t) src << 8 ) + cMessage[port-1][2+shift];		/* Neighbor ID + Neighbor own port */
 800876c:	2238      	movs	r2, #56	; 0x38
 800876e:	9904      	ldr	r1, [sp, #16]
 8008770:	9b04      	ldr	r3, [sp, #16]
 8008772:	434a      	muls	r2, r1
 8008774:	49d9      	ldr	r1, [pc, #868]	; (8008adc <PxMessagingTask+0x708>)
 8008776:	4cda      	ldr	r4, [pc, #872]	; (8008ae0 <PxMessagingTask+0x70c>)
 8008778:	188a      	adds	r2, r1, r2
 800877a:	19d0      	adds	r0, r2, r7
 800877c:	7881      	ldrb	r1, [r0, #2]
 800877e:	0236      	lsls	r6, r6, #8
 8008780:	009b      	lsls	r3, r3, #2
 8008782:	1989      	adds	r1, r1, r6
 8008784:	5319      	strh	r1, [r3, r4]
							neighbors[port-1][1] = ( (uint16_t) cMessage[port-1][shift] << 8 ) + cMessage[port-1][1+shift];		/* Neighbor PN */	
 8008786:	5dd1      	ldrb	r1, [r2, r7]
 8008788:	7842      	ldrb	r2, [r0, #1]
 800878a:	0209      	lsls	r1, r1, #8
 800878c:	18e3      	adds	r3, r4, r3
 800878e:	1852      	adds	r2, r2, r1
 8008790:	805a      	strh	r2, [r3, #2]
 8008792:	e781      	b.n	8008698 <PxMessagingTask+0x2c4>
							ExploreNeighbors(port);	indMode = IND_TOPOLOGY;
 8008794:	9806      	ldr	r0, [sp, #24]
 8008796:	f7fa feb9 	bl	800350c <ExploreNeighbors>
 800879a:	2202      	movs	r2, #2
 800879c:	4bd1      	ldr	r3, [pc, #836]	; (8008ae4 <PxMessagingTask+0x710>)
							osDelay(10); temp = 0;
 800879e:	200a      	movs	r0, #10
							ExploreNeighbors(port);	indMode = IND_TOPOLOGY;
 80087a0:	701a      	strb	r2, [r3, #0]
							osDelay(10); temp = 0;
 80087a2:	f006 ffde 	bl	800f762 <osDelay>
 80087a6:	2300      	movs	r3, #0
 80087a8:	2401      	movs	r4, #1
 80087aa:	9305      	str	r3, [sp, #20]
 80087ac:	00a2      	lsls	r2, r4, #2
								if (neighbors[p-1][0])
 80087ae:	4bcc      	ldr	r3, [pc, #816]	; (8008ae0 <PxMessagingTask+0x70c>)
 80087b0:	1f10      	subs	r0, r2, #4
 80087b2:	5a18      	ldrh	r0, [r3, r0]
 80087b4:	b2e1      	uxtb	r1, r4
 80087b6:	2800      	cmp	r0, #0
 80087b8:	d00e      	beq.n	80087d8 <PxMessagingTask+0x404>
									messageParams[temp] = p;
 80087ba:	48cb      	ldr	r0, [pc, #812]	; (8008ae8 <PxMessagingTask+0x714>)
 80087bc:	9d05      	ldr	r5, [sp, #20]
 80087be:	5541      	strb	r1, [r0, r5]
									memcpy(messageParams+temp+1, neighbors[p-1], (size_t)(4));
 80087c0:	0029      	movs	r1, r5
 80087c2:	3101      	adds	r1, #1
 80087c4:	1808      	adds	r0, r1, r0
 80087c6:	1f19      	subs	r1, r3, #4
 80087c8:	1889      	adds	r1, r1, r2
 80087ca:	2204      	movs	r2, #4
 80087cc:	f00b ff42 	bl	8014654 <memcpy>
									temp += 5;		
 80087d0:	9b05      	ldr	r3, [sp, #20]
 80087d2:	1d58      	adds	r0, r3, #5
 80087d4:	b2c3      	uxtb	r3, r0
 80087d6:	9305      	str	r3, [sp, #20]
 80087d8:	3401      	adds	r4, #1
							for (uint8_t p=1 ; p<=NumOfPorts ; p++)  
 80087da:	2c06      	cmp	r4, #6
 80087dc:	d1e6      	bne.n	80087ac <PxMessagingTask+0x3d8>
							SendMessageToModule(src, CODE_EXPLORE_ADJ_RESPONSE, temp);
 80087de:	466b      	mov	r3, sp
 80087e0:	210d      	movs	r1, #13
 80087e2:	8a9a      	ldrh	r2, [r3, #20]
			SendMessageToModule(src, CODE_UNKNOWN_MESSAGE, 0);
 80087e4:	0030      	movs	r0, r6
 80087e6:	f7ff fba1 	bl	8007f2c <SendMessageToModule>
 80087ea:	e766      	b.n	80086ba <PxMessagingTask+0x2e6>
							temp = numOfParams/5;
 80087ec:	2105      	movs	r1, #5
 80087ee:	0028      	movs	r0, r5
 80087f0:	f7f7 fcc2 	bl	8000178 <__udivsi3>
 80087f4:	2105      	movs	r1, #5
 80087f6:	b2c3      	uxtb	r3, r0
 80087f8:	9305      	str	r3, [sp, #20]
 80087fa:	9b07      	ldr	r3, [sp, #28]
 80087fc:	4db7      	ldr	r5, [pc, #732]	; (8008adc <PxMessagingTask+0x708>)
 80087fe:	19dc      	adds	r4, r3, r7
 8008800:	1964      	adds	r4, r4, r5
 8008802:	195d      	adds	r5, r3, r5
 8008804:	9b05      	ldr	r3, [sp, #20]
 8008806:	19ed      	adds	r5, r5, r7
 8008808:	4359      	muls	r1, r3
 800880a:	186d      	adds	r5, r5, r1
							for (uint8_t k=0 ; k<temp ; k++)  {
 800880c:	42a5      	cmp	r5, r4
 800880e:	d100      	bne.n	8008812 <PxMessagingTask+0x43e>
 8008810:	e742      	b.n	8008698 <PxMessagingTask+0x2c4>
								memcpy(&neighbors2[(cMessage[port-1][shift+k*5])-1][0], &cMessage[port-1][1+shift+k*5], (size_t)(4));
 8008812:	7820      	ldrb	r0, [r4, #0]
 8008814:	4bb5      	ldr	r3, [pc, #724]	; (8008aec <PxMessagingTask+0x718>)
 8008816:	3801      	subs	r0, #1
 8008818:	0080      	lsls	r0, r0, #2
 800881a:	1c61      	adds	r1, r4, #1
 800881c:	18c0      	adds	r0, r0, r3
 800881e:	2204      	movs	r2, #4
 8008820:	f00b ff18 	bl	8014654 <memcpy>
 8008824:	3405      	adds	r4, #5
 8008826:	e7f1      	b.n	800880c <PxMessagingTask+0x438>
					switch (code)
 8008828:	2401      	movs	r4, #1
 800882a:	9b07      	ldr	r3, [sp, #28]
 800882c:	18fd      	adds	r5, r7, r3
								if (p != port)	SwapUartPins(GetUart(p), cMessage[port-1][shift+p-1]); 
 800882e:	9b06      	ldr	r3, [sp, #24]
 8008830:	b2e0      	uxtb	r0, r4
 8008832:	4283      	cmp	r3, r0
 8008834:	d007      	beq.n	8008846 <PxMessagingTask+0x472>
 8008836:	f004 fde3 	bl	800d400 <GetUart>
 800883a:	192b      	adds	r3, r5, r4
 800883c:	4aa7      	ldr	r2, [pc, #668]	; (8008adc <PxMessagingTask+0x708>)
 800883e:	3b01      	subs	r3, #1
 8008840:	5cd1      	ldrb	r1, [r2, r3]
 8008842:	f004 fe53 	bl	800d4ec <SwapUartPins>
 8008846:	3401      	adds	r4, #1
							for (uint8_t p=1 ; p<=NumOfPorts ; p++) {
 8008848:	2c06      	cmp	r4, #6
 800884a:	d1f0      	bne.n	800882e <PxMessagingTask+0x45a>
							SwapUartPins(GetUart(port), cMessage[port-1][shift+MaxNumOfPorts]);
 800884c:	2538      	movs	r5, #56	; 0x38
 800884e:	9806      	ldr	r0, [sp, #24]
 8008850:	f004 fdd6 	bl	800d400 <GetUart>
 8008854:	9b04      	ldr	r3, [sp, #16]
 8008856:	49a1      	ldr	r1, [pc, #644]	; (8008adc <PxMessagingTask+0x708>)
 8008858:	435d      	muls	r5, r3
 800885a:	1949      	adds	r1, r1, r5
 800885c:	19c9      	adds	r1, r1, r7
 800885e:	7a89      	ldrb	r1, [r1, #10]
 8008860:	f004 fe44 	bl	800d4ec <SwapUartPins>
 8008864:	e729      	b.n	80086ba <PxMessagingTask+0x2e6>
							if (cMessage[port-1][shift] == 0)						/* Change my own ID */
 8008866:	2138      	movs	r1, #56	; 0x38
 8008868:	9b04      	ldr	r3, [sp, #16]
 800886a:	4d9c      	ldr	r5, [pc, #624]	; (8008adc <PxMessagingTask+0x708>)
 800886c:	4359      	muls	r1, r3
 800886e:	186d      	adds	r5, r5, r1
 8008870:	5deb      	ldrb	r3, [r5, r7]
 8008872:	2b00      	cmp	r3, #0
 8008874:	d105      	bne.n	8008882 <PxMessagingTask+0x4ae>
								myID = cMessage[port-1][1+shift];
 8008876:	19ed      	adds	r5, r5, r7
 8008878:	7869      	ldrb	r1, [r5, #1]
 800887a:	4a9d      	ldr	r2, [pc, #628]	; (8008af0 <PxMessagingTask+0x71c>)
 800887c:	7011      	strb	r1, [r2, #0]
 800887e:	001c      	movs	r4, r3
 8008880:	e677      	b.n	8008572 <PxMessagingTask+0x19e>
 8008882:	2400      	movs	r4, #0
							else if (cMessage[port-1][shift] == 1) {		/* Change my neighbor's ID */
 8008884:	2b01      	cmp	r3, #1
 8008886:	d000      	beq.n	800888a <PxMessagingTask+0x4b6>
 8008888:	e673      	b.n	8008572 <PxMessagingTask+0x19e>
								messageParams[1] = cMessage[port-1][1+shift];		/* The new ID */
 800888a:	19ed      	adds	r5, r5, r7
 800888c:	786a      	ldrb	r2, [r5, #1]
								messageParams[0] = 0;											/* change own ID */
 800888e:	4b96      	ldr	r3, [pc, #600]	; (8008ae8 <PxMessagingTask+0x714>)
								SendMessageFromPort(cMessage[port-1][2+shift], 0, 0, CODE_MODULE_ID, 3);
 8008890:	78a8      	ldrb	r0, [r5, #2]
								messageParams[0] = 0;											/* change own ID */
 8008892:	701c      	strb	r4, [r3, #0]
								messageParams[1] = cMessage[port-1][1+shift];		/* The new ID */
 8008894:	705a      	strb	r2, [r3, #1]
								SendMessageFromPort(cMessage[port-1][2+shift], 0, 0, CODE_MODULE_ID, 3);
 8008896:	2303      	movs	r3, #3
 8008898:	0022      	movs	r2, r4
 800889a:	9300      	str	r3, [sp, #0]
 800889c:	0021      	movs	r1, r4
 800889e:	330d      	adds	r3, #13
 80088a0:	f7ff f97a 	bl	8007b98 <SendMessageFromPort>
 80088a4:	e665      	b.n	8008572 <PxMessagingTask+0x19e>
 80088a6:	4b93      	ldr	r3, [pc, #588]	; (8008af4 <PxMessagingTask+0x720>)
								memcpy(&longMessageScratchpad[0]+longMessageLastPtr, &cMessage[port-1][shift], (size_t) numOfParams );	
 80088a8:	002a      	movs	r2, r5
 80088aa:	881e      	ldrh	r6, [r3, #0]
 80088ac:	4b92      	ldr	r3, [pc, #584]	; (8008af8 <PxMessagingTask+0x724>)
 80088ae:	18f0      	adds	r0, r6, r3
 80088b0:	9b07      	ldr	r3, [sp, #28]
 80088b2:	1976      	adds	r6, r6, r5
 80088b4:	18f9      	adds	r1, r7, r3
 80088b6:	4b89      	ldr	r3, [pc, #548]	; (8008adc <PxMessagingTask+0x708>)
 80088b8:	b2b6      	uxth	r6, r6
 80088ba:	18c9      	adds	r1, r1, r3
							if (longMessage) {
 80088bc:	4b8f      	ldr	r3, [pc, #572]	; (8008afc <PxMessagingTask+0x728>)
 80088be:	781c      	ldrb	r4, [r3, #0]
 80088c0:	2c00      	cmp	r4, #0
 80088c2:	d004      	beq.n	80088ce <PxMessagingTask+0x4fa>
								memcpy(&longMessageScratchpad[0]+longMessageLastPtr, &cMessage[port-1][shift], (size_t) numOfParams );	
 80088c4:	f00b fec6 	bl	8014654 <memcpy>
								longMessageLastPtr += numOfParams;
 80088c8:	4b8a      	ldr	r3, [pc, #552]	; (8008af4 <PxMessagingTask+0x720>)
 80088ca:	801e      	strh	r6, [r3, #0]
 80088cc:	e6f5      	b.n	80086ba <PxMessagingTask+0x2e6>
								memcpy(&longMessageScratchpad[0]+longMessageLastPtr, &cMessage[port-1][shift], (size_t) numOfParams );
 80088ce:	f00b fec1 	bl	8014654 <memcpy>
								N = (longMessageLastPtr / (MaxNumOfPorts+1)) / 2;
 80088d2:	2116      	movs	r1, #22
 80088d4:	0030      	movs	r0, r6
 80088d6:	f7f7 fc4f 	bl	8000178 <__udivsi3>
 80088da:	4b89      	ldr	r3, [pc, #548]	; (8008b00 <PxMessagingTask+0x72c>)
								memcpy(&array, &longMessageScratchpad, longMessageLastPtr);
 80088dc:	0032      	movs	r2, r6
								N = (longMessageLastPtr / (MaxNumOfPorts+1)) / 2;
 80088de:	7018      	strb	r0, [r3, #0]
								memcpy(&array, &longMessageScratchpad, longMessageLastPtr);
 80088e0:	4985      	ldr	r1, [pc, #532]	; (8008af8 <PxMessagingTask+0x724>)
 80088e2:	4888      	ldr	r0, [pc, #544]	; (8008b04 <PxMessagingTask+0x730>)
 80088e4:	f00b feb6 	bl	8014654 <memcpy>
								longMessageLastPtr = 0;
 80088e8:	4b82      	ldr	r3, [pc, #520]	; (8008af4 <PxMessagingTask+0x720>)
 80088ea:	801c      	strh	r4, [r3, #0]
 80088ec:	e641      	b.n	8008572 <PxMessagingTask+0x19e>
							temp = 0;
 80088ee:	2300      	movs	r3, #0
								if (GetUart(p)->AdvancedInit.Swap == UART_ADVFEATURE_SWAP_ENABLE) {
 80088f0:	2580      	movs	r5, #128	; 0x80
								for (p=1 ; p<=NumOfPorts ; p++) {
 80088f2:	2401      	movs	r4, #1
							temp = 0;
 80088f4:	9305      	str	r3, [sp, #20]
								if (GetUart(p)->AdvancedInit.Swap == UART_ADVFEATURE_SWAP_ENABLE) {
 80088f6:	022d      	lsls	r5, r5, #8
 80088f8:	0020      	movs	r0, r4
 80088fa:	f004 fd81 	bl	800d400 <GetUart>
 80088fe:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008900:	42ab      	cmp	r3, r5
 8008902:	d106      	bne.n	8008912 <PxMessagingTask+0x53e>
									messageParams[temp++] = p;
 8008904:	9b05      	ldr	r3, [sp, #20]
 8008906:	9905      	ldr	r1, [sp, #20]
 8008908:	3301      	adds	r3, #1
 800890a:	4a77      	ldr	r2, [pc, #476]	; (8008ae8 <PxMessagingTask+0x714>)
 800890c:	b2db      	uxtb	r3, r3
 800890e:	5454      	strb	r4, [r2, r1]
 8008910:	9305      	str	r3, [sp, #20]
								for (p=1 ; p<=NumOfPorts ; p++) {
 8008912:	3401      	adds	r4, #1
 8008914:	b2e4      	uxtb	r4, r4
 8008916:	2c06      	cmp	r4, #6
 8008918:	d1ee      	bne.n	80088f8 <PxMessagingTask+0x524>
							SendMessageToModule(src, CODE_READ_PORT_DIR_RESPONSE, temp);
 800891a:	466b      	mov	r3, sp
 800891c:	2114      	movs	r1, #20
 800891e:	8a9a      	ldrh	r2, [r3, #20]
 8008920:	e760      	b.n	80087e4 <PxMessagingTask+0x410>
								temp32 = ( (uint32_t) cMessage[port-1][shift] << 24 ) + ( (uint32_t) cMessage[port-1][1+shift] << 16 ) + ( (uint32_t) cMessage[port-1][2+shift] << 8 ) + cMessage[port-1][3+shift];		
 8008922:	2338      	movs	r3, #56	; 0x38
 8008924:	9904      	ldr	r1, [sp, #16]
 8008926:	4a6d      	ldr	r2, [pc, #436]	; (8008adc <PxMessagingTask+0x708>)
 8008928:	434b      	muls	r3, r1
 800892a:	18d3      	adds	r3, r2, r3
 800892c:	5ddc      	ldrb	r4, [r3, r7]
 800892e:	19db      	adds	r3, r3, r7
 8008930:	78d9      	ldrb	r1, [r3, #3]
 8008932:	0624      	lsls	r4, r4, #24
 8008934:	1864      	adds	r4, r4, r1
 8008936:	7859      	ldrb	r1, [r3, #1]
 8008938:	0409      	lsls	r1, r1, #16
 800893a:	1864      	adds	r4, r4, r1
 800893c:	7899      	ldrb	r1, [r3, #2]
								if (cMessage[port-1][4+shift] == 0xFF)					// All ports
 800893e:	791b      	ldrb	r3, [r3, #4]
								temp32 = ( (uint32_t) cMessage[port-1][shift] << 24 ) + ( (uint32_t) cMessage[port-1][1+shift] << 16 ) + ( (uint32_t) cMessage[port-1][2+shift] << 8 ) + cMessage[port-1][3+shift];		
 8008940:	0209      	lsls	r1, r1, #8
 8008942:	1864      	adds	r4, r4, r1
								if (cMessage[port-1][4+shift] == 0xFF)					// All ports
 8008944:	2bff      	cmp	r3, #255	; 0xff
 8008946:	d017      	beq.n	8008978 <PxMessagingTask+0x5a4>
 8008948:	9b07      	ldr	r3, [sp, #28]
 800894a:	1d11      	adds	r1, r2, #4
 800894c:	1d1e      	adds	r6, r3, #4
 800894e:	18c9      	adds	r1, r1, r3
								temp = temp32 = 0;
 8008950:	2300      	movs	r3, #0
 8008952:	19f6      	adds	r6, r6, r7
 8008954:	19c9      	adds	r1, r1, r7
 8008956:	18b6      	adds	r6, r6, r2
 8008958:	194d      	adds	r5, r1, r5
 800895a:	9305      	str	r3, [sp, #20]
									for (p=0 ; p<numOfParams ; p++) 
 800895c:	42b5      	cmp	r5, r6
 800895e:	d100      	bne.n	8008962 <PxMessagingTask+0x58e>
 8008960:	e6ab      	b.n	80086ba <PxMessagingTask+0x2e6>
										temp = cMessage[port-1][4+shift+p];
 8008962:	7833      	ldrb	r3, [r6, #0]
 8008964:	9305      	str	r3, [sp, #20]
										if (temp>0 && temp<=NumOfPorts)	{
 8008966:	3b01      	subs	r3, #1
 8008968:	2b04      	cmp	r3, #4
 800896a:	d803      	bhi.n	8008974 <PxMessagingTask+0x5a0>
											UpdateBaudrate(temp, temp32); 
 800896c:	0021      	movs	r1, r4
 800896e:	9805      	ldr	r0, [sp, #20]
 8008970:	f004 fdb2 	bl	800d4d8 <UpdateBaudrate>
 8008974:	3601      	adds	r6, #1
 8008976:	e7f1      	b.n	800895c <PxMessagingTask+0x588>
									for (p=1 ; p<=NumOfPorts ; p++) 
 8008978:	2501      	movs	r5, #1
										UpdateBaudrate(p, temp32); 
 800897a:	0028      	movs	r0, r5
									for (p=1 ; p<=NumOfPorts ; p++) 
 800897c:	3501      	adds	r5, #1
										UpdateBaudrate(p, temp32); 
 800897e:	0021      	movs	r1, r4
									for (p=1 ; p<=NumOfPorts ; p++) 
 8008980:	b2ed      	uxtb	r5, r5
										UpdateBaudrate(p, temp32); 
 8008982:	f004 fda9 	bl	800d4d8 <UpdateBaudrate>
									for (p=1 ; p<=NumOfPorts ; p++) 
 8008986:	2d06      	cmp	r5, #6
 8008988:	d1f7      	bne.n	800897a <PxMessagingTask+0x5a6>
								temp = temp32 = 0;
 800898a:	2300      	movs	r3, #0
 800898c:	9305      	str	r3, [sp, #20]
 800898e:	e776      	b.n	800887e <PxMessagingTask+0x4aa>
								SaveToRO();
 8008990:	f000 fecc 	bl	800972c <SaveToRO>
							SaveEEportsDir();
 8008994:	f7fa f9f8 	bl	8002d88 <SaveEEportsDir>
							indMode = IND_PING;
 8008998:	2201      	movs	r2, #1
 800899a:	4b52      	ldr	r3, [pc, #328]	; (8008ae4 <PxMessagingTask+0x710>)
							responseStatus = (BOS_Status) cMessage[port-1][shift];
 800899c:	701a      	strb	r2, [r3, #0]
 800899e:	e68c      	b.n	80086ba <PxMessagingTask+0x2e6>
							ClearEEportsDir();
 80089a0:	f7fa fa10 	bl	8002dc4 <ClearEEportsDir>
							ClearROtopology();
 80089a4:	f000 ff90 	bl	80098c8 <ClearROtopology>
							osDelay(100);
 80089a8:	2064      	movs	r0, #100	; 0x64
 80089aa:	f006 feda 	bl	800f762 <osDelay>
							indMode = IND_TOPOLOGY;
 80089ae:	4b4d      	ldr	r3, [pc, #308]	; (8008ae4 <PxMessagingTask+0x710>)
 80089b0:	2202      	movs	r2, #2
 80089b2:	e7f3      	b.n	800899c <PxMessagingTask+0x5c8>
							pcOutputString = FreeRTOS_CLIGetOutputBuffer();
 80089b4:	f006 ffce 	bl	800f954 <FreeRTOS_CLIGetOutputBuffer>
 80089b8:	9b07      	ldr	r3, [sp, #28]
 80089ba:	4948      	ldr	r1, [pc, #288]	; (8008adc <PxMessagingTask+0x708>)
 80089bc:	18ff      	adds	r7, r7, r3
							if (dst == BOS_BROADCAST)
 80089be:	9b08      	ldr	r3, [sp, #32]
							pcOutputString = FreeRTOS_CLIGetOutputBuffer();
 80089c0:	0004      	movs	r4, r0
 80089c2:	1879      	adds	r1, r7, r1
 80089c4:	4850      	ldr	r0, [pc, #320]	; (8008b08 <PxMessagingTask+0x734>)
								memcpy(cCLIString, &cMessage[port-1][shift], (size_t) (numOfParams-1));					// remove bcastID
 80089c6:	1e6a      	subs	r2, r5, #1
							if (dst == BOS_BROADCAST)
 80089c8:	2bff      	cmp	r3, #255	; 0xff
 80089ca:	d006      	beq.n	80089da <PxMessagingTask+0x606>
							else if (dst == BOS_MULTICAST)
 80089cc:	9b08      	ldr	r3, [sp, #32]
								memcpy(cCLIString, &cMessage[port-1][shift], (size_t) numOfParams);
 80089ce:	002a      	movs	r2, r5
							else if (dst == BOS_MULTICAST)
 80089d0:	2bfe      	cmp	r3, #254	; 0xfe
 80089d2:	d102      	bne.n	80089da <PxMessagingTask+0x606>
								memcpy(cCLIString, &cMessage[port-1][shift], (size_t) (numOfParams-temp-2));		// remove bcastID + groupm members + group count
 80089d4:	9b05      	ldr	r3, [sp, #20]
 80089d6:	1aea      	subs	r2, r5, r3
 80089d8:	3a02      	subs	r2, #2
								xReturned = FreeRTOS_CLIProcessCommand( cCLIString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 80089da:	2799      	movs	r7, #153	; 0x99
								memcpy(cCLIString, &cMessage[port-1][shift], (size_t) numOfParams);
 80089dc:	f00b fe3a 	bl	8014654 <memcpy>
								xReturned = FreeRTOS_CLIProcessCommand( cCLIString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 80089e0:	00bf      	lsls	r7, r7, #2
								temp = PcPort; PcPort = port;
 80089e2:	4d4a      	ldr	r5, [pc, #296]	; (8008b0c <PxMessagingTask+0x738>)
								xReturned = FreeRTOS_CLIProcessCommand( cCLIString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 80089e4:	003a      	movs	r2, r7
								temp = PcPort; PcPort = port;
 80089e6:	782b      	ldrb	r3, [r5, #0]
								xReturned = FreeRTOS_CLIProcessCommand( cCLIString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 80089e8:	0021      	movs	r1, r4
								temp = PcPort; PcPort = port;
 80089ea:	9305      	str	r3, [sp, #20]
 80089ec:	9b06      	ldr	r3, [sp, #24]
								xReturned = FreeRTOS_CLIProcessCommand( cCLIString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 80089ee:	4846      	ldr	r0, [pc, #280]	; (8008b08 <PxMessagingTask+0x734>)
								temp = PcPort; PcPort = port;
 80089f0:	702b      	strb	r3, [r5, #0]
								xReturned = FreeRTOS_CLIProcessCommand( cCLIString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 80089f2:	f006 ff43 	bl	800f87c <FreeRTOS_CLIProcessCommand>
								PcPort = temp;
 80089f6:	9b05      	ldr	r3, [sp, #20]
								xReturned = FreeRTOS_CLIProcessCommand( cCLIString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );	
 80089f8:	9008      	str	r0, [sp, #32]
								PcPort = temp;
 80089fa:	702b      	strb	r3, [r5, #0]
								if (BOS.response == BOS_RESPONSE_ALL)
 80089fc:	4b44      	ldr	r3, [pc, #272]	; (8008b10 <PxMessagingTask+0x73c>)
 80089fe:	799b      	ldrb	r3, [r3, #6]
 8008a00:	2b60      	cmp	r3, #96	; 0x60
 8008a02:	d112      	bne.n	8008a2a <PxMessagingTask+0x656>
									memcpy(messageParams, pcOutputString, strlen((char*) pcOutputString));
 8008a04:	0020      	movs	r0, r4
 8008a06:	f7f7 fb87 	bl	8000118 <strlen>
 8008a0a:	0021      	movs	r1, r4
 8008a0c:	0002      	movs	r2, r0
 8008a0e:	4836      	ldr	r0, [pc, #216]	; (8008ae8 <PxMessagingTask+0x714>)
 8008a10:	f00b fe20 	bl	8014654 <memcpy>
									SendMessageToModule(src, CODE_CLI_RESPONSE, strlen((char*) pcOutputString));
 8008a14:	0020      	movs	r0, r4
 8008a16:	f7f7 fb7f 	bl	8000118 <strlen>
 8008a1a:	2118      	movs	r1, #24
 8008a1c:	b282      	uxth	r2, r0
 8008a1e:	0030      	movs	r0, r6
 8008a20:	f7ff fa84 	bl	8007f2c <SendMessageToModule>
									osDelay(10); 
 8008a24:	200a      	movs	r0, #10
 8008a26:	f006 fe9c 	bl	800f762 <osDelay>
							while( xReturned != pdFALSE );								
 8008a2a:	9b08      	ldr	r3, [sp, #32]
 8008a2c:	2b00      	cmp	r3, #0
 8008a2e:	d1d8      	bne.n	80089e2 <PxMessagingTask+0x60e>
							memset( cCLIString, 0x00, cmdMAX_INPUT_SIZE );
 8008a30:	2232      	movs	r2, #50	; 0x32
 8008a32:	0019      	movs	r1, r3
 8008a34:	4834      	ldr	r0, [pc, #208]	; (8008b08 <PxMessagingTask+0x734>)
 8008a36:	f00b fe16 	bl	8014666 <memset>
 8008a3a:	e63e      	b.n	80086ba <PxMessagingTask+0x2e6>
							pcOutputString = FreeRTOS_CLIGetOutputBuffer();
 8008a3c:	f006 ff8a 	bl	800f954 <FreeRTOS_CLIGetOutputBuffer>
 8008a40:	0006      	movs	r6, r0
							memset( pcOutputString, 0x00, strlen((char*)pcOutputString) );
 8008a42:	f7f7 fb69 	bl	8000118 <strlen>
 8008a46:	2100      	movs	r1, #0
 8008a48:	0002      	movs	r2, r0
 8008a4a:	0030      	movs	r0, r6
 8008a4c:	f00b fe0b 	bl	8014666 <memset>
 8008a50:	9b07      	ldr	r3, [sp, #28]
 8008a52:	4922      	ldr	r1, [pc, #136]	; (8008adc <PxMessagingTask+0x708>)
 8008a54:	18ff      	adds	r7, r7, r3
 8008a56:	1879      	adds	r1, r7, r1
							if (longMessage) {
 8008a58:	4b28      	ldr	r3, [pc, #160]	; (8008afc <PxMessagingTask+0x728>)
 8008a5a:	4f26      	ldr	r7, [pc, #152]	; (8008af4 <PxMessagingTask+0x720>)
 8008a5c:	781c      	ldrb	r4, [r3, #0]
								memcpy(&pcOutputString[0]+longMessageLastPtr, &cMessage[port-1][shift], (size_t) numOfParams );
 8008a5e:	8838      	ldrh	r0, [r7, #0]
 8008a60:	002a      	movs	r2, r5
 8008a62:	1830      	adds	r0, r6, r0
							if (longMessage) {
 8008a64:	2c00      	cmp	r4, #0
 8008a66:	d005      	beq.n	8008a74 <PxMessagingTask+0x6a0>
								memcpy(&pcOutputString[0]+longMessageLastPtr, &cMessage[port-1][shift], (size_t) numOfParams );
 8008a68:	f00b fdf4 	bl	8014654 <memcpy>
								longMessageLastPtr += numOfParams;
 8008a6c:	883a      	ldrh	r2, [r7, #0]
 8008a6e:	1955      	adds	r5, r2, r5
 8008a70:	803d      	strh	r5, [r7, #0]
 8008a72:	e622      	b.n	80086ba <PxMessagingTask+0x2e6>
								memcpy(&pcOutputString[0]+longMessageLastPtr, &cMessage[port-1][shift], (size_t) numOfParams );
 8008a74:	f00b fdee 	bl	8014654 <memcpy>
								responseStatus = BOS_OK;
 8008a78:	4b26      	ldr	r3, [pc, #152]	; (8008b14 <PxMessagingTask+0x740>)
								xTaskNotify( ( xCommandConsoleTaskHandle ), 0, eNoAction );			// Notify the task without modifying its notification value
 8008a7a:	4827      	ldr	r0, [pc, #156]	; (8008b18 <PxMessagingTask+0x744>)
								responseStatus = BOS_OK;
 8008a7c:	701c      	strb	r4, [r3, #0]
								xTaskNotify( ( xCommandConsoleTaskHandle ), 0, eNoAction );			// Notify the task without modifying its notification value
 8008a7e:	0022      	movs	r2, r4
 8008a80:	0023      	movs	r3, r4
 8008a82:	0021      	movs	r1, r4
 8008a84:	6800      	ldr	r0, [r0, #0]
								longMessageLastPtr = 0;
 8008a86:	803c      	strh	r4, [r7, #0]
								xTaskNotify( ( xCommandConsoleTaskHandle ), 0, eNoAction );			// Notify the task without modifying its notification value
 8008a88:	f008 f998 	bl	8010dbc <xTaskGenericNotify>
 8008a8c:	e571      	b.n	8008572 <PxMessagingTask+0x19e>
								*((unsigned long *)0x20007FF0) = 0xDEADBEEF;   
 8008a8e:	4b23      	ldr	r3, [pc, #140]	; (8008b1c <PxMessagingTask+0x748>)
 8008a90:	4a23      	ldr	r2, [pc, #140]	; (8008b20 <PxMessagingTask+0x74c>)
								osDelay(10);
 8008a92:	200a      	movs	r0, #10
								*((unsigned long *)0x20007FF0) = 0xDEADBEEF;   
 8008a94:	601a      	str	r2, [r3, #0]
								indMode = IND_PING;
 8008a96:	2201      	movs	r2, #1
 8008a98:	4b12      	ldr	r3, [pc, #72]	; (8008ae4 <PxMessagingTask+0x710>)
 8008a9a:	701a      	strb	r2, [r3, #0]
								osDelay(10);
 8008a9c:	f006 fe61 	bl	800f762 <osDelay>
  __ASM volatile ("dsb 0xF":::"memory");
 8008aa0:	f3bf 8f4f 	dsb	sy
 8008aa4:	4b1f      	ldr	r3, [pc, #124]	; (8008b24 <PxMessagingTask+0x750>)
 8008aa6:	4a20      	ldr	r2, [pc, #128]	; (8008b28 <PxMessagingTask+0x754>)
 8008aa8:	60da      	str	r2, [r3, #12]
 8008aaa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8008aae:	46c0      	nop			; (mov r8, r8)
 8008ab0:	e7fd      	b.n	8008aae <PxMessagingTask+0x6da>
								SendMessageFromPort(cMessage[port-1][shift], 0, 0, CODE_UPDATE, 0);
 8008ab2:	2538      	movs	r5, #56	; 0x38
 8008ab4:	2400      	movs	r4, #0
 8008ab6:	9b04      	ldr	r3, [sp, #16]
 8008ab8:	0022      	movs	r2, r4
 8008aba:	435d      	muls	r5, r3
 8008abc:	4b07      	ldr	r3, [pc, #28]	; (8008adc <PxMessagingTask+0x708>)
 8008abe:	0021      	movs	r1, r4
 8008ac0:	195d      	adds	r5, r3, r5
 8008ac2:	5de8      	ldrb	r0, [r5, r7]
 8008ac4:	2319      	movs	r3, #25
 8008ac6:	9400      	str	r4, [sp, #0]
 8008ac8:	f7ff f866 	bl	8007b98 <SendMessageFromPort>
								osDelay(100);
 8008acc:	2064      	movs	r0, #100	; 0x64
 8008ace:	f006 fe48 	bl	800f762 <osDelay>
								remoteBootloaderUpdate(src, myID, port, cMessage[port-1][shift]);
 8008ad2:	4a07      	ldr	r2, [pc, #28]	; (8008af0 <PxMessagingTask+0x71c>)
 8008ad4:	5deb      	ldrb	r3, [r5, r7]
 8008ad6:	7811      	ldrb	r1, [r2, #0]
 8008ad8:	9a06      	ldr	r2, [sp, #24]
 8008ada:	e4e7      	b.n	80084ac <PxMessagingTask+0xd8>
 8008adc:	20000d13 	.word	0x20000d13
 8008ae0:	2000103a 	.word	0x2000103a
 8008ae4:	20000ec6 	.word	0x20000ec6
 8008ae8:	20000f07 	.word	0x20000f07
 8008aec:	2000104e 	.word	0x2000104e
 8008af0:	20001039 	.word	0x20001039
 8008af4:	20000ec8 	.word	0x20000ec8
 8008af8:	20001501 	.word	0x20001501
 8008afc:	20000ec7 	.word	0x20000ec7
 8008b00:	2000001c 	.word	0x2000001c
 8008b04:	20000aa0 	.word	0x20000aa0
 8008b08:	200014cf 	.word	0x200014cf
 8008b0c:	20000a9f 	.word	0x20000a9f
 8008b10:	20006f70 	.word	0x20006f70
 8008b14:	200010c8 	.word	0x200010c8
 8008b18:	20001454 	.word	0x20001454
 8008b1c:	20007ff0 	.word	0x20007ff0
 8008b20:	deadbeef 	.word	0xdeadbeef
 8008b24:	e000ed00 	.word	0xe000ed00
 8008b28:	05fa0004 	.word	0x05fa0004
							temp = cMessage[port-1][11+shift];
 8008b2c:	003b      	movs	r3, r7
 8008b2e:	2238      	movs	r2, #56	; 0x38
 8008b30:	330b      	adds	r3, #11
 8008b32:	9305      	str	r3, [sp, #20]
 8008b34:	9b04      	ldr	r3, [sp, #16]
 8008b36:	435a      	muls	r2, r3
 8008b38:	4bd0      	ldr	r3, [pc, #832]	; (8008e7c <PxMessagingTask+0xaa8>)
 8008b3a:	189b      	adds	r3, r3, r2
 8008b3c:	9a05      	ldr	r2, [sp, #20]
 8008b3e:	5c9a      	ldrb	r2, [r3, r2]
							if (numOfParams == 15)	temp = cMessage[port-1][13+shift];							
 8008b40:	2d0f      	cmp	r5, #15
 8008b42:	d16d      	bne.n	8008c20 <PxMessagingTask+0x84c>
 8008b44:	19db      	adds	r3, r3, r7
 8008b46:	7b5a      	ldrb	r2, [r3, #13]
								count = ( (uint32_t) cMessage[port-1][shift] << 24 ) + ( (uint32_t) cMessage[port-1][1+shift] << 16 ) + ( (uint32_t) cMessage[port-1][2+shift] << 8 ) + cMessage[port-1][3+shift];
 8008b48:	2438      	movs	r4, #56	; 0x38
 8008b4a:	1c7b      	adds	r3, r7, #1
 8008b4c:	930b      	str	r3, [sp, #44]	; 0x2c
 8008b4e:	1cbb      	adds	r3, r7, #2
 8008b50:	930d      	str	r3, [sp, #52]	; 0x34
 8008b52:	1cfb      	adds	r3, r7, #3
 8008b54:	930e      	str	r3, [sp, #56]	; 0x38
 8008b56:	9b04      	ldr	r3, [sp, #16]
 8008b58:	1cf9      	adds	r1, r7, #3
 8008b5a:	435c      	muls	r4, r3
 8008b5c:	4bc7      	ldr	r3, [pc, #796]	; (8008e7c <PxMessagingTask+0xaa8>)
 8008b5e:	191c      	adds	r4, r3, r4
 8008b60:	5de3      	ldrb	r3, [r4, r7]
 8008b62:	5c61      	ldrb	r1, [r4, r1]
 8008b64:	061b      	lsls	r3, r3, #24
 8008b66:	185b      	adds	r3, r3, r1
 8008b68:	1c79      	adds	r1, r7, #1
 8008b6a:	5c61      	ldrb	r1, [r4, r1]
 8008b6c:	0409      	lsls	r1, r1, #16
 8008b6e:	185b      	adds	r3, r3, r1
 8008b70:	1cb9      	adds	r1, r7, #2
 8008b72:	5c61      	ldrb	r1, [r4, r1]
 8008b74:	0209      	lsls	r1, r1, #8
 8008b76:	185b      	adds	r3, r3, r1
 8008b78:	9308      	str	r3, [sp, #32]
								timeout = ( (uint32_t) cMessage[port-1][4+shift] << 24 ) + ( (uint32_t) cMessage[port-1][5+shift] << 16 ) + ( (uint32_t) cMessage[port-1][6+shift] << 8 ) + cMessage[port-1][7+shift];									
 8008b7a:	1d3b      	adds	r3, r7, #4
 8008b7c:	930f      	str	r3, [sp, #60]	; 0x3c
 8008b7e:	1d7b      	adds	r3, r7, #5
 8008b80:	9310      	str	r3, [sp, #64]	; 0x40
 8008b82:	1dbb      	adds	r3, r7, #6
 8008b84:	9311      	str	r3, [sp, #68]	; 0x44
 8008b86:	1dfb      	adds	r3, r7, #7
 8008b88:	9312      	str	r3, [sp, #72]	; 0x48
 8008b8a:	1d3b      	adds	r3, r7, #4
 8008b8c:	5ce6      	ldrb	r6, [r4, r3]
 8008b8e:	1d7b      	adds	r3, r7, #5
 8008b90:	5ce3      	ldrb	r3, [r4, r3]
 8008b92:	0636      	lsls	r6, r6, #24
 8008b94:	041b      	lsls	r3, r3, #16
 8008b96:	18f6      	adds	r6, r6, r3
 8008b98:	1dfb      	adds	r3, r7, #7
 8008b9a:	5ce3      	ldrb	r3, [r4, r3]
 8008b9c:	18f6      	adds	r6, r6, r3
 8008b9e:	1dbb      	adds	r3, r7, #6
 8008ba0:	5ce3      	ldrb	r3, [r4, r3]
 8008ba2:	021b      	lsls	r3, r3, #8
 8008ba4:	18f6      	adds	r6, r6, r3
 8008ba6:	003b      	movs	r3, r7
 8008ba8:	3309      	adds	r3, #9
 8008baa:	9309      	str	r3, [sp, #36]	; 0x24
							if (temp == false)
 8008bac:	2a00      	cmp	r2, #0
 8008bae:	d13c      	bne.n	8008c2a <PxMessagingTask+0x856>
								if (cMessage[port-1][9+shift] && cMessage[port-1][10+shift])
 8008bb0:	5ce3      	ldrb	r3, [r4, r3]
 8008bb2:	2b00      	cmp	r3, #0
 8008bb4:	d009      	beq.n	8008bca <PxMessagingTask+0x7f6>
 8008bb6:	19e4      	adds	r4, r4, r7
 8008bb8:	7aa2      	ldrb	r2, [r4, #10]
 8008bba:	2a00      	cmp	r2, #0
 8008bbc:	d005      	beq.n	8008bca <PxMessagingTask+0x7f6>
									SetupDMAStreams(cMessage[port-1][8+shift], count, timeout, cMessage[port-1][9+shift], cMessage[port-1][10+shift]);
 8008bbe:	7a20      	ldrb	r0, [r4, #8]
 8008bc0:	9908      	ldr	r1, [sp, #32]
 8008bc2:	9200      	str	r2, [sp, #0]
 8008bc4:	0032      	movs	r2, r6
 8008bc6:	f7fe ff09 	bl	80079dc <SetupDMAStreams>
								if (cMessage[port-1][11+shift] && cMessage[port-1][12+shift])
 8008bca:	2338      	movs	r3, #56	; 0x38
 8008bcc:	9a04      	ldr	r2, [sp, #16]
 8008bce:	4353      	muls	r3, r2
 8008bd0:	4aaa      	ldr	r2, [pc, #680]	; (8008e7c <PxMessagingTask+0xaa8>)
 8008bd2:	18d2      	adds	r2, r2, r3
 8008bd4:	9b05      	ldr	r3, [sp, #20]
 8008bd6:	5cd3      	ldrb	r3, [r2, r3]
 8008bd8:	2b00      	cmp	r3, #0
 8008bda:	d009      	beq.n	8008bf0 <PxMessagingTask+0x81c>
 8008bdc:	19d2      	adds	r2, r2, r7
 8008bde:	7b11      	ldrb	r1, [r2, #12]
 8008be0:	2900      	cmp	r1, #0
 8008be2:	d005      	beq.n	8008bf0 <PxMessagingTask+0x81c>
									SetupDMAStreams(cMessage[port-1][8+shift], count, timeout, cMessage[port-1][11+shift], cMessage[port-1][12+shift]);
 8008be4:	7a10      	ldrb	r0, [r2, #8]
 8008be6:	9100      	str	r1, [sp, #0]
 8008be8:	0032      	movs	r2, r6
 8008bea:	9908      	ldr	r1, [sp, #32]
 8008bec:	f7fe fef6 	bl	80079dc <SetupDMAStreams>
								if (cMessage[port-1][13+shift] && cMessage[port-1][14+shift])
 8008bf0:	2538      	movs	r5, #56	; 0x38
 8008bf2:	9b04      	ldr	r3, [sp, #16]
 8008bf4:	49a1      	ldr	r1, [pc, #644]	; (8008e7c <PxMessagingTask+0xaa8>)
 8008bf6:	435d      	muls	r5, r3
 8008bf8:	1949      	adds	r1, r1, r5
 8008bfa:	19c9      	adds	r1, r1, r7
 8008bfc:	7b4b      	ldrb	r3, [r1, #13]
 8008bfe:	2b00      	cmp	r3, #0
 8008c00:	d100      	bne.n	8008c04 <PxMessagingTask+0x830>
 8008c02:	e6c3      	b.n	800898c <PxMessagingTask+0x5b8>
 8008c04:	2400      	movs	r4, #0
 8008c06:	7b8a      	ldrb	r2, [r1, #14]
 8008c08:	9205      	str	r2, [sp, #20]
 8008c0a:	42a2      	cmp	r2, r4
 8008c0c:	d100      	bne.n	8008c10 <PxMessagingTask+0x83c>
 8008c0e:	e4b0      	b.n	8008572 <PxMessagingTask+0x19e>
									SetupDMAStreams(cMessage[port-1][8+shift], count, timeout, cMessage[port-1][13+shift], cMessage[port-1][14+shift]);
 8008c10:	7a08      	ldrb	r0, [r1, #8]
 8008c12:	9200      	str	r2, [sp, #0]
 8008c14:	9908      	ldr	r1, [sp, #32]
 8008c16:	0032      	movs	r2, r6
 8008c18:	f7fe fee0 	bl	80079dc <SetupDMAStreams>
 8008c1c:	9405      	str	r4, [sp, #20]
 8008c1e:	e4a8      	b.n	8008572 <PxMessagingTask+0x19e>
							if (numOfParams == 17)	temp = cMessage[port-1][15+shift];
 8008c20:	2d11      	cmp	r5, #17
 8008c22:	d191      	bne.n	8008b48 <PxMessagingTask+0x774>
 8008c24:	19db      	adds	r3, r3, r7
 8008c26:	7bda      	ldrb	r2, [r3, #15]
 8008c28:	e78e      	b.n	8008b48 <PxMessagingTask+0x774>
								EE_WriteVariable(_EE_DMA_STREAM_BASE, cMessage[port-1][8+shift]);			/* Direction */
 8008c2a:	19e6      	adds	r6, r4, r7
 8008c2c:	7a31      	ldrb	r1, [r6, #8]
 8008c2e:	20e4      	movs	r0, #228	; 0xe4
 8008c30:	f7fd fee4 	bl	80069fc <EE_WriteVariable>
								EE_WriteVariable(_EE_DMA_STREAM_BASE+1, ( (uint16_t) cMessage[port-1][shift] << 8 ) + cMessage[port-1][1+shift]);			/* Count high half-word */
 8008c34:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008c36:	5de3      	ldrb	r3, [r4, r7]
 8008c38:	5ca1      	ldrb	r1, [r4, r2]
 8008c3a:	021b      	lsls	r3, r3, #8
 8008c3c:	18c9      	adds	r1, r1, r3
 8008c3e:	b289      	uxth	r1, r1
 8008c40:	20e5      	movs	r0, #229	; 0xe5
 8008c42:	f7fd fedb 	bl	80069fc <EE_WriteVariable>
								EE_WriteVariable(_EE_DMA_STREAM_BASE+2, ( (uint16_t) cMessage[port-1][2+shift] << 8 ) + cMessage[port-1][3+shift]);			/* Count low half-word */
 8008c46:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008c48:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8008c4a:	5ce3      	ldrb	r3, [r4, r3]
 8008c4c:	5ca1      	ldrb	r1, [r4, r2]
 8008c4e:	021b      	lsls	r3, r3, #8
 8008c50:	18c9      	adds	r1, r1, r3
 8008c52:	b289      	uxth	r1, r1
 8008c54:	20e6      	movs	r0, #230	; 0xe6
 8008c56:	f7fd fed1 	bl	80069fc <EE_WriteVariable>
								EE_WriteVariable(_EE_DMA_STREAM_BASE+3, ( (uint16_t) cMessage[port-1][4+shift] << 8 ) + cMessage[port-1][5+shift]);			/* Timeout high half-word */
 8008c5a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008c5c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8008c5e:	5ce3      	ldrb	r3, [r4, r3]
 8008c60:	5ca1      	ldrb	r1, [r4, r2]
 8008c62:	021b      	lsls	r3, r3, #8
 8008c64:	18c9      	adds	r1, r1, r3
 8008c66:	b289      	uxth	r1, r1
 8008c68:	20e7      	movs	r0, #231	; 0xe7
 8008c6a:	f7fd fec7 	bl	80069fc <EE_WriteVariable>
								EE_WriteVariable(_EE_DMA_STREAM_BASE+4, ( (uint16_t) cMessage[port-1][6+shift] << 8 ) + cMessage[port-1][7+shift]);			/* Timeout low half-word */
 8008c6e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008c70:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8008c72:	5ce3      	ldrb	r3, [r4, r3]
 8008c74:	5ca1      	ldrb	r1, [r4, r2]
 8008c76:	021b      	lsls	r3, r3, #8
 8008c78:	18c9      	adds	r1, r1, r3
 8008c7a:	b289      	uxth	r1, r1
 8008c7c:	20e8      	movs	r0, #232	; 0xe8
 8008c7e:	f7fd febd 	bl	80069fc <EE_WriteVariable>
								EE_WriteVariable(_EE_DMA_STREAM_BASE+5, ( (uint16_t) cMessage[port-1][9+shift] << 8 ) + cMessage[port-1][10+shift]);			/* src1 | dst1 */
 8008c82:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008c84:	7ab1      	ldrb	r1, [r6, #10]
 8008c86:	5ce3      	ldrb	r3, [r4, r3]
 8008c88:	20e9      	movs	r0, #233	; 0xe9
 8008c8a:	021b      	lsls	r3, r3, #8
 8008c8c:	18c9      	adds	r1, r1, r3
 8008c8e:	b289      	uxth	r1, r1
 8008c90:	f7fd feb4 	bl	80069fc <EE_WriteVariable>
								if (numOfParams == 19)
 8008c94:	2d13      	cmp	r5, #19
 8008c96:	d111      	bne.n	8008cbc <PxMessagingTask+0x8e8>
									EE_WriteVariable(_EE_DMA_STREAM_BASE+6, ( (uint16_t) cMessage[port-1][11+shift] << 8 ) + cMessage[port-1][12+shift]);			/* src2 | dst2 */
 8008c98:	20ea      	movs	r0, #234	; 0xea
 8008c9a:	9b05      	ldr	r3, [sp, #20]
 8008c9c:	7b31      	ldrb	r1, [r6, #12]
 8008c9e:	5ce3      	ldrb	r3, [r4, r3]
 8008ca0:	021b      	lsls	r3, r3, #8
 8008ca2:	18c9      	adds	r1, r1, r3
 8008ca4:	b289      	uxth	r1, r1
									EE_WriteVariable(_EE_DMA_STREAM_BASE+7, ( (uint16_t) cMessage[port-1][13+shift] << 8 ) + cMessage[port-1][14+shift]);			/* src3 | dst3 */
 8008ca6:	f7fd fea9 	bl	80069fc <EE_WriteVariable>
  __ASM volatile ("dsb 0xF":::"memory");
 8008caa:	f3bf 8f4f 	dsb	sy
 8008cae:	4b74      	ldr	r3, [pc, #464]	; (8008e80 <PxMessagingTask+0xaac>)
 8008cb0:	4a74      	ldr	r2, [pc, #464]	; (8008e84 <PxMessagingTask+0xab0>)
 8008cb2:	60da      	str	r2, [r3, #12]
 8008cb4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8008cb8:	46c0      	nop			; (mov r8, r8)
 8008cba:	e7fd      	b.n	8008cb8 <PxMessagingTask+0x8e4>
								if (numOfParams == 21)
 8008cbc:	2d15      	cmp	r5, #21
 8008cbe:	d1f4      	bne.n	8008caa <PxMessagingTask+0x8d6>
									EE_WriteVariable(_EE_DMA_STREAM_BASE+7, ( (uint16_t) cMessage[port-1][13+shift] << 8 ) + cMessage[port-1][14+shift]);			/* src3 | dst3 */
 8008cc0:	7b73      	ldrb	r3, [r6, #13]
 8008cc2:	7bb1      	ldrb	r1, [r6, #14]
 8008cc4:	021b      	lsls	r3, r3, #8
 8008cc6:	18c9      	adds	r1, r1, r3
 8008cc8:	b289      	uxth	r1, r1
 8008cca:	20eb      	movs	r0, #235	; 0xeb
 8008ccc:	e7eb      	b.n	8008ca6 <PxMessagingTask+0x8d2>
							StartScastDMAStream(cMessage[port-1][9+shift], myID, cMessage[port-1][11+shift], cMessage[port-1][10+shift], cMessage[port-1][8+shift], count, timeout, cMessage[port-1][12+shift]);
 8008cce:	2638      	movs	r6, #56	; 0x38
 8008cd0:	9b04      	ldr	r3, [sp, #16]
 8008cd2:	496d      	ldr	r1, [pc, #436]	; (8008e88 <PxMessagingTask+0xab4>)
 8008cd4:	435e      	muls	r6, r3
 8008cd6:	4b69      	ldr	r3, [pc, #420]	; (8008e7c <PxMessagingTask+0xaa8>)
 8008cd8:	7809      	ldrb	r1, [r1, #0]
 8008cda:	199e      	adds	r6, r3, r6
 8008cdc:	19f4      	adds	r4, r6, r7
 8008cde:	7aa3      	ldrb	r3, [r4, #10]
 8008ce0:	7b25      	ldrb	r5, [r4, #12]
 8008ce2:	9308      	str	r3, [sp, #32]
 8008ce4:	1e6b      	subs	r3, r5, #1
 8008ce6:	419d      	sbcs	r5, r3
 8008ce8:	7ae2      	ldrb	r2, [r4, #11]
 8008cea:	7a60      	ldrb	r0, [r4, #9]
 8008cec:	9503      	str	r5, [sp, #12]
							timeout = ( (uint32_t) cMessage[port-1][4+shift] << 24 ) + ( (uint32_t) cMessage[port-1][5+shift] << 16 ) + ( (uint32_t) cMessage[port-1][6+shift] << 8 ) + cMessage[port-1][7+shift];
 8008cee:	7925      	ldrb	r5, [r4, #4]
 8008cf0:	79e3      	ldrb	r3, [r4, #7]
 8008cf2:	062d      	lsls	r5, r5, #24
 8008cf4:	46ac      	mov	ip, r5
 8008cf6:	7965      	ldrb	r5, [r4, #5]
 8008cf8:	042d      	lsls	r5, r5, #16
 8008cfa:	4465      	add	r5, ip
 8008cfc:	469c      	mov	ip, r3
 8008cfe:	79a3      	ldrb	r3, [r4, #6]
 8008d00:	4465      	add	r5, ip
 8008d02:	021b      	lsls	r3, r3, #8
 8008d04:	469c      	mov	ip, r3
 8008d06:	4465      	add	r5, ip
							StartScastDMAStream(cMessage[port-1][9+shift], myID, cMessage[port-1][11+shift], cMessage[port-1][10+shift], cMessage[port-1][8+shift], count, timeout, cMessage[port-1][12+shift]);
 8008d08:	9502      	str	r5, [sp, #8]
							count = ( (uint32_t) cMessage[port-1][shift] << 24 ) + ( (uint32_t) cMessage[port-1][1+shift] << 16 ) + ( (uint32_t) cMessage[port-1][2+shift] << 8 ) + cMessage[port-1][3+shift];
 8008d0a:	5df5      	ldrb	r5, [r6, r7]
 8008d0c:	78e6      	ldrb	r6, [r4, #3]
 8008d0e:	062d      	lsls	r5, r5, #24
 8008d10:	19ad      	adds	r5, r5, r6
 8008d12:	7866      	ldrb	r6, [r4, #1]
							StartScastDMAStream(cMessage[port-1][9+shift], myID, cMessage[port-1][11+shift], cMessage[port-1][10+shift], cMessage[port-1][8+shift], count, timeout, cMessage[port-1][12+shift]);
 8008d14:	9b08      	ldr	r3, [sp, #32]
							count = ( (uint32_t) cMessage[port-1][shift] << 24 ) + ( (uint32_t) cMessage[port-1][1+shift] << 16 ) + ( (uint32_t) cMessage[port-1][2+shift] << 8 ) + cMessage[port-1][3+shift];
 8008d16:	0436      	lsls	r6, r6, #16
 8008d18:	19ad      	adds	r5, r5, r6
 8008d1a:	78a6      	ldrb	r6, [r4, #2]
 8008d1c:	0236      	lsls	r6, r6, #8
 8008d1e:	19ad      	adds	r5, r5, r6
							StartScastDMAStream(cMessage[port-1][9+shift], myID, cMessage[port-1][11+shift], cMessage[port-1][10+shift], cMessage[port-1][8+shift], count, timeout, cMessage[port-1][12+shift]);
 8008d20:	9501      	str	r5, [sp, #4]
 8008d22:	7a24      	ldrb	r4, [r4, #8]
 8008d24:	9400      	str	r4, [sp, #0]
 8008d26:	f7ff f923 	bl	8007f70 <StartScastDMAStream>
 8008d2a:	e4c6      	b.n	80086ba <PxMessagingTask+0x2e6>
							 if	(cMessage[port-1][shift]==REMOTE_MEMORY_ADD)											// request for a memory address
 8008d2c:	2138      	movs	r1, #56	; 0x38
 8008d2e:	9a04      	ldr	r2, [sp, #16]
 8008d30:	4852      	ldr	r0, [pc, #328]	; (8008e7c <PxMessagingTask+0xaa8>)
 8008d32:	4351      	muls	r1, r2
 8008d34:	1841      	adds	r1, r0, r1
 8008d36:	5dca      	ldrb	r2, [r1, r7]
 8008d38:	2a00      	cmp	r2, #0
 8008d3a:	d14c      	bne.n	8008dd6 <PxMessagingTask+0xa02>
									temp32 = ( (uint32_t) cMessage[port-1][2+shift] << 24 ) + ( (uint32_t) cMessage[port-1][3+shift] << 16 ) + ( (uint32_t) cMessage[port-1][4+shift] << 8 ) + cMessage[port-1][5+shift];				
 8008d3c:	19c9      	adds	r1, r1, r7
 8008d3e:	788b      	ldrb	r3, [r1, #2]
 8008d40:	78c8      	ldrb	r0, [r1, #3]
 8008d42:	061b      	lsls	r3, r3, #24
 8008d44:	0400      	lsls	r0, r0, #16
 8008d46:	181b      	adds	r3, r3, r0
 8008d48:	7948      	ldrb	r0, [r1, #5]
									switch (cMessage[port-1][1+shift])											// requested format
 8008d4a:	0014      	movs	r4, r2
									temp32 = ( (uint32_t) cMessage[port-1][2+shift] << 24 ) + ( (uint32_t) cMessage[port-1][3+shift] << 16 ) + ( (uint32_t) cMessage[port-1][4+shift] << 8 ) + cMessage[port-1][5+shift];				
 8008d4c:	181b      	adds	r3, r3, r0
 8008d4e:	7908      	ldrb	r0, [r1, #4]
 8008d50:	0200      	lsls	r0, r0, #8
 8008d52:	181b      	adds	r3, r3, r0
									switch (cMessage[port-1][1+shift])											// requested format
 8008d54:	7848      	ldrb	r0, [r1, #1]
 8008d56:	3801      	subs	r0, #1
 8008d58:	2807      	cmp	r0, #7
 8008d5a:	d901      	bls.n	8008d60 <PxMessagingTask+0x98c>
 8008d5c:	f7ff fc09 	bl	8008572 <PxMessagingTask+0x19e>
 8008d60:	4a4a      	ldr	r2, [pc, #296]	; (8008e8c <PxMessagingTask+0xab8>)
 8008d62:	f7f7 f9eb 	bl	800013c <__gnu_thumb1_case_uqi>
 8008d66:	0404      	.short	0x0404
 8008d68:	23150f08 	.word	0x23150f08
 8008d6c:	042e      	.short	0x042e
											messageParams[0] = *(__IO int8_t *)temp32; 
 8008d6e:	781b      	ldrb	r3, [r3, #0]
 8008d70:	7013      	strb	r3, [r2, #0]
									SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 1);							
 8008d72:	2201      	movs	r2, #1
 8008d74:	e018      	b.n	8008da8 <PxMessagingTask+0x9d4>
											messageParams[0] = (uint8_t)((*(__IO uint16_t *)temp32)>>0); messageParams[1] = (uint8_t)((*(__IO uint16_t *)temp32)>>8);  
 8008d76:	8819      	ldrh	r1, [r3, #0]
 8008d78:	7011      	strb	r1, [r2, #0]
 8008d7a:	881b      	ldrh	r3, [r3, #0]
 8008d7c:	0a1b      	lsrs	r3, r3, #8
											messageParams[0] = (uint8_t)((*(__IO int16_t *)temp32)>>0); messageParams[1] = (uint8_t)((*(__IO int16_t *)temp32)>>8); 
 8008d7e:	7053      	strb	r3, [r2, #1]
												SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 2); break;
 8008d80:	2202      	movs	r2, #2
 8008d82:	e011      	b.n	8008da8 <PxMessagingTask+0x9d4>
											messageParams[0] = (uint8_t)((*(__IO int16_t *)temp32)>>0); messageParams[1] = (uint8_t)((*(__IO int16_t *)temp32)>>8); 
 8008d84:	8819      	ldrh	r1, [r3, #0]
 8008d86:	7011      	strb	r1, [r2, #0]
 8008d88:	881b      	ldrh	r3, [r3, #0]
 8008d8a:	b21b      	sxth	r3, r3
 8008d8c:	121b      	asrs	r3, r3, #8
 8008d8e:	e7f6      	b.n	8008d7e <PxMessagingTask+0x9aa>
											messageParams[0] = (uint8_t)((*(__IO uint32_t *)temp32)>>0); messageParams[1] = (uint8_t)((*(__IO uint32_t *)temp32)>>8); 
 8008d90:	6819      	ldr	r1, [r3, #0]
 8008d92:	7011      	strb	r1, [r2, #0]
 8008d94:	6819      	ldr	r1, [r3, #0]
 8008d96:	0a09      	lsrs	r1, r1, #8
 8008d98:	7051      	strb	r1, [r2, #1]
											messageParams[2] = (uint8_t)((*(__IO uint32_t *)temp32)>>16); messageParams[3] = (uint8_t)((*(__IO uint32_t *)temp32)>>24); 
 8008d9a:	6819      	ldr	r1, [r3, #0]
 8008d9c:	0c09      	lsrs	r1, r1, #16
 8008d9e:	7091      	strb	r1, [r2, #2]
 8008da0:	681b      	ldr	r3, [r3, #0]
 8008da2:	0e1b      	lsrs	r3, r3, #24
											messageParams[2] = (uint8_t)((*(__IO int32_t *)temp32)>>16); messageParams[3] = (uint8_t)((*(__IO int32_t *)temp32)>>24);
 8008da4:	70d3      	strb	r3, [r2, #3]
											SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 4); break;										
 8008da6:	2204      	movs	r2, #4
									SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 1);							
 8008da8:	211f      	movs	r1, #31
 8008daa:	e51b      	b.n	80087e4 <PxMessagingTask+0x410>
											messageParams[0] = (uint8_t)((*(__IO int32_t *)temp32)>>0); messageParams[1] = (uint8_t)((*(__IO int32_t *)temp32)>>8); 
 8008dac:	6819      	ldr	r1, [r3, #0]
 8008dae:	7011      	strb	r1, [r2, #0]
 8008db0:	6819      	ldr	r1, [r3, #0]
 8008db2:	1209      	asrs	r1, r1, #8
 8008db4:	7051      	strb	r1, [r2, #1]
											messageParams[2] = (uint8_t)((*(__IO int32_t *)temp32)>>16); messageParams[3] = (uint8_t)((*(__IO int32_t *)temp32)>>24);
 8008db6:	6819      	ldr	r1, [r3, #0]
 8008db8:	1409      	asrs	r1, r1, #16
 8008dba:	7091      	strb	r1, [r2, #2]
 8008dbc:	681b      	ldr	r3, [r3, #0]
 8008dbe:	161b      	asrs	r3, r3, #24
 8008dc0:	e7f0      	b.n	8008da4 <PxMessagingTask+0x9d0>
											messageParams[0] = *(__IO uint8_t *)(temp32+0); messageParams[1] = *(__IO uint8_t *)(temp32+1); 
 8008dc2:	7819      	ldrb	r1, [r3, #0]
 8008dc4:	7011      	strb	r1, [r2, #0]
 8008dc6:	7859      	ldrb	r1, [r3, #1]
 8008dc8:	7051      	strb	r1, [r2, #1]
											messageParams[2] = *(__IO uint8_t *)(temp32+2); messageParams[3] = *(__IO uint8_t *)(temp32+3); 
 8008dca:	7899      	ldrb	r1, [r3, #2]
 8008dcc:	7091      	strb	r1, [r2, #2]
 8008dce:	78db      	ldrb	r3, [r3, #3]
 8008dd0:	70d3      	strb	r3, [r2, #3]
											SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 8); break;	// You cannot bitwise floats	
 8008dd2:	2208      	movs	r2, #8
 8008dd4:	e7e8      	b.n	8008da8 <PxMessagingTask+0x9d4>
 8008dd6:	2500      	movs	r5, #0
								else if(cMessage[port-1][shift]==REMOTE_MODULE_PARAM)			// request for a Module param
 8008dd8:	2a02      	cmp	r2, #2
 8008dda:	d12b      	bne.n	8008e34 <PxMessagingTask+0xa60>
									temp=IsModuleParameter((char *)&cMessage[port-1][1+shift]);          // extrating module parameter
 8008ddc:	9a07      	ldr	r2, [sp, #28]
									cMessage[port-1][messageLength[port-1]-1] = 0;		 // adding string termination
 8008dde:	18c9      	adds	r1, r1, r3
									temp=IsModuleParameter((char *)&cMessage[port-1][1+shift]);          // extrating module parameter
 8008de0:	1c7b      	adds	r3, r7, #1
 8008de2:	189b      	adds	r3, r3, r2
									cMessage[port-1][messageLength[port-1]-1] = 0;		 // adding string termination
 8008de4:	3901      	subs	r1, #1
									temp=IsModuleParameter((char *)&cMessage[port-1][1+shift]);          // extrating module parameter
 8008de6:	1818      	adds	r0, r3, r0
									cMessage[port-1][messageLength[port-1]-1] = 0;		 // adding string termination
 8008de8:	700d      	strb	r5, [r1, #0]
									temp=IsModuleParameter((char *)&cMessage[port-1][1+shift]);          // extrating module parameter
 8008dea:	f7fa fb3d 	bl	8003468 <IsModuleParameter>
 8008dee:	9005      	str	r0, [sp, #20]
									if (temp == 0) {																					// Parameter does not exist
 8008df0:	42a8      	cmp	r0, r5
 8008df2:	d0be      	beq.n	8008d72 <PxMessagingTask+0x99e>
										temp32 = (uint32_t) modParam[temp-1].paramPtr;
 8008df4:	210c      	movs	r1, #12
 8008df6:	9b05      	ldr	r3, [sp, #20]
									switch (messageParams[0])											// requested format
 8008df8:	002c      	movs	r4, r5
										temp32 = (uint32_t) modParam[temp-1].paramPtr;
 8008dfa:	1e5a      	subs	r2, r3, #1
 8008dfc:	4351      	muls	r1, r2
 8008dfe:	4b24      	ldr	r3, [pc, #144]	; (8008e90 <PxMessagingTask+0xabc>)
 8008e00:	58ca      	ldr	r2, [r1, r3]
										messageParams[0] = modParam[temp-1].paramFormat;
 8008e02:	185b      	adds	r3, r3, r1
 8008e04:	7918      	ldrb	r0, [r3, #4]
 8008e06:	4b21      	ldr	r3, [pc, #132]	; (8008e8c <PxMessagingTask+0xab8>)
 8008e08:	7018      	strb	r0, [r3, #0]
									switch (messageParams[0])											// requested format
 8008e0a:	3801      	subs	r0, #1
 8008e0c:	2807      	cmp	r0, #7
 8008e0e:	d901      	bls.n	8008e14 <PxMessagingTask+0xa40>
 8008e10:	f7ff fbaf 	bl	8008572 <PxMessagingTask+0x19e>
 8008e14:	f7f7 f992 	bl	800013c <__gnu_thumb1_case_uqi>
 8008e18:	47402f2f 	.word	0x47402f2f
 8008e1c:	2f045a4d 	.word	0x2f045a4d
											messageParams[1] = *(__IO uint8_t *)(temp32+0); messageParams[2] = *(__IO uint8_t *)(temp32+1);  
 8008e20:	7811      	ldrb	r1, [r2, #0]
 8008e22:	7059      	strb	r1, [r3, #1]
 8008e24:	7851      	ldrb	r1, [r2, #1]
 8008e26:	7099      	strb	r1, [r3, #2]
											messageParams[3] = *(__IO uint8_t *)(temp32+2); messageParams[4] = *(__IO uint8_t *)(temp32+3);  			// You cannot bitwise floats	
 8008e28:	7891      	ldrb	r1, [r2, #2]
 8008e2a:	70d9      	strb	r1, [r3, #3]
 8008e2c:	78d2      	ldrb	r2, [r2, #3]
												messageParams[3] = *(__IO uint8_t *)(temp32+2); messageParams[4] = *(__IO uint8_t *)(temp32+3);  			// You cannot bitwise floats	
 8008e2e:	711a      	strb	r2, [r3, #4]
												SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 9); break;			
 8008e30:	2209      	movs	r2, #9
 8008e32:	e7b9      	b.n	8008da8 <PxMessagingTask+0x9d4>
									}
 8008e34:	002c      	movs	r4, r5
								else if(cMessage[port-1][shift]>=REMOTE_BOS_VAR)			// request for a BOS var
 8008e36:	2a02      	cmp	r2, #2
 8008e38:	d801      	bhi.n	8008e3e <PxMessagingTask+0xa6a>
 8008e3a:	f7ff fb9a 	bl	8008572 <PxMessagingTask+0x19e>
									messageParams[0] = BOS_var_reg[cMessage[port-1][shift]-REMOTE_BOS_VAR-1]&0x000F;					// send variable format (lower 4 bits)
 8008e3e:	200f      	movs	r0, #15
 8008e40:	4b14      	ldr	r3, [pc, #80]	; (8008e94 <PxMessagingTask+0xac0>)
 8008e42:	3a04      	subs	r2, #4
 8008e44:	0092      	lsls	r2, r2, #2
 8008e46:	58d1      	ldr	r1, [r2, r3]
 8008e48:	4b10      	ldr	r3, [pc, #64]	; (8008e8c <PxMessagingTask+0xab8>)
 8008e4a:	4008      	ands	r0, r1
 8008e4c:	7018      	strb	r0, [r3, #0]
									if (messageParams[0] == 0) {																					// Variable does not exist
 8008e4e:	d103      	bne.n	8008e58 <PxMessagingTask+0xa84>
										SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 1);							
 8008e50:	2201      	movs	r2, #1
 8008e52:	211f      	movs	r1, #31
 8008e54:	f7ff fc01 	bl	800865a <PxMessagingTask+0x286>
										temp32 = (BOS_var_reg[cMessage[port-1][shift]-REMOTE_BOS_VAR-1]>>16) + SRAM_BASE;
 8008e58:	2280      	movs	r2, #128	; 0x80
 8008e5a:	0c09      	lsrs	r1, r1, #16
 8008e5c:	0592      	lsls	r2, r2, #22
										switch (messageParams[0])											// requested format
 8008e5e:	3801      	subs	r0, #1
										temp32 = (BOS_var_reg[cMessage[port-1][shift]-REMOTE_BOS_VAR-1]>>16) + SRAM_BASE;
 8008e60:	188a      	adds	r2, r1, r2
										switch (messageParams[0])											// requested format
 8008e62:	2807      	cmp	r0, #7
 8008e64:	d901      	bls.n	8008e6a <PxMessagingTask+0xa96>
 8008e66:	f7ff fb84 	bl	8008572 <PxMessagingTask+0x19e>
 8008e6a:	f7f7 f967 	bl	800013c <__gnu_thumb1_case_uqi>
 8008e6e:	0404      	.short	0x0404
 8008e70:	2f221c15 	.word	0x2f221c15
 8008e74:	043a      	.short	0x043a
												messageParams[1] = *(__IO int8_t *)temp32; 
 8008e76:	7812      	ldrb	r2, [r2, #0]
 8008e78:	705a      	strb	r2, [r3, #1]
 8008e7a:	e781      	b.n	8008d80 <PxMessagingTask+0x9ac>
 8008e7c:	20000d13 	.word	0x20000d13
 8008e80:	e000ed00 	.word	0xe000ed00
 8008e84:	05fa0004 	.word	0x05fa0004
 8008e88:	20001039 	.word	0x20001039
 8008e8c:	20000f07 	.word	0x20000f07
 8008e90:	2000008c 	.word	0x2000008c
 8008e94:	20006ef8 	.word	0x20006ef8
												messageParams[1] = (uint8_t)((*(__IO uint16_t *)temp32)>>0); messageParams[2] = (uint8_t)((*(__IO uint16_t *)temp32)>>8); 
 8008e98:	8811      	ldrh	r1, [r2, #0]
 8008e9a:	7059      	strb	r1, [r3, #1]
 8008e9c:	8812      	ldrh	r2, [r2, #0]
 8008e9e:	0a12      	lsrs	r2, r2, #8
												messageParams[1] = (uint8_t)((*(__IO int16_t *)temp32)>>0); messageParams[2] = (uint8_t)((*(__IO int16_t *)temp32)>>8); 
 8008ea0:	709a      	strb	r2, [r3, #2]
												SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 3); break;
 8008ea2:	2203      	movs	r2, #3
 8008ea4:	e780      	b.n	8008da8 <PxMessagingTask+0x9d4>
												messageParams[1] = (uint8_t)((*(__IO int16_t *)temp32)>>0); messageParams[2] = (uint8_t)((*(__IO int16_t *)temp32)>>8); 
 8008ea6:	8811      	ldrh	r1, [r2, #0]
 8008ea8:	7059      	strb	r1, [r3, #1]
 8008eaa:	8812      	ldrh	r2, [r2, #0]
 8008eac:	b212      	sxth	r2, r2
 8008eae:	1212      	asrs	r2, r2, #8
 8008eb0:	e7f6      	b.n	8008ea0 <PxMessagingTask+0xacc>
												messageParams[1] = (uint8_t)((*(__IO uint32_t *)temp32)>>0); messageParams[2] = (uint8_t)((*(__IO uint32_t *)temp32)>>8); 
 8008eb2:	6811      	ldr	r1, [r2, #0]
 8008eb4:	7059      	strb	r1, [r3, #1]
 8008eb6:	6811      	ldr	r1, [r2, #0]
 8008eb8:	0a09      	lsrs	r1, r1, #8
 8008eba:	7099      	strb	r1, [r3, #2]
												messageParams[3] = (uint8_t)((*(__IO uint32_t *)temp32)>>16); messageParams[4] = (uint8_t)((*(__IO uint32_t *)temp32)>>24); 
 8008ebc:	6811      	ldr	r1, [r2, #0]
 8008ebe:	0c09      	lsrs	r1, r1, #16
 8008ec0:	70d9      	strb	r1, [r3, #3]
 8008ec2:	6812      	ldr	r2, [r2, #0]
 8008ec4:	0e12      	lsrs	r2, r2, #24
												messageParams[3] = (uint8_t)((*(__IO int32_t *)temp32)>>16); messageParams[4] = (uint8_t)((*(__IO int32_t *)temp32)>>24);
 8008ec6:	711a      	strb	r2, [r3, #4]
												SendMessageToModule(src, CODE_READ_REMOTE_RESPONSE, 5); break;										
 8008ec8:	2205      	movs	r2, #5
 8008eca:	e76d      	b.n	8008da8 <PxMessagingTask+0x9d4>
												messageParams[1] = (uint8_t)((*(__IO int32_t *)temp32)>>0); messageParams[2] = (uint8_t)((*(__IO int32_t *)temp32)>>8); 
 8008ecc:	6811      	ldr	r1, [r2, #0]
 8008ece:	7059      	strb	r1, [r3, #1]
 8008ed0:	6811      	ldr	r1, [r2, #0]
 8008ed2:	1209      	asrs	r1, r1, #8
 8008ed4:	7099      	strb	r1, [r3, #2]
												messageParams[3] = (uint8_t)((*(__IO int32_t *)temp32)>>16); messageParams[4] = (uint8_t)((*(__IO int32_t *)temp32)>>24);
 8008ed6:	6811      	ldr	r1, [r2, #0]
 8008ed8:	1409      	asrs	r1, r1, #16
 8008eda:	70d9      	strb	r1, [r3, #3]
 8008edc:	6812      	ldr	r2, [r2, #0]
 8008ede:	1612      	asrs	r2, r2, #24
 8008ee0:	e7f1      	b.n	8008ec6 <PxMessagingTask+0xaf2>
												messageParams[1] = *(__IO uint8_t *)(temp32+0); messageParams[2] = *(__IO uint8_t *)(temp32+1); 
 8008ee2:	7812      	ldrb	r2, [r2, #0]
 8008ee4:	705a      	strb	r2, [r3, #1]
 8008ee6:	4ac6      	ldr	r2, [pc, #792]	; (8009200 <PxMessagingTask+0xe2c>)
 8008ee8:	188a      	adds	r2, r1, r2
 8008eea:	7812      	ldrb	r2, [r2, #0]
 8008eec:	709a      	strb	r2, [r3, #2]
												messageParams[3] = *(__IO uint8_t *)(temp32+2); messageParams[4] = *(__IO uint8_t *)(temp32+3);  			// You cannot bitwise floats	
 8008eee:	4ac5      	ldr	r2, [pc, #788]	; (8009204 <PxMessagingTask+0xe30>)
 8008ef0:	188a      	adds	r2, r1, r2
 8008ef2:	7812      	ldrb	r2, [r2, #0]
 8008ef4:	70da      	strb	r2, [r3, #3]
 8008ef6:	4ac4      	ldr	r2, [pc, #784]	; (8009208 <PxMessagingTask+0xe34>)
 8008ef8:	1889      	adds	r1, r1, r2
 8008efa:	780a      	ldrb	r2, [r1, #0]
 8008efc:	e797      	b.n	8008e2e <PxMessagingTask+0xa5a>
							if (remoteBuffer == REMOTE_BOS_VAR || remoteBuffer == REMOTE_MODULE_PARAM)				// We requested a BOS variable or module param
 8008efe:	2002      	movs	r0, #2
 8008f00:	4240      	negs	r0, r0
 8008f02:	17c1      	asrs	r1, r0, #31
 8008f04:	4bc1      	ldr	r3, [pc, #772]	; (800920c <PxMessagingTask+0xe38>)
 8008f06:	681a      	ldr	r2, [r3, #0]
 8008f08:	685b      	ldr	r3, [r3, #4]
 8008f0a:	1812      	adds	r2, r2, r0
 8008f0c:	414b      	adcs	r3, r1
 8008f0e:	2b00      	cmp	r3, #0
 8008f10:	d115      	bne.n	8008f3e <PxMessagingTask+0xb6a>
 8008f12:	2a01      	cmp	r2, #1
 8008f14:	d813      	bhi.n	8008f3e <PxMessagingTask+0xb6a>
								remoteVarFormat = (varFormat_t) cMessage[port-1][shift];
 8008f16:	2238      	movs	r2, #56	; 0x38
 8008f18:	9904      	ldr	r1, [sp, #16]
 8008f1a:	4bbd      	ldr	r3, [pc, #756]	; (8009210 <PxMessagingTask+0xe3c>)
 8008f1c:	434a      	muls	r2, r1
 8008f1e:	189a      	adds	r2, r3, r2
 8008f20:	5dd0      	ldrb	r0, [r2, r7]
 8008f22:	4abc      	ldr	r2, [pc, #752]	; (8009214 <PxMessagingTask+0xe40>)
 8008f24:	7010      	strb	r0, [r2, #0]
								switch (cMessage[port-1][shift])											// Remote format
 8008f26:	2808      	cmp	r0, #8
 8008f28:	d809      	bhi.n	8008f3e <PxMessagingTask+0xb6a>
 8008f2a:	f7f7 f907 	bl	800013c <__gnu_thumb1_case_uqi>
 8008f2e:	1305      	.short	0x1305
 8008f30:	3629291d 	.word	0x3629291d
 8008f34:	5a4a      	.short	0x5a4a
 8008f36:	13          	.byte	0x13
 8008f37:	00          	.byte	0x00
										responseStatus = BOS_ERR_REMOTE_READ_NO_VAR; break;
 8008f38:	2210      	movs	r2, #16
 8008f3a:	4bb7      	ldr	r3, [pc, #732]	; (8009218 <PxMessagingTask+0xe44>)
 8008f3c:	701a      	strb	r2, [r3, #0]
 8008f3e:	2300      	movs	r3, #0
							if (responseStatus != BOS_ERR_REMOTE_READ_NO_VAR)	responseStatus = BOS_OK;
 8008f40:	4ab5      	ldr	r2, [pc, #724]	; (8009218 <PxMessagingTask+0xe44>)
 8008f42:	001c      	movs	r4, r3
 8008f44:	7811      	ldrb	r1, [r2, #0]
 8008f46:	2910      	cmp	r1, #16
 8008f48:	d101      	bne.n	8008f4e <PxMessagingTask+0xb7a>
 8008f4a:	f7ff fb12 	bl	8008572 <PxMessagingTask+0x19e>
 8008f4e:	7013      	strb	r3, [r2, #0]
 8008f50:	f7ff fb0f 	bl	8008572 <PxMessagingTask+0x19e>
										remoteBuffer = cMessage[port-1][1+shift]; break;
 8008f54:	2138      	movs	r1, #56	; 0x38
 8008f56:	9804      	ldr	r0, [sp, #16]
 8008f58:	4aac      	ldr	r2, [pc, #688]	; (800920c <PxMessagingTask+0xe38>)
 8008f5a:	4341      	muls	r1, r0
 8008f5c:	1859      	adds	r1, r3, r1
 8008f5e:	19c9      	adds	r1, r1, r7
 8008f60:	784b      	ldrb	r3, [r1, #1]
										remoteBuffer = ((uint32_t)cMessage[port-1][1+shift]<<0) + ((uint32_t)cMessage[port-1][2+shift]<<8) + ((uint32_t)cMessage[port-1][3+shift]<<16) + ((uint32_t)cMessage[port-1][4+shift]<<24); break;
 8008f62:	6013      	str	r3, [r2, #0]
 8008f64:	2300      	movs	r3, #0
 8008f66:	e009      	b.n	8008f7c <PxMessagingTask+0xba8>
										remoteBuffer = (int8_t)cMessage[port-1][1+shift]; break;
 8008f68:	2138      	movs	r1, #56	; 0x38
 8008f6a:	9804      	ldr	r0, [sp, #16]
 8008f6c:	4aa7      	ldr	r2, [pc, #668]	; (800920c <PxMessagingTask+0xe38>)
 8008f6e:	4341      	muls	r1, r0
 8008f70:	1859      	adds	r1, r3, r1
 8008f72:	2301      	movs	r3, #1
 8008f74:	19c9      	adds	r1, r1, r7
 8008f76:	56cb      	ldrsb	r3, [r1, r3]
 8008f78:	6013      	str	r3, [r2, #0]
 8008f7a:	17db      	asrs	r3, r3, #31
										remoteBuffer = ((uint32_t)cMessage[port-1][1+shift]<<0) + ((uint32_t)cMessage[port-1][2+shift]<<8) + ((uint32_t)cMessage[port-1][3+shift]<<16) + ((uint32_t)cMessage[port-1][4+shift]<<24); break;
 8008f7c:	6053      	str	r3, [r2, #4]
 8008f7e:	e7de      	b.n	8008f3e <PxMessagingTask+0xb6a>
										remoteBuffer = ((int16_t)cMessage[port-1][1+shift]<<0) + ((int16_t)cMessage[port-1][2+shift]<<8); break;
 8008f80:	2138      	movs	r1, #56	; 0x38
 8008f82:	9a04      	ldr	r2, [sp, #16]
 8008f84:	4ca1      	ldr	r4, [pc, #644]	; (800920c <PxMessagingTask+0xe38>)
 8008f86:	4351      	muls	r1, r2
 8008f88:	1859      	adds	r1, r3, r1
 8008f8a:	19c9      	adds	r1, r1, r7
 8008f8c:	788b      	ldrb	r3, [r1, #2]
 8008f8e:	784a      	ldrb	r2, [r1, #1]
 8008f90:	021b      	lsls	r3, r3, #8
										remoteBuffer = ((int32_t)cMessage[port-1][1+shift]<<0) + ((int32_t)cMessage[port-1][2+shift]<<8) + ((int32_t)cMessage[port-1][3+shift]<<16) + ((int32_t)cMessage[port-1][4+shift]<<24); break;									
 8008f92:	189b      	adds	r3, r3, r2
 8008f94:	6023      	str	r3, [r4, #0]
 8008f96:	17db      	asrs	r3, r3, #31
 8008f98:	e011      	b.n	8008fbe <PxMessagingTask+0xbea>
										remoteBuffer = ((uint32_t)cMessage[port-1][1+shift]<<0) + ((uint32_t)cMessage[port-1][2+shift]<<8) + ((uint32_t)cMessage[port-1][3+shift]<<16) + ((uint32_t)cMessage[port-1][4+shift]<<24); break;
 8008f9a:	2138      	movs	r1, #56	; 0x38
 8008f9c:	9a04      	ldr	r2, [sp, #16]
 8008f9e:	4c9b      	ldr	r4, [pc, #620]	; (800920c <PxMessagingTask+0xe38>)
 8008fa0:	4351      	muls	r1, r2
 8008fa2:	1859      	adds	r1, r3, r1
 8008fa4:	19c9      	adds	r1, r1, r7
 8008fa6:	788b      	ldrb	r3, [r1, #2]
 8008fa8:	78ca      	ldrb	r2, [r1, #3]
 8008faa:	021b      	lsls	r3, r3, #8
 8008fac:	0412      	lsls	r2, r2, #16
 8008fae:	189b      	adds	r3, r3, r2
 8008fb0:	784a      	ldrb	r2, [r1, #1]
 8008fb2:	189b      	adds	r3, r3, r2
 8008fb4:	790a      	ldrb	r2, [r1, #4]
 8008fb6:	0612      	lsls	r2, r2, #24
 8008fb8:	189b      	adds	r3, r3, r2
 8008fba:	6023      	str	r3, [r4, #0]
 8008fbc:	2300      	movs	r3, #0
										remoteBuffer = ((int32_t)cMessage[port-1][1+shift]<<0) + ((int32_t)cMessage[port-1][2+shift]<<8) + ((int32_t)cMessage[port-1][3+shift]<<16) + ((int32_t)cMessage[port-1][4+shift]<<24); break;									
 8008fbe:	6063      	str	r3, [r4, #4]
 8008fc0:	e7bd      	b.n	8008f3e <PxMessagingTask+0xb6a>
 8008fc2:	2138      	movs	r1, #56	; 0x38
 8008fc4:	9a04      	ldr	r2, [sp, #16]
 8008fc6:	4c91      	ldr	r4, [pc, #580]	; (800920c <PxMessagingTask+0xe38>)
 8008fc8:	4351      	muls	r1, r2
 8008fca:	1859      	adds	r1, r3, r1
 8008fcc:	19c9      	adds	r1, r1, r7
 8008fce:	788b      	ldrb	r3, [r1, #2]
 8008fd0:	784a      	ldrb	r2, [r1, #1]
 8008fd2:	021b      	lsls	r3, r3, #8
 8008fd4:	189b      	adds	r3, r3, r2
 8008fd6:	78ca      	ldrb	r2, [r1, #3]
 8008fd8:	0412      	lsls	r2, r2, #16
 8008fda:	189b      	adds	r3, r3, r2
 8008fdc:	790a      	ldrb	r2, [r1, #4]
 8008fde:	0612      	lsls	r2, r2, #24
 8008fe0:	e7d7      	b.n	8008f92 <PxMessagingTask+0xbbe>
										remoteBuffer = ((uint32_t)cMessage[port-1][1+shift]<<0) + ((uint32_t)cMessage[port-1][2+shift]<<8) + ((uint32_t)cMessage[port-1][3+shift]<<16) + ((uint32_t)cMessage[port-1][4+shift]<<24); break;
 8008fe2:	2138      	movs	r1, #56	; 0x38
 8008fe4:	9804      	ldr	r0, [sp, #16]
 8008fe6:	4a89      	ldr	r2, [pc, #548]	; (800920c <PxMessagingTask+0xe38>)
 8008fe8:	4341      	muls	r1, r0
 8008fea:	1859      	adds	r1, r3, r1
 8008fec:	19c9      	adds	r1, r1, r7
 8008fee:	788b      	ldrb	r3, [r1, #2]
 8008ff0:	78c8      	ldrb	r0, [r1, #3]
 8008ff2:	021b      	lsls	r3, r3, #8
 8008ff4:	0400      	lsls	r0, r0, #16
 8008ff6:	181b      	adds	r3, r3, r0
 8008ff8:	7848      	ldrb	r0, [r1, #1]
 8008ffa:	7909      	ldrb	r1, [r1, #4]
 8008ffc:	181b      	adds	r3, r3, r0
 8008ffe:	0609      	lsls	r1, r1, #24
 8009000:	185b      	adds	r3, r3, r1
 8009002:	e7ae      	b.n	8008f62 <PxMessagingTask+0xb8e>
							responseStatus = BOS_OK;		// Initialize response
 8009004:	2300      	movs	r3, #0
 8009006:	4884      	ldr	r0, [pc, #528]	; (8009218 <PxMessagingTask+0xe44>)
							if(cMessage[port-1][shift])			// request for a BOS var
 8009008:	9904      	ldr	r1, [sp, #16]
							responseStatus = BOS_OK;		// Initialize response
 800900a:	7003      	strb	r3, [r0, #0]
							if(cMessage[port-1][shift])			// request for a BOS var
 800900c:	3338      	adds	r3, #56	; 0x38
 800900e:	4359      	muls	r1, r3
 8009010:	4a7f      	ldr	r2, [pc, #508]	; (8009210 <PxMessagingTask+0xe3c>)
 8009012:	1851      	adds	r1, r2, r1
 8009014:	5dcc      	ldrb	r4, [r1, r7]
 8009016:	9408      	str	r4, [sp, #32]
 8009018:	2c00      	cmp	r4, #0
 800901a:	d100      	bne.n	800901e <PxMessagingTask+0xc4a>
 800901c:	e12f      	b.n	800927e <PxMessagingTask+0xeaa>
								if(cMessage[port-1][shift] <= MAX_BOS_VARS)
 800901e:	0023      	movs	r3, r4
 8009020:	2c1e      	cmp	r4, #30
 8009022:	d900      	bls.n	8009026 <PxMessagingTask+0xc52>
 8009024:	e128      	b.n	8009278 <PxMessagingTask+0xea4>
									temp32 = (BOS_var_reg[cMessage[port-1][shift]-1]>>16) + SRAM_BASE;				// Get var memory addres
 8009026:	2080      	movs	r0, #128	; 0x80
 8009028:	3b01      	subs	r3, #1
 800902a:	009d      	lsls	r5, r3, #2
 800902c:	4b7b      	ldr	r3, [pc, #492]	; (800921c <PxMessagingTask+0xe48>)
 800902e:	0580      	lsls	r0, r0, #22
 8009030:	58ea      	ldr	r2, [r5, r3]
 8009032:	0c13      	lsrs	r3, r2, #16
 8009034:	181b      	adds	r3, r3, r0
									switch (cMessage[port-1][1+shift])											// requested format
 8009036:	1c78      	adds	r0, r7, #1
 8009038:	5c0c      	ldrb	r4, [r1, r0]
 800903a:	210f      	movs	r1, #15
 800903c:	9008      	str	r0, [sp, #32]
 800903e:	1e60      	subs	r0, r4, #1
 8009040:	400a      	ands	r2, r1
 8009042:	2807      	cmp	r0, #7
 8009044:	d81c      	bhi.n	8009080 <PxMessagingTask+0xcac>
 8009046:	f7f7 f879 	bl	800013c <__gnu_thumb1_case_uqi>
 800904a:	3804      	.short	0x3804
 800904c:	b9937454 	.word	0xb9937454
 8009050:	04ed      	.short	0x04ed
											if ((BOS_var_reg[cMessage[port-1][shift]-1]&0x000F) == 0) {		// Variable does not exist																															
 8009052:	2a00      	cmp	r2, #0
 8009054:	d108      	bne.n	8009068 <PxMessagingTask+0xc94>
												temp32 = (uint32_t)malloc(sizeof(uint8_t));							// Create a new one
 8009056:	2001      	movs	r0, #1
 8009058:	f00b f8be 	bl	80141d8 <malloc>
 800905c:	1e03      	subs	r3, r0, #0
												if (temp32 != 0) {
 800905e:	d028      	beq.n	80090b2 <PxMessagingTask+0xcde>
													BOS_var_reg[cMessage[port-1][shift]-1] = ((temp32-SRAM_BASE)<<16) + cMessage[port-1][1+shift];
 8009060:	0402      	lsls	r2, r0, #16
 8009062:	1914      	adds	r4, r2, r4
 8009064:	4a6d      	ldr	r2, [pc, #436]	; (800921c <PxMessagingTask+0xe48>)
 8009066:	5154      	str	r4, [r2, r5]
											if (responseStatus != BOS_ERR_REMOTE_WRITE_MEM_FULL)			// Write remote value
 8009068:	4a6b      	ldr	r2, [pc, #428]	; (8009218 <PxMessagingTask+0xe44>)
 800906a:	7812      	ldrb	r2, [r2, #0]
 800906c:	2a12      	cmp	r2, #18
 800906e:	d007      	beq.n	8009080 <PxMessagingTask+0xcac>
												*(__IO uint8_t *)temp32 = cMessage[port-1][2+shift];					
 8009070:	2138      	movs	r1, #56	; 0x38
 8009072:	9a04      	ldr	r2, [sp, #16]
 8009074:	4351      	muls	r1, r2
 8009076:	4a66      	ldr	r2, [pc, #408]	; (8009210 <PxMessagingTask+0xe3c>)
 8009078:	1852      	adds	r2, r2, r1
 800907a:	19d2      	adds	r2, r2, r7
 800907c:	7892      	ldrb	r2, [r2, #2]
												*(__IO int8_t *)temp32 = (int8_t)cMessage[port-1][2+shift];		
 800907e:	701a      	strb	r2, [r3, #0]
									if ( (BOS_var_reg[cMessage[port-1][shift]-1] & 0x000F) != cMessage[port-1][1+shift] ) {		
 8009080:	2338      	movs	r3, #56	; 0x38
 8009082:	9a04      	ldr	r2, [sp, #16]
 8009084:	9c08      	ldr	r4, [sp, #32]
 8009086:	4353      	muls	r3, r2
 8009088:	4a61      	ldr	r2, [pc, #388]	; (8009210 <PxMessagingTask+0xe3c>)
 800908a:	4864      	ldr	r0, [pc, #400]	; (800921c <PxMessagingTask+0xe48>)
 800908c:	18d3      	adds	r3, r2, r3
 800908e:	5dda      	ldrb	r2, [r3, r7]
 8009090:	5d1b      	ldrb	r3, [r3, r4]
 8009092:	240f      	movs	r4, #15
 8009094:	3a01      	subs	r2, #1
 8009096:	0092      	lsls	r2, r2, #2
 8009098:	5811      	ldr	r1, [r2, r0]
 800909a:	400c      	ands	r4, r1
 800909c:	429c      	cmp	r4, r3
 800909e:	d100      	bne.n	80090a2 <PxMessagingTask+0xcce>
 80090a0:	e110      	b.n	80092c4 <PxMessagingTask+0xef0>
										BOS_var_reg[cMessage[port-1][shift]-1] &= (0xFFF0+cMessage[port-1][1+shift]);
 80090a2:	4c5f      	ldr	r4, [pc, #380]	; (8009220 <PxMessagingTask+0xe4c>)
 80090a4:	191b      	adds	r3, r3, r4
 80090a6:	400b      	ands	r3, r1
 80090a8:	5013      	str	r3, [r2, r0]
										responseStatus = BOS_ERR_LOCAL_FORMAT_UPDATED;
 80090aa:	2214      	movs	r2, #20
 80090ac:	4b5a      	ldr	r3, [pc, #360]	; (8009218 <PxMessagingTask+0xe44>)
									if (status != HAL_OK)	responseStatus = BOS_ERR_REMOTE_WRITE_FLASH;
 80090ae:	701a      	strb	r2, [r3, #0]
 80090b0:	e108      	b.n	80092c4 <PxMessagingTask+0xef0>
													responseStatus = BOS_ERR_REMOTE_WRITE_MEM_FULL;
 80090b2:	2112      	movs	r1, #18
 80090b4:	4a58      	ldr	r2, [pc, #352]	; (8009218 <PxMessagingTask+0xe44>)
 80090b6:	7011      	strb	r1, [r2, #0]
 80090b8:	e7d6      	b.n	8009068 <PxMessagingTask+0xc94>
											if ((BOS_var_reg[cMessage[port-1][shift]-1]&0x000F) == 0) {		// Variable does not exist																															
 80090ba:	2a00      	cmp	r2, #0
 80090bc:	d108      	bne.n	80090d0 <PxMessagingTask+0xcfc>
												temp32 = (uint32_t)malloc(sizeof(int8_t));							// Create a new one
 80090be:	2001      	movs	r0, #1
 80090c0:	f00b f88a 	bl	80141d8 <malloc>
 80090c4:	1e03      	subs	r3, r0, #0
												if (temp32 != 0) {
 80090c6:	d010      	beq.n	80090ea <PxMessagingTask+0xd16>
													BOS_var_reg[cMessage[port-1][shift]-1] = ((temp32-SRAM_BASE)<<16) + cMessage[port-1][1+shift];
 80090c8:	0402      	lsls	r2, r0, #16
 80090ca:	4954      	ldr	r1, [pc, #336]	; (800921c <PxMessagingTask+0xe48>)
 80090cc:	3202      	adds	r2, #2
 80090ce:	514a      	str	r2, [r1, r5]
											if (responseStatus != BOS_ERR_REMOTE_WRITE_MEM_FULL)			// Write remote value
 80090d0:	4a51      	ldr	r2, [pc, #324]	; (8009218 <PxMessagingTask+0xe44>)
 80090d2:	7812      	ldrb	r2, [r2, #0]
 80090d4:	2a12      	cmp	r2, #18
 80090d6:	d0d3      	beq.n	8009080 <PxMessagingTask+0xcac>
												*(__IO int8_t *)temp32 = (int8_t)cMessage[port-1][2+shift];		
 80090d8:	2138      	movs	r1, #56	; 0x38
 80090da:	9a04      	ldr	r2, [sp, #16]
 80090dc:	4351      	muls	r1, r2
 80090de:	4a4c      	ldr	r2, [pc, #304]	; (8009210 <PxMessagingTask+0xe3c>)
 80090e0:	1852      	adds	r2, r2, r1
 80090e2:	19d2      	adds	r2, r2, r7
 80090e4:	7892      	ldrb	r2, [r2, #2]
 80090e6:	b252      	sxtb	r2, r2
 80090e8:	e7c9      	b.n	800907e <PxMessagingTask+0xcaa>
													responseStatus = BOS_ERR_REMOTE_WRITE_MEM_FULL;
 80090ea:	2112      	movs	r1, #18
 80090ec:	4a4a      	ldr	r2, [pc, #296]	; (8009218 <PxMessagingTask+0xe44>)
 80090ee:	7011      	strb	r1, [r2, #0]
 80090f0:	e7ee      	b.n	80090d0 <PxMessagingTask+0xcfc>
											if ((BOS_var_reg[cMessage[port-1][shift]-1]&0x000F) == 0) {		// Variable does not exist																															
 80090f2:	2a00      	cmp	r2, #0
 80090f4:	d108      	bne.n	8009108 <PxMessagingTask+0xd34>
												temp32 = (uint32_t)malloc(sizeof(uint16_t));						// Create a new one
 80090f6:	2002      	movs	r0, #2
 80090f8:	f00b f86e 	bl	80141d8 <malloc>
 80090fc:	1e03      	subs	r3, r0, #0
												if (temp32 != 0) {
 80090fe:	d014      	beq.n	800912a <PxMessagingTask+0xd56>
													BOS_var_reg[cMessage[port-1][shift]-1] = ((temp32-SRAM_BASE)<<16) + cMessage[port-1][1+shift];
 8009100:	0402      	lsls	r2, r0, #16
 8009102:	4946      	ldr	r1, [pc, #280]	; (800921c <PxMessagingTask+0xe48>)
 8009104:	3203      	adds	r2, #3
 8009106:	514a      	str	r2, [r1, r5]
											if (responseStatus != BOS_ERR_REMOTE_WRITE_MEM_FULL)			// Write remote value
 8009108:	4a43      	ldr	r2, [pc, #268]	; (8009218 <PxMessagingTask+0xe44>)
 800910a:	7812      	ldrb	r2, [r2, #0]
 800910c:	2a12      	cmp	r2, #18
 800910e:	d0b7      	beq.n	8009080 <PxMessagingTask+0xcac>
												*(__IO uint16_t *)temp32 = ((uint16_t)cMessage[port-1][2+shift]<<0) + ((uint16_t)cMessage[port-1][3+shift]<<8);					
 8009110:	2138      	movs	r1, #56	; 0x38
 8009112:	9a04      	ldr	r2, [sp, #16]
 8009114:	4351      	muls	r1, r2
 8009116:	4a3e      	ldr	r2, [pc, #248]	; (8009210 <PxMessagingTask+0xe3c>)
 8009118:	1852      	adds	r2, r2, r1
 800911a:	19d2      	adds	r2, r2, r7
 800911c:	78d1      	ldrb	r1, [r2, #3]
 800911e:	7892      	ldrb	r2, [r2, #2]
 8009120:	0209      	lsls	r1, r1, #8
 8009122:	1852      	adds	r2, r2, r1
 8009124:	b292      	uxth	r2, r2
												*(__IO int16_t *)temp32 = ((int16_t)cMessage[port-1][2+shift]<<0) + ((int16_t)cMessage[port-1][3+shift]<<8);					
 8009126:	801a      	strh	r2, [r3, #0]
 8009128:	e7aa      	b.n	8009080 <PxMessagingTask+0xcac>
													responseStatus = BOS_ERR_REMOTE_WRITE_MEM_FULL;
 800912a:	2112      	movs	r1, #18
 800912c:	4a3a      	ldr	r2, [pc, #232]	; (8009218 <PxMessagingTask+0xe44>)
 800912e:	7011      	strb	r1, [r2, #0]
 8009130:	e7ea      	b.n	8009108 <PxMessagingTask+0xd34>
											if ((BOS_var_reg[cMessage[port-1][shift]-1]&0x000F) == 0) {		// Variable does not exist																															
 8009132:	2a00      	cmp	r2, #0
 8009134:	d108      	bne.n	8009148 <PxMessagingTask+0xd74>
												temp32 = (uint32_t)malloc(sizeof(int16_t));							// Create a new one
 8009136:	2002      	movs	r0, #2
 8009138:	f00b f84e 	bl	80141d8 <malloc>
 800913c:	1e03      	subs	r3, r0, #0
												if (temp32 != 0) {
 800913e:	d013      	beq.n	8009168 <PxMessagingTask+0xd94>
													BOS_var_reg[cMessage[port-1][shift]-1] = ((temp32-SRAM_BASE)<<16) + cMessage[port-1][1+shift];
 8009140:	0402      	lsls	r2, r0, #16
 8009142:	4936      	ldr	r1, [pc, #216]	; (800921c <PxMessagingTask+0xe48>)
 8009144:	3204      	adds	r2, #4
 8009146:	514a      	str	r2, [r1, r5]
											if (responseStatus != BOS_ERR_REMOTE_WRITE_MEM_FULL)			// Write remote value
 8009148:	4a33      	ldr	r2, [pc, #204]	; (8009218 <PxMessagingTask+0xe44>)
 800914a:	7812      	ldrb	r2, [r2, #0]
 800914c:	2a12      	cmp	r2, #18
 800914e:	d097      	beq.n	8009080 <PxMessagingTask+0xcac>
												*(__IO int16_t *)temp32 = ((int16_t)cMessage[port-1][2+shift]<<0) + ((int16_t)cMessage[port-1][3+shift]<<8);					
 8009150:	2138      	movs	r1, #56	; 0x38
 8009152:	9a04      	ldr	r2, [sp, #16]
 8009154:	4351      	muls	r1, r2
 8009156:	4a2e      	ldr	r2, [pc, #184]	; (8009210 <PxMessagingTask+0xe3c>)
 8009158:	1852      	adds	r2, r2, r1
 800915a:	19d2      	adds	r2, r2, r7
 800915c:	78d1      	ldrb	r1, [r2, #3]
 800915e:	7892      	ldrb	r2, [r2, #2]
 8009160:	0209      	lsls	r1, r1, #8
 8009162:	1852      	adds	r2, r2, r1
 8009164:	b212      	sxth	r2, r2
 8009166:	e7de      	b.n	8009126 <PxMessagingTask+0xd52>
													responseStatus = BOS_ERR_REMOTE_WRITE_MEM_FULL;
 8009168:	2112      	movs	r1, #18
 800916a:	4a2b      	ldr	r2, [pc, #172]	; (8009218 <PxMessagingTask+0xe44>)
 800916c:	7011      	strb	r1, [r2, #0]
 800916e:	e7eb      	b.n	8009148 <PxMessagingTask+0xd74>
											if ((BOS_var_reg[cMessage[port-1][shift]-1]&0x000F) == 0) {		// Variable does not exist																															
 8009170:	2a00      	cmp	r2, #0
 8009172:	d108      	bne.n	8009186 <PxMessagingTask+0xdb2>
												temp32 = (uint32_t)malloc(sizeof(uint32_t));						// Create a new one
 8009174:	2004      	movs	r0, #4
 8009176:	f00b f82f 	bl	80141d8 <malloc>
 800917a:	1e03      	subs	r3, r0, #0
												if (temp32 != 0) {
 800917c:	d01a      	beq.n	80091b4 <PxMessagingTask+0xde0>
													BOS_var_reg[cMessage[port-1][shift]-1] = ((temp32-SRAM_BASE)<<16) + cMessage[port-1][1+shift];
 800917e:	0402      	lsls	r2, r0, #16
 8009180:	4926      	ldr	r1, [pc, #152]	; (800921c <PxMessagingTask+0xe48>)
 8009182:	3205      	adds	r2, #5
 8009184:	514a      	str	r2, [r1, r5]
											if (responseStatus != BOS_ERR_REMOTE_WRITE_MEM_FULL)			// Write remote value
 8009186:	4a24      	ldr	r2, [pc, #144]	; (8009218 <PxMessagingTask+0xe44>)
 8009188:	7812      	ldrb	r2, [r2, #0]
 800918a:	2a12      	cmp	r2, #18
 800918c:	d100      	bne.n	8009190 <PxMessagingTask+0xdbc>
 800918e:	e777      	b.n	8009080 <PxMessagingTask+0xcac>
												*(__IO uint32_t *)temp32 = ((uint32_t)cMessage[port-1][2+shift]<<0) + ((uint32_t)cMessage[port-1][3+shift]<<8) + ((uint32_t)cMessage[port-1][4+shift]<<16) + ((uint32_t)cMessage[port-1][5+shift]<<24);					
 8009190:	2238      	movs	r2, #56	; 0x38
 8009192:	9904      	ldr	r1, [sp, #16]
 8009194:	434a      	muls	r2, r1
 8009196:	491e      	ldr	r1, [pc, #120]	; (8009210 <PxMessagingTask+0xe3c>)
 8009198:	1889      	adds	r1, r1, r2
 800919a:	19c9      	adds	r1, r1, r7
 800919c:	78ca      	ldrb	r2, [r1, #3]
 800919e:	7908      	ldrb	r0, [r1, #4]
 80091a0:	0212      	lsls	r2, r2, #8
 80091a2:	0400      	lsls	r0, r0, #16
 80091a4:	1812      	adds	r2, r2, r0
 80091a6:	7888      	ldrb	r0, [r1, #2]
												*(__IO int32_t *)temp32 = ((int32_t)cMessage[port-1][2+shift]<<0) + ((int32_t)cMessage[port-1][3+shift]<<8) + ((int32_t)cMessage[port-1][4+shift]<<16) + ((int32_t)cMessage[port-1][5+shift]<<24);					
 80091a8:	7949      	ldrb	r1, [r1, #5]
 80091aa:	1812      	adds	r2, r2, r0
 80091ac:	0609      	lsls	r1, r1, #24
 80091ae:	1852      	adds	r2, r2, r1
 80091b0:	601a      	str	r2, [r3, #0]
 80091b2:	e765      	b.n	8009080 <PxMessagingTask+0xcac>
													responseStatus = BOS_ERR_REMOTE_WRITE_MEM_FULL;
 80091b4:	2112      	movs	r1, #18
 80091b6:	4a18      	ldr	r2, [pc, #96]	; (8009218 <PxMessagingTask+0xe44>)
 80091b8:	7011      	strb	r1, [r2, #0]
 80091ba:	e7e4      	b.n	8009186 <PxMessagingTask+0xdb2>
											if ((BOS_var_reg[cMessage[port-1][shift]-1]&0x000F) == 0) {		// Variable does not exist																															
 80091bc:	2a00      	cmp	r2, #0
 80091be:	d108      	bne.n	80091d2 <PxMessagingTask+0xdfe>
												temp32 = (uint32_t)malloc(sizeof(int32_t));							// Create a new one
 80091c0:	2004      	movs	r0, #4
 80091c2:	f00b f809 	bl	80141d8 <malloc>
 80091c6:	1e03      	subs	r3, r0, #0
												if (temp32 != 0) {
 80091c8:	d015      	beq.n	80091f6 <PxMessagingTask+0xe22>
													BOS_var_reg[cMessage[port-1][shift]-1] = ((temp32-SRAM_BASE)<<16) + cMessage[port-1][1+shift];
 80091ca:	0402      	lsls	r2, r0, #16
 80091cc:	4913      	ldr	r1, [pc, #76]	; (800921c <PxMessagingTask+0xe48>)
 80091ce:	3206      	adds	r2, #6
 80091d0:	514a      	str	r2, [r1, r5]
											if (responseStatus != BOS_ERR_REMOTE_WRITE_MEM_FULL)			// Write remote value
 80091d2:	4a11      	ldr	r2, [pc, #68]	; (8009218 <PxMessagingTask+0xe44>)
 80091d4:	7812      	ldrb	r2, [r2, #0]
 80091d6:	2a12      	cmp	r2, #18
 80091d8:	d100      	bne.n	80091dc <PxMessagingTask+0xe08>
 80091da:	e751      	b.n	8009080 <PxMessagingTask+0xcac>
												*(__IO int32_t *)temp32 = ((int32_t)cMessage[port-1][2+shift]<<0) + ((int32_t)cMessage[port-1][3+shift]<<8) + ((int32_t)cMessage[port-1][4+shift]<<16) + ((int32_t)cMessage[port-1][5+shift]<<24);					
 80091dc:	2238      	movs	r2, #56	; 0x38
 80091de:	9904      	ldr	r1, [sp, #16]
 80091e0:	434a      	muls	r2, r1
 80091e2:	490b      	ldr	r1, [pc, #44]	; (8009210 <PxMessagingTask+0xe3c>)
 80091e4:	1889      	adds	r1, r1, r2
 80091e6:	19c9      	adds	r1, r1, r7
 80091e8:	78ca      	ldrb	r2, [r1, #3]
 80091ea:	7888      	ldrb	r0, [r1, #2]
 80091ec:	0212      	lsls	r2, r2, #8
 80091ee:	1812      	adds	r2, r2, r0
 80091f0:	7908      	ldrb	r0, [r1, #4]
 80091f2:	0400      	lsls	r0, r0, #16
 80091f4:	e7d8      	b.n	80091a8 <PxMessagingTask+0xdd4>
													responseStatus = BOS_ERR_REMOTE_WRITE_MEM_FULL;
 80091f6:	2112      	movs	r1, #18
 80091f8:	4a07      	ldr	r2, [pc, #28]	; (8009218 <PxMessagingTask+0xe44>)
 80091fa:	7011      	strb	r1, [r2, #0]
 80091fc:	e7e9      	b.n	80091d2 <PxMessagingTask+0xdfe>
 80091fe:	46c0      	nop			; (mov r8, r8)
 8009200:	20000001 	.word	0x20000001
 8009204:	20000002 	.word	0x20000002
 8009208:	20000003 	.word	0x20000003
 800920c:	200010c0 	.word	0x200010c0
 8009210:	20000d13 	.word	0x20000d13
 8009214:	20000070 	.word	0x20000070
 8009218:	200010c8 	.word	0x200010c8
 800921c:	20006ef8 	.word	0x20006ef8
 8009220:	0000fff0 	.word	0x0000fff0
											if ((BOS_var_reg[cMessage[port-1][shift]-1]&0x000F) == 0) {		// Variable does not exist																															
 8009224:	2a00      	cmp	r2, #0
 8009226:	d108      	bne.n	800923a <PxMessagingTask+0xe66>
												temp32 = (uint32_t)malloc(sizeof(float));								// Create a new one
 8009228:	2004      	movs	r0, #4
 800922a:	f00a ffd5 	bl	80141d8 <malloc>
 800922e:	1e03      	subs	r3, r0, #0
												if (temp32 != 0) {
 8009230:	d01e      	beq.n	8009270 <PxMessagingTask+0xe9c>
													BOS_var_reg[cMessage[port-1][shift]-1] = ((temp32-SRAM_BASE)<<16) + cMessage[port-1][1+shift];
 8009232:	0402      	lsls	r2, r0, #16
 8009234:	49b6      	ldr	r1, [pc, #728]	; (8009510 <PxMessagingTask+0x113c>)
 8009236:	3207      	adds	r2, #7
 8009238:	514a      	str	r2, [r1, r5]
											if (responseStatus != BOS_ERR_REMOTE_WRITE_MEM_FULL) {			// Write remote value
 800923a:	4ab6      	ldr	r2, [pc, #728]	; (8009514 <PxMessagingTask+0x1140>)
 800923c:	7812      	ldrb	r2, [r2, #0]
 800923e:	2a12      	cmp	r2, #18
 8009240:	d100      	bne.n	8009244 <PxMessagingTask+0xe70>
 8009242:	e71d      	b.n	8009080 <PxMessagingTask+0xcac>
												remoteBuffer = ((uint32_t)cMessage[port-1][2+shift]<<0) + ((uint32_t)cMessage[port-1][3+shift]<<8) + ((uint32_t)cMessage[port-1][4+shift]<<16) + ((uint32_t)cMessage[port-1][5+shift]<<24);
 8009244:	2238      	movs	r2, #56	; 0x38
 8009246:	9904      	ldr	r1, [sp, #16]
 8009248:	434a      	muls	r2, r1
 800924a:	49b3      	ldr	r1, [pc, #716]	; (8009518 <PxMessagingTask+0x1144>)
 800924c:	1889      	adds	r1, r1, r2
 800924e:	19c9      	adds	r1, r1, r7
 8009250:	78ca      	ldrb	r2, [r1, #3]
 8009252:	7908      	ldrb	r0, [r1, #4]
 8009254:	0212      	lsls	r2, r2, #8
 8009256:	0400      	lsls	r0, r0, #16
 8009258:	1812      	adds	r2, r2, r0
 800925a:	7888      	ldrb	r0, [r1, #2]
 800925c:	7949      	ldrb	r1, [r1, #5]
 800925e:	1812      	adds	r2, r2, r0
 8009260:	2000      	movs	r0, #0
 8009262:	0609      	lsls	r1, r1, #24
 8009264:	1852      	adds	r2, r2, r1
 8009266:	49ad      	ldr	r1, [pc, #692]	; (800951c <PxMessagingTask+0x1148>)
 8009268:	600a      	str	r2, [r1, #0]
 800926a:	6048      	str	r0, [r1, #4]
												*(float *)temp32 = *(float *)&remoteBuffer;																		
 800926c:	601a      	str	r2, [r3, #0]
 800926e:	e707      	b.n	8009080 <PxMessagingTask+0xcac>
													responseStatus = BOS_ERR_REMOTE_WRITE_MEM_FULL;
 8009270:	2112      	movs	r1, #18
 8009272:	4aa8      	ldr	r2, [pc, #672]	; (8009514 <PxMessagingTask+0x1140>)
 8009274:	7011      	strb	r1, [r2, #0]
 8009276:	e7e0      	b.n	800923a <PxMessagingTask+0xe66>
									responseStatus = BOS_ERR_REMOTE_WRITE_INDEX;		// BOS var index out of range
 8009278:	2313      	movs	r3, #19
									responseStatus = BOS_ERR_REMOTE_WRITE_ADDRESS;
 800927a:	7003      	strb	r3, [r0, #0]
 800927c:	e022      	b.n	80092c4 <PxMessagingTask+0xef0>
								temp32 = ( (uint32_t) cMessage[port-1][2+shift] << 24 ) + ( (uint32_t) cMessage[port-1][3+shift] << 16 ) + ( (uint32_t) cMessage[port-1][4+shift] << 8 ) + cMessage[port-1][5+shift];				
 800927e:	19c9      	adds	r1, r1, r7
 8009280:	788d      	ldrb	r5, [r1, #2]
 8009282:	78cc      	ldrb	r4, [r1, #3]
 8009284:	062d      	lsls	r5, r5, #24
 8009286:	0424      	lsls	r4, r4, #16
 8009288:	192c      	adds	r4, r5, r4
 800928a:	794d      	ldrb	r5, [r1, #5]
 800928c:	1964      	adds	r4, r4, r5
 800928e:	790d      	ldrb	r5, [r1, #4]
 8009290:	022d      	lsls	r5, r5, #8
 8009292:	1964      	adds	r4, r4, r5
								if ( temp32 >= SRAM_BASE && temp32 < (SRAM_BASE+SRAM_SIZE) )			// SRAM
 8009294:	25e0      	movs	r5, #224	; 0xe0
 8009296:	062d      	lsls	r5, r5, #24
 8009298:	46ac      	mov	ip, r5
 800929a:	4da1      	ldr	r5, [pc, #644]	; (8009520 <PxMessagingTask+0x114c>)
 800929c:	44a4      	add	ip, r4
 800929e:	45ac      	cmp	ip, r5
 80092a0:	d866      	bhi.n	8009370 <PxMessagingTask+0xf9c>
									switch (cMessage[port-1][1+shift])															// Requested format
 80092a2:	7848      	ldrb	r0, [r1, #1]
 80092a4:	3801      	subs	r0, #1
 80092a6:	2807      	cmp	r0, #7
 80092a8:	d80c      	bhi.n	80092c4 <PxMessagingTask+0xef0>
 80092aa:	0019      	movs	r1, r3
											remoteBuffer = ((uint32_t)cMessage[port-1][6+shift]<<0) + ((uint32_t)cMessage[port-1][7+shift]<<8) + ((uint32_t)cMessage[port-1][8+shift]<<16) + ((uint32_t)cMessage[port-1][9+shift]<<24);
 80092ac:	9b04      	ldr	r3, [sp, #16]
									switch (cMessage[port-1][1+shift])															// Requested format
 80092ae:	f7f6 ff45 	bl	800013c <__gnu_thumb1_case_uqi>
 80092b2:	1a04      	.short	0x1a04
 80092b4:	42332a20 	.word	0x42332a20
 80092b8:	044c      	.short	0x044c
											*(__IO uint8_t *)temp32 = cMessage[port-1][6+shift]; break;
 80092ba:	4359      	muls	r1, r3
 80092bc:	1851      	adds	r1, r2, r1
 80092be:	19c9      	adds	r1, r1, r7
 80092c0:	798b      	ldrb	r3, [r1, #6]
											*(__IO int8_t *)temp32 = (int8_t)cMessage[port-1][6+shift]; break;
 80092c2:	7023      	strb	r3, [r4, #0]
							if (BOS.response == BOS_RESPONSE_ALL || BOS.response == BOS_RESPONSE_MSG) {
 80092c4:	2240      	movs	r2, #64	; 0x40
 80092c6:	4b97      	ldr	r3, [pc, #604]	; (8009524 <PxMessagingTask+0x1150>)
 80092c8:	2400      	movs	r4, #0
 80092ca:	799b      	ldrb	r3, [r3, #6]
 80092cc:	4393      	bics	r3, r2
 80092ce:	2b20      	cmp	r3, #32
 80092d0:	d001      	beq.n	80092d6 <PxMessagingTask+0xf02>
 80092d2:	f7ff f94e 	bl	8008572 <PxMessagingTask+0x19e>
								messageParams[0] = responseStatus;
 80092d6:	4b8f      	ldr	r3, [pc, #572]	; (8009514 <PxMessagingTask+0x1140>)
								SendMessageToModule(src, CODE_WRITE_REMOTE_RESPONSE, 1);											
 80092d8:	2121      	movs	r1, #33	; 0x21
								messageParams[0] = responseStatus;
 80092da:	781a      	ldrb	r2, [r3, #0]
 80092dc:	4b92      	ldr	r3, [pc, #584]	; (8009528 <PxMessagingTask+0x1154>)
 80092de:	701a      	strb	r2, [r3, #0]
								SendMessageToModule(src, CODE_WRITE_REMOTE_RESPONSE, 1);											
 80092e0:	2201      	movs	r2, #1
 80092e2:	f7ff f9ba 	bl	800865a <PxMessagingTask+0x286>
											*(__IO int8_t *)temp32 = (int8_t)cMessage[port-1][6+shift]; break;
 80092e6:	4359      	muls	r1, r3
 80092e8:	2306      	movs	r3, #6
 80092ea:	1851      	adds	r1, r2, r1
 80092ec:	19c9      	adds	r1, r1, r7
 80092ee:	56cb      	ldrsb	r3, [r1, r3]
 80092f0:	e7e7      	b.n	80092c2 <PxMessagingTask+0xeee>
											*(__IO uint16_t *)temp32 = ((uint16_t)cMessage[port-1][6+shift]<<0) + ((uint16_t)cMessage[port-1][7+shift]<<8);	break;
 80092f2:	4359      	muls	r1, r3
 80092f4:	1851      	adds	r1, r2, r1
 80092f6:	19c9      	adds	r1, r1, r7
 80092f8:	79ca      	ldrb	r2, [r1, #7]
 80092fa:	798b      	ldrb	r3, [r1, #6]
 80092fc:	0212      	lsls	r2, r2, #8
 80092fe:	189b      	adds	r3, r3, r2
 8009300:	b29b      	uxth	r3, r3
											*(__IO int16_t *)temp32 = ((int16_t)cMessage[port-1][6+shift]<<0) + ((int16_t)cMessage[port-1][7+shift]<<8);	break;
 8009302:	8023      	strh	r3, [r4, #0]
 8009304:	e7de      	b.n	80092c4 <PxMessagingTask+0xef0>
 8009306:	4359      	muls	r1, r3
 8009308:	1851      	adds	r1, r2, r1
 800930a:	19c9      	adds	r1, r1, r7
 800930c:	79ca      	ldrb	r2, [r1, #7]
 800930e:	798b      	ldrb	r3, [r1, #6]
 8009310:	0212      	lsls	r2, r2, #8
 8009312:	189b      	adds	r3, r3, r2
 8009314:	b21b      	sxth	r3, r3
 8009316:	e7f4      	b.n	8009302 <PxMessagingTask+0xf2e>
											*(__IO uint32_t *)temp32 = ((uint32_t)cMessage[port-1][6+shift]<<0) + ((uint32_t)cMessage[port-1][7+shift]<<8) + ((uint32_t)cMessage[port-1][8+shift]<<16) + ((uint32_t)cMessage[port-1][9+shift]<<24); break;
 8009318:	4359      	muls	r1, r3
 800931a:	1851      	adds	r1, r2, r1
 800931c:	19c9      	adds	r1, r1, r7
 800931e:	79cb      	ldrb	r3, [r1, #7]
 8009320:	7a0a      	ldrb	r2, [r1, #8]
 8009322:	021b      	lsls	r3, r3, #8
 8009324:	0412      	lsls	r2, r2, #16
 8009326:	189b      	adds	r3, r3, r2
 8009328:	798a      	ldrb	r2, [r1, #6]
											*(__IO int32_t *)temp32 = ((int32_t)cMessage[port-1][6+shift]<<0) + ((int32_t)cMessage[port-1][7+shift]<<8) + ((int32_t)cMessage[port-1][8+shift]<<16) + ((int32_t)cMessage[port-1][9+shift]<<24); break; 									
 800932a:	189b      	adds	r3, r3, r2
 800932c:	7a4a      	ldrb	r2, [r1, #9]
 800932e:	0612      	lsls	r2, r2, #24
 8009330:	189b      	adds	r3, r3, r2
 8009332:	6023      	str	r3, [r4, #0]
 8009334:	e7c6      	b.n	80092c4 <PxMessagingTask+0xef0>
 8009336:	4359      	muls	r1, r3
 8009338:	1851      	adds	r1, r2, r1
 800933a:	19c9      	adds	r1, r1, r7
 800933c:	79cb      	ldrb	r3, [r1, #7]
 800933e:	798a      	ldrb	r2, [r1, #6]
 8009340:	021b      	lsls	r3, r3, #8
 8009342:	189b      	adds	r3, r3, r2
 8009344:	7a0a      	ldrb	r2, [r1, #8]
 8009346:	0412      	lsls	r2, r2, #16
 8009348:	e7ef      	b.n	800932a <PxMessagingTask+0xf56>
											remoteBuffer = ((uint32_t)cMessage[port-1][6+shift]<<0) + ((uint32_t)cMessage[port-1][7+shift]<<8) + ((uint32_t)cMessage[port-1][8+shift]<<16) + ((uint32_t)cMessage[port-1][9+shift]<<24);
 800934a:	434b      	muls	r3, r1
 800934c:	18d1      	adds	r1, r2, r3
 800934e:	19c9      	adds	r1, r1, r7
 8009350:	79cb      	ldrb	r3, [r1, #7]
 8009352:	7a0a      	ldrb	r2, [r1, #8]
 8009354:	021b      	lsls	r3, r3, #8
 8009356:	0412      	lsls	r2, r2, #16
 8009358:	189b      	adds	r3, r3, r2
 800935a:	798a      	ldrb	r2, [r1, #6]
 800935c:	189b      	adds	r3, r3, r2
 800935e:	7a4a      	ldrb	r2, [r1, #9]
 8009360:	2100      	movs	r1, #0
 8009362:	0612      	lsls	r2, r2, #24
 8009364:	189b      	adds	r3, r3, r2
 8009366:	4a6d      	ldr	r2, [pc, #436]	; (800951c <PxMessagingTask+0x1148>)
 8009368:	6013      	str	r3, [r2, #0]
 800936a:	6051      	str	r1, [r2, #4]
											*(float *)temp32 = *(float *)&remoteBuffer;	break;
 800936c:	6023      	str	r3, [r4, #0]
 800936e:	e7a9      	b.n	80092c4 <PxMessagingTask+0xef0>
								else if ( temp32 >= FLASH_BASE && temp32 < (FLASH_BASE+FLASH_SIZE) )			// Flash
 8009370:	23f8      	movs	r3, #248	; 0xf8
 8009372:	4a6e      	ldr	r2, [pc, #440]	; (800952c <PxMessagingTask+0x1158>)
 8009374:	061b      	lsls	r3, r3, #24
 8009376:	18e3      	adds	r3, r4, r3
 8009378:	4293      	cmp	r3, r2
 800937a:	d900      	bls.n	800937e <PxMessagingTask+0xfaa>
 800937c:	e08c      	b.n	8009498 <PxMessagingTask+0x10c4>
									HAL_FLASH_Unlock();
 800937e:	f008 fe17 	bl	8011fb0 <HAL_FLASH_Unlock>
									if (code == CODE_WRITE_REMOTE_FORCE)
 8009382:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009384:	2b22      	cmp	r3, #34	; 0x22
 8009386:	d111      	bne.n	80093ac <PxMessagingTask+0xfd8>
										erase.TypeErase = FLASH_TYPEERASE_PAGES;
 8009388:	9b08      	ldr	r3, [sp, #32]
										status = HAL_FLASHEx_Erase(&erase, &eraseError);
 800938a:	a914      	add	r1, sp, #80	; 0x50
										erase.TypeErase = FLASH_TYPEERASE_PAGES;
 800938c:	9315      	str	r3, [sp, #84]	; 0x54
										erase.NbPages = 1;
 800938e:	2301      	movs	r3, #1
										status = HAL_FLASHEx_Erase(&erase, &eraseError);
 8009390:	a815      	add	r0, sp, #84	; 0x54
										erase.PageAddress = temp32;
 8009392:	9416      	str	r4, [sp, #88]	; 0x58
										erase.NbPages = 1;
 8009394:	9317      	str	r3, [sp, #92]	; 0x5c
										status = HAL_FLASHEx_Erase(&erase, &eraseError);
 8009396:	f008 feb7 	bl	8012108 <HAL_FLASHEx_Erase>
 800939a:	900a      	str	r0, [sp, #40]	; 0x28
										if (status != HAL_OK || eraseError != 0xFFFFFFFF) responseStatus = BOS_ERR_REMOTE_WRITE_FLASH;							
 800939c:	2800      	cmp	r0, #0
 800939e:	d102      	bne.n	80093a6 <PxMessagingTask+0xfd2>
 80093a0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80093a2:	3301      	adds	r3, #1
 80093a4:	d002      	beq.n	80093ac <PxMessagingTask+0xfd8>
 80093a6:	2216      	movs	r2, #22
 80093a8:	4b5a      	ldr	r3, [pc, #360]	; (8009514 <PxMessagingTask+0x1140>)
 80093aa:	701a      	strb	r2, [r3, #0]
									if (responseStatus == BOS_OK)
 80093ac:	4b59      	ldr	r3, [pc, #356]	; (8009514 <PxMessagingTask+0x1140>)
 80093ae:	781b      	ldrb	r3, [r3, #0]
 80093b0:	2b00      	cmp	r3, #0
 80093b2:	d116      	bne.n	80093e2 <PxMessagingTask+0x100e>
										switch (cMessage[port-1][1+shift])															// Requested format
 80093b4:	2238      	movs	r2, #56	; 0x38
 80093b6:	9b04      	ldr	r3, [sp, #16]
 80093b8:	435a      	muls	r2, r3
 80093ba:	4b57      	ldr	r3, [pc, #348]	; (8009518 <PxMessagingTask+0x1144>)
 80093bc:	189b      	adds	r3, r3, r2
 80093be:	19db      	adds	r3, r3, r7
 80093c0:	7858      	ldrb	r0, [r3, #1]
 80093c2:	3801      	subs	r0, #1
 80093c4:	2807      	cmp	r0, #7
 80093c6:	d80c      	bhi.n	80093e2 <PxMessagingTask+0x100e>
 80093c8:	f7f6 feb8 	bl	800013c <__gnu_thumb1_case_uqi>
 80093cc:	24240404 	.word	0x24240404
 80093d0:	044d3434 	.word	0x044d3434
												if (*(__IO uint16_t *)temp32 != 0xFFFF) {
 80093d4:	8822      	ldrh	r2, [r4, #0]
 80093d6:	4b56      	ldr	r3, [pc, #344]	; (8009530 <PxMessagingTask+0x115c>)
 80093d8:	429a      	cmp	r2, r3
 80093da:	d00b      	beq.n	80093f4 <PxMessagingTask+0x1020>
													responseStatus = BOS_ERR_REMOTE_WRITE_FLASH; break;
 80093dc:	2216      	movs	r2, #22
 80093de:	4b4d      	ldr	r3, [pc, #308]	; (8009514 <PxMessagingTask+0x1140>)
 80093e0:	701a      	strb	r2, [r3, #0]
									HAL_FLASH_Lock();
 80093e2:	f008 fdf7 	bl	8011fd4 <HAL_FLASH_Lock>
									if (status != HAL_OK)	responseStatus = BOS_ERR_REMOTE_WRITE_FLASH;
 80093e6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80093e8:	2b00      	cmp	r3, #0
 80093ea:	d100      	bne.n	80093ee <PxMessagingTask+0x101a>
 80093ec:	e76a      	b.n	80092c4 <PxMessagingTask+0xef0>
 80093ee:	4b49      	ldr	r3, [pc, #292]	; (8009514 <PxMessagingTask+0x1140>)
 80093f0:	2216      	movs	r2, #22
 80093f2:	e65c      	b.n	80090ae <PxMessagingTask+0xcda>
													remoteBuffer = cMessage[port-1][6+shift]; status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, temp32, remoteBuffer); break;
 80093f4:	2538      	movs	r5, #56	; 0x38
 80093f6:	9b04      	ldr	r3, [sp, #16]
 80093f8:	4947      	ldr	r1, [pc, #284]	; (8009518 <PxMessagingTask+0x1144>)
 80093fa:	435d      	muls	r5, r3
 80093fc:	2300      	movs	r3, #0
 80093fe:	1949      	adds	r1, r1, r5
 8009400:	19c9      	adds	r1, r1, r7
 8009402:	798a      	ldrb	r2, [r1, #6]
													remoteBuffer = ((uint16_t)cMessage[port-1][6+shift]<<0) + ((uint16_t)cMessage[port-1][7+shift]<<8);
 8009404:	4945      	ldr	r1, [pc, #276]	; (800951c <PxMessagingTask+0x1148>)
													status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, temp32, remoteBuffer); break;
 8009406:	2001      	movs	r0, #1
													remoteBuffer = ((uint16_t)cMessage[port-1][6+shift]<<0) + ((uint16_t)cMessage[port-1][7+shift]<<8);
 8009408:	c10c      	stmia	r1!, {r2, r3}
													status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, temp32, remoteBuffer); break;
 800940a:	0021      	movs	r1, r4
													status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, temp32, remoteBuffer); break;
 800940c:	f008 fe16 	bl	801203c <HAL_FLASH_Program>
 8009410:	900a      	str	r0, [sp, #40]	; 0x28
 8009412:	e7e6      	b.n	80093e2 <PxMessagingTask+0x100e>
												if (*(__IO uint16_t *)temp32 != 0xFFFF) {
 8009414:	8822      	ldrh	r2, [r4, #0]
 8009416:	4b46      	ldr	r3, [pc, #280]	; (8009530 <PxMessagingTask+0x115c>)
 8009418:	429a      	cmp	r2, r3
 800941a:	d1df      	bne.n	80093dc <PxMessagingTask+0x1008>
													remoteBuffer = ((uint16_t)cMessage[port-1][6+shift]<<0) + ((uint16_t)cMessage[port-1][7+shift]<<8);
 800941c:	2538      	movs	r5, #56	; 0x38
 800941e:	9b04      	ldr	r3, [sp, #16]
 8009420:	493d      	ldr	r1, [pc, #244]	; (8009518 <PxMessagingTask+0x1144>)
 8009422:	435d      	muls	r5, r3
 8009424:	1949      	adds	r1, r1, r5
 8009426:	19c9      	adds	r1, r1, r7
 8009428:	79ca      	ldrb	r2, [r1, #7]
 800942a:	798b      	ldrb	r3, [r1, #6]
 800942c:	0212      	lsls	r2, r2, #8
 800942e:	18d2      	adds	r2, r2, r3
 8009430:	17d3      	asrs	r3, r2, #31
 8009432:	e7e7      	b.n	8009404 <PxMessagingTask+0x1030>
												if (*(__IO uint32_t *)temp32 != 0xFFFFFFFF) {
 8009434:	6823      	ldr	r3, [r4, #0]
 8009436:	3301      	adds	r3, #1
 8009438:	d1d0      	bne.n	80093dc <PxMessagingTask+0x1008>
													remoteBuffer = ((uint32_t)cMessage[port-1][6+shift]<<0) + ((uint32_t)cMessage[port-1][7+shift]<<8) + ((uint32_t)cMessage[port-1][8+shift]<<16) + ((uint32_t)cMessage[port-1][9+shift]<<24); 
 800943a:	2538      	movs	r5, #56	; 0x38
 800943c:	9b04      	ldr	r3, [sp, #16]
 800943e:	4936      	ldr	r1, [pc, #216]	; (8009518 <PxMessagingTask+0x1144>)
 8009440:	435d      	muls	r5, r3
 8009442:	1949      	adds	r1, r1, r5
 8009444:	19c9      	adds	r1, r1, r7
 8009446:	79ca      	ldrb	r2, [r1, #7]
 8009448:	7a0b      	ldrb	r3, [r1, #8]
 800944a:	0212      	lsls	r2, r2, #8
 800944c:	041b      	lsls	r3, r3, #16
 800944e:	18d2      	adds	r2, r2, r3
 8009450:	798b      	ldrb	r3, [r1, #6]
													status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, temp32, remoteBuffer); break;
 8009452:	2002      	movs	r0, #2
													remoteBuffer = ((uint32_t)cMessage[port-1][6+shift]<<0) + ((uint32_t)cMessage[port-1][7+shift]<<8) + ((uint32_t)cMessage[port-1][8+shift]<<16) + ((uint32_t)cMessage[port-1][9+shift]<<24); 
 8009454:	18d2      	adds	r2, r2, r3
 8009456:	7a4b      	ldrb	r3, [r1, #9]
 8009458:	4930      	ldr	r1, [pc, #192]	; (800951c <PxMessagingTask+0x1148>)
 800945a:	061b      	lsls	r3, r3, #24
 800945c:	18d2      	adds	r2, r2, r3
 800945e:	2300      	movs	r3, #0
 8009460:	c10c      	stmia	r1!, {r2, r3}
													status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, temp32, remoteBuffer); break;
 8009462:	0021      	movs	r1, r4
 8009464:	e7d2      	b.n	800940c <PxMessagingTask+0x1038>
												if (*(__IO uint32_t *)temp32 != 0xFFFFFFFF) {
 8009466:	6823      	ldr	r3, [r4, #0]
 8009468:	3301      	adds	r3, #1
 800946a:	d1b7      	bne.n	80093dc <PxMessagingTask+0x1008>
													remoteBuffer = ((uint32_t)cMessage[port-1][6+shift]<<0) + ((uint32_t)cMessage[port-1][7+shift]<<8) + ((uint32_t)cMessage[port-1][8+shift]<<16) + ((uint32_t)cMessage[port-1][9+shift]<<24);
 800946c:	2538      	movs	r5, #56	; 0x38
 800946e:	9b04      	ldr	r3, [sp, #16]
 8009470:	4929      	ldr	r1, [pc, #164]	; (8009518 <PxMessagingTask+0x1144>)
 8009472:	435d      	muls	r5, r3
 8009474:	1949      	adds	r1, r1, r5
 8009476:	19c9      	adds	r1, r1, r7
 8009478:	79ca      	ldrb	r2, [r1, #7]
 800947a:	7a0b      	ldrb	r3, [r1, #8]
 800947c:	0212      	lsls	r2, r2, #8
 800947e:	041b      	lsls	r3, r3, #16
 8009480:	18d2      	adds	r2, r2, r3
 8009482:	798b      	ldrb	r3, [r1, #6]
													status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, temp32, remoteBuffer); break;
 8009484:	2003      	movs	r0, #3
													remoteBuffer = ((uint32_t)cMessage[port-1][6+shift]<<0) + ((uint32_t)cMessage[port-1][7+shift]<<8) + ((uint32_t)cMessage[port-1][8+shift]<<16) + ((uint32_t)cMessage[port-1][9+shift]<<24);
 8009486:	18d2      	adds	r2, r2, r3
 8009488:	7a4b      	ldrb	r3, [r1, #9]
 800948a:	4924      	ldr	r1, [pc, #144]	; (800951c <PxMessagingTask+0x1148>)
 800948c:	061b      	lsls	r3, r3, #24
 800948e:	18d2      	adds	r2, r2, r3
 8009490:	2300      	movs	r3, #0
 8009492:	c10c      	stmia	r1!, {r2, r3}
													status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, temp32, remoteBuffer); break;
 8009494:	0021      	movs	r1, r4
 8009496:	e7b9      	b.n	800940c <PxMessagingTask+0x1038>
									responseStatus = BOS_ERR_REMOTE_WRITE_ADDRESS;
 8009498:	2315      	movs	r3, #21
 800949a:	e6ee      	b.n	800927a <PxMessagingTask+0xea6>
							responseStatus = (BOS_Status) cMessage[port-1][shift];
 800949c:	2238      	movs	r2, #56	; 0x38
 800949e:	9b04      	ldr	r3, [sp, #16]
 80094a0:	435a      	muls	r2, r3
 80094a2:	4b1d      	ldr	r3, [pc, #116]	; (8009518 <PxMessagingTask+0x1144>)
 80094a4:	189b      	adds	r3, r3, r2
 80094a6:	5dda      	ldrb	r2, [r3, r7]
 80094a8:	4b1a      	ldr	r3, [pc, #104]	; (8009514 <PxMessagingTask+0x1140>)
 80094aa:	f7ff fa77 	bl	800899c <PxMessagingTask+0x5c8>
							writePxMutex(cMessage[port-1][shift], (char *)&cMessage[port-1][shift+1], numOfParams-1, 10, 10);
 80094ae:	2038      	movs	r0, #56	; 0x38
 80094b0:	9c04      	ldr	r4, [sp, #16]
 80094b2:	9b07      	ldr	r3, [sp, #28]
 80094b4:	4360      	muls	r0, r4
 80094b6:	1c79      	adds	r1, r7, #1
 80094b8:	18c9      	adds	r1, r1, r3
 80094ba:	4b17      	ldr	r3, [pc, #92]	; (8009518 <PxMessagingTask+0x1144>)
 80094bc:	3d01      	subs	r5, #1
 80094be:	18c9      	adds	r1, r1, r3
 80094c0:	181b      	adds	r3, r3, r0
 80094c2:	5dd8      	ldrb	r0, [r3, r7]
 80094c4:	230a      	movs	r3, #10
 80094c6:	b2aa      	uxth	r2, r5
 80094c8:	9300      	str	r3, [sp, #0]
 80094ca:	f003 ffa5 	bl	800d418 <writePxMutex>
 80094ce:	f7ff f8f4 	bl	80086ba <PxMessagingTask+0x2e6>
							result = (BOS_Status) User_MessagingParser(code, port, src, dst, shift);			
 80094d2:	9700      	str	r7, [sp, #0]
 80094d4:	9b08      	ldr	r3, [sp, #32]
 80094d6:	0032      	movs	r2, r6
 80094d8:	9906      	ldr	r1, [sp, #24]
 80094da:	9809      	ldr	r0, [sp, #36]	; 0x24
 80094dc:	f7fe ff78 	bl	80083d0 <User_MessagingParser>
 80094e0:	0004      	movs	r4, r0
							if (result == BOS_ERR_UnknownMessage) {
 80094e2:	2801      	cmp	r0, #1
 80094e4:	d001      	beq.n	80094ea <PxMessagingTask+0x1116>
 80094e6:	f7ff f844 	bl	8008572 <PxMessagingTask+0x19e>
								result = (BOS_Status) Module_MessagingTask(code, port, src, dst, shift);
 80094ea:	9700      	str	r7, [sp, #0]
 80094ec:	9b08      	ldr	r3, [sp, #32]
 80094ee:	0032      	movs	r2, r6
 80094f0:	9906      	ldr	r1, [sp, #24]
 80094f2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80094f4:	f000 fa2c 	bl	8009950 <Module_MessagingTask>
 80094f8:	0004      	movs	r4, r0
		if (result == BOS_ERR_UnknownMessage) {
 80094fa:	2801      	cmp	r0, #1
 80094fc:	d001      	beq.n	8009502 <PxMessagingTask+0x112e>
 80094fe:	f7ff f838 	bl	8008572 <PxMessagingTask+0x19e>
			SendMessageToModule(src, CODE_UNKNOWN_MESSAGE, 0);
 8009502:	2200      	movs	r2, #0
 8009504:	0011      	movs	r1, r2
 8009506:	f7ff f96d 	bl	80087e4 <PxMessagingTask+0x410>
					result = BOS_ERR_MSG_Reflection;
 800950a:	2403      	movs	r4, #3
 800950c:	f7ff f831 	bl	8008572 <PxMessagingTask+0x19e>
 8009510:	20006ef8 	.word	0x20006ef8
 8009514:	200010c8 	.word	0x200010c8
 8009518:	20000d13 	.word	0x20000d13
 800951c:	200010c0 	.word	0x200010c0
 8009520:	00007fff 	.word	0x00007fff
 8009524:	20006f70 	.word	0x20006f70
 8009528:	20000f07 	.word	0x20000f07
 800952c:	0001ffff 	.word	0x0001ffff
 8009530:	0000ffff 	.word	0x0000ffff

08009534 <demoCommand>:
	|															Commands																 	|
   ----------------------------------------------------------------------- 
*/

portBASE_TYPE demoCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
 8009534:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009536:	0006      	movs	r6, r0
 8009538:	b087      	sub	sp, #28
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) pcCommandString;
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 800953a:	2800      	cmp	r0, #0
 800953c:	d101      	bne.n	8009542 <demoCommand+0xe>
 800953e:	b672      	cpsid	i
 8009540:	e7fe      	b.n	8009540 <demoCommand+0xc>

	/* Create a file */
	res = f_open(&tempFile, "TestFile", FA_CREATE_ALWAYS | FA_WRITE | FA_READ);
 8009542:	4c25      	ldr	r4, [pc, #148]	; (80095d8 <demoCommand+0xa4>)
 8009544:	220b      	movs	r2, #11
 8009546:	4925      	ldr	r1, [pc, #148]	; (80095dc <demoCommand+0xa8>)
 8009548:	0020      	movs	r0, r4
 800954a:	f005 fc07 	bl	800ed5c <f_open>
	if (res != FR_OK) {
 800954e:	2800      	cmp	r0, #0
 8009550:	d006      	beq.n	8009560 <demoCommand+0x2c>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcFileMessage);		
 8009552:	4923      	ldr	r1, [pc, #140]	; (80095e0 <demoCommand+0xac>)
	res = f_unlink("TestFile");
	if (res != FR_OK) {
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcFileMessage);		
		return pdFALSE;
	}	
	strcpy( ( char * ) pcWriteBuffer, ( char * ) pcDeleteMessage);
 8009554:	0030      	movs	r0, r6
 8009556:	f00b fabd 	bl	8014ad4 <strcpy>
	
	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
 800955a:	2000      	movs	r0, #0
 800955c:	b007      	add	sp, #28
 800955e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	writePxMutex(PcPort, ( char * ) pcOpenMessage, strlen(( char * ) pcOpenMessage), 10, 10);
 8009560:	250a      	movs	r5, #10
 8009562:	4b20      	ldr	r3, [pc, #128]	; (80095e4 <demoCommand+0xb0>)
 8009564:	2213      	movs	r2, #19
 8009566:	7818      	ldrb	r0, [r3, #0]
 8009568:	491f      	ldr	r1, [pc, #124]	; (80095e8 <demoCommand+0xb4>)
 800956a:	002b      	movs	r3, r5
 800956c:	9500      	str	r5, [sp, #0]
 800956e:	f003 ff53 	bl	800d418 <writePxMutex>
	res = f_write(&tempFile, "HEXABITZ", 8, (void *)&byteswritten);
 8009572:	4b1e      	ldr	r3, [pc, #120]	; (80095ec <demoCommand+0xb8>)
 8009574:	2208      	movs	r2, #8
 8009576:	491e      	ldr	r1, [pc, #120]	; (80095f0 <demoCommand+0xbc>)
 8009578:	0020      	movs	r0, r4
 800957a:	f005 fdaa 	bl	800f0d2 <f_write>
 800957e:	1e07      	subs	r7, r0, #0
	if (res != FR_OK) {
 8009580:	d1e7      	bne.n	8009552 <demoCommand+0x1e>
	char tempStr[10] = {0};
 8009582:	002a      	movs	r2, r5
 8009584:	0001      	movs	r1, r0
 8009586:	a803      	add	r0, sp, #12
 8009588:	f00b f86d 	bl	8014666 <memset>
	res = f_lseek(&tempFile, 0);
 800958c:	0039      	movs	r1, r7
 800958e:	0020      	movs	r0, r4
 8009590:	f005 fec9 	bl	800f326 <f_lseek>
	res = f_read(&tempFile, tempStr, 8, (void *)&byteswritten);
 8009594:	4b15      	ldr	r3, [pc, #84]	; (80095ec <demoCommand+0xb8>)
 8009596:	2208      	movs	r2, #8
 8009598:	a903      	add	r1, sp, #12
 800959a:	0020      	movs	r0, r4
 800959c:	f005 fcea 	bl	800ef74 <f_read>
	if (res != FR_OK || strncmp(tempStr, "HEXABITZ", 8) != 0) {
 80095a0:	2800      	cmp	r0, #0
 80095a2:	d1d6      	bne.n	8009552 <demoCommand+0x1e>
 80095a4:	2208      	movs	r2, #8
 80095a6:	4912      	ldr	r1, [pc, #72]	; (80095f0 <demoCommand+0xbc>)
 80095a8:	a803      	add	r0, sp, #12
 80095aa:	f00b fa9b 	bl	8014ae4 <strncmp>
 80095ae:	2800      	cmp	r0, #0
 80095b0:	d1cf      	bne.n	8009552 <demoCommand+0x1e>
	writePxMutex(PcPort, ( char * ) pcVerifyMessage, strlen(( char * ) pcVerifyMessage), 10, 10);
 80095b2:	4b0c      	ldr	r3, [pc, #48]	; (80095e4 <demoCommand+0xb0>)
 80095b4:	2220      	movs	r2, #32
 80095b6:	7818      	ldrb	r0, [r3, #0]
 80095b8:	490e      	ldr	r1, [pc, #56]	; (80095f4 <demoCommand+0xc0>)
 80095ba:	002b      	movs	r3, r5
 80095bc:	9500      	str	r5, [sp, #0]
 80095be:	f003 ff2b 	bl	800d418 <writePxMutex>
	res = f_close(&tempFile);
 80095c2:	0020      	movs	r0, r4
 80095c4:	f005 fe97 	bl	800f2f6 <f_close>
	res = f_unlink("TestFile");
 80095c8:	4804      	ldr	r0, [pc, #16]	; (80095dc <demoCommand+0xa8>)
 80095ca:	f005 ffb4 	bl	800f536 <f_unlink>
	if (res != FR_OK) {
 80095ce:	2800      	cmp	r0, #0
 80095d0:	d1bf      	bne.n	8009552 <demoCommand+0x1e>
	strcpy( ( char * ) pcWriteBuffer, ( char * ) pcDeleteMessage);
 80095d2:	4909      	ldr	r1, [pc, #36]	; (80095f8 <demoCommand+0xc4>)
 80095d4:	e7be      	b.n	8009554 <demoCommand+0x20>
 80095d6:	46c0      	nop			; (mov r8, r8)
 80095d8:	200078f4 	.word	0x200078f4
 80095dc:	0801b7cc 	.word	0x0801b7cc
 80095e0:	0801b7d5 	.word	0x0801b7d5
 80095e4:	20000a9f 	.word	0x20000a9f
 80095e8:	0801b7e6 	.word	0x0801b7e6
 80095ec:	2000714c 	.word	0x2000714c
 80095f0:	0801b7fa 	.word	0x0801b7fa
 80095f4:	0801b803 	.word	0x0801b803
 80095f8:	0801b824 	.word	0x0801b824

080095fc <deleteLogCommand>:
}

/*-----------------------------------------------------------*/

portBASE_TYPE deleteLogCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
 80095fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	Module_Status result = H1BR6_OK;
	
	int8_t *pcParameterString1, *pcParameterString2; 
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0; 
 80095fe:	2500      	movs	r5, #0
{
 8009600:	0004      	movs	r4, r0
 8009602:	0016      	movs	r6, r2
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0; 
 8009604:	9500      	str	r5, [sp, #0]
 8009606:	9501      	str	r5, [sp, #4]
	
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 8009608:	42a8      	cmp	r0, r5
 800960a:	d101      	bne.n	8009610 <deleteLogCommand+0x14>
 800960c:	b672      	cpsid	i
 800960e:	e7fe      	b.n	800960e <deleteLogCommand+0x12>
	
	/* Obtain the 1st parameter string: log name */
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 8009610:	466a      	mov	r2, sp
 8009612:	2101      	movs	r1, #1
 8009614:	0030      	movs	r0, r6
 8009616:	f006 f9a1 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800961a:	0007      	movs	r7, r0
	/* Obtain the 2nd parameter string: delete options */
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800961c:	aa01      	add	r2, sp, #4
 800961e:	2102      	movs	r1, #2
 8009620:	0030      	movs	r0, r6
 8009622:	f006 f99b 	bl	800f95c <FreeRTOS_CLIGetParameter>
	
	/* log name */
	pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 8009626:	9b00      	ldr	r3, [sp, #0]
	
	/* type */
	if (!strncmp((const char *)pcParameterString2, "all", xParameterStringLength2))
 8009628:	490b      	ldr	r1, [pc, #44]	; (8009658 <deleteLogCommand+0x5c>)
	pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 800962a:	54fd      	strb	r5, [r7, r3]
	if (!strncmp((const char *)pcParameterString2, "all", xParameterStringLength2))
 800962c:	9d01      	ldr	r5, [sp, #4]
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800962e:	0006      	movs	r6, r0
	if (!strncmp((const char *)pcParameterString2, "all", xParameterStringLength2))
 8009630:	002a      	movs	r2, r5
 8009632:	f00b fa57 	bl	8014ae4 <strncmp>
		result = DeleteLog((char *)pcParameterString1, options);	
	}
	
	/* Respond to the command */
	if (result == H1BR6_OK && options == DELETE_ALL) {
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage1);
 8009636:	4909      	ldr	r1, [pc, #36]	; (800965c <deleteLogCommand+0x60>)
	if (!strncmp((const char *)pcParameterString2, "all", xParameterStringLength2))
 8009638:	2800      	cmp	r0, #0
 800963a:	d008      	beq.n	800964e <deleteLogCommand+0x52>
	else if (!strncmp((const char *)pcParameterString2, "keepdisk", xParameterStringLength2))
 800963c:	4908      	ldr	r1, [pc, #32]	; (8009660 <deleteLogCommand+0x64>)
 800963e:	002a      	movs	r2, r5
 8009640:	0030      	movs	r0, r6
 8009642:	f00b fa4f 	bl	8014ae4 <strncmp>
	} else if (result == H1BR6_OK && options == KEEP_ON_DISK) {
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage2);
 8009646:	4907      	ldr	r1, [pc, #28]	; (8009664 <deleteLogCommand+0x68>)
	else if (!strncmp((const char *)pcParameterString2, "keepdisk", xParameterStringLength2))
 8009648:	2800      	cmp	r0, #0
 800964a:	d000      	beq.n	800964e <deleteLogCommand+0x52>
	} else if (result == H1BR6_ERR_WrongParams) {
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcWrongValue);
 800964c:	4906      	ldr	r1, [pc, #24]	; (8009668 <deleteLogCommand+0x6c>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage2);
 800964e:	0020      	movs	r0, r4
 8009650:	f00b fa40 	bl	8014ad4 <strcpy>
	} 
	
	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
 8009654:	2000      	movs	r0, #0
 8009656:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8009658:	080192de 	.word	0x080192de
 800965c:	0801b735 	.word	0x0801b735
 8009660:	0801b72c 	.word	0x0801b72c
 8009664:	0801b78d 	.word	0x0801b78d
 8009668:	0801b765 	.word	0x0801b765

0800966c <pauseCommand.part.6>:
	return pdFALSE;
}

/*-----------------------------------------------------------*/

portBASE_TYPE startCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
 800966c:	b510      	push	{r4, lr}
	
	/* Respond to the command */
	if (result == H1BR6_OK) {
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage, pcParameterString1);
	} else if (result ==  H1BR6_ERR_LogDoesNotExist) {
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcLogDoesNotExist);
 800966e:	4902      	ldr	r1, [pc, #8]	; (8009678 <pauseCommand.part.6+0xc>)
 8009670:	f00b fa30 	bl	8014ad4 <strcpy>
	} 
	
	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
 8009674:	bd10      	pop	{r4, pc}
 8009676:	46c0      	nop			; (mov r8, r8)
 8009678:	0801b94c 	.word	0x0801b94c

0800967c <SystemClock_Config>:
	RCC_OscInitStruct.HSICalibrationValue =16;
 800967c:	2310      	movs	r3, #16
{
 800967e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009680:	b09b      	sub	sp, #108	; 0x6c
	RCC_OscInitStruct.HSICalibrationValue =16;
 8009682:	9311      	str	r3, [sp, #68]	; 0x44
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8009684:	2780      	movs	r7, #128	; 0x80
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 8009686:	2380      	movs	r3, #128	; 0x80
	RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 8009688:	2400      	movs	r4, #0
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800968a:	2501      	movs	r5, #1
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800968c:	2602      	movs	r6, #2
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800968e:	027f      	lsls	r7, r7, #9
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 8009690:	035b      	lsls	r3, r3, #13
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8009692:	a80d      	add	r0, sp, #52	; 0x34
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8009694:	950d      	str	r5, [sp, #52]	; 0x34
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8009696:	950e      	str	r5, [sp, #56]	; 0x38
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8009698:	9510      	str	r5, [sp, #64]	; 0x40
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800969a:	9616      	str	r6, [sp, #88]	; 0x58
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 800969c:	9318      	str	r3, [sp, #96]	; 0x60
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800969e:	9717      	str	r7, [sp, #92]	; 0x5c
	RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 80096a0:	9419      	str	r4, [sp, #100]	; 0x64
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80096a2:	f008 fe53 	bl	801234c <HAL_RCC_OscConfig>
	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1);
 80096a6:	2307      	movs	r3, #7
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct,FLASH_LATENCY_1);
 80096a8:	0029      	movs	r1, r5
 80096aa:	a802      	add	r0, sp, #8
	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1);
 80096ac:	9302      	str	r3, [sp, #8]
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80096ae:	9603      	str	r6, [sp, #12]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80096b0:	9404      	str	r4, [sp, #16]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80096b2:	9405      	str	r4, [sp, #20]
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct,FLASH_LATENCY_1);
 80096b4:	f009 f88a 	bl	80127cc <HAL_RCC_ClockConfig>
	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3;
 80096b8:	4b1a      	ldr	r3, [pc, #104]	; (8009724 <SystemClock_Config+0xa8>)
	HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 80096ba:	a806      	add	r0, sp, #24
	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3;
 80096bc:	9306      	str	r3, [sp, #24]
	PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
 80096be:	9408      	str	r4, [sp, #32]
	PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 80096c0:	9409      	str	r4, [sp, #36]	; 0x24
	PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
 80096c2:	940a      	str	r4, [sp, #40]	; 0x28
	HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 80096c4:	f009 f9ea 	bl	8012a9c <HAL_RCCEx_PeriphCLKConfig>
	__HAL_RCC_PWR_CLK_ENABLE();
 80096c8:	2180      	movs	r1, #128	; 0x80
 80096ca:	4e17      	ldr	r6, [pc, #92]	; (8009728 <SystemClock_Config+0xac>)
 80096cc:	0549      	lsls	r1, r1, #21
 80096ce:	69f2      	ldr	r2, [r6, #28]
 80096d0:	430a      	orrs	r2, r1
 80096d2:	61f2      	str	r2, [r6, #28]
 80096d4:	69f3      	ldr	r3, [r6, #28]
 80096d6:	400b      	ands	r3, r1
 80096d8:	9300      	str	r3, [sp, #0]
 80096da:	9b00      	ldr	r3, [sp, #0]
	HAL_PWR_EnableBkUpAccess();
 80096dc:	f008 fe2c 	bl	8012338 <HAL_PWR_EnableBkUpAccess>
	PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_HSE_DIV32;
 80096e0:	23c0      	movs	r3, #192	; 0xc0
	HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 80096e2:	a806      	add	r0, sp, #24
	PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_HSE_DIV32;
 80096e4:	009b      	lsls	r3, r3, #2
 80096e6:	9307      	str	r3, [sp, #28]
	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 80096e8:	9706      	str	r7, [sp, #24]
	HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 80096ea:	f009 f9d7 	bl	8012a9c <HAL_RCCEx_PeriphCLKConfig>
	HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
 80096ee:	f009 f9b1 	bl	8012a54 <HAL_RCC_GetHCLKFreq>
 80096f2:	21fa      	movs	r1, #250	; 0xfa
 80096f4:	0089      	lsls	r1, r1, #2
 80096f6:	f7f6 fd3f 	bl	8000178 <__udivsi3>
 80096fa:	f007 ff5f 	bl	80115bc <HAL_SYSTICK_Config>
	HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80096fe:	2004      	movs	r0, #4
 8009700:	f007 ff76 	bl	80115f0 <HAL_SYSTICK_CLKSourceConfig>
	HAL_NVIC_SetPriority(SysTick_IRQn,0,0);
 8009704:	2001      	movs	r0, #1
	__SYSCFG_CLK_ENABLE()
 8009706:	69b3      	ldr	r3, [r6, #24]
	HAL_NVIC_SetPriority(SysTick_IRQn,0,0);
 8009708:	0022      	movs	r2, r4
	__SYSCFG_CLK_ENABLE()
 800970a:	432b      	orrs	r3, r5
 800970c:	61b3      	str	r3, [r6, #24]
 800970e:	69b3      	ldr	r3, [r6, #24]
	HAL_NVIC_SetPriority(SysTick_IRQn,0,0);
 8009710:	0021      	movs	r1, r4
	__SYSCFG_CLK_ENABLE()
 8009712:	401d      	ands	r5, r3
 8009714:	9501      	str	r5, [sp, #4]
	HAL_NVIC_SetPriority(SysTick_IRQn,0,0);
 8009716:	4240      	negs	r0, r0
	__SYSCFG_CLK_ENABLE()
 8009718:	9b01      	ldr	r3, [sp, #4]
	HAL_NVIC_SetPriority(SysTick_IRQn,0,0);
 800971a:	f007 ff11 	bl	8011540 <HAL_NVIC_SetPriority>
}
 800971e:	b01b      	add	sp, #108	; 0x6c
 8009720:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009722:	46c0      	nop			; (mov r8, r8)
 8009724:	00040003 	.word	0x00040003
 8009728:	40021000 	.word	0x40021000

0800972c <SaveToRO>:
{
 800972c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800972e:	b089      	sub	sp, #36	; 0x24
	uint8_t snipBuffer[sizeof(snippet_t)+1] = {0};
 8009730:	2215      	movs	r2, #21
 8009732:	2100      	movs	r1, #0
 8009734:	a802      	add	r0, sp, #8
 8009736:	f00a ff96 	bl	8014666 <memset>
	HAL_FLASH_Unlock();
 800973a:	f008 fc39 	bl	8011fb0 <HAL_FLASH_Unlock>
	FLASH_PageErase(RO_START_ADDRESS);
 800973e:	4858      	ldr	r0, [pc, #352]	; (80098a0 <SaveToRO+0x174>)
 8009740:	f008 fcd0 	bl	80120e4 <FLASH_PageErase>
	FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8009744:	4857      	ldr	r0, [pc, #348]	; (80098a4 <SaveToRO+0x178>)
 8009746:	f008 fc4f 	bl	8011fe8 <FLASH_WaitForLastOperation>
 800974a:	1e03      	subs	r3, r0, #0
	if(FlashStatus != HAL_OK) {
 800974c:	d004      	beq.n	8009758 <SaveToRO+0x2c>
					return pFlash.ErrorCode;
 800974e:	4b56      	ldr	r3, [pc, #344]	; (80098a8 <SaveToRO+0x17c>)
 8009750:	69d8      	ldr	r0, [r3, #28]
 8009752:	b2c0      	uxtb	r0, r0
}
 8009754:	b009      	add	sp, #36	; 0x24
 8009756:	bdf0      	pop	{r4, r5, r6, r7, pc}
		CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8009758:	2602      	movs	r6, #2
 800975a:	4c54      	ldr	r4, [pc, #336]	; (80098ac <SaveToRO+0x180>)
 800975c:	6922      	ldr	r2, [r4, #16]
 800975e:	43b2      	bics	r2, r6
 8009760:	6122      	str	r2, [r4, #16]
	if (myID)
 8009762:	4a53      	ldr	r2, [pc, #332]	; (80098b0 <SaveToRO+0x184>)
 8009764:	7811      	ldrb	r1, [r2, #0]
 8009766:	2900      	cmp	r1, #0
 8009768:	d109      	bne.n	800977e <SaveToRO+0x52>
			for(uint8_t j=0 ; j<((strlen(snippets[s].cmd)+1)/2) ; j++)
 800976a:	2700      	movs	r7, #0
 800976c:	4d51      	ldr	r5, [pc, #324]	; (80098b4 <SaveToRO+0x188>)
	for(uint8_t s=0 ; s<numOfRecordedSnippets ; s++) 
 800976e:	4b52      	ldr	r3, [pc, #328]	; (80098b8 <SaveToRO+0x18c>)
 8009770:	781b      	ldrb	r3, [r3, #0]
 8009772:	42bb      	cmp	r3, r7
 8009774:	d842      	bhi.n	80097fc <SaveToRO+0xd0>
	HAL_FLASH_Lock();
 8009776:	f008 fc2d 	bl	8011fd4 <HAL_FLASH_Lock>
	return result;
 800977a:	2000      	movs	r0, #0
 800977c:	e7ea      	b.n	8009754 <SaveToRO+0x28>
		temp = (uint16_t) (N<<8) + myID;
 800977e:	4a4f      	ldr	r2, [pc, #316]	; (80098bc <SaveToRO+0x190>)
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, RO_START_ADDRESS, temp);
 8009780:	2001      	movs	r0, #1
		temp = (uint16_t) (N<<8) + myID;
 8009782:	7812      	ldrb	r2, [r2, #0]
 8009784:	0212      	lsls	r2, r2, #8
 8009786:	1852      	adds	r2, r2, r1
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, RO_START_ADDRESS, temp);
 8009788:	b292      	uxth	r2, r2
 800978a:	4945      	ldr	r1, [pc, #276]	; (80098a0 <SaveToRO+0x174>)
 800978c:	f008 fc56 	bl	801203c <HAL_FLASH_Program>
		FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8009790:	4844      	ldr	r0, [pc, #272]	; (80098a4 <SaveToRO+0x178>)
 8009792:	f008 fc29 	bl	8011fe8 <FLASH_WaitForLastOperation>
		if (FlashStatus != HAL_OK) {
 8009796:	2800      	cmp	r0, #0
 8009798:	d1d9      	bne.n	800974e <SaveToRO+0x22>
			CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 800979a:	2501      	movs	r5, #1
 800979c:	6923      	ldr	r3, [r4, #16]
 800979e:	43ab      	bics	r3, r5
 80097a0:	6123      	str	r3, [r4, #16]
		for(uint8_t i=1 ; i<=N ; i++)
 80097a2:	4b46      	ldr	r3, [pc, #280]	; (80098bc <SaveToRO+0x190>)
 80097a4:	781b      	ldrb	r3, [r3, #0]
 80097a6:	42ab      	cmp	r3, r5
 80097a8:	d3df      	bcc.n	800976a <SaveToRO+0x3e>
 80097aa:	2316      	movs	r3, #22
				if (array[i-1][0]) {
 80097ac:	2216      	movs	r2, #22
		for(uint8_t i=1 ; i<=N ; i++)
 80097ae:	2700      	movs	r7, #0
 80097b0:	436b      	muls	r3, r5
 80097b2:	9300      	str	r3, [sp, #0]
				if (array[i-1][0]) {
 80097b4:	1e6b      	subs	r3, r5, #1
 80097b6:	435a      	muls	r2, r3
 80097b8:	9201      	str	r2, [sp, #4]
 80097ba:	4a41      	ldr	r2, [pc, #260]	; (80098c0 <SaveToRO+0x194>)
 80097bc:	9b01      	ldr	r3, [sp, #4]
 80097be:	5a9b      	ldrh	r3, [r3, r2]
 80097c0:	2b00      	cmp	r3, #0
 80097c2:	d015      	beq.n	80097f0 <SaveToRO+0xc4>
					HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, RO_START_ADDRESS+add, array[i-1][j]);
 80097c4:	9900      	ldr	r1, [sp, #0]
 80097c6:	007b      	lsls	r3, r7, #1
 80097c8:	185b      	adds	r3, r3, r1
 80097ca:	3b16      	subs	r3, #22
 80097cc:	5ad2      	ldrh	r2, [r2, r3]
 80097ce:	4b34      	ldr	r3, [pc, #208]	; (80098a0 <SaveToRO+0x174>)
 80097d0:	2001      	movs	r0, #1
 80097d2:	18f1      	adds	r1, r6, r3
 80097d4:	2300      	movs	r3, #0
 80097d6:	f008 fc31 	bl	801203c <HAL_FLASH_Program>
					add += 2;
 80097da:	3602      	adds	r6, #2
					FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 80097dc:	4831      	ldr	r0, [pc, #196]	; (80098a4 <SaveToRO+0x178>)
					add += 2;
 80097de:	b2b6      	uxth	r6, r6
					FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 80097e0:	f008 fc02 	bl	8011fe8 <FLASH_WaitForLastOperation>
					if (FlashStatus != HAL_OK) {
 80097e4:	2800      	cmp	r0, #0
 80097e6:	d1b2      	bne.n	800974e <SaveToRO+0x22>
						CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 80097e8:	2201      	movs	r2, #1
 80097ea:	6923      	ldr	r3, [r4, #16]
 80097ec:	4393      	bics	r3, r2
 80097ee:	6123      	str	r3, [r4, #16]
 80097f0:	3701      	adds	r7, #1
			for(uint8_t j=0 ; j<=MaxNumOfPorts ; j++)
 80097f2:	2f0b      	cmp	r7, #11
 80097f4:	d1e1      	bne.n	80097ba <SaveToRO+0x8e>
		for(uint8_t i=1 ; i<=N ; i++)
 80097f6:	3501      	adds	r5, #1
 80097f8:	b2ed      	uxtb	r5, r5
 80097fa:	e7d2      	b.n	80097a2 <SaveToRO+0x76>
		if (snippets[s].cond.conditionType) 
 80097fc:	2114      	movs	r1, #20
 80097fe:	4379      	muls	r1, r7
 8009800:	4b30      	ldr	r3, [pc, #192]	; (80098c4 <SaveToRO+0x198>)
 8009802:	5ccb      	ldrb	r3, [r1, r3]
 8009804:	2b00      	cmp	r3, #0
 8009806:	d032      	beq.n	800986e <SaveToRO+0x142>
			snipBuffer[0] = 0xFE;		// A marker to separate Snippets
 8009808:	22fe      	movs	r2, #254	; 0xfe
 800980a:	002e      	movs	r6, r5
 800980c:	ab02      	add	r3, sp, #8
 800980e:	701a      	strb	r2, [r3, #0]
			memcpy( (uint8_t *)&snipBuffer[1], (uint8_t *)&snippets[s], sizeof(snippet_t));
 8009810:	4b2c      	ldr	r3, [pc, #176]	; (80098c4 <SaveToRO+0x198>)
 8009812:	2214      	movs	r2, #20
 8009814:	18c9      	adds	r1, r1, r3
 8009816:	ab02      	add	r3, sp, #8
 8009818:	1c58      	adds	r0, r3, #1
 800981a:	f00a ff1b 	bl	8014654 <memcpy>
 800981e:	3614      	adds	r6, #20
 8009820:	9500      	str	r5, [sp, #0]
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, currentAdd, *(uint16_t *)&snipBuffer[j*2]);
 8009822:	9a00      	ldr	r2, [sp, #0]
 8009824:	ab02      	add	r3, sp, #8
 8009826:	1a9b      	subs	r3, r3, r2
 8009828:	5b5a      	ldrh	r2, [r3, r5]
 800982a:	0029      	movs	r1, r5
 800982c:	2300      	movs	r3, #0
 800982e:	2001      	movs	r0, #1
 8009830:	f008 fc04 	bl	801203c <HAL_FLASH_Program>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8009834:	481b      	ldr	r0, [pc, #108]	; (80098a4 <SaveToRO+0x178>)
 8009836:	f008 fbd7 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if (FlashStatus != HAL_OK) {
 800983a:	2800      	cmp	r0, #0
 800983c:	d000      	beq.n	8009840 <SaveToRO+0x114>
 800983e:	e786      	b.n	800974e <SaveToRO+0x22>
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8009840:	2201      	movs	r2, #1
 8009842:	6923      	ldr	r3, [r4, #16]
					currentAdd += 2;
 8009844:	3502      	adds	r5, #2
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8009846:	4393      	bics	r3, r2
 8009848:	6123      	str	r3, [r4, #16]
			for(uint8_t j=0 ; j<(sizeof(snippet_t)/2) ; j++)
 800984a:	42ae      	cmp	r6, r5
 800984c:	d1e9      	bne.n	8009822 <SaveToRO+0xf6>
			for(uint8_t j=0 ; j<((strlen(snippets[s].cmd)+1)/2) ; j++)
 800984e:	2314      	movs	r3, #20
 8009850:	0006      	movs	r6, r0
 8009852:	437b      	muls	r3, r7
 8009854:	9301      	str	r3, [sp, #4]
 8009856:	9a01      	ldr	r2, [sp, #4]
 8009858:	4b1a      	ldr	r3, [pc, #104]	; (80098c4 <SaveToRO+0x198>)
 800985a:	189b      	adds	r3, r3, r2
 800985c:	68db      	ldr	r3, [r3, #12]
 800985e:	0018      	movs	r0, r3
 8009860:	9300      	str	r3, [sp, #0]
 8009862:	f7f6 fc59 	bl	8000118 <strlen>
 8009866:	3001      	adds	r0, #1
 8009868:	0840      	lsrs	r0, r0, #1
 800986a:	4286      	cmp	r6, r0
 800986c:	d302      	bcc.n	8009874 <SaveToRO+0x148>
	for(uint8_t s=0 ; s<numOfRecordedSnippets ; s++) 
 800986e:	3701      	adds	r7, #1
 8009870:	b2ff      	uxtb	r7, r7
 8009872:	e77c      	b.n	800976e <SaveToRO+0x42>
				HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, currentAdd, *(uint16_t *)(snippets[s].cmd+j*2));
 8009874:	9a00      	ldr	r2, [sp, #0]
 8009876:	0073      	lsls	r3, r6, #1
 8009878:	5ad2      	ldrh	r2, [r2, r3]
 800987a:	0029      	movs	r1, r5
 800987c:	2300      	movs	r3, #0
 800987e:	2001      	movs	r0, #1
 8009880:	f008 fbdc 	bl	801203c <HAL_FLASH_Program>
				FlashStatus = FLASH_WaitForLastOperation((uint32_t)HAL_FLASH_TIMEOUT_VALUE); 
 8009884:	4807      	ldr	r0, [pc, #28]	; (80098a4 <SaveToRO+0x178>)
 8009886:	f008 fbaf 	bl	8011fe8 <FLASH_WaitForLastOperation>
				if (FlashStatus != HAL_OK) {
 800988a:	2800      	cmp	r0, #0
 800988c:	d000      	beq.n	8009890 <SaveToRO+0x164>
 800988e:	e75e      	b.n	800974e <SaveToRO+0x22>
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8009890:	2201      	movs	r2, #1
 8009892:	6923      	ldr	r3, [r4, #16]
			for(uint8_t j=0 ; j<((strlen(snippets[s].cmd)+1)/2) ; j++)
 8009894:	18b6      	adds	r6, r6, r2
					CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8009896:	4393      	bics	r3, r2
 8009898:	6123      	str	r3, [r4, #16]
					currentAdd += 2;
 800989a:	3502      	adds	r5, #2
			for(uint8_t j=0 ; j<((strlen(snippets[s].cmd)+1)/2) ; j++)
 800989c:	b2f6      	uxtb	r6, r6
 800989e:	e7da      	b.n	8009856 <SaveToRO+0x12a>
 80098a0:	0801d800 	.word	0x0801d800
 80098a4:	0000c350 	.word	0x0000c350
 80098a8:	20007ab8 	.word	0x20007ab8
 80098ac:	40022000 	.word	0x40022000
 80098b0:	20001039 	.word	0x20001039
 80098b4:	0801dc00 	.word	0x0801dc00
 80098b8:	200011c7 	.word	0x200011c7
 80098bc:	2000001c 	.word	0x2000001c
 80098c0:	20000aa0 	.word	0x20000aa0
 80098c4:	20006f8c 	.word	0x20006f8c

080098c8 <ClearROtopology>:
{
 80098c8:	b510      	push	{r4, lr}
	memset(array, 0, sizeof(array));
 80098ca:	4a07      	ldr	r2, [pc, #28]	; (80098e8 <ClearROtopology+0x20>)
 80098cc:	2100      	movs	r1, #0
 80098ce:	4807      	ldr	r0, [pc, #28]	; (80098ec <ClearROtopology+0x24>)
 80098d0:	f00a fec9 	bl	8014666 <memset>
	N = 1; myID = 0;
 80098d4:	2201      	movs	r2, #1
 80098d6:	4b06      	ldr	r3, [pc, #24]	; (80098f0 <ClearROtopology+0x28>)
 80098d8:	701a      	strb	r2, [r3, #0]
 80098da:	2200      	movs	r2, #0
 80098dc:	4b05      	ldr	r3, [pc, #20]	; (80098f4 <ClearROtopology+0x2c>)
 80098de:	701a      	strb	r2, [r3, #0]
	return SaveToRO();
 80098e0:	f7ff ff24 	bl	800972c <SaveToRO>
}
 80098e4:	bd10      	pop	{r4, pc}
 80098e6:	46c0      	nop			; (mov r8, r8)
 80098e8:	00000226 	.word	0x00000226
 80098ec:	20000aa0 	.word	0x20000aa0
 80098f0:	2000001c 	.word	0x2000001c
 80098f4:	20001039 	.word	0x20001039

080098f8 <Module_Init>:
{
 80098f8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	enableSequential = true;
 80098fa:	2401      	movs	r4, #1
 80098fc:	4b0e      	ldr	r3, [pc, #56]	; (8009938 <Module_Init+0x40>)
 80098fe:	701c      	strb	r4, [r3, #0]
	enableTimeDateHeader = true;
 8009900:	4b0e      	ldr	r3, [pc, #56]	; (800993c <Module_Init+0x44>)
 8009902:	701c      	strb	r4, [r3, #0]
	MX_USART1_UART_Init();
 8009904:	f003 fc24 	bl	800d150 <MX_USART1_UART_Init>
	MX_USART2_UART_Init();
 8009908:	f003 fc3a 	bl	800d180 <MX_USART2_UART_Init>
	MX_USART3_UART_Init();
 800990c:	f003 fc50 	bl	800d1b0 <MX_USART3_UART_Init>
	MX_USART4_UART_Init();
 8009910:	f003 fc66 	bl	800d1e0 <MX_USART4_UART_Init>
	MX_USART5_UART_Init();
 8009914:	f003 fc7c 	bl	800d210 <MX_USART5_UART_Init>
	needToDelayButtonStateReset = true;
 8009918:	4b09      	ldr	r3, [pc, #36]	; (8009940 <Module_Init+0x48>)
	xTaskCreate(LogTask, (const char *) "LogTask", (2*configMINIMAL_STACK_SIZE), NULL, osPriorityNormal-osPriorityIdle, &LogTaskHandle);
 800991a:	490a      	ldr	r1, [pc, #40]	; (8009944 <Module_Init+0x4c>)
	needToDelayButtonStateReset = true;
 800991c:	701c      	strb	r4, [r3, #0]
	xTaskCreate(LogTask, (const char *) "LogTask", (2*configMINIMAL_STACK_SIZE), NULL, osPriorityNormal-osPriorityIdle, &LogTaskHandle);
 800991e:	22a0      	movs	r2, #160	; 0xa0
 8009920:	2300      	movs	r3, #0
 8009922:	9101      	str	r1, [sp, #4]
 8009924:	2103      	movs	r1, #3
 8009926:	9303      	str	r3, [sp, #12]
 8009928:	9100      	str	r1, [sp, #0]
 800992a:	9302      	str	r3, [sp, #8]
 800992c:	0092      	lsls	r2, r2, #2
 800992e:	4906      	ldr	r1, [pc, #24]	; (8009948 <Module_Init+0x50>)
 8009930:	4806      	ldr	r0, [pc, #24]	; (800994c <Module_Init+0x54>)
 8009932:	f006 fd8c 	bl	801044e <xTaskGenericCreate>
}
 8009936:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8009938:	2000166e 	.word	0x2000166e
 800993c:	2000166f 	.word	0x2000166f
 8009940:	20001496 	.word	0x20001496
 8009944:	20001668 	.word	0x20001668
 8009948:	0801b5e1 	.word	0x0801b5e1
 800994c:	0800adf9 	.word	0x0800adf9

08009950 <Module_MessagingTask>:
{
 8009950:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009952:	ab05      	add	r3, sp, #20
 8009954:	781a      	ldrb	r2, [r3, #0]
	switch (code)
 8009956:	4b22      	ldr	r3, [pc, #136]	; (80099e0 <Module_MessagingTask+0x90>)
 8009958:	4298      	cmp	r0, r3
 800995a:	d004      	beq.n	8009966 <Module_MessagingTask+0x16>
 800995c:	4b21      	ldr	r3, [pc, #132]	; (80099e4 <Module_MessagingTask+0x94>)
 800995e:	4298      	cmp	r0, r3
 8009960:	d012      	beq.n	8009988 <Module_MessagingTask+0x38>
			result = H1BR6_ERR_UnknownMessage;
 8009962:	2001      	movs	r0, #1
 8009964:	e00f      	b.n	8009986 <Module_MessagingTask+0x36>
				temp_H07R3_ID = cMessage[port-1][shift];
 8009966:	2338      	movs	r3, #56	; 0x38
 8009968:	3901      	subs	r1, #1
 800996a:	434b      	muls	r3, r1
 800996c:	491e      	ldr	r1, [pc, #120]	; (80099e8 <Module_MessagingTask+0x98>)
 800996e:	18c9      	adds	r1, r1, r3
 8009970:	5c88      	ldrb	r0, [r1, r2]
 8009972:	4b1e      	ldr	r3, [pc, #120]	; (80099ec <Module_MessagingTask+0x9c>)
				temp_H07R3_DST = cMessage[port-1][shift+1];		// Note this is not used
 8009974:	1889      	adds	r1, r1, r2
				temp_H07R3_ID = cMessage[port-1][shift];
 8009976:	7018      	strb	r0, [r3, #0]
				temp_H07R3_DST = cMessage[port-1][shift+1];		// Note this is not used
 8009978:	784a      	ldrb	r2, [r1, #1]
 800997a:	4b1d      	ldr	r3, [pc, #116]	; (80099f0 <Module_MessagingTask+0xa0>)
	Module_Status result = H1BR6_OK;
 800997c:	2000      	movs	r0, #0
				temp_H07R3_DST = cMessage[port-1][shift+1];		// Note this is not used
 800997e:	701a      	strb	r2, [r3, #0]
				SD_MODE = WAV_STREAM_MODE;			
 8009980:	2202      	movs	r2, #2
 8009982:	4b1c      	ldr	r3, [pc, #112]	; (80099f4 <Module_MessagingTask+0xa4>)
 8009984:	701a      	strb	r2, [r3, #0]
}
 8009986:	bdf0      	pop	{r4, r5, r6, r7, pc}
		  templn = messageLength[port-1]-shift-1;		
 8009988:	43d0      	mvns	r0, r2
 800998a:	2438      	movs	r4, #56	; 0x38
 800998c:	4b1a      	ldr	r3, [pc, #104]	; (80099f8 <Module_MessagingTask+0xa8>)
 800998e:	3901      	subs	r1, #1
 8009990:	5c5b      	ldrb	r3, [r3, r1]
 8009992:	434c      	muls	r4, r1
 8009994:	181b      	adds	r3, r3, r0
			for (uint8_t i=0 ; i<templn ; i++)
 8009996:	2000      	movs	r0, #0
 8009998:	4e13      	ldr	r6, [pc, #76]	; (80099e8 <Module_MessagingTask+0x98>)
 800999a:	4d18      	ldr	r5, [pc, #96]	; (80099fc <Module_MessagingTask+0xac>)
		  templn = messageLength[port-1]-shift-1;		
 800999c:	b2db      	uxtb	r3, r3
 800999e:	18a4      	adds	r4, r4, r2
			for (uint8_t i=0 ; i<templn ; i++)
 80099a0:	b2c7      	uxtb	r7, r0
 80099a2:	42bb      	cmp	r3, r7
 80099a4:	d816      	bhi.n	80099d4 <Module_MessagingTask+0x84>
			Const_WAVE_NAME[templn] = '.';
 80099a6:	202e      	movs	r0, #46	; 0x2e
 80099a8:	54e8      	strb	r0, [r5, r3]
			Const_WAVE_NAME[templn+1] = 'w';
 80099aa:	18eb      	adds	r3, r5, r3
 80099ac:	3049      	adds	r0, #73	; 0x49
 80099ae:	7058      	strb	r0, [r3, #1]
			Const_WAVE_NAME[templn+2] = 'a';
 80099b0:	3816      	subs	r0, #22
 80099b2:	7098      	strb	r0, [r3, #2]
			Const_WAVE_NAME[templn+3] = 'v';
 80099b4:	3015      	adds	r0, #21
 80099b6:	70d8      	strb	r0, [r3, #3]
			Const_WAVE_NAME[templn+4] = 0;
 80099b8:	2000      	movs	r0, #0
 80099ba:	7118      	strb	r0, [r3, #4]
			WAVE_NAME = (char *) &Const_WAVE_NAME[0];
 80099bc:	4b10      	ldr	r3, [pc, #64]	; (8009a00 <Module_MessagingTask+0xb0>)
 80099be:	601d      	str	r5, [r3, #0]
			temp_H07R3_ID = cMessage[port-1][shift];
 80099c0:	2338      	movs	r3, #56	; 0x38
 80099c2:	4359      	muls	r1, r3
 80099c4:	1871      	adds	r1, r6, r1
 80099c6:	5c8a      	ldrb	r2, [r1, r2]
 80099c8:	4b08      	ldr	r3, [pc, #32]	; (80099ec <Module_MessagingTask+0x9c>)
 80099ca:	701a      	strb	r2, [r3, #0]
			SD_MODE = WAV_SCAN_MODE;
 80099cc:	2201      	movs	r2, #1
 80099ce:	4b09      	ldr	r3, [pc, #36]	; (80099f4 <Module_MessagingTask+0xa4>)
 80099d0:	701a      	strb	r2, [r3, #0]
		break;
 80099d2:	e7d8      	b.n	8009986 <Module_MessagingTask+0x36>
				Const_WAVE_NAME[i] = (char) cMessage[port-1][shift+1+i];
 80099d4:	1907      	adds	r7, r0, r4
 80099d6:	19f7      	adds	r7, r6, r7
 80099d8:	787f      	ldrb	r7, [r7, #1]
 80099da:	542f      	strb	r7, [r5, r0]
 80099dc:	3001      	adds	r0, #1
 80099de:	e7df      	b.n	80099a0 <Module_MessagingTask+0x50>
 80099e0:	00000546 	.word	0x00000546
 80099e4:	00000547 	.word	0x00000547
 80099e8:	20000d13 	.word	0x20000d13
 80099ec:	200070d9 	.word	0x200070d9
 80099f0:	20007184 	.word	0x20007184
 80099f4:	2000166d 	.word	0x2000166d
 80099f8:	20000f02 	.word	0x20000f02
 80099fc:	200076d8 	.word	0x200076d8
 8009a00:	200073ac 	.word	0x200073ac

08009a04 <RegisterModuleCLICommands>:
{
 8009a04:	b510      	push	{r4, lr}
	FreeRTOS_CLIRegisterCommand( &demoCommandDefinition );
 8009a06:	480c      	ldr	r0, [pc, #48]	; (8009a38 <RegisterModuleCLICommands+0x34>)
 8009a08:	f005 ff1c 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &addLogCommandDefinition );
 8009a0c:	480b      	ldr	r0, [pc, #44]	; (8009a3c <RegisterModuleCLICommands+0x38>)
 8009a0e:	f005 ff19 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &deleteLogCommandDefinition );
 8009a12:	480b      	ldr	r0, [pc, #44]	; (8009a40 <RegisterModuleCLICommands+0x3c>)
 8009a14:	f005 ff16 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &logVarCommandDefinition );
 8009a18:	480a      	ldr	r0, [pc, #40]	; (8009a44 <RegisterModuleCLICommands+0x40>)
 8009a1a:	f005 ff13 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &startCommandDefinition );
 8009a1e:	480a      	ldr	r0, [pc, #40]	; (8009a48 <RegisterModuleCLICommands+0x44>)
 8009a20:	f005 ff10 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &stopCommandDefinition );
 8009a24:	4809      	ldr	r0, [pc, #36]	; (8009a4c <RegisterModuleCLICommands+0x48>)
 8009a26:	f005 ff0d 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &pauseCommandDefinition );
 8009a2a:	4809      	ldr	r0, [pc, #36]	; (8009a50 <RegisterModuleCLICommands+0x4c>)
 8009a2c:	f005 ff0a 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &resumeCommandDefinition );
 8009a30:	4808      	ldr	r0, [pc, #32]	; (8009a54 <RegisterModuleCLICommands+0x50>)
 8009a32:	f005 ff07 	bl	800f844 <FreeRTOS_CLIRegisterCommand>
}
 8009a36:	bd10      	pop	{r4, pc}
 8009a38:	0801b838 	.word	0x0801b838
 8009a3c:	0801b71c 	.word	0x0801b71c
 8009a40:	0801b7bc 	.word	0x0801b7bc
 8009a44:	0801ba2c 	.word	0x0801ba2c
 8009a48:	0801baa4 	.word	0x0801baa4
 8009a4c:	0801bae0 	.word	0x0801bae0
 8009a50:	0801ba54 	.word	0x0801ba54
 8009a54:	0801ba7c 	.word	0x0801ba7c

08009a58 <GetPort>:
	if (huart->Instance == USART4)
 8009a58:	6803      	ldr	r3, [r0, #0]
 8009a5a:	4a0b      	ldr	r2, [pc, #44]	; (8009a88 <GetPort+0x30>)
			return P1;
 8009a5c:	2001      	movs	r0, #1
	if (huart->Instance == USART4)
 8009a5e:	4293      	cmp	r3, r2
 8009a60:	d010      	beq.n	8009a84 <GetPort+0x2c>
	else if (huart->Instance == USART2)
 8009a62:	4a0a      	ldr	r2, [pc, #40]	; (8009a8c <GetPort+0x34>)
			return P2;
 8009a64:	1800      	adds	r0, r0, r0
	else if (huart->Instance == USART2)
 8009a66:	4293      	cmp	r3, r2
 8009a68:	d00c      	beq.n	8009a84 <GetPort+0x2c>
	else if (huart->Instance == USART3)
 8009a6a:	4a09      	ldr	r2, [pc, #36]	; (8009a90 <GetPort+0x38>)
			return P3;
 8009a6c:	3001      	adds	r0, #1
	else if (huart->Instance == USART3)
 8009a6e:	4293      	cmp	r3, r2
 8009a70:	d008      	beq.n	8009a84 <GetPort+0x2c>
	else if (huart->Instance == USART1)
 8009a72:	4a08      	ldr	r2, [pc, #32]	; (8009a94 <GetPort+0x3c>)
			return P4;
 8009a74:	3001      	adds	r0, #1
	else if (huart->Instance == USART1)
 8009a76:	4293      	cmp	r3, r2
 8009a78:	d004      	beq.n	8009a84 <GetPort+0x2c>
	else if (huart->Instance == USART5)
 8009a7a:	4a07      	ldr	r2, [pc, #28]	; (8009a98 <GetPort+0x40>)
			return P5;
 8009a7c:	3001      	adds	r0, #1
	else if (huart->Instance == USART5)
 8009a7e:	4293      	cmp	r3, r2
 8009a80:	d000      	beq.n	8009a84 <GetPort+0x2c>
	return 0;
 8009a82:	2000      	movs	r0, #0
}
 8009a84:	4770      	bx	lr
 8009a86:	46c0      	nop			; (mov r8, r8)
 8009a88:	40004c00 	.word	0x40004c00
 8009a8c:	40004400 	.word	0x40004400
 8009a90:	40004800 	.word	0x40004800
 8009a94:	40013800 	.word	0x40013800
 8009a98:	40005000 	.word	0x40005000

08009a9c <MicroSD_Init>:
{	
 8009a9c:	b530      	push	{r4, r5, lr}
 8009a9e:	b08f      	sub	sp, #60	; 0x3c
	if (BSP_SD_Init() == MSD_ERROR) 
 8009aa0:	f002 ff38 	bl	800c914 <BSP_SD_Init>
 8009aa4:	2801      	cmp	r0, #1
 8009aa6:	d114      	bne.n	8009ad2 <MicroSD_Init+0x36>
		while(1) { RTOS_IND_blink(500); Delay_ms(500); }	
 8009aa8:	2480      	movs	r4, #128	; 0x80
 8009aaa:	01e4      	lsls	r4, r4, #7
 8009aac:	0021      	movs	r1, r4
 8009aae:	2201      	movs	r2, #1
 8009ab0:	4820      	ldr	r0, [pc, #128]	; (8009b34 <MicroSD_Init+0x98>)
 8009ab2:	f008 fc35 	bl	8012320 <HAL_GPIO_WritePin>
 8009ab6:	20fa      	movs	r0, #250	; 0xfa
 8009ab8:	0040      	lsls	r0, r0, #1
 8009aba:	f005 fe52 	bl	800f762 <osDelay>
 8009abe:	2200      	movs	r2, #0
 8009ac0:	0021      	movs	r1, r4
 8009ac2:	481c      	ldr	r0, [pc, #112]	; (8009b34 <MicroSD_Init+0x98>)
 8009ac4:	f008 fc2c 	bl	8012320 <HAL_GPIO_WritePin>
 8009ac8:	20fa      	movs	r0, #250	; 0xfa
 8009aca:	0040      	lsls	r0, r0, #1
 8009acc:	f007 fd1e 	bl	801150c <HAL_Delay>
 8009ad0:	e7ec      	b.n	8009aac <MicroSD_Init+0x10>
		BSP_SD_GetCardInfo(&CardInfo);
 8009ad2:	4668      	mov	r0, sp
 8009ad4:	f003 f864 	bl	800cba0 <BSP_SD_GetCardInfo>
		if(FATFS_LinkDriver(&SD_Driver, SDPath) == 0)
 8009ad8:	4d17      	ldr	r5, [pc, #92]	; (8009b38 <MicroSD_Init+0x9c>)
 8009ada:	4818      	ldr	r0, [pc, #96]	; (8009b3c <MicroSD_Init+0xa0>)
 8009adc:	0029      	movs	r1, r5
 8009ade:	f003 fdd5 	bl	800d68c <FATFS_LinkDriver>
 8009ae2:	1e04      	subs	r4, r0, #0
 8009ae4:	d123      	bne.n	8009b2e <MicroSD_Init+0x92>
			if(f_mount(&SDFatFs, SDPath, 1) != FR_OK)
 8009ae6:	2201      	movs	r2, #1
 8009ae8:	0029      	movs	r1, r5
 8009aea:	4815      	ldr	r0, [pc, #84]	; (8009b40 <MicroSD_Init+0xa4>)
 8009aec:	f005 f8f0 	bl	800ecd0 <f_mount>
 8009af0:	2800      	cmp	r0, #0
 8009af2:	d019      	beq.n	8009b28 <MicroSD_Init+0x8c>
				f_mount(0, SDPath, 0); 
 8009af4:	0022      	movs	r2, r4
 8009af6:	0020      	movs	r0, r4
 8009af8:	0029      	movs	r1, r5
				while(1) { RTOS_IND_blink(500); Delay_ms(500); }	
 8009afa:	2480      	movs	r4, #128	; 0x80
				f_mount(0, SDPath, 0); 
 8009afc:	f005 f8e8 	bl	800ecd0 <f_mount>
				while(1) { RTOS_IND_blink(500); Delay_ms(500); }	
 8009b00:	01e4      	lsls	r4, r4, #7
 8009b02:	0021      	movs	r1, r4
 8009b04:	2201      	movs	r2, #1
 8009b06:	480b      	ldr	r0, [pc, #44]	; (8009b34 <MicroSD_Init+0x98>)
 8009b08:	f008 fc0a 	bl	8012320 <HAL_GPIO_WritePin>
 8009b0c:	20fa      	movs	r0, #250	; 0xfa
 8009b0e:	0040      	lsls	r0, r0, #1
 8009b10:	f005 fe27 	bl	800f762 <osDelay>
 8009b14:	2200      	movs	r2, #0
 8009b16:	0021      	movs	r1, r4
 8009b18:	4806      	ldr	r0, [pc, #24]	; (8009b34 <MicroSD_Init+0x98>)
 8009b1a:	f008 fc01 	bl	8012320 <HAL_GPIO_WritePin>
 8009b1e:	20fa      	movs	r0, #250	; 0xfa
 8009b20:	0040      	lsls	r0, r0, #1
 8009b22:	f007 fcf3 	bl	801150c <HAL_Delay>
 8009b26:	e7ec      	b.n	8009b02 <MicroSD_Init+0x66>
        f_mount_ok=1;
 8009b28:	2201      	movs	r2, #1
 8009b2a:	4b06      	ldr	r3, [pc, #24]	; (8009b44 <MicroSD_Init+0xa8>)
 8009b2c:	701a      	strb	r2, [r3, #0]
}
 8009b2e:	2000      	movs	r0, #0
 8009b30:	b00f      	add	sp, #60	; 0x3c
 8009b32:	bd30      	pop	{r4, r5, pc}
 8009b34:	48000400 	.word	0x48000400
 8009b38:	20007494 	.word	0x20007494
 8009b3c:	200000a4 	.word	0x200000a4
 8009b40:	20007498 	.word	0x20007498
 8009b44:	20001670 	.word	0x20001670

08009b48 <CheckLogVarEvent>:
	switch (logVars[varIndex].type)
 8009b48:	220c      	movs	r2, #12
{
 8009b4a:	0003      	movs	r3, r0
	switch (logVars[varIndex].type)
 8009b4c:	0010      	movs	r0, r2
{
 8009b4e:	b530      	push	{r4, r5, lr}
	switch (logVars[varIndex].type)
 8009b50:	4358      	muls	r0, r3
 8009b52:	4932      	ldr	r1, [pc, #200]	; (8009c1c <CheckLogVarEvent+0xd4>)
	return 0;	
 8009b54:	2400      	movs	r4, #0
	switch (logVars[varIndex].type)
 8009b56:	1808      	adds	r0, r1, r0
 8009b58:	7840      	ldrb	r0, [r0, #1]
 8009b5a:	3803      	subs	r0, #3
 8009b5c:	2807      	cmp	r0, #7
 8009b5e:	d815      	bhi.n	8009b8c <CheckLogVarEvent+0x44>
 8009b60:	f7f6 faec 	bl	800013c <__gnu_thumb1_case_uqi>
 8009b64:	32251604 	.word	0x32251604
 8009b68:	4d4d4d40 	.word	0x4d4d4d40
			if ((button[logVars[varIndex].source].state != temp_uint8) && (button[logVars[varIndex].source].state != 0)) {
 8009b6c:	220c      	movs	r2, #12
 8009b6e:	435a      	muls	r2, r3
 8009b70:	2309      	movs	r3, #9
 8009b72:	188a      	adds	r2, r1, r2
 8009b74:	6892      	ldr	r2, [r2, #8]
 8009b76:	4353      	muls	r3, r2
 8009b78:	4a29      	ldr	r2, [pc, #164]	; (8009c20 <CheckLogVarEvent+0xd8>)
 8009b7a:	5c9c      	ldrb	r4, [r3, r2]
 8009b7c:	4b29      	ldr	r3, [pc, #164]	; (8009c24 <CheckLogVarEvent+0xdc>)
 8009b7e:	781a      	ldrb	r2, [r3, #0]
 8009b80:	42a2      	cmp	r2, r4
 8009b82:	d049      	beq.n	8009c18 <CheckLogVarEvent+0xd0>
				temp_uint8 = button[logVars[varIndex].source].state;
 8009b84:	701c      	strb	r4, [r3, #0]
			if ((button[logVars[varIndex].source].state != temp_uint8) && (button[logVars[varIndex].source].state != 0)) {
 8009b86:	2c00      	cmp	r4, #0
 8009b88:	d000      	beq.n	8009b8c <CheckLogVarEvent+0x44>
				return 1;
 8009b8a:	2401      	movs	r4, #1
} 
 8009b8c:	0020      	movs	r0, r4
 8009b8e:	bd30      	pop	{r4, r5, pc}
			if (*(__IO uint8_t *)logVars[varIndex].source != (uint8_t)compareValue[varIndex]) {
 8009b90:	435a      	muls	r2, r3
 8009b92:	188a      	adds	r2, r1, r2
 8009b94:	4924      	ldr	r1, [pc, #144]	; (8009c28 <CheckLogVarEvent+0xe0>)
 8009b96:	6890      	ldr	r0, [r2, #8]
 8009b98:	009b      	lsls	r3, r3, #2
 8009b9a:	585a      	ldr	r2, [r3, r1]
 8009b9c:	7805      	ldrb	r5, [r0, #0]
 8009b9e:	b2d2      	uxtb	r2, r2
	return 0;	
 8009ba0:	2400      	movs	r4, #0
			if (*(__IO uint8_t *)logVars[varIndex].source != (uint8_t)compareValue[varIndex]) {
 8009ba2:	42aa      	cmp	r2, r5
 8009ba4:	d0f2      	beq.n	8009b8c <CheckLogVarEvent+0x44>
				*(uint8_t*)&compareValue[varIndex] = *(__IO uint8_t *)logVars[varIndex].source;
 8009ba6:	7802      	ldrb	r2, [r0, #0]
 8009ba8:	54ca      	strb	r2, [r1, r3]
				return 1;
 8009baa:	3401      	adds	r4, #1
 8009bac:	e7ee      	b.n	8009b8c <CheckLogVarEvent+0x44>
			if (*(__IO int8_t *)logVars[varIndex].source != (int8_t)compareValue[varIndex]) {
 8009bae:	435a      	muls	r2, r3
 8009bb0:	188a      	adds	r2, r1, r2
 8009bb2:	6891      	ldr	r1, [r2, #8]
 8009bb4:	4a1c      	ldr	r2, [pc, #112]	; (8009c28 <CheckLogVarEvent+0xe0>)
 8009bb6:	009b      	lsls	r3, r3, #2
 8009bb8:	780d      	ldrb	r5, [r1, #0]
 8009bba:	5cd0      	ldrb	r0, [r2, r3]
	return 0;	
 8009bbc:	2400      	movs	r4, #0
			if (*(__IO int8_t *)logVars[varIndex].source != (int8_t)compareValue[varIndex]) {
 8009bbe:	4285      	cmp	r5, r0
 8009bc0:	d0e4      	beq.n	8009b8c <CheckLogVarEvent+0x44>
				*(int8_t*)&compareValue[varIndex] = (int8_t)*(__IO int8_t *)logVars[varIndex].source;
 8009bc2:	7809      	ldrb	r1, [r1, #0]
 8009bc4:	54d1      	strb	r1, [r2, r3]
 8009bc6:	e7f0      	b.n	8009baa <CheckLogVarEvent+0x62>
			if ((uint16_t)*(__IO uint16_t *)logVars[varIndex].source != (uint16_t)compareValue[varIndex]) {
 8009bc8:	435a      	muls	r2, r3
 8009bca:	188a      	adds	r2, r1, r2
 8009bcc:	4916      	ldr	r1, [pc, #88]	; (8009c28 <CheckLogVarEvent+0xe0>)
 8009bce:	6890      	ldr	r0, [r2, #8]
 8009bd0:	009b      	lsls	r3, r3, #2
 8009bd2:	585a      	ldr	r2, [r3, r1]
 8009bd4:	8805      	ldrh	r5, [r0, #0]
 8009bd6:	b292      	uxth	r2, r2
	return 0;	
 8009bd8:	2400      	movs	r4, #0
			if ((uint16_t)*(__IO uint16_t *)logVars[varIndex].source != (uint16_t)compareValue[varIndex]) {
 8009bda:	42aa      	cmp	r2, r5
 8009bdc:	d0d6      	beq.n	8009b8c <CheckLogVarEvent+0x44>
				*(uint16_t*)&compareValue[varIndex] = (uint16_t)*(__IO uint16_t *)logVars[varIndex].source;
 8009bde:	8802      	ldrh	r2, [r0, #0]
 8009be0:	52ca      	strh	r2, [r1, r3]
 8009be2:	e7e2      	b.n	8009baa <CheckLogVarEvent+0x62>
			if ((int16_t)*(__IO uint16_t *)logVars[varIndex].source != (int16_t)compareValue[varIndex]) {
 8009be4:	435a      	muls	r2, r3
 8009be6:	188a      	adds	r2, r1, r2
 8009be8:	6891      	ldr	r1, [r2, #8]
 8009bea:	4a0f      	ldr	r2, [pc, #60]	; (8009c28 <CheckLogVarEvent+0xe0>)
 8009bec:	009b      	lsls	r3, r3, #2
 8009bee:	880d      	ldrh	r5, [r1, #0]
 8009bf0:	5ad0      	ldrh	r0, [r2, r3]
	return 0;	
 8009bf2:	2400      	movs	r4, #0
			if ((int16_t)*(__IO uint16_t *)logVars[varIndex].source != (int16_t)compareValue[varIndex]) {
 8009bf4:	4285      	cmp	r5, r0
 8009bf6:	d0c9      	beq.n	8009b8c <CheckLogVarEvent+0x44>
				*(int16_t*)&compareValue[varIndex] = (int16_t)*(__IO uint16_t *)logVars[varIndex].source;
 8009bf8:	8809      	ldrh	r1, [r1, #0]
 8009bfa:	52d1      	strh	r1, [r2, r3]
 8009bfc:	e7d5      	b.n	8009baa <CheckLogVarEvent+0x62>
			if ((int32_t)*(__IO uint32_t *)logVars[varIndex].source != (int32_t)compareValue[varIndex]) {
 8009bfe:	435a      	muls	r2, r3
 8009c00:	188a      	adds	r2, r1, r2
 8009c02:	6891      	ldr	r1, [r2, #8]
 8009c04:	4a08      	ldr	r2, [pc, #32]	; (8009c28 <CheckLogVarEvent+0xe0>)
 8009c06:	009b      	lsls	r3, r3, #2
 8009c08:	6808      	ldr	r0, [r1, #0]
 8009c0a:	589d      	ldr	r5, [r3, r2]
	return 0;	
 8009c0c:	2400      	movs	r4, #0
			if ((int32_t)*(__IO uint32_t *)logVars[varIndex].source != (int32_t)compareValue[varIndex]) {
 8009c0e:	42a8      	cmp	r0, r5
 8009c10:	d0bc      	beq.n	8009b8c <CheckLogVarEvent+0x44>
				compareValue[varIndex] = *(__IO uint32_t *)logVars[varIndex].source;
 8009c12:	6809      	ldr	r1, [r1, #0]
 8009c14:	5099      	str	r1, [r3, r2]
 8009c16:	e7c8      	b.n	8009baa <CheckLogVarEvent+0x62>
	return 0;	
 8009c18:	2400      	movs	r4, #0
 8009c1a:	e7b7      	b.n	8009b8c <CheckLogVarEvent+0x44>
 8009c1c:	20001674 	.word	0x20001674
 8009c20:	20001458 	.word	0x20001458
 8009c24:	20001936 	.word	0x20001936
 8009c28:	2000787c 	.word	0x2000787c

08009c2c <OpenThisLog>:
{ 
 8009c2c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8009c2e:	0004      	movs	r4, r0
 8009c30:	000d      	movs	r5, r1
  while(f_mount_ok==0){Delay_us(10);}		// Add a flag to allow card to be initialized on startup
 8009c32:	4b15      	ldr	r3, [pc, #84]	; (8009c88 <OpenThisLog+0x5c>)
 8009c34:	781b      	ldrb	r3, [r3, #0]
 8009c36:	2b00      	cmp	r3, #0
 8009c38:	d01c      	beq.n	8009c74 <OpenThisLog+0x48>
	if ((0U != logs[logindex].file_extension) && (true == enableSequential))
 8009c3a:	4b14      	ldr	r3, [pc, #80]	; (8009c8c <OpenThisLog+0x60>)
 8009c3c:	0164      	lsls	r4, r4, #5
 8009c3e:	191a      	adds	r2, r3, r4
 8009c40:	7911      	ldrb	r1, [r2, #4]
 8009c42:	58e2      	ldr	r2, [r4, r3]
 8009c44:	4c12      	ldr	r4, [pc, #72]	; (8009c90 <OpenThisLog+0x64>)
 8009c46:	4b13      	ldr	r3, [pc, #76]	; (8009c94 <OpenThisLog+0x68>)
 8009c48:	2900      	cmp	r1, #0
 8009c4a:	d017      	beq.n	8009c7c <OpenThisLog+0x50>
 8009c4c:	4812      	ldr	r0, [pc, #72]	; (8009c98 <OpenThisLog+0x6c>)
 8009c4e:	7800      	ldrb	r0, [r0, #0]
 8009c50:	2800      	cmp	r0, #0
 8009c52:	d013      	beq.n	8009c7c <OpenThisLog+0x50>
		sprintf((char *)tempName, "%s_%d%s", logs[logindex].name, logs[logindex].file_extension, ".TXT");
 8009c54:	9300      	str	r3, [sp, #0]
 8009c56:	0020      	movs	r0, r4
 8009c58:	000b      	movs	r3, r1
 8009c5a:	4910      	ldr	r1, [pc, #64]	; (8009c9c <OpenThisLog+0x70>)
 8009c5c:	f00a fefe 	bl	8014a5c <sprintf>
	res = f_open(objFile, tempName, FA_OPEN_APPEND | FA_WRITE | FA_READ);
 8009c60:	0028      	movs	r0, r5
 8009c62:	2233      	movs	r2, #51	; 0x33
 8009c64:	0021      	movs	r1, r4
 8009c66:	f005 f879 	bl	800ed5c <f_open>
	if (res != FR_OK)	
 8009c6a:	1e43      	subs	r3, r0, #1
 8009c6c:	4198      	sbcs	r0, r3
 8009c6e:	4240      	negs	r0, r0
 8009c70:	b2c0      	uxtb	r0, r0
} 
 8009c72:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
  while(f_mount_ok==0){Delay_us(10);}		// Add a flag to allow card to be initialized on startup
 8009c74:	200a      	movs	r0, #10
 8009c76:	f003 fa47 	bl	800d108 <StartMicroDelay>
 8009c7a:	e7da      	b.n	8009c32 <OpenThisLog+0x6>
		sprintf((char *)tempName, "%s%s", logs[logindex].name, ".TXT");
 8009c7c:	4908      	ldr	r1, [pc, #32]	; (8009ca0 <OpenThisLog+0x74>)
 8009c7e:	0020      	movs	r0, r4
 8009c80:	f00a feec 	bl	8014a5c <sprintf>
 8009c84:	e7ec      	b.n	8009c60 <OpenThisLog+0x34>
 8009c86:	46c0      	nop			; (mov r8, r8)
 8009c88:	20001670 	.word	0x20001670
 8009c8c:	200017dc 	.word	0x200017dc
 8009c90:	2000191d 	.word	0x2000191d
 8009c94:	0801b5f1 	.word	0x0801b5f1
 8009c98:	2000166e 	.word	0x2000166e
 8009c9c:	0801b5e9 	.word	0x0801b5e9
 8009ca0:	0801b5f6 	.word	0x0801b5f6

08009ca4 <READ_WAVE_FILE_HEADER>:
{
 8009ca4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8009ca6:	0004      	movs	r4, r0
  while(f_mount_ok==0){Delay_us(10);}		// Add a flag to allow card to be initialized on startup
 8009ca8:	4b7c      	ldr	r3, [pc, #496]	; (8009e9c <READ_WAVE_FILE_HEADER+0x1f8>)
 8009caa:	781b      	ldrb	r3, [r3, #0]
 8009cac:	2b00      	cmp	r3, #0
 8009cae:	d017      	beq.n	8009ce0 <READ_WAVE_FILE_HEADER+0x3c>
	if (f_open (&_path_pointer,Wave_Path,FA_READ)==FR_OK)
 8009cb0:	4d7b      	ldr	r5, [pc, #492]	; (8009ea0 <READ_WAVE_FILE_HEADER+0x1fc>)
 8009cb2:	2201      	movs	r2, #1
 8009cb4:	0021      	movs	r1, r4
 8009cb6:	0028      	movs	r0, r5
 8009cb8:	f005 f850 	bl	800ed5c <f_open>
 8009cbc:	2800      	cmp	r0, #0
 8009cbe:	d000      	beq.n	8009cc2 <READ_WAVE_FILE_HEADER+0x1e>
 8009cc0:	e0e7      	b.n	8009e92 <READ_WAVE_FILE_HEADER+0x1ee>
				if(f_read ( &_path_pointer,  &wavebuff, 44,  &Number_br)!=FR_OK)
 8009cc2:	4c78      	ldr	r4, [pc, #480]	; (8009ea4 <READ_WAVE_FILE_HEADER+0x200>)
 8009cc4:	4b78      	ldr	r3, [pc, #480]	; (8009ea8 <READ_WAVE_FILE_HEADER+0x204>)
 8009cc6:	222c      	movs	r2, #44	; 0x2c
 8009cc8:	0021      	movs	r1, r4
 8009cca:	0028      	movs	r0, r5
 8009ccc:	f005 f952 	bl	800ef74 <f_read>
 8009cd0:	2800      	cmp	r0, #0
 8009cd2:	d009      	beq.n	8009ce8 <READ_WAVE_FILE_HEADER+0x44>
					f_close (&_path_pointer);
 8009cd4:	0028      	movs	r0, r5
 8009cd6:	f005 fb0e 	bl	800f2f6 <f_close>
					return WAVE_FILE_READ_FAILD;
 8009cda:	2105      	movs	r1, #5
}
 8009cdc:	0008      	movs	r0, r1
 8009cde:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  while(f_mount_ok==0){Delay_us(10);}		// Add a flag to allow card to be initialized on startup
 8009ce0:	200a      	movs	r0, #10
 8009ce2:	f003 fa11 	bl	800d108 <StartMicroDelay>
 8009ce6:	e7df      	b.n	8009ca8 <READ_WAVE_FILE_HEADER+0x4>
				f_close (&_path_pointer);
 8009ce8:	0028      	movs	r0, r5
 8009cea:	f005 fb04 	bl	800f2f6 <f_close>
 8009cee:	2224      	movs	r2, #36	; 0x24
 8009cf0:	4b6e      	ldr	r3, [pc, #440]	; (8009eac <READ_WAVE_FILE_HEADER+0x208>)
 8009cf2:	18a0      	adds	r0, r4, r2
	WAVEFIL.CHUNKID[_i] = wavebuff[_i];
 8009cf4:	0006      	movs	r6, r0
 8009cf6:	18d1      	adds	r1, r2, r3
 8009cf8:	000d      	movs	r5, r1
 8009cfa:	3e24      	subs	r6, #36	; 0x24
 8009cfc:	7836      	ldrb	r6, [r6, #0]
 8009cfe:	3d24      	subs	r5, #36	; 0x24
 8009d00:	702e      	strb	r6, [r5, #0]
	WAVEFIL.FORMAT[_i] = wavebuff[_i+8];
 8009d02:	0006      	movs	r6, r0
 8009d04:	3e1c      	subs	r6, #28
 8009d06:	7836      	ldrb	r6, [r6, #0]
 8009d08:	3201      	adds	r2, #1
 8009d0a:	722e      	strb	r6, [r5, #8]
	WAVEFIL.SUBCHhUNK1ID[_i] = wavebuff[_i+12];
 8009d0c:	0006      	movs	r6, r0
 8009d0e:	3e18      	subs	r6, #24
 8009d10:	7836      	ldrb	r6, [r6, #0]
	WAVEFIL.SUBCHUNK2ID[_i] = wavebuff[_i+36];
 8009d12:	7800      	ldrb	r0, [r0, #0]
	WAVEFIL.SUBCHhUNK1ID[_i] = wavebuff[_i+12];
 8009d14:	732e      	strb	r6, [r5, #12]
	WAVEFIL.SUBCHUNK2ID[_i] = wavebuff[_i+36];
 8009d16:	7008      	strb	r0, [r1, #0]
	for(uint8_t _i=0 ; _i<4 ; _i++)				
 8009d18:	2a28      	cmp	r2, #40	; 0x28
 8009d1a:	d1ea      	bne.n	8009cf2 <READ_WAVE_FILE_HEADER+0x4e>
	WAVEFIL.CHUNKSIZE = (wavebuff[7]<<24)+(wavebuff[6]<<16)+(wavebuff[5]<<8)+wavebuff[4];
 8009d1c:	79e2      	ldrb	r2, [r4, #7]
 8009d1e:	79a1      	ldrb	r1, [r4, #6]
 8009d20:	0612      	lsls	r2, r2, #24
 8009d22:	0409      	lsls	r1, r1, #16
 8009d24:	1852      	adds	r2, r2, r1
 8009d26:	7961      	ldrb	r1, [r4, #5]
 8009d28:	0209      	lsls	r1, r1, #8
 8009d2a:	1852      	adds	r2, r2, r1
 8009d2c:	7921      	ldrb	r1, [r4, #4]
 8009d2e:	1852      	adds	r2, r2, r1
 8009d30:	605a      	str	r2, [r3, #4]
	WAVEFIL.SUBCHUNK1SIZE = (wavebuff[19]<<24)+(wavebuff[18]<<16)+(wavebuff[17]<<8)+wavebuff[16];
 8009d32:	7ce2      	ldrb	r2, [r4, #19]
 8009d34:	7ca1      	ldrb	r1, [r4, #18]
 8009d36:	0612      	lsls	r2, r2, #24
 8009d38:	0409      	lsls	r1, r1, #16
 8009d3a:	1852      	adds	r2, r2, r1
 8009d3c:	7c61      	ldrb	r1, [r4, #17]
 8009d3e:	0209      	lsls	r1, r1, #8
 8009d40:	1852      	adds	r2, r2, r1
 8009d42:	7c21      	ldrb	r1, [r4, #16]
 8009d44:	1852      	adds	r2, r2, r1
 8009d46:	611a      	str	r2, [r3, #16]
 8009d48:	4694      	mov	ip, r2
	WAVEFIL.SUBCHUNK2SIZE = (wavebuff[43]<<24)+(wavebuff[42]<<16)+(wavebuff[41]<<8)+wavebuff[40];
 8009d4a:	0022      	movs	r2, r4
 8009d4c:	322b      	adds	r2, #43	; 0x2b
 8009d4e:	7810      	ldrb	r0, [r2, #0]
 8009d50:	0022      	movs	r2, r4
 8009d52:	322a      	adds	r2, #42	; 0x2a
 8009d54:	7812      	ldrb	r2, [r2, #0]
 8009d56:	0600      	lsls	r0, r0, #24
 8009d58:	0412      	lsls	r2, r2, #16
 8009d5a:	1880      	adds	r0, r0, r2
 8009d5c:	0022      	movs	r2, r4
 8009d5e:	3229      	adds	r2, #41	; 0x29
 8009d60:	7812      	ldrb	r2, [r2, #0]
 8009d62:	0212      	lsls	r2, r2, #8
 8009d64:	1880      	adds	r0, r0, r2
 8009d66:	0022      	movs	r2, r4
 8009d68:	3228      	adds	r2, #40	; 0x28
 8009d6a:	7812      	ldrb	r2, [r2, #0]
 8009d6c:	1880      	adds	r0, r0, r2
 8009d6e:	6298      	str	r0, [r3, #40]	; 0x28
	WAVEFIL.AUDIOFMT = (wavebuff[21]<<8)+wavebuff[20];
 8009d70:	7d62      	ldrb	r2, [r4, #21]
 8009d72:	7d27      	ldrb	r7, [r4, #20]
 8009d74:	0212      	lsls	r2, r2, #8
 8009d76:	18bf      	adds	r7, r7, r2
 8009d78:	b2bf      	uxth	r7, r7
 8009d7a:	829f      	strh	r7, [r3, #20]
	WAVEFIL.NO_CHANNEL = (wavebuff[23]<<8)+wavebuff[22];
 8009d7c:	7de2      	ldrb	r2, [r4, #23]
 8009d7e:	7da6      	ldrb	r6, [r4, #22]
 8009d80:	0212      	lsls	r2, r2, #8
 8009d82:	18b6      	adds	r6, r6, r2
 8009d84:	b2b6      	uxth	r6, r6
 8009d86:	82de      	strh	r6, [r3, #22]
	WAVEFIL.SAMPLERATE = (wavebuff[27]<<24)+(wavebuff[26]<<16)+(wavebuff[25]<<8)+wavebuff[24];
 8009d88:	7ee5      	ldrb	r5, [r4, #27]
 8009d8a:	7ea2      	ldrb	r2, [r4, #26]
 8009d8c:	062d      	lsls	r5, r5, #24
 8009d8e:	0412      	lsls	r2, r2, #16
 8009d90:	18ad      	adds	r5, r5, r2
 8009d92:	7e62      	ldrb	r2, [r4, #25]
 8009d94:	0212      	lsls	r2, r2, #8
 8009d96:	18ad      	adds	r5, r5, r2
 8009d98:	7e22      	ldrb	r2, [r4, #24]
 8009d9a:	18aa      	adds	r2, r5, r2
 8009d9c:	9200      	str	r2, [sp, #0]
 8009d9e:	619a      	str	r2, [r3, #24]
	WAVEFIL.BYTERATE = (wavebuff[31]<<24)+(wavebuff[30]<<16)+(wavebuff[29]<<8)+wavebuff[28];
 8009da0:	7fe1      	ldrb	r1, [r4, #31]
 8009da2:	7fa2      	ldrb	r2, [r4, #30]
 8009da4:	0609      	lsls	r1, r1, #24
 8009da6:	0412      	lsls	r2, r2, #16
 8009da8:	188a      	adds	r2, r1, r2
 8009daa:	7f61      	ldrb	r1, [r4, #29]
 8009dac:	0209      	lsls	r1, r1, #8
 8009dae:	1852      	adds	r2, r2, r1
 8009db0:	7f21      	ldrb	r1, [r4, #28]
 8009db2:	1852      	adds	r2, r2, r1
 8009db4:	61da      	str	r2, [r3, #28]
	WAVEFIL.BLOCKALIGN = (wavebuff[33]<<8)+wavebuff[32];
 8009db6:	1ca2      	adds	r2, r4, #2
 8009db8:	7fd1      	ldrb	r1, [r2, #31]
 8009dba:	1c62      	adds	r2, r4, #1
 8009dbc:	7fd2      	ldrb	r2, [r2, #31]
 8009dbe:	0209      	lsls	r1, r1, #8
 8009dc0:	1852      	adds	r2, r2, r1
 8009dc2:	b292      	uxth	r2, r2
 8009dc4:	9201      	str	r2, [sp, #4]
 8009dc6:	841a      	strh	r2, [r3, #32]
	WAVEFIL.BITPERSAMPLE = (wavebuff[35]<<8)+wavebuff[34];
 8009dc8:	1d22      	adds	r2, r4, #4
 8009dca:	7fd2      	ldrb	r2, [r2, #31]
 8009dcc:	3403      	adds	r4, #3
 8009dce:	7fe1      	ldrb	r1, [r4, #31]
		if(WAVEFIL.CHUNKID[1] != 'R' && WAVEFIL.CHUNKID[1] != 'I' &&  WAVEFIL.CHUNKID[1] != 'F' &&  WAVEFIL.CHUNKID[1] != 'F')	
 8009dd0:	785c      	ldrb	r4, [r3, #1]
	WAVEFIL.BITPERSAMPLE = (wavebuff[35]<<8)+wavebuff[34];
 8009dd2:	0212      	lsls	r2, r2, #8
 8009dd4:	188a      	adds	r2, r1, r2
		if(WAVEFIL.CHUNKID[1] != 'R' && WAVEFIL.CHUNKID[1] != 'I' &&  WAVEFIL.CHUNKID[1] != 'F' &&  WAVEFIL.CHUNKID[1] != 'F')	
 8009dd6:	3c46      	subs	r4, #70	; 0x46
	WAVEFIL.BITPERSAMPLE = (wavebuff[35]<<8)+wavebuff[34];
 8009dd8:	b292      	uxth	r2, r2
		if(WAVEFIL.CHUNKID[1] != 'R' && WAVEFIL.CHUNKID[1] != 'I' &&  WAVEFIL.CHUNKID[1] != 'F' &&  WAVEFIL.CHUNKID[1] != 'F')	
 8009dda:	b2e4      	uxtb	r4, r4
	WAVEFIL.BITPERSAMPLE = (wavebuff[35]<<8)+wavebuff[34];
 8009ddc:	845a      	strh	r2, [r3, #34]	; 0x22
				{return HEADER_CHUNK_FAULT;}
 8009dde:	2103      	movs	r1, #3
		if(WAVEFIL.CHUNKID[1] != 'R' && WAVEFIL.CHUNKID[1] != 'I' &&  WAVEFIL.CHUNKID[1] != 'F' &&  WAVEFIL.CHUNKID[1] != 'F')	
 8009de0:	2c0c      	cmp	r4, #12
 8009de2:	d900      	bls.n	8009de6 <READ_WAVE_FILE_HEADER+0x142>
 8009de4:	e77a      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
 8009de6:	4d32      	ldr	r5, [pc, #200]	; (8009eb0 <READ_WAVE_FILE_HEADER+0x20c>)
 8009de8:	40e5      	lsrs	r5, r4
 8009dea:	002c      	movs	r4, r5
 8009dec:	07e4      	lsls	r4, r4, #31
 8009dee:	d400      	bmi.n	8009df2 <READ_WAVE_FILE_HEADER+0x14e>
 8009df0:	e774      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
		else if (WAVEFIL.FORMAT[1] != 'W' && WAVEFIL.FORMAT[1] != 'A' &&  WAVEFIL.FORMAT[1] != 'V' &&  WAVEFIL.FORMAT[1] != 'E')
 8009df2:	7a5b      	ldrb	r3, [r3, #9]
 8009df4:	2404      	movs	r4, #4
 8009df6:	001d      	movs	r5, r3
 8009df8:	43a5      	bics	r5, r4
 8009dfa:	2d41      	cmp	r5, #65	; 0x41
 8009dfc:	d003      	beq.n	8009e06 <READ_WAVE_FILE_HEADER+0x162>
 8009dfe:	3b56      	subs	r3, #86	; 0x56
 8009e00:	2b01      	cmp	r3, #1
 8009e02:	d900      	bls.n	8009e06 <READ_WAVE_FILE_HEADER+0x162>
 8009e04:	e76a      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
		else if (WAVEFIL.SUBCHhUNK1ID[1] != 'f' && WAVEFIL.SUBCHhUNK1ID[1] != 'm' &&  WAVEFIL.SUBCHhUNK1ID[1] != 't' &&  WAVEFIL.SUBCHhUNK1ID[1] != 0x20)
 8009e06:	4b29      	ldr	r3, [pc, #164]	; (8009eac <READ_WAVE_FILE_HEADER+0x208>)
 8009e08:	7b5b      	ldrb	r3, [r3, #13]
 8009e0a:	0019      	movs	r1, r3
 8009e0c:	3966      	subs	r1, #102	; 0x66
 8009e0e:	b2c9      	uxtb	r1, r1
 8009e10:	290e      	cmp	r1, #14
 8009e12:	d83a      	bhi.n	8009e8a <READ_WAVE_FILE_HEADER+0x1e6>
 8009e14:	4b27      	ldr	r3, [pc, #156]	; (8009eb4 <READ_WAVE_FILE_HEADER+0x210>)
 8009e16:	40cb      	lsrs	r3, r1
				{return HEADER_CHUNK_FAULT;}
 8009e18:	2103      	movs	r1, #3
		else if (WAVEFIL.SUBCHhUNK1ID[1] != 'f' && WAVEFIL.SUBCHhUNK1ID[1] != 'm' &&  WAVEFIL.SUBCHhUNK1ID[1] != 't' &&  WAVEFIL.SUBCHhUNK1ID[1] != 0x20)
 8009e1a:	07db      	lsls	r3, r3, #31
 8009e1c:	d400      	bmi.n	8009e20 <READ_WAVE_FILE_HEADER+0x17c>
 8009e1e:	e75d      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
		else if (WAVEFIL.SUBCHUNK2ID[1] != 'd' && WAVEFIL.SUBCHUNK2ID[1] != 'a' &&  WAVEFIL.SUBCHUNK2ID[1] != 't' &&  WAVEFIL.SUBCHUNK2ID[1] != 'a')
 8009e20:	4b22      	ldr	r3, [pc, #136]	; (8009eac <READ_WAVE_FILE_HEADER+0x208>)
 8009e22:	2110      	movs	r1, #16
 8009e24:	3306      	adds	r3, #6
 8009e26:	7fdb      	ldrb	r3, [r3, #31]
 8009e28:	001c      	movs	r4, r3
 8009e2a:	438c      	bics	r4, r1
 8009e2c:	2c64      	cmp	r4, #100	; 0x64
 8009e2e:	d003      	beq.n	8009e38 <READ_WAVE_FILE_HEADER+0x194>
				{return HEADER_CHUNK_FAULT;}
 8009e30:	2103      	movs	r1, #3
		else if (WAVEFIL.SUBCHUNK2ID[1] != 'd' && WAVEFIL.SUBCHUNK2ID[1] != 'a' &&  WAVEFIL.SUBCHUNK2ID[1] != 't' &&  WAVEFIL.SUBCHUNK2ID[1] != 'a')
 8009e32:	2b61      	cmp	r3, #97	; 0x61
 8009e34:	d000      	beq.n	8009e38 <READ_WAVE_FILE_HEADER+0x194>
 8009e36:	e751      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
				{return HEADER_CHUNK_FAULT;}
 8009e38:	2103      	movs	r1, #3
		else if (WAVEFIL.AUDIOFMT != 1)  // Audio Format != PCM
 8009e3a:	2f01      	cmp	r7, #1
 8009e3c:	d000      	beq.n	8009e40 <READ_WAVE_FILE_HEADER+0x19c>
 8009e3e:	e74d      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
		else if (WAVEFIL.NO_CHANNEL > 2)  // Number of audio channel more than 2 channel
 8009e40:	2e02      	cmp	r6, #2
 8009e42:	d900      	bls.n	8009e46 <READ_WAVE_FILE_HEADER+0x1a2>
 8009e44:	e74a      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
		else if (WAVEFIL.SUBCHUNK1SIZE != 0x10)  // chunk size 2 error must be 16 byte
 8009e46:	4663      	mov	r3, ip
 8009e48:	2b10      	cmp	r3, #16
 8009e4a:	d000      	beq.n	8009e4e <READ_WAVE_FILE_HEADER+0x1aa>
 8009e4c:	e746      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
				{return BITPERSAMPLE_ERR;}
 8009e4e:	3104      	adds	r1, #4
		else if (WAVEFIL.BITPERSAMPLE > 16 ) 		// bit per sample more than 16 bit
 8009e50:	2a10      	cmp	r2, #16
 8009e52:	d900      	bls.n	8009e56 <READ_WAVE_FILE_HEADER+0x1b2>
 8009e54:	e742      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
				WAVE_SIZE	=	WAVEFIL.SUBCHUNK2SIZE + READ_WAVE_BYTES;
 8009e56:	4b18      	ldr	r3, [pc, #96]	; (8009eb8 <READ_WAVE_FILE_HEADER+0x214>)
 8009e58:	4918      	ldr	r1, [pc, #96]	; (8009ebc <READ_WAVE_FILE_HEADER+0x218>)
 8009e5a:	681b      	ldr	r3, [r3, #0]
				WAVE_bytes	= WAVEFIL.SUBCHUNK2SIZE/((WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL);
 8009e5c:	08d4      	lsrs	r4, r2, #3
				WAVE_SIZE	=	WAVEFIL.SUBCHUNK2SIZE + READ_WAVE_BYTES;
 8009e5e:	181b      	adds	r3, r3, r0
 8009e60:	600b      	str	r3, [r1, #0]
				WAVE_bytes	= WAVEFIL.SUBCHUNK2SIZE/((WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL);
 8009e62:	0031      	movs	r1, r6
 8009e64:	4361      	muls	r1, r4
 8009e66:	f7f6 f987 	bl	8000178 <__udivsi3>
				NO_BYTE_SAMPLE =	WAVEFIL.BLOCKALIGN*(WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL;	
 8009e6a:	9a01      	ldr	r2, [sp, #4]
				WAVE_bytes	= WAVEFIL.SUBCHUNK2SIZE/((WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL);
 8009e6c:	4b14      	ldr	r3, [pc, #80]	; (8009ec0 <READ_WAVE_FILE_HEADER+0x21c>)
				NO_BYTE_SAMPLE =	WAVEFIL.BLOCKALIGN*(WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL;	
 8009e6e:	4372      	muls	r2, r6
 8009e70:	4362      	muls	r2, r4
				WAVE_bytes	= WAVEFIL.SUBCHUNK2SIZE/((WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL);
 8009e72:	6018      	str	r0, [r3, #0]
				NO_BYTE_SAMPLE =	WAVEFIL.BLOCKALIGN*(WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL;	
 8009e74:	4b13      	ldr	r3, [pc, #76]	; (8009ec4 <READ_WAVE_FILE_HEADER+0x220>)
				SAMPLETIME = (1000000/WAVEFIL.SAMPLERATE)-20;
 8009e76:	9900      	ldr	r1, [sp, #0]
				NO_BYTE_SAMPLE =	WAVEFIL.BLOCKALIGN*(WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL;	
 8009e78:	701a      	strb	r2, [r3, #0]
				SAMPLETIME = (1000000/WAVEFIL.SAMPLERATE)-20;
 8009e7a:	4813      	ldr	r0, [pc, #76]	; (8009ec8 <READ_WAVE_FILE_HEADER+0x224>)
 8009e7c:	f7f6 f97c 	bl	8000178 <__udivsi3>
 8009e80:	4b12      	ldr	r3, [pc, #72]	; (8009ecc <READ_WAVE_FILE_HEADER+0x228>)
 8009e82:	3814      	subs	r0, #20
 8009e84:	8018      	strh	r0, [r3, #0]
				return HEADER_CHUNK_OK; 
 8009e86:	2102      	movs	r1, #2
 8009e88:	e728      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
				{return HEADER_CHUNK_FAULT;}
 8009e8a:	2103      	movs	r1, #3
		else if (WAVEFIL.SUBCHhUNK1ID[1] != 'f' && WAVEFIL.SUBCHhUNK1ID[1] != 'm' &&  WAVEFIL.SUBCHhUNK1ID[1] != 't' &&  WAVEFIL.SUBCHhUNK1ID[1] != 0x20)
 8009e8c:	2b20      	cmp	r3, #32
 8009e8e:	d0c7      	beq.n	8009e20 <READ_WAVE_FILE_HEADER+0x17c>
 8009e90:	e724      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
		f_close (&_path_pointer);
 8009e92:	0028      	movs	r0, r5
 8009e94:	f005 fa2f 	bl	800f2f6 <f_close>
		return	WAVE_FILE_OPEN_FAILD;
 8009e98:	2104      	movs	r1, #4
 8009e9a:	e71f      	b.n	8009cdc <READ_WAVE_FILE_HEADER+0x38>
 8009e9c:	20001670 	.word	0x20001670
 8009ea0:	200076f8 	.word	0x200076f8
 8009ea4:	20007044 	.word	0x20007044
 8009ea8:	200070d4 	.word	0x200070d4
 8009eac:	20007154 	.word	0x20007154
 8009eb0:	00001009 	.word	0x00001009
 8009eb4:	00004081 	.word	0x00004081
 8009eb8:	20000084 	.word	0x20000084
 8009ebc:	200076d4 	.word	0x200076d4
 8009ec0:	20007150 	.word	0x20007150
 8009ec4:	200077cc 	.word	0x200077cc
 8009ec8:	000f4240 	.word	0x000f4240
 8009ecc:	20007420 	.word	0x20007420

08009ed0 <StreamWaveToPort>:
	  READ_WAVE_BYTES=44;
 8009ed0:	232c      	movs	r3, #44	; 0x2c
{
 8009ed2:	b5f0      	push	{r4, r5, r6, r7, lr}
	  READ_WAVE_BYTES=44;
 8009ed4:	4e58      	ldr	r6, [pc, #352]	; (800a038 <StreamWaveToPort+0x168>)
{
 8009ed6:	b087      	sub	sp, #28
 8009ed8:	9103      	str	r1, [sp, #12]
		SCALE_FAC=1;
 8009eda:	4958      	ldr	r1, [pc, #352]	; (800a03c <StreamWaveToPort+0x16c>)
	  READ_WAVE_BYTES=44;
 8009edc:	6033      	str	r3, [r6, #0]
		SCALE_FAC=1;
 8009ede:	3b2b      	subs	r3, #43	; 0x2b
 8009ee0:	700b      	strb	r3, [r1, #0]
 8009ee2:	469c      	mov	ip, r3
		SCALE_SHIFT=0;
 8009ee4:	2300      	movs	r3, #0
 8009ee6:	4c56      	ldr	r4, [pc, #344]	; (800a040 <StreamWaveToPort+0x170>)
		if (WAVEFIL.NO_CHANNEL == 1 && WAVEFIL.BITPERSAMPLE == 8)
 8009ee8:	4d56      	ldr	r5, [pc, #344]	; (800a044 <StreamWaveToPort+0x174>)
		SCALE_SHIFT=0;
 8009eea:	7023      	strb	r3, [r4, #0]
		if (WAVEFIL.NO_CHANNEL == 1 && WAVEFIL.BITPERSAMPLE == 8)
 8009eec:	8aea      	ldrh	r2, [r5, #22]
 8009eee:	4562      	cmp	r2, ip
 8009ef0:	d116      	bne.n	8009f20 <StreamWaveToPort+0x50>
 8009ef2:	8c6a      	ldrh	r2, [r5, #34]	; 0x22
 8009ef4:	2a08      	cmp	r2, #8
 8009ef6:	d004      	beq.n	8009f02 <StreamWaveToPort+0x32>
		else {return HEADER_CHUNK_FAULT;}
 8009ef8:	3303      	adds	r3, #3
		else if (WAVEFIL.NO_CHANNEL == 1 && WAVEFIL.BITPERSAMPLE == 16)
 8009efa:	2a10      	cmp	r2, #16
 8009efc:	d10d      	bne.n	8009f1a <StreamWaveToPort+0x4a>
				{SCALE_FAC=2;SCALE_SHIFT=0;} 		//read sample MSB from channel
 8009efe:	3b01      	subs	r3, #1
 8009f00:	700b      	strb	r3, [r1, #0]
		if (f_open (&_path_pointer,Wave_Path,FA_READ)!=FR_OK) {
 8009f02:	4c51      	ldr	r4, [pc, #324]	; (800a048 <StreamWaveToPort+0x178>)
 8009f04:	0001      	movs	r1, r0
 8009f06:	2201      	movs	r2, #1
 8009f08:	0020      	movs	r0, r4
 8009f0a:	f004 ff27 	bl	800ed5c <f_open>
 8009f0e:	1e07      	subs	r7, r0, #0
 8009f10:	d016      	beq.n	8009f40 <StreamWaveToPort+0x70>
			f_close(&_path_pointer);
 8009f12:	0020      	movs	r0, r4
 8009f14:	f005 f9ef 	bl	800f2f6 <f_close>
			return	WAVE_FILE_OPEN_FAILD;
 8009f18:	2304      	movs	r3, #4
}
 8009f1a:	0018      	movs	r0, r3
 8009f1c:	b007      	add	sp, #28
 8009f1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		else {return HEADER_CHUNK_FAULT;}
 8009f20:	2303      	movs	r3, #3
		else if (WAVEFIL.NO_CHANNEL == 2 && WAVEFIL.BITPERSAMPLE == 8)
 8009f22:	2a02      	cmp	r2, #2
 8009f24:	d1f9      	bne.n	8009f1a <StreamWaveToPort+0x4a>
 8009f26:	8c6f      	ldrh	r7, [r5, #34]	; 0x22
 8009f28:	2f08      	cmp	r7, #8
 8009f2a:	d103      	bne.n	8009f34 <StreamWaveToPort+0x64>
				{SCALE_FAC=2;SCALE_SHIFT=1;}			//read sample from right channel
 8009f2c:	4663      	mov	r3, ip
 8009f2e:	700a      	strb	r2, [r1, #0]
 8009f30:	7023      	strb	r3, [r4, #0]
 8009f32:	e7e6      	b.n	8009f02 <StreamWaveToPort+0x32>
		else if (WAVEFIL.NO_CHANNEL == 2 && WAVEFIL.BITPERSAMPLE == 16)
 8009f34:	2f10      	cmp	r7, #16
 8009f36:	d1f0      	bne.n	8009f1a <StreamWaveToPort+0x4a>
				{SCALE_FAC=4;SCALE_SHIFT=2;}			//read sample from MSB right channel
 8009f38:	2304      	movs	r3, #4
 8009f3a:	7022      	strb	r2, [r4, #0]
 8009f3c:	700b      	strb	r3, [r1, #0]
 8009f3e:	e7e0      	b.n	8009f02 <StreamWaveToPort+0x32>
			_wave_pointer=_path_pointer;
 8009f40:	4b42      	ldr	r3, [pc, #264]	; (800a04c <StreamWaveToPort+0x17c>)
 8009f42:	cc07      	ldmia	r4!, {r0, r1, r2}
 8009f44:	c307      	stmia	r3!, {r0, r1, r2}
 8009f46:	cc07      	ldmia	r4!, {r0, r1, r2}
 8009f48:	c307      	stmia	r3!, {r0, r1, r2}
 8009f4a:	cc07      	ldmia	r4!, {r0, r1, r2}
 8009f4c:	c307      	stmia	r3!, {r0, r1, r2}
 8009f4e:	cc07      	ldmia	r4!, {r0, r1, r2}
 8009f50:	c307      	stmia	r3!, {r0, r1, r2}
		__TIM16_CLK_ENABLE();	
 8009f52:	2080      	movs	r0, #128	; 0x80
 8009f54:	4a3e      	ldr	r2, [pc, #248]	; (800a050 <StreamWaveToPort+0x180>)
 8009f56:	0280      	lsls	r0, r0, #10
 8009f58:	6991      	ldr	r1, [r2, #24]
		htim16.Instance = TIM16;
 8009f5a:	4c3e      	ldr	r4, [pc, #248]	; (800a054 <StreamWaveToPort+0x184>)
		__TIM16_CLK_ENABLE();	
 8009f5c:	4301      	orrs	r1, r0
 8009f5e:	6191      	str	r1, [r2, #24]
 8009f60:	6993      	ldr	r3, [r2, #24]
 8009f62:	4003      	ands	r3, r0
 8009f64:	9305      	str	r3, [sp, #20]
 8009f66:	9b05      	ldr	r3, [sp, #20]
		htim16.Instance = TIM16;
 8009f68:	4b3b      	ldr	r3, [pc, #236]	; (800a058 <StreamWaveToPort+0x188>)
 8009f6a:	6023      	str	r3, [r4, #0]
		htim16.Init.Prescaler = 0;
 8009f6c:	6067      	str	r7, [r4, #4]
		htim16.Init.Period = (uint16_t)((SystemCoreClock/WAVEFIL.SAMPLERATE)-1);
 8009f6e:	4b3b      	ldr	r3, [pc, #236]	; (800a05c <StreamWaveToPort+0x18c>)
 8009f70:	69a9      	ldr	r1, [r5, #24]
 8009f72:	6818      	ldr	r0, [r3, #0]
		htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
 8009f74:	60a7      	str	r7, [r4, #8]
		htim16.Init.Period = (uint16_t)((SystemCoreClock/WAVEFIL.SAMPLERATE)-1);
 8009f76:	f7f6 f8ff 	bl	8000178 <__udivsi3>
 8009f7a:	3801      	subs	r0, #1
 8009f7c:	b280      	uxth	r0, r0
 8009f7e:	60e0      	str	r0, [r4, #12]
		HAL_TIM_Base_Init(&htim16);
 8009f80:	0020      	movs	r0, r4
 8009f82:	f009 fb8f 	bl	80136a4 <HAL_TIM_Base_Init>
		HAL_NVIC_SetPriority(TIM16_IRQn, 1, 0);
 8009f86:	003a      	movs	r2, r7
 8009f88:	2101      	movs	r1, #1
 8009f8a:	2015      	movs	r0, #21
 8009f8c:	f007 fad8 	bl	8011540 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM16_IRQn);
 8009f90:	2015      	movs	r0, #21
 8009f92:	f007 faff 	bl	8011594 <HAL_NVIC_EnableIRQ>
		HAL_TIM_Base_Start_IT(&htim16);
 8009f96:	0020      	movs	r0, r4
 8009f98:	f009 fa7e 	bl	8013498 <HAL_TIM_Base_Start_IT>
		portENTER_CRITICAL();
 8009f9c:	f007 f966 	bl	801126c <vPortEnterCritical>
      f_lseek (&_path_pointer,READ_WAVE_BYTES);
 8009fa0:	4c29      	ldr	r4, [pc, #164]	; (800a048 <StreamWaveToPort+0x178>)
 8009fa2:	6831      	ldr	r1, [r6, #0]
 8009fa4:	0020      	movs	r0, r4
 8009fa6:	f005 f9be 	bl	800f326 <f_lseek>
			f_read (&_path_pointer, &WaveAlignBuff, 500,  &Number_br);
 8009faa:	22fa      	movs	r2, #250	; 0xfa
 8009fac:	0020      	movs	r0, r4
 8009fae:	4b2c      	ldr	r3, [pc, #176]	; (800a060 <StreamWaveToPort+0x190>)
 8009fb0:	0052      	lsls	r2, r2, #1
 8009fb2:	492c      	ldr	r1, [pc, #176]	; (800a064 <StreamWaveToPort+0x194>)
 8009fb4:	f004 ffde 	bl	800ef74 <f_read>
			for(uint8_t Align=0 ; Align<WAVEFIL.BLOCKALIGN ;Align++)
 8009fb8:	2400      	movs	r4, #0
 8009fba:	8c2b      	ldrh	r3, [r5, #32]
 8009fbc:	42a3      	cmp	r3, r4
 8009fbe:	d818      	bhi.n	8009ff2 <StreamWaveToPort+0x122>
			READ_WAVE_BYTES +=500;
 8009fc0:	6833      	ldr	r3, [r6, #0]
		} while(READ_WAVE_BYTES <= WAVE_SIZE);
 8009fc2:	4c29      	ldr	r4, [pc, #164]	; (800a068 <StreamWaveToPort+0x198>)
			READ_WAVE_BYTES +=500;
 8009fc4:	33f5      	adds	r3, #245	; 0xf5
		} while(READ_WAVE_BYTES <= WAVE_SIZE);
 8009fc6:	6822      	ldr	r2, [r4, #0]
			READ_WAVE_BYTES +=500;
 8009fc8:	33ff      	adds	r3, #255	; 0xff
 8009fca:	6033      	str	r3, [r6, #0]
		} while(READ_WAVE_BYTES <= WAVE_SIZE);
 8009fcc:	4293      	cmp	r3, r2
 8009fce:	d9e7      	bls.n	8009fa0 <StreamWaveToPort+0xd0>
  	portEXIT_CRITICAL();
 8009fd0:	f007 f958 	bl	8011284 <vPortExitCritical>
		f_close (&_wave_pointer);
 8009fd4:	481d      	ldr	r0, [pc, #116]	; (800a04c <StreamWaveToPort+0x17c>)
 8009fd6:	f005 f98e 	bl	800f2f6 <f_close>
		HAL_TIM_Base_Stop(&htim16);
 8009fda:	481e      	ldr	r0, [pc, #120]	; (800a054 <StreamWaveToPort+0x184>)
 8009fdc:	f009 fa42 	bl	8013464 <HAL_TIM_Base_Stop>
		Delay_ms(20);
 8009fe0:	2014      	movs	r0, #20
 8009fe2:	f007 fa93 	bl	801150c <HAL_Delay>
		WAVE_bytes = 0;
 8009fe6:	2300      	movs	r3, #0
 8009fe8:	4a20      	ldr	r2, [pc, #128]	; (800a06c <StreamWaveToPort+0x19c>)
		WAVE_SIZE = 0;
 8009fea:	6023      	str	r3, [r4, #0]
		WAVE_bytes = 0;
 8009fec:	6013      	str	r3, [r2, #0]
		return STREAM_WAVE_OK;
 8009fee:	3306      	adds	r3, #6
 8009ff0:	e793      	b.n	8009f1a <StreamWaveToPort+0x4a>
				for( I=0 ; I<500 ;I++)
 8009ff2:	2200      	movs	r2, #0
 8009ff4:	4b1e      	ldr	r3, [pc, #120]	; (800a070 <StreamWaveToPort+0x1a0>)
 8009ff6:	801a      	strh	r2, [r3, #0]
 8009ff8:	4f1d      	ldr	r7, [pc, #116]	; (800a070 <StreamWaveToPort+0x1a0>)
 8009ffa:	2300      	movs	r3, #0
 8009ffc:	5ef9      	ldrsh	r1, [r7, r3]
 8009ffe:	23f4      	movs	r3, #244	; 0xf4
 800a000:	33ff      	adds	r3, #255	; 0xff
 800a002:	4299      	cmp	r1, r3
 800a004:	dd08      	ble.n	800a018 <StreamWaveToPort+0x148>
				while (__HAL_TIM_GET_FLAG(&htim16, TIM_FLAG_UPDATE) == false){};
 800a006:	4b13      	ldr	r3, [pc, #76]	; (800a054 <StreamWaveToPort+0x184>)
 800a008:	681a      	ldr	r2, [r3, #0]
 800a00a:	2101      	movs	r1, #1
 800a00c:	6913      	ldr	r3, [r2, #16]
 800a00e:	420b      	tst	r3, r1
 800a010:	d0fb      	beq.n	800a00a <StreamWaveToPort+0x13a>
			for(uint8_t Align=0 ; Align<WAVEFIL.BLOCKALIGN ;Align++)
 800a012:	1864      	adds	r4, r4, r1
 800a014:	b2e4      	uxtb	r4, r4
 800a016:	e7d0      	b.n	8009fba <StreamWaveToPort+0xea>
				writePxMutex(_port,(char *) &WaveAlignBuff[I],1,0,0);
 800a018:	4b12      	ldr	r3, [pc, #72]	; (800a064 <StreamWaveToPort+0x194>)
 800a01a:	2201      	movs	r2, #1
 800a01c:	18c9      	adds	r1, r1, r3
 800a01e:	2300      	movs	r3, #0
 800a020:	9803      	ldr	r0, [sp, #12]
 800a022:	9300      	str	r3, [sp, #0]
 800a024:	f003 f9f8 	bl	800d418 <writePxMutex>
				Delay_us(SAMPLETIME);
 800a028:	4b12      	ldr	r3, [pc, #72]	; (800a074 <StreamWaveToPort+0x1a4>)
 800a02a:	8818      	ldrh	r0, [r3, #0]
 800a02c:	f003 f86c 	bl	800d108 <StartMicroDelay>
				for( I=0 ; I<500 ;I++)
 800a030:	883b      	ldrh	r3, [r7, #0]
 800a032:	3301      	adds	r3, #1
 800a034:	803b      	strh	r3, [r7, #0]
 800a036:	e7df      	b.n	8009ff8 <StreamWaveToPort+0x128>
 800a038:	20000084 	.word	0x20000084
 800a03c:	20000088 	.word	0x20000088
 800a040:	2000166c 	.word	0x2000166c
 800a044:	20007154 	.word	0x20007154
 800a048:	200076f8 	.word	0x200076f8
 800a04c:	20007188 	.word	0x20007188
 800a050:	40021000 	.word	0x40021000
 800a054:	20007840 	.word	0x20007840
 800a058:	40014400 	.word	0x40014400
 800a05c:	200000a0 	.word	0x200000a0
 800a060:	200070d4 	.word	0x200070d4
 800a064:	200071b8 	.word	0x200071b8
 800a068:	200076d4 	.word	0x200076d4
 800a06c:	20007150 	.word	0x20007150
 800a070:	200077ca 	.word	0x200077ca
 800a074:	20007420 	.word	0x20007420

0800a078 <ScanWaveFile>:
{
 800a078:	b570      	push	{r4, r5, r6, lr}
 800a07a:	0004      	movs	r4, r0
 800a07c:	000d      	movs	r5, r1
	  while(f_mount_ok==0){Delay_us(10);}		// Add a flag to allow card to be initialized on startup
 800a07e:	4b20      	ldr	r3, [pc, #128]	; (800a100 <ScanWaveFile+0x88>)
 800a080:	781b      	ldrb	r3, [r3, #0]
 800a082:	2b00      	cmp	r3, #0
 800a084:	d02f      	beq.n	800a0e6 <ScanWaveFile+0x6e>
	result = READ_WAVE_FILE_HEADER(Wave_Full_Name);
 800a086:	0020      	movs	r0, r4
 800a088:	f7ff fe0c 	bl	8009ca4 <READ_WAVE_FILE_HEADER>
 800a08c:	4b1d      	ldr	r3, [pc, #116]	; (800a104 <ScanWaveFile+0x8c>)
 800a08e:	0004      	movs	r4, r0
	if(result == HEADER_CHUNK_OK)
 800a090:	2802      	cmp	r0, #2
 800a092:	d12c      	bne.n	800a0ee <ScanWaveFile+0x76>
		messageParams[0]=(uint8_t) (WAVE_bytes>>24);
 800a094:	4a1c      	ldr	r2, [pc, #112]	; (800a108 <ScanWaveFile+0x90>)
 800a096:	6812      	ldr	r2, [r2, #0]
 800a098:	0e11      	lsrs	r1, r2, #24
 800a09a:	7019      	strb	r1, [r3, #0]
		messageParams[1]=(uint8_t) (WAVE_bytes>>16);
 800a09c:	0c11      	lsrs	r1, r2, #16
 800a09e:	7059      	strb	r1, [r3, #1]
		messageParams[3]=(uint8_t)  WAVE_bytes;
 800a0a0:	70da      	strb	r2, [r3, #3]
		messageParams[2]=(uint8_t) (WAVE_bytes>>8);
 800a0a2:	0a11      	lsrs	r1, r2, #8
		messageParams[4]=(uint8_t) (WAVEFIL.SAMPLERATE>>24);
 800a0a4:	4a19      	ldr	r2, [pc, #100]	; (800a10c <ScanWaveFile+0x94>)
		messageParams[2]=(uint8_t) (WAVE_bytes>>8);
 800a0a6:	7099      	strb	r1, [r3, #2]
		messageParams[4]=(uint8_t) (WAVEFIL.SAMPLERATE>>24);
 800a0a8:	6992      	ldr	r2, [r2, #24]
 800a0aa:	0e11      	lsrs	r1, r2, #24
 800a0ac:	7119      	strb	r1, [r3, #4]
		messageParams[5]=(uint8_t) (WAVEFIL.SAMPLERATE>>16);
 800a0ae:	0c11      	lsrs	r1, r2, #16
 800a0b0:	7159      	strb	r1, [r3, #5]
		messageParams[6]=(uint8_t) (WAVEFIL.SAMPLERATE>>8);
 800a0b2:	0a11      	lsrs	r1, r2, #8
 800a0b4:	7199      	strb	r1, [r3, #6]
	IND_blink(100);
 800a0b6:	2180      	movs	r1, #128	; 0x80
		messageParams[7]=(uint8_t) 0xFF;
 800a0b8:	71da      	strb	r2, [r3, #7]
	IND_blink(100);
 800a0ba:	01c9      	lsls	r1, r1, #7
 800a0bc:	2201      	movs	r2, #1
 800a0be:	4814      	ldr	r0, [pc, #80]	; (800a110 <ScanWaveFile+0x98>)
 800a0c0:	f008 f92e 	bl	8012320 <HAL_GPIO_WritePin>
 800a0c4:	2064      	movs	r0, #100	; 0x64
 800a0c6:	f007 fa21 	bl	801150c <HAL_Delay>
 800a0ca:	2180      	movs	r1, #128	; 0x80
 800a0cc:	2200      	movs	r2, #0
 800a0ce:	01c9      	lsls	r1, r1, #7
 800a0d0:	480f      	ldr	r0, [pc, #60]	; (800a110 <ScanWaveFile+0x98>)
 800a0d2:	f008 f925 	bl	8012320 <HAL_GPIO_WritePin>
	SendMessageToModule(H07R3x_ID, CODE_H07R3_SCAN_WAVE_RESPONSE,8);
 800a0d6:	2162      	movs	r1, #98	; 0x62
 800a0d8:	0028      	movs	r0, r5
 800a0da:	2208      	movs	r2, #8
 800a0dc:	31ff      	adds	r1, #255	; 0xff
 800a0de:	f7fd ff25 	bl	8007f2c <SendMessageToModule>
}
 800a0e2:	0020      	movs	r0, r4
 800a0e4:	bd70      	pop	{r4, r5, r6, pc}
	  while(f_mount_ok==0){Delay_us(10);}		// Add a flag to allow card to be initialized on startup
 800a0e6:	200a      	movs	r0, #10
 800a0e8:	f003 f80e 	bl	800d108 <StartMicroDelay>
 800a0ec:	e7c7      	b.n	800a07e <ScanWaveFile+0x6>
		messageParams[0]=(uint8_t) 0xFF;
 800a0ee:	22ff      	movs	r2, #255	; 0xff
 800a0f0:	701a      	strb	r2, [r3, #0]
		messageParams[1]=(uint8_t) 0xFF;
 800a0f2:	705a      	strb	r2, [r3, #1]
		messageParams[2]=(uint8_t) 0xFF;
 800a0f4:	709a      	strb	r2, [r3, #2]
		messageParams[3]=(uint8_t) 0xFF;
 800a0f6:	70da      	strb	r2, [r3, #3]
		messageParams[4]=(uint8_t) 0xFF;
 800a0f8:	711a      	strb	r2, [r3, #4]
		messageParams[5]=(uint8_t) 0xFF;
 800a0fa:	715a      	strb	r2, [r3, #5]
		messageParams[6]=(uint8_t) 0xFF;
 800a0fc:	719a      	strb	r2, [r3, #6]
 800a0fe:	e7da      	b.n	800a0b6 <ScanWaveFile+0x3e>
 800a100:	20001670 	.word	0x20001670
 800a104:	20000f07 	.word	0x20000f07
 800a108:	20007150 	.word	0x20007150
 800a10c:	20007154 	.word	0x20007154
 800a110:	48000400 	.word	0x48000400

0800a114 <CreateLog>:
{ 
 800a114:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a116:	b08b      	sub	sp, #44	; 0x2c
 800a118:	9308      	str	r3, [sp, #32]
 800a11a:	ab10      	add	r3, sp, #64	; 0x40
 800a11c:	781b      	ldrb	r3, [r3, #0]
 800a11e:	9002      	str	r0, [sp, #8]
 800a120:	9105      	str	r1, [sp, #20]
 800a122:	9206      	str	r2, [sp, #24]
 800a124:	9309      	str	r3, [sp, #36]	; 0x24
  while(f_mount_ok==0){Delay_ms_no_rtos(1);}  // Add a flag to allow card to be initialized on startup
 800a126:	4bc3      	ldr	r3, [pc, #780]	; (800a434 <CreateLog+0x320>)
 800a128:	781b      	ldrb	r3, [r3, #0]
 800a12a:	2b00      	cmp	r3, #0
 800a12c:	d055      	beq.n	800a1da <CreateLog+0xc6>
	for( i=0 ; i<MAX_LOGS ; i++)
 800a12e:	25a0      	movs	r5, #160	; 0xa0
 800a130:	2400      	movs	r4, #0
 800a132:	006d      	lsls	r5, r5, #1
		if((0U != logs[i].current_extension)  && (true == enableSequential))
 800a134:	4ac0      	ldr	r2, [pc, #768]	; (800a438 <CreateLog+0x324>)
 800a136:	18a2      	adds	r2, r4, r2
 800a138:	7953      	ldrb	r3, [r2, #5]
 800a13a:	6812      	ldr	r2, [r2, #0]
 800a13c:	2b00      	cmp	r3, #0
 800a13e:	d050      	beq.n	800a1e2 <CreateLog+0xce>
 800a140:	49be      	ldr	r1, [pc, #760]	; (800a43c <CreateLog+0x328>)
 800a142:	7809      	ldrb	r1, [r1, #0]
 800a144:	2900      	cmp	r1, #0
 800a146:	d04c      	beq.n	800a1e2 <CreateLog+0xce>
			sprintf(tempName, "%s_%d", logs[i].name, logs[i].current_extension);
 800a148:	49bd      	ldr	r1, [pc, #756]	; (800a440 <CreateLog+0x32c>)
 800a14a:	48be      	ldr	r0, [pc, #760]	; (800a444 <CreateLog+0x330>)
 800a14c:	f00a fc86 	bl	8014a5c <sprintf>
		if(!strcmp(tempName, logName))
 800a150:	9902      	ldr	r1, [sp, #8]
 800a152:	48bc      	ldr	r0, [pc, #752]	; (800a444 <CreateLog+0x330>)
 800a154:	f7f5 ffd6 	bl	8000104 <strcmp>
 800a158:	2800      	cmp	r0, #0
 800a15a:	d079      	beq.n	800a250 <CreateLog+0x13c>
 800a15c:	3420      	adds	r4, #32
	for( i=0 ; i<MAX_LOGS ; i++)
 800a15e:	42ac      	cmp	r4, r5
 800a160:	d1e8      	bne.n	800a134 <CreateLog+0x20>
	if ( (type != RATE && type != EVENT)	||
 800a162:	9b05      	ldr	r3, [sp, #20]
		return H1BR6_ERR_WrongParams;				
 800a164:	2403      	movs	r4, #3
	if ( (type != RATE && type != EVENT)	||
 800a166:	3b01      	subs	r3, #1
 800a168:	2b01      	cmp	r3, #1
 800a16a:	d900      	bls.n	800a16e <CreateLog+0x5a>
 800a16c:	e081      	b.n	800a272 <CreateLog+0x15e>
 800a16e:	9b08      	ldr	r3, [sp, #32]
 800a170:	3b01      	subs	r3, #1
 800a172:	2b02      	cmp	r3, #2
 800a174:	d87d      	bhi.n	800a272 <CreateLog+0x15e>
			 (delimiterFormat != FMT_SPACE && delimiterFormat != FMT_TAB && delimiterFormat != FMT_COMMA)	||
 800a176:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a178:	2b02      	cmp	r3, #2
 800a17a:	d87a      	bhi.n	800a272 <CreateLog+0x15e>
			 (indexColumnFormat != FMT_NONE && indexColumnFormat != FMT_SAMPLE && indexColumnFormat != FMT_TIME)	||
 800a17c:	49b2      	ldr	r1, [pc, #712]	; (800a448 <CreateLog+0x334>)
 800a17e:	9806      	ldr	r0, [sp, #24]
 800a180:	f7f6 f9e0 	bl	8000544 <__aeabi_fcmpgt>
 800a184:	2800      	cmp	r0, #0
 800a186:	d174      	bne.n	800a272 <CreateLog+0x15e>
		if(logs[i].name == 0)
 800a188:	4bab      	ldr	r3, [pc, #684]	; (800a438 <CreateLog+0x324>)
			 (indexColumnFormat != FMT_NONE && indexColumnFormat != FMT_SAMPLE && indexColumnFormat != FMT_TIME)	||
 800a18a:	9004      	str	r0, [sp, #16]
		if(logs[i].name == 0)
 800a18c:	9a04      	ldr	r2, [sp, #16]
 800a18e:	0152      	lsls	r2, r2, #5
 800a190:	589c      	ldr	r4, [r3, r2]
 800a192:	2c00      	cmp	r4, #0
 800a194:	d000      	beq.n	800a198 <CreateLog+0x84>
 800a196:	e141      	b.n	800a41c <CreateLog+0x308>
			if (true == enableSequential)
 800a198:	4ba8      	ldr	r3, [pc, #672]	; (800a43c <CreateLog+0x328>)
 800a19a:	781b      	ldrb	r3, [r3, #0]
 800a19c:	9303      	str	r3, [sp, #12]
 800a19e:	2b00      	cmp	r3, #0
 800a1a0:	d058      	beq.n	800a254 <CreateLog+0x140>
				pChar = strchr(logName , '_');
 800a1a2:	215f      	movs	r1, #95	; 0x5f
 800a1a4:	9802      	ldr	r0, [sp, #8]
 800a1a6:	f00a fc87 	bl	8014ab8 <strchr>
					pChar = strchr(pChar + 1 , '_');
 800a1aa:	255f      	movs	r5, #95	; 0x5f
				pChar = strchr(logName , '_');
 800a1ac:	0007      	movs	r7, r0
				while (pChar != NULL)
 800a1ae:	2f00      	cmp	r7, #0
 800a1b0:	d11c      	bne.n	800a1ec <CreateLog+0xd8>
				if(0 != position)
 800a1b2:	2c00      	cmp	r4, #0
 800a1b4:	d032      	beq.n	800a21c <CreateLog+0x108>
					pChar = logName + position;
 800a1b6:	9b02      	ldr	r3, [sp, #8]
 800a1b8:	191d      	adds	r5, r3, r4
					length = strlen(pChar);
 800a1ba:	0028      	movs	r0, r5
 800a1bc:	f7f5 ffac 	bl	8000118 <strlen>
							countFile += ((uint8_t)(*pChar - 0x30) * numberMap[length - 1]);
 800a1c0:	4aa2      	ldr	r2, [pc, #648]	; (800a44c <CreateLog+0x338>)
					length = strlen(pChar);
 800a1c2:	b2c0      	uxtb	r0, r0
					while ('\0' != (char)*pChar)
 800a1c4:	782b      	ldrb	r3, [r5, #0]
 800a1c6:	2b00      	cmp	r3, #0
 800a1c8:	d11a      	bne.n	800a200 <CreateLog+0xec>
				if (countFile != 0)
 800a1ca:	2f00      	cmp	r7, #0
 800a1cc:	d048      	beq.n	800a260 <CreateLog+0x14c>
					logs[i].current_extension = countFile ;
 800a1ce:	9b04      	ldr	r3, [sp, #16]
 800a1d0:	015a      	lsls	r2, r3, #5
 800a1d2:	4b99      	ldr	r3, [pc, #612]	; (800a438 <CreateLog+0x324>)
 800a1d4:	189b      	adds	r3, r3, r2
 800a1d6:	715f      	strb	r7, [r3, #5]
 800a1d8:	e027      	b.n	800a22a <CreateLog+0x116>
  while(f_mount_ok==0){Delay_ms_no_rtos(1);}  // Add a flag to allow card to be initialized on startup
 800a1da:	2001      	movs	r0, #1
 800a1dc:	f002 ffa6 	bl	800d12c <StartMilliDelay>
 800a1e0:	e7a1      	b.n	800a126 <CreateLog+0x12>
			sprintf(tempName, "%s", logs[i].name);
 800a1e2:	0011      	movs	r1, r2
 800a1e4:	4897      	ldr	r0, [pc, #604]	; (800a444 <CreateLog+0x330>)
 800a1e6:	f00a fc75 	bl	8014ad4 <strcpy>
 800a1ea:	e7b1      	b.n	800a150 <CreateLog+0x3c>
					position = (uint8_t)((uint32_t)pChar - (uint32_t)logName + 1UL);
 800a1ec:	9b02      	ldr	r3, [sp, #8]
					pChar = strchr(pChar + 1 , '_');
 800a1ee:	1c78      	adds	r0, r7, #1
 800a1f0:	0029      	movs	r1, r5
					position = (uint8_t)((uint32_t)pChar - (uint32_t)logName + 1UL);
 800a1f2:	1afc      	subs	r4, r7, r3
					pChar = strchr(pChar + 1 , '_');
 800a1f4:	f00a fc60 	bl	8014ab8 <strchr>
					position = (uint8_t)((uint32_t)pChar - (uint32_t)logName + 1UL);
 800a1f8:	3401      	adds	r4, #1
 800a1fa:	b2e4      	uxtb	r4, r4
					pChar = strchr(pChar + 1 , '_');
 800a1fc:	0007      	movs	r7, r0
 800a1fe:	e7d6      	b.n	800a1ae <CreateLog+0x9a>
						if((0x30 <= *pChar) && (*pChar <= 0x39))
 800a200:	3b30      	subs	r3, #48	; 0x30
 800a202:	b2d9      	uxtb	r1, r3
 800a204:	2909      	cmp	r1, #9
 800a206:	d828      	bhi.n	800a25a <CreateLog+0x146>
							countFile += ((uint8_t)(*pChar - 0x30) * numberMap[length - 1]);
 800a208:	1813      	adds	r3, r2, r0
 800a20a:	3b01      	subs	r3, #1
 800a20c:	781b      	ldrb	r3, [r3, #0]
						length--;
 800a20e:	3801      	subs	r0, #1
							countFile += ((uint8_t)(*pChar - 0x30) * numberMap[length - 1]);
 800a210:	434b      	muls	r3, r1
 800a212:	18ff      	adds	r7, r7, r3
 800a214:	b2ff      	uxtb	r7, r7
						pChar++;
 800a216:	3501      	adds	r5, #1
						length--;
 800a218:	b2c0      	uxtb	r0, r0
 800a21a:	e7d3      	b.n	800a1c4 <CreateLog+0xb0>
					countFile = 0;
 800a21c:	0027      	movs	r7, r4
					logs[i].current_extension = 0;
 800a21e:	9b04      	ldr	r3, [sp, #16]
					extensionFile = false;
 800a220:	9403      	str	r4, [sp, #12]
					logs[i].current_extension = 0;
 800a222:	015a      	lsls	r2, r3, #5
 800a224:	4b84      	ldr	r3, [pc, #528]	; (800a438 <CreateLog+0x324>)
 800a226:	189b      	adds	r3, r3, r2
 800a228:	715c      	strb	r4, [r3, #5]
			sprintf((char *)tempName, "%s%s", logName, ".TXT");
 800a22a:	4d86      	ldr	r5, [pc, #536]	; (800a444 <CreateLog+0x330>)
 800a22c:	4b88      	ldr	r3, [pc, #544]	; (800a450 <CreateLog+0x33c>)
 800a22e:	9a02      	ldr	r2, [sp, #8]
 800a230:	4988      	ldr	r1, [pc, #544]	; (800a454 <CreateLog+0x340>)
 800a232:	0028      	movs	r0, r5
 800a234:	f00a fc12 	bl	8014a5c <sprintf>
			res = f_open(&tempFile, tempName, FA_CREATE_NEW | FA_WRITE | FA_READ);
 800a238:	2207      	movs	r2, #7
 800a23a:	0029      	movs	r1, r5
 800a23c:	4886      	ldr	r0, [pc, #536]	; (800a458 <CreateLog+0x344>)
 800a23e:	f004 fd8d 	bl	800ed5c <f_open>
			if ((false == enableSequential) && (res == FR_EXIST))
 800a242:	4b7e      	ldr	r3, [pc, #504]	; (800a43c <CreateLog+0x328>)
 800a244:	781b      	ldrb	r3, [r3, #0]
 800a246:	2b00      	cmp	r3, #0
 800a248:	d10d      	bne.n	800a266 <CreateLog+0x152>
 800a24a:	2808      	cmp	r0, #8
 800a24c:	d000      	beq.n	800a250 <CreateLog+0x13c>
 800a24e:	e0ed      	b.n	800a42c <CreateLog+0x318>
			return H1BR6_ERR_LogNameExists;
 800a250:	2402      	movs	r4, #2
 800a252:	e00e      	b.n	800a272 <CreateLog+0x15e>
	uint8_t position = 0;
 800a254:	9c03      	ldr	r4, [sp, #12]
	uint8_t countFile = 0;
 800a256:	0027      	movs	r7, r4
 800a258:	e7e7      	b.n	800a22a <CreateLog+0x116>
	uint8_t position = 0;
 800a25a:	2400      	movs	r4, #0
	bool extensionFile = false;
 800a25c:	9403      	str	r4, [sp, #12]
 800a25e:	e7fa      	b.n	800a256 <CreateLog+0x142>
					position = 0;
 800a260:	003c      	movs	r4, r7
					extensionFile = false;
 800a262:	9703      	str	r7, [sp, #12]
 800a264:	e7e1      	b.n	800a22a <CreateLog+0x116>
			else if ((res != FR_OK) && (FR_EXIST != res))
 800a266:	2800      	cmp	r0, #0
 800a268:	d03b      	beq.n	800a2e2 <CreateLog+0x1ce>
 800a26a:	2500      	movs	r5, #0
 800a26c:	2808      	cmp	r0, #8
 800a26e:	d018      	beq.n	800a2a2 <CreateLog+0x18e>
				return H1BR6_ERR_SD;
 800a270:	2404      	movs	r4, #4
}
 800a272:	0020      	movs	r0, r4
 800a274:	b00b      	add	sp, #44	; 0x2c
 800a276:	bdf0      	pop	{r4, r5, r6, r7, pc}
						strncpy(tempName, logName, (size_t)((uint32_t)position - 1));
 800a278:	9902      	ldr	r1, [sp, #8]
 800a27a:	1e62      	subs	r2, r4, #1
 800a27c:	0030      	movs	r0, r6
 800a27e:	f00a fc42 	bl	8014b06 <strncpy>
 800a282:	4973      	ldr	r1, [pc, #460]	; (800a450 <CreateLog+0x33c>)
						if(0U == countFile)
 800a284:	2d00      	cmp	r5, #0
 800a286:	d122      	bne.n	800a2ce <CreateLog+0x1ba>
							strncat ((char *)tempName, ".TXT", 4);
 800a288:	0030      	movs	r0, r6
 800a28a:	f00a fc07 	bl	8014a9c <strcat>
					res = f_open(&tempFile, tempName, FA_CREATE_NEW | FA_WRITE | FA_READ);
 800a28e:	2207      	movs	r2, #7
 800a290:	496c      	ldr	r1, [pc, #432]	; (800a444 <CreateLog+0x330>)
 800a292:	4871      	ldr	r0, [pc, #452]	; (800a458 <CreateLog+0x344>)
 800a294:	f004 fd62 	bl	800ed5c <f_open>
				}while ((FR_EXIST == res) && (MAX_DUPLICATE_FILE > countFile));
 800a298:	2808      	cmp	r0, #8
 800a29a:	d11c      	bne.n	800a2d6 <CreateLog+0x1c2>
 800a29c:	3501      	adds	r5, #1
 800a29e:	2dff      	cmp	r5, #255	; 0xff
 800a2a0:	d0d6      	beq.n	800a250 <CreateLog+0x13c>
					memset((char *)tempName, 0, sizeof(tempName));
 800a2a2:	4e68      	ldr	r6, [pc, #416]	; (800a444 <CreateLog+0x330>)
 800a2a4:	b2ef      	uxtb	r7, r5
 800a2a6:	2219      	movs	r2, #25
 800a2a8:	2100      	movs	r1, #0
 800a2aa:	0030      	movs	r0, r6
 800a2ac:	f00a f9db 	bl	8014666 <memset>
 800a2b0:	1c7b      	adds	r3, r7, #1
 800a2b2:	b2db      	uxtb	r3, r3
 800a2b4:	9307      	str	r3, [sp, #28]
					if(false == extensionFile)
 800a2b6:	9b03      	ldr	r3, [sp, #12]
 800a2b8:	2b00      	cmp	r3, #0
 800a2ba:	d1dd      	bne.n	800a278 <CreateLog+0x164>
						sprintf(tempName, "%s_%d%s", logName, countFile, ".TXT");
 800a2bc:	4b64      	ldr	r3, [pc, #400]	; (800a450 <CreateLog+0x33c>)
 800a2be:	9a02      	ldr	r2, [sp, #8]
 800a2c0:	9300      	str	r3, [sp, #0]
 800a2c2:	9b07      	ldr	r3, [sp, #28]
							sprintf(tempName, "%s_%d%s", tempName, countFile, ".TXT");
 800a2c4:	4965      	ldr	r1, [pc, #404]	; (800a45c <CreateLog+0x348>)
 800a2c6:	0030      	movs	r0, r6
 800a2c8:	f00a fbc8 	bl	8014a5c <sprintf>
 800a2cc:	e7df      	b.n	800a28e <CreateLog+0x17a>
 800a2ce:	9100      	str	r1, [sp, #0]
 800a2d0:	002b      	movs	r3, r5
 800a2d2:	0032      	movs	r2, r6
 800a2d4:	e7f6      	b.n	800a2c4 <CreateLog+0x1b0>
				else if (FR_OK != res)
 800a2d6:	2800      	cmp	r0, #0
 800a2d8:	d1ca      	bne.n	800a270 <CreateLog+0x15c>
				if(true == extensionFile)
 800a2da:	9b03      	ldr	r3, [sp, #12]
 800a2dc:	2b00      	cmp	r3, #0
 800a2de:	d100      	bne.n	800a2e2 <CreateLog+0x1ce>
 800a2e0:	9f07      	ldr	r7, [sp, #28]
			if ((true == enableSequential) && (0U != position))
 800a2e2:	4b56      	ldr	r3, [pc, #344]	; (800a43c <CreateLog+0x328>)
 800a2e4:	9a04      	ldr	r2, [sp, #16]
 800a2e6:	781b      	ldrb	r3, [r3, #0]
 800a2e8:	0155      	lsls	r5, r2, #5
 800a2ea:	2b00      	cmp	r3, #0
 800a2ec:	d062      	beq.n	800a3b4 <CreateLog+0x2a0>
 800a2ee:	2c00      	cmp	r4, #0
 800a2f0:	d060      	beq.n	800a3b4 <CreateLog+0x2a0>
				logs[i].name = malloc((size_t)position);
 800a2f2:	0020      	movs	r0, r4
 800a2f4:	f009 ff70 	bl	80141d8 <malloc>
 800a2f8:	4b4f      	ldr	r3, [pc, #316]	; (800a438 <CreateLog+0x324>)
				memset(logs[i].name, 0x00U, (size_t)position);
 800a2fa:	0022      	movs	r2, r4
 800a2fc:	2100      	movs	r1, #0
				logs[i].name = malloc((size_t)position);
 800a2fe:	5158      	str	r0, [r3, r5]
 800a300:	0006      	movs	r6, r0
				memset(logs[i].name, 0x00U, (size_t)position);
 800a302:	f00a f9b0 	bl	8014666 <memset>
				strncpy(logs[i].name, tempName, (size_t)(position - 1));
 800a306:	494f      	ldr	r1, [pc, #316]	; (800a444 <CreateLog+0x330>)
 800a308:	1e62      	subs	r2, r4, #1
				strncpy(logs[i].name, logName, (size_t)length);
 800a30a:	0030      	movs	r0, r6
 800a30c:	f00a fbfb 	bl	8014b06 <strncpy>
			logs[i].file_extension = countFile;
 800a310:	4b49      	ldr	r3, [pc, #292]	; (800a438 <CreateLog+0x324>)
			char *buffer = malloc(100);
 800a312:	2064      	movs	r0, #100	; 0x64
			logs[i].file_extension = countFile;
 800a314:	195d      	adds	r5, r3, r5
			logs[i].type = type;
 800a316:	9b05      	ldr	r3, [sp, #20]
			logs[i].file_extension = countFile;
 800a318:	712f      	strb	r7, [r5, #4]
			logs[i].type = type;
 800a31a:	71ab      	strb	r3, [r5, #6]
			logs[i].rate = rate;
 800a31c:	9b06      	ldr	r3, [sp, #24]
 800a31e:	60ab      	str	r3, [r5, #8]
			logs[i].delimiterFormat = delimiterFormat;
 800a320:	9b08      	ldr	r3, [sp, #32]
 800a322:	732b      	strb	r3, [r5, #12]
			logs[i].indexColumnFormat = indexColumnFormat;
 800a324:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a326:	736b      	strb	r3, [r5, #13]
			logs[i].indexColumnLabel = indexColumnLabel;
 800a328:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800a32a:	612b      	str	r3, [r5, #16]
			char *buffer = malloc(100);
 800a32c:	f009 ff54 	bl	80141d8 <malloc>
			memset (buffer, 0x00, 100);
 800a330:	2264      	movs	r2, #100	; 0x64
 800a332:	2100      	movs	r1, #0
			char *buffer = malloc(100);
 800a334:	0004      	movs	r4, r0
			memset (buffer, 0x00, 100);
 800a336:	f00a f996 	bl	8014666 <memset>
			sprintf(buffer, logHeaderText1, _firmMajor, _firmMinor, _firmPatch, modulePNstring[myPN]);
 800a33a:	4b49      	ldr	r3, [pc, #292]	; (800a460 <CreateLog+0x34c>)
 800a33c:	4949      	ldr	r1, [pc, #292]	; (800a464 <CreateLog+0x350>)
 800a33e:	881a      	ldrh	r2, [r3, #0]
 800a340:	2306      	movs	r3, #6
 800a342:	4353      	muls	r3, r2
 800a344:	4a48      	ldr	r2, [pc, #288]	; (800a468 <CreateLog+0x354>)
 800a346:	0020      	movs	r0, r4
 800a348:	189b      	adds	r3, r3, r2
 800a34a:	9301      	str	r3, [sp, #4]
 800a34c:	2304      	movs	r3, #4
 800a34e:	2200      	movs	r2, #0
 800a350:	9300      	str	r3, [sp, #0]
 800a352:	3b02      	subs	r3, #2
 800a354:	f00a fb82 	bl	8014a5c <sprintf>
			res = f_write(&tempFile, buffer, strlen(buffer), (void *)&byteswritten);
 800a358:	0020      	movs	r0, r4
 800a35a:	f7f5 fedd 	bl	8000118 <strlen>
 800a35e:	4e43      	ldr	r6, [pc, #268]	; (800a46c <CreateLog+0x358>)
 800a360:	4d3d      	ldr	r5, [pc, #244]	; (800a458 <CreateLog+0x344>)
 800a362:	0002      	movs	r2, r0
 800a364:	0033      	movs	r3, r6
 800a366:	0021      	movs	r1, r4
 800a368:	0028      	movs	r0, r5
 800a36a:	f004 feb2 	bl	800f0d2 <f_write>
			if (enableTimeDateHeader)
 800a36e:	4b40      	ldr	r3, [pc, #256]	; (800a470 <CreateLog+0x35c>)
 800a370:	781b      	ldrb	r3, [r3, #0]
 800a372:	2b00      	cmp	r3, #0
 800a374:	d015      	beq.n	800a3a2 <CreateLog+0x28e>
				GetTimeDate();
 800a376:	f002 f90b 	bl	800c590 <GetTimeDate>
				sprintf(buffer, logHeaderTimeDate, GetDateString(), GetTimeString());
 800a37a:	f7f9 fee5 	bl	8004148 <GetDateString>
 800a37e:	0007      	movs	r7, r0
 800a380:	f7f9 ff02 	bl	8004188 <GetTimeString>
 800a384:	003a      	movs	r2, r7
 800a386:	0003      	movs	r3, r0
 800a388:	493a      	ldr	r1, [pc, #232]	; (800a474 <CreateLog+0x360>)
 800a38a:	0020      	movs	r0, r4
 800a38c:	f00a fb66 	bl	8014a5c <sprintf>
				res = f_write(&tempFile, buffer, strlen(buffer), (void *)&byteswritten);
 800a390:	0020      	movs	r0, r4
 800a392:	f7f5 fec1 	bl	8000118 <strlen>
 800a396:	0033      	movs	r3, r6
 800a398:	0002      	movs	r2, r0
 800a39a:	0021      	movs	r1, r4
 800a39c:	0028      	movs	r0, r5
 800a39e:	f004 fe98 	bl	800f0d2 <f_write>
			if(type == RATE) 
 800a3a2:	9b05      	ldr	r3, [sp, #20]
 800a3a4:	4d2c      	ldr	r5, [pc, #176]	; (800a458 <CreateLog+0x344>)
 800a3a6:	4e31      	ldr	r6, [pc, #196]	; (800a46c <CreateLog+0x358>)
 800a3a8:	2b01      	cmp	r3, #1
 800a3aa:	d014      	beq.n	800a3d6 <CreateLog+0x2c2>
				res = f_write(&tempFile, logHeaderText3, strlen(logHeaderText3), (void *)&byteswritten);	
 800a3ac:	0033      	movs	r3, r6
 800a3ae:	2212      	movs	r2, #18
 800a3b0:	4931      	ldr	r1, [pc, #196]	; (800a478 <CreateLog+0x364>)
 800a3b2:	e01f      	b.n	800a3f4 <CreateLog+0x2e0>
				length = strlen(logName);
 800a3b4:	9802      	ldr	r0, [sp, #8]
 800a3b6:	f7f5 feaf 	bl	8000118 <strlen>
 800a3ba:	b2c4      	uxtb	r4, r0
				logs[i].name = malloc(length + 1);
 800a3bc:	1c60      	adds	r0, r4, #1
 800a3be:	f009 ff0b 	bl	80141d8 <malloc>
 800a3c2:	4b1d      	ldr	r3, [pc, #116]	; (800a438 <CreateLog+0x324>)
				memset(logs[i].name, 0x00U, (size_t)(length + 1));
 800a3c4:	1c62      	adds	r2, r4, #1
 800a3c6:	2100      	movs	r1, #0
				logs[i].name = malloc(length + 1);
 800a3c8:	5158      	str	r0, [r3, r5]
 800a3ca:	0006      	movs	r6, r0
				memset(logs[i].name, 0x00U, (size_t)(length + 1));
 800a3cc:	f00a f94b 	bl	8014666 <memset>
				strncpy(logs[i].name, logName, (size_t)length);
 800a3d0:	0022      	movs	r2, r4
 800a3d2:	9902      	ldr	r1, [sp, #8]
 800a3d4:	e799      	b.n	800a30a <CreateLog+0x1f6>
				sprintf(buffer, logHeaderText2, rate);
 800a3d6:	9806      	ldr	r0, [sp, #24]
 800a3d8:	f7f8 fb64 	bl	8002aa4 <__aeabi_f2d>
 800a3dc:	0002      	movs	r2, r0
 800a3de:	000b      	movs	r3, r1
 800a3e0:	0020      	movs	r0, r4
 800a3e2:	4926      	ldr	r1, [pc, #152]	; (800a47c <CreateLog+0x368>)
 800a3e4:	f00a fb3a 	bl	8014a5c <sprintf>
				res = f_write(&tempFile, buffer, strlen(buffer), (void *)&byteswritten);
 800a3e8:	0020      	movs	r0, r4
 800a3ea:	f7f5 fe95 	bl	8000118 <strlen>
 800a3ee:	0033      	movs	r3, r6
 800a3f0:	0002      	movs	r2, r0
 800a3f2:	0021      	movs	r1, r4
				res = f_write(&tempFile, logHeaderText3, strlen(logHeaderText3), (void *)&byteswritten);	
 800a3f4:	0028      	movs	r0, r5
 800a3f6:	f004 fe6c 	bl	800f0d2 <f_write>
			res = f_write(&tempFile, indexColumnLabel, strlen(indexColumnLabel), (void *)&byteswritten);
 800a3fa:	9811      	ldr	r0, [sp, #68]	; 0x44
 800a3fc:	f7f5 fe8c 	bl	8000118 <strlen>
 800a400:	0033      	movs	r3, r6
 800a402:	0002      	movs	r2, r0
 800a404:	9911      	ldr	r1, [sp, #68]	; 0x44
 800a406:	0028      	movs	r0, r5
 800a408:	f004 fe63 	bl	800f0d2 <f_write>
			f_close(&tempFile);
 800a40c:	0028      	movs	r0, r5
 800a40e:	f004 ff72 	bl	800f2f6 <f_close>
			free(buffer);
 800a412:	0020      	movs	r0, r4
 800a414:	f009 feea 	bl	80141ec <free>
			return H1BR6_OK;
 800a418:	2400      	movs	r4, #0
 800a41a:	e72a      	b.n	800a272 <CreateLog+0x15e>
 800a41c:	9a04      	ldr	r2, [sp, #16]
 800a41e:	3201      	adds	r2, #1
 800a420:	9204      	str	r2, [sp, #16]
	for( i=0 ; i<MAX_LOGS ; i++)
 800a422:	2a0a      	cmp	r2, #10
 800a424:	d000      	beq.n	800a428 <CreateLog+0x314>
 800a426:	e6b1      	b.n	800a18c <CreateLog+0x78>
	return H1BR6_ERR_MaxLogs;	
 800a428:	2405      	movs	r4, #5
 800a42a:	e722      	b.n	800a272 <CreateLog+0x15e>
			else if ((res != FR_OK) && (FR_EXIST != res))
 800a42c:	2800      	cmp	r0, #0
 800a42e:	d100      	bne.n	800a432 <CreateLog+0x31e>
 800a430:	e757      	b.n	800a2e2 <CreateLog+0x1ce>
 800a432:	e71d      	b.n	800a270 <CreateLog+0x15c>
 800a434:	20001670 	.word	0x20001670
 800a438:	200017dc 	.word	0x200017dc
 800a43c:	2000166e 	.word	0x2000166e
 800a440:	0801b54f 	.word	0x0801b54f
 800a444:	2000191d 	.word	0x2000191d
 800a448:	447a0000 	.word	0x447a0000
 800a44c:	0801ba3c 	.word	0x0801ba3c
 800a450:	0801b5f1 	.word	0x0801b5f1
 800a454:	0801b5f6 	.word	0x0801b5f6
 800a458:	200078f4 	.word	0x200078f4
 800a45c:	0801b5e9 	.word	0x0801b5e9
 800a460:	20000050 	.word	0x20000050
 800a464:	0801b848 	.word	0x0801b848
 800a468:	0801930e 	.word	0x0801930e
 800a46c:	2000714c 	.word	0x2000714c
 800a470:	2000166f 	.word	0x2000166f
 800a474:	0801b89e 	.word	0x0801b89e
 800a478:	0801b88b 	.word	0x0801b88b
 800a47c:	0801b870 	.word	0x0801b870

0800a480 <addLogCommand>:
{
 800a480:	b5f0      	push	{r4, r5, r6, r7, lr}
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0, xParameterStringLength3 = 0; 
 800a482:	2400      	movs	r4, #0
{
 800a484:	b091      	sub	sp, #68	; 0x44
 800a486:	0007      	movs	r7, r0
 800a488:	0015      	movs	r5, r2
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0, xParameterStringLength3 = 0; 
 800a48a:	940a      	str	r4, [sp, #40]	; 0x28
 800a48c:	940b      	str	r4, [sp, #44]	; 0x2c
 800a48e:	940c      	str	r4, [sp, #48]	; 0x30
	portBASE_TYPE xParameterStringLength4 = 0, xParameterStringLength5 = 0, xParameterStringLength6 = 0;
 800a490:	940d      	str	r4, [sp, #52]	; 0x34
 800a492:	940e      	str	r4, [sp, #56]	; 0x38
 800a494:	940f      	str	r4, [sp, #60]	; 0x3c
	configASSERT( pcWriteBuffer );
 800a496:	42a0      	cmp	r0, r4
 800a498:	d101      	bne.n	800a49e <addLogCommand+0x1e>
 800a49a:	b672      	cpsid	i
 800a49c:	e7fe      	b.n	800a49c <addLogCommand+0x1c>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800a49e:	aa0a      	add	r2, sp, #40	; 0x28
 800a4a0:	2101      	movs	r1, #1
 800a4a2:	0028      	movs	r0, r5
 800a4a4:	f005 fa5a 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800a4a8:	aa0b      	add	r2, sp, #44	; 0x2c
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800a4aa:	0006      	movs	r6, r0
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800a4ac:	2102      	movs	r1, #2
 800a4ae:	0028      	movs	r0, r5
 800a4b0:	f005 fa54 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 800a4b4:	aa0c      	add	r2, sp, #48	; 0x30
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800a4b6:	9007      	str	r0, [sp, #28]
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 800a4b8:	2103      	movs	r1, #3
 800a4ba:	0028      	movs	r0, r5
 800a4bc:	f005 fa4e 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 800a4c0:	aa0d      	add	r2, sp, #52	; 0x34
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 800a4c2:	9009      	str	r0, [sp, #36]	; 0x24
	pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 800a4c4:	2104      	movs	r1, #4
 800a4c6:	0028      	movs	r0, r5
 800a4c8:	f005 fa48 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 800a4cc:	aa0e      	add	r2, sp, #56	; 0x38
	pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 800a4ce:	9005      	str	r0, [sp, #20]
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 800a4d0:	2105      	movs	r1, #5
 800a4d2:	0028      	movs	r0, r5
 800a4d4:	f005 fa42 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString6 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 6, &xParameterStringLength6);
 800a4d8:	aa0f      	add	r2, sp, #60	; 0x3c
 800a4da:	2106      	movs	r1, #6
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 800a4dc:	9006      	str	r0, [sp, #24]
	pcParameterString6 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 6, &xParameterStringLength6);
 800a4de:	0028      	movs	r0, r5
 800a4e0:	f005 fa3c 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 800a4e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	pcParameterString6 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 6, &xParameterStringLength6);
 800a4e6:	9003      	str	r0, [sp, #12]
	pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 800a4e8:	54f4      	strb	r4, [r6, r3]
	name = (char *)malloc(strlen((const char *)pcParameterString1) + 1);		// Move string out of the stack
 800a4ea:	0030      	movs	r0, r6
 800a4ec:	f7f5 fe14 	bl	8000118 <strlen>
 800a4f0:	3001      	adds	r0, #1
 800a4f2:	f009 fe71 	bl	80141d8 <malloc>
 800a4f6:	9004      	str	r0, [sp, #16]
	memset (name, 0, strlen((const char *)pcParameterString1) + 1);
 800a4f8:	0030      	movs	r0, r6
 800a4fa:	f7f5 fe0d 	bl	8000118 <strlen>
 800a4fe:	0021      	movs	r1, r4
 800a500:	1c42      	adds	r2, r0, #1
 800a502:	9804      	ldr	r0, [sp, #16]
 800a504:	f00a f8af 	bl	8014666 <memset>
		strcpy(name, (const char *)pcParameterString1);
 800a508:	0031      	movs	r1, r6
 800a50a:	9804      	ldr	r0, [sp, #16]
 800a50c:	f00a fae2 	bl	8014ad4 <strcpy>
	if (!strncmp((const char *)pcParameterString2, "rate", xParameterStringLength2))
 800a510:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800a512:	4951      	ldr	r1, [pc, #324]	; (800a658 <addLogCommand+0x1d8>)
 800a514:	002a      	movs	r2, r5
 800a516:	9807      	ldr	r0, [sp, #28]
 800a518:	f00a fae4 	bl	8014ae4 <strncmp>
 800a51c:	2800      	cmp	r0, #0
 800a51e:	d009      	beq.n	800a534 <addLogCommand+0xb4>
	else if (!strncmp((const char *)pcParameterString2, "event", xParameterStringLength2))
 800a520:	002a      	movs	r2, r5
 800a522:	494e      	ldr	r1, [pc, #312]	; (800a65c <addLogCommand+0x1dc>)
 800a524:	9807      	ldr	r0, [sp, #28]
 800a526:	f00a fadd 	bl	8014ae4 <strncmp>
		result = H1BR6_ERR_WrongParams;
 800a52a:	2403      	movs	r4, #3
	else if (!strncmp((const char *)pcParameterString2, "event", xParameterStringLength2))
 800a52c:	2800      	cmp	r0, #0
 800a52e:	d104      	bne.n	800a53a <addLogCommand+0xba>
		type = EVENT;		
 800a530:	2302      	movs	r3, #2
 800a532:	e000      	b.n	800a536 <addLogCommand+0xb6>
		type = RATE;
 800a534:	2301      	movs	r3, #1
 800a536:	0004      	movs	r4, r0
		type = EVENT;		
 800a538:	9308      	str	r3, [sp, #32]
	rate = atof( ( const char * ) pcParameterString3 );
 800a53a:	9809      	ldr	r0, [sp, #36]	; 0x24
 800a53c:	f009 fe05 	bl	801414a <atof>
 800a540:	f7f8 fb02 	bl	8002b48 <__aeabi_d2f>
	if (rate < 0.0f || rate > 1000.0f)
 800a544:	2100      	movs	r1, #0
	rate = atof( ( const char * ) pcParameterString3 );
 800a546:	9007      	str	r0, [sp, #28]
	if (rate < 0.0f || rate > 1000.0f)
 800a548:	f7f5 ffe8 	bl	800051c <__aeabi_fcmplt>
 800a54c:	2800      	cmp	r0, #0
 800a54e:	d000      	beq.n	800a552 <addLogCommand+0xd2>
 800a550:	e07b      	b.n	800a64a <addLogCommand+0x1ca>
 800a552:	4943      	ldr	r1, [pc, #268]	; (800a660 <addLogCommand+0x1e0>)
 800a554:	9807      	ldr	r0, [sp, #28]
 800a556:	f7f5 fff5 	bl	8000544 <__aeabi_fcmpgt>
 800a55a:	2800      	cmp	r0, #0
 800a55c:	d000      	beq.n	800a560 <addLogCommand+0xe0>
 800a55e:	e074      	b.n	800a64a <addLogCommand+0x1ca>
	if (!strncmp((const char *)pcParameterString4, "space", xParameterStringLength4))
 800a560:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800a562:	4940      	ldr	r1, [pc, #256]	; (800a664 <addLogCommand+0x1e4>)
 800a564:	002a      	movs	r2, r5
 800a566:	9805      	ldr	r0, [sp, #20]
 800a568:	f00a fabc 	bl	8014ae4 <strncmp>
		dformat = FMT_SPACE;
 800a56c:	2601      	movs	r6, #1
	if (!strncmp((const char *)pcParameterString4, "space", xParameterStringLength4))
 800a56e:	2800      	cmp	r0, #0
 800a570:	d010      	beq.n	800a594 <addLogCommand+0x114>
	else if (!strncmp((const char *)pcParameterString4, "tab", xParameterStringLength4))
 800a572:	002a      	movs	r2, r5
 800a574:	493c      	ldr	r1, [pc, #240]	; (800a668 <addLogCommand+0x1e8>)
 800a576:	9805      	ldr	r0, [sp, #20]
 800a578:	f00a fab4 	bl	8014ae4 <strncmp>
		dformat = FMT_TAB;		
 800a57c:	19b6      	adds	r6, r6, r6
	else if (!strncmp((const char *)pcParameterString4, "tab", xParameterStringLength4))
 800a57e:	2800      	cmp	r0, #0
 800a580:	d008      	beq.n	800a594 <addLogCommand+0x114>
	else if (!strncmp((const char *)pcParameterString4, "comma", xParameterStringLength4))
 800a582:	002a      	movs	r2, r5
 800a584:	4939      	ldr	r1, [pc, #228]	; (800a66c <addLogCommand+0x1ec>)
 800a586:	9805      	ldr	r0, [sp, #20]
 800a588:	f00a faac 	bl	8014ae4 <strncmp>
		dformat = FMT_COMMA;		
 800a58c:	3601      	adds	r6, #1
	else if (!strncmp((const char *)pcParameterString4, "comma", xParameterStringLength4))
 800a58e:	2800      	cmp	r0, #0
 800a590:	d000      	beq.n	800a594 <addLogCommand+0x114>
		result = H1BR6_ERR_WrongParams;
 800a592:	0034      	movs	r4, r6
	if (!strncmp((const char *)pcParameterString5, "sample", xParameterStringLength5))
 800a594:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 800a596:	4936      	ldr	r1, [pc, #216]	; (800a670 <addLogCommand+0x1f0>)
 800a598:	002a      	movs	r2, r5
 800a59a:	9806      	ldr	r0, [sp, #24]
 800a59c:	f00a faa2 	bl	8014ae4 <strncmp>
		iformat = FMT_SAMPLE;
 800a5a0:	2301      	movs	r3, #1
 800a5a2:	9305      	str	r3, [sp, #20]
	if (!strncmp((const char *)pcParameterString5, "sample", xParameterStringLength5))
 800a5a4:	2800      	cmp	r0, #0
 800a5a6:	d012      	beq.n	800a5ce <addLogCommand+0x14e>
	else if (!strncmp((const char *)pcParameterString5, "time", xParameterStringLength5))
 800a5a8:	002a      	movs	r2, r5
 800a5aa:	4932      	ldr	r1, [pc, #200]	; (800a674 <addLogCommand+0x1f4>)
 800a5ac:	9806      	ldr	r0, [sp, #24]
 800a5ae:	f00a fa99 	bl	8014ae4 <strncmp>
		iformat = FMT_TIME;		
 800a5b2:	2302      	movs	r3, #2
 800a5b4:	9305      	str	r3, [sp, #20]
	else if (!strncmp((const char *)pcParameterString5, "time", xParameterStringLength5))
 800a5b6:	2800      	cmp	r0, #0
 800a5b8:	d009      	beq.n	800a5ce <addLogCommand+0x14e>
	else if (!strncmp((const char *)pcParameterString5, "none", xParameterStringLength5))
 800a5ba:	002a      	movs	r2, r5
 800a5bc:	492e      	ldr	r1, [pc, #184]	; (800a678 <addLogCommand+0x1f8>)
 800a5be:	9806      	ldr	r0, [sp, #24]
 800a5c0:	f00a fa90 	bl	8014ae4 <strncmp>
		iformat = FMT_NONE;		
 800a5c4:	2300      	movs	r3, #0
 800a5c6:	9305      	str	r3, [sp, #20]
	else if (!strncmp((const char *)pcParameterString5, "none", xParameterStringLength5))
 800a5c8:	4298      	cmp	r0, r3
 800a5ca:	d000      	beq.n	800a5ce <addLogCommand+0x14e>
		result = H1BR6_ERR_WrongParams;
 800a5cc:	2403      	movs	r4, #3
	pcParameterString6[xParameterStringLength6] = 0;		// Get rid of the remaining parameters
 800a5ce:	2100      	movs	r1, #0
 800a5d0:	9b03      	ldr	r3, [sp, #12]
 800a5d2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
	index = (char *)malloc(strlen((const char *)pcParameterString6) + 1);		// Move string out of the stack
 800a5d4:	0018      	movs	r0, r3
	pcParameterString6[xParameterStringLength6] = 0;		// Get rid of the remaining parameters
 800a5d6:	5499      	strb	r1, [r3, r2]
	index = (char *)malloc(strlen((const char *)pcParameterString6) + 1);		// Move string out of the stack
 800a5d8:	f7f5 fd9e 	bl	8000118 <strlen>
 800a5dc:	3001      	adds	r0, #1
 800a5de:	f009 fdfb 	bl	80141d8 <malloc>
 800a5e2:	0005      	movs	r5, r0
	memset (index, 0, strlen((const char *)pcParameterString6) + 1);
 800a5e4:	9803      	ldr	r0, [sp, #12]
 800a5e6:	f7f5 fd97 	bl	8000118 <strlen>
 800a5ea:	2100      	movs	r1, #0
 800a5ec:	1c42      	adds	r2, r0, #1
 800a5ee:	0028      	movs	r0, r5
 800a5f0:	f00a f839 	bl	8014666 <memset>
		strcpy(index, (const char *)pcParameterString6);
 800a5f4:	9903      	ldr	r1, [sp, #12]
 800a5f6:	0028      	movs	r0, r5
 800a5f8:	f00a fa6c 	bl	8014ad4 <strcpy>
	if (result == H1BR6_OK) {
 800a5fc:	2c00      	cmp	r4, #0
 800a5fe:	d126      	bne.n	800a64e <addLogCommand+0x1ce>
		result = CreateLog(name, type, rate, dformat, iformat, index);	
 800a600:	9b05      	ldr	r3, [sp, #20]
 800a602:	9501      	str	r5, [sp, #4]
 800a604:	9300      	str	r3, [sp, #0]
 800a606:	9a07      	ldr	r2, [sp, #28]
 800a608:	0033      	movs	r3, r6
 800a60a:	9908      	ldr	r1, [sp, #32]
 800a60c:	9804      	ldr	r0, [sp, #16]
 800a60e:	f7ff fd81 	bl	800a114 <CreateLog>
 800a612:	0004      	movs	r4, r0
	free(name);
 800a614:	9804      	ldr	r0, [sp, #16]
 800a616:	f009 fde9 	bl	80141ec <free>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage);
 800a61a:	4918      	ldr	r1, [pc, #96]	; (800a67c <addLogCommand+0x1fc>)
	if (result == H1BR6_OK) {
 800a61c:	2c00      	cmp	r4, #0
 800a61e:	d00e      	beq.n	800a63e <addLogCommand+0x1be>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcWrongValue);
 800a620:	4917      	ldr	r1, [pc, #92]	; (800a680 <addLogCommand+0x200>)
	} else if (result == H1BR6_ERR_WrongParams) {
 800a622:	2c03      	cmp	r4, #3
 800a624:	d00b      	beq.n	800a63e <addLogCommand+0x1be>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcLogExists);
 800a626:	4917      	ldr	r1, [pc, #92]	; (800a684 <addLogCommand+0x204>)
	} else if (result ==  H1BR6_ERR_LogNameExists) {
 800a628:	2c02      	cmp	r4, #2
 800a62a:	d008      	beq.n	800a63e <addLogCommand+0x1be>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcSDerror);
 800a62c:	4916      	ldr	r1, [pc, #88]	; (800a688 <addLogCommand+0x208>)
	} else if (result ==  H1BR6_ERR_SD) {
 800a62e:	2c04      	cmp	r4, #4
 800a630:	d005      	beq.n	800a63e <addLogCommand+0x1be>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMaxLogs);
 800a632:	4916      	ldr	r1, [pc, #88]	; (800a68c <addLogCommand+0x20c>)
	} else if (result ==  H1BR6_ERR_MaxLogs) {
 800a634:	2c05      	cmp	r4, #5
 800a636:	d002      	beq.n	800a63e <addLogCommand+0x1be>
	} else if (result ==  H1BR6_ERR_MemoryFull) {
 800a638:	2c09      	cmp	r4, #9
 800a63a:	d103      	bne.n	800a644 <addLogCommand+0x1c4>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMemoryFull);
 800a63c:	4914      	ldr	r1, [pc, #80]	; (800a690 <addLogCommand+0x210>)
 800a63e:	0038      	movs	r0, r7
 800a640:	f00a fa48 	bl	8014ad4 <strcpy>
}
 800a644:	2000      	movs	r0, #0
 800a646:	b011      	add	sp, #68	; 0x44
 800a648:	bdf0      	pop	{r4, r5, r6, r7, pc}
		result = H1BR6_ERR_WrongParams;
 800a64a:	2403      	movs	r4, #3
 800a64c:	e788      	b.n	800a560 <addLogCommand+0xe0>
		free(index);
 800a64e:	0028      	movs	r0, r5
 800a650:	f009 fdcc 	bl	80141ec <free>
 800a654:	e7de      	b.n	800a614 <addLogCommand+0x194>
 800a656:	46c0      	nop			; (mov r8, r8)
 800a658:	0801a907 	.word	0x0801a907
 800a65c:	0801b5fb 	.word	0x0801b5fb
 800a660:	447a0000 	.word	0x447a0000
 800a664:	0801b601 	.word	0x0801b601
 800a668:	0801b607 	.word	0x0801b607
 800a66c:	0801b60b 	.word	0x0801b60b
 800a670:	0801b611 	.word	0x0801b611
 800a674:	08019d41 	.word	0x08019d41
 800a678:	08019d16 	.word	0x08019d16
 800a67c:	0801b618 	.word	0x0801b618
 800a680:	0801b633 	.word	0x0801b633
 800a684:	0801b65b 	.word	0x0801b65b
 800a688:	0801b68a 	.word	0x0801b68a
 800a68c:	0801b6af 	.word	0x0801b6af
 800a690:	0801b6e5 	.word	0x0801b6e5

0800a694 <LogVar>:
{
 800a694:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800a696:	0007      	movs	r7, r0
 800a698:	0015      	movs	r5, r2
 800a69a:	001e      	movs	r6, r3
 800a69c:	2400      	movs	r4, #0
 800a69e:	9101      	str	r1, [sp, #4]
 800a6a0:	b2e3      	uxtb	r3, r4
 800a6a2:	9300      	str	r3, [sp, #0]
		if((0 != logs[j].current_extension) && (true == enableSequential))
 800a6a4:	4b3c      	ldr	r3, [pc, #240]	; (800a798 <LogVar+0x104>)
 800a6a6:	0162      	lsls	r2, r4, #5
 800a6a8:	18d2      	adds	r2, r2, r3
 800a6aa:	7953      	ldrb	r3, [r2, #5]
 800a6ac:	6812      	ldr	r2, [r2, #0]
 800a6ae:	2b00      	cmp	r3, #0
 800a6b0:	d056      	beq.n	800a760 <LogVar+0xcc>
 800a6b2:	493a      	ldr	r1, [pc, #232]	; (800a79c <LogVar+0x108>)
 800a6b4:	7809      	ldrb	r1, [r1, #0]
 800a6b6:	2900      	cmp	r1, #0
 800a6b8:	d052      	beq.n	800a760 <LogVar+0xcc>
			sprintf(tempName, "%s_%d", logs[j].name, logs[j].current_extension);
 800a6ba:	4939      	ldr	r1, [pc, #228]	; (800a7a0 <LogVar+0x10c>)
 800a6bc:	4839      	ldr	r0, [pc, #228]	; (800a7a4 <LogVar+0x110>)
 800a6be:	f00a f9cd 	bl	8014a5c <sprintf>
		if (!strcmp(tempName, logName))
 800a6c2:	0039      	movs	r1, r7
 800a6c4:	4837      	ldr	r0, [pc, #220]	; (800a7a4 <LogVar+0x110>)
 800a6c6:	f7f5 fd1d 	bl	8000104 <strcmp>
 800a6ca:	2800      	cmp	r0, #0
 800a6cc:	d15e      	bne.n	800a78c <LogVar+0xf8>
				if(logVars[i].type == 0)
 800a6ce:	4a36      	ldr	r2, [pc, #216]	; (800a7a8 <LogVar+0x114>)
 800a6d0:	0003      	movs	r3, r0
 800a6d2:	300c      	adds	r0, #12
 800a6d4:	0001      	movs	r1, r0
 800a6d6:	4359      	muls	r1, r3
 800a6d8:	1889      	adds	r1, r1, r2
 800a6da:	784f      	ldrb	r7, [r1, #1]
 800a6dc:	2f00      	cmp	r7, #0
 800a6de:	d150      	bne.n	800a782 <LogVar+0xee>
					logVars[i].type = type;
 800a6e0:	9801      	ldr	r0, [sp, #4]
 800a6e2:	7048      	strb	r0, [r1, #1]
					if(type > 3) {
 800a6e4:	2803      	cmp	r0, #3
 800a6e6:	d914      	bls.n	800a712 <LogVar+0x7e>
					if ((source < FLASH_BASE || source > (FLASH_BASE+FLASH_SIZE)) && (source < SRAM_BASE || source > (SRAM_BASE+SRAM_SIZE)) && (source < PERIPH_BASE || source > (PERIPH_BASE+PERIPH_SIZE)))
 800a6e8:	21f8      	movs	r1, #248	; 0xf8
 800a6ea:	2080      	movs	r0, #128	; 0x80
 800a6ec:	0609      	lsls	r1, r1, #24
 800a6ee:	1869      	adds	r1, r5, r1
 800a6f0:	0280      	lsls	r0, r0, #10
 800a6f2:	4281      	cmp	r1, r0
 800a6f4:	d90d      	bls.n	800a712 <LogVar+0x7e>
 800a6f6:	21e0      	movs	r1, #224	; 0xe0
 800a6f8:	2080      	movs	r0, #128	; 0x80
 800a6fa:	0609      	lsls	r1, r1, #24
 800a6fc:	1869      	adds	r1, r5, r1
 800a6fe:	0200      	lsls	r0, r0, #8
 800a700:	4281      	cmp	r1, r0
 800a702:	d906      	bls.n	800a712 <LogVar+0x7e>
 800a704:	21c0      	movs	r1, #192	; 0xc0
 800a706:	4f29      	ldr	r7, [pc, #164]	; (800a7ac <LogVar+0x118>)
 800a708:	0609      	lsls	r1, r1, #24
 800a70a:	1869      	adds	r1, r5, r1
								return H1BR6_ERR_WrongAddress;}
 800a70c:	200a      	movs	r0, #10
					if ((source < FLASH_BASE || source > (FLASH_BASE+FLASH_SIZE)) && (source < SRAM_BASE || source > (SRAM_BASE+SRAM_SIZE)) && (source < PERIPH_BASE || source > (PERIPH_BASE+PERIPH_SIZE)))
 800a70e:	42b9      	cmp	r1, r7
 800a710:	d825      	bhi.n	800a75e <LogVar+0xca>
					logVars[i].source = source;
 800a712:	200c      	movs	r0, #12
 800a714:	4343      	muls	r3, r0
					logVars[i].logIndex = j;
 800a716:	9800      	ldr	r0, [sp, #0]
					logVars[i].source = source;
 800a718:	18d1      	adds	r1, r2, r3
					logVars[i].logIndex = j;
 800a71a:	54d0      	strb	r0, [r2, r3]
					OpenThisLog(j, &tempFile);
 800a71c:	466b      	mov	r3, sp
					logVars[i].source = source;
 800a71e:	608d      	str	r5, [r1, #8]
					OpenThisLog(j, &tempFile);
 800a720:	4d23      	ldr	r5, [pc, #140]	; (800a7b0 <LogVar+0x11c>)
					logVars[i].varLabel = ColumnLabel;
 800a722:	604e      	str	r6, [r1, #4]
					OpenThisLog(j, &tempFile);
 800a724:	8818      	ldrh	r0, [r3, #0]
 800a726:	0029      	movs	r1, r5
 800a728:	f7ff fa80 	bl	8009c2c <OpenThisLog>
					if (logs[j].delimiterFormat == FMT_SPACE)
 800a72c:	4b1a      	ldr	r3, [pc, #104]	; (800a798 <LogVar+0x104>)
 800a72e:	0164      	lsls	r4, r4, #5
 800a730:	191c      	adds	r4, r3, r4
 800a732:	7b22      	ldrb	r2, [r4, #12]
 800a734:	4c1f      	ldr	r4, [pc, #124]	; (800a7b4 <LogVar+0x120>)
 800a736:	2a01      	cmp	r2, #1
 800a738:	d117      	bne.n	800a76a <LogVar+0xd6>
						f_write(&tempFile, " ", 1, (void *)&byteswritten);
 800a73a:	0023      	movs	r3, r4
 800a73c:	491e      	ldr	r1, [pc, #120]	; (800a7b8 <LogVar+0x124>)
						f_write(&tempFile, ",", 1, (void *)&byteswritten);
 800a73e:	0028      	movs	r0, r5
 800a740:	f004 fcc7 	bl	800f0d2 <f_write>
					f_write(&tempFile, ColumnLabel, strlen(ColumnLabel), (void *)&byteswritten);
 800a744:	0030      	movs	r0, r6
 800a746:	f7f5 fce7 	bl	8000118 <strlen>
 800a74a:	0023      	movs	r3, r4
 800a74c:	0002      	movs	r2, r0
 800a74e:	0031      	movs	r1, r6
 800a750:	0028      	movs	r0, r5
 800a752:	f004 fcbe 	bl	800f0d2 <f_write>
					f_close(&tempFile);
 800a756:	0028      	movs	r0, r5
 800a758:	f004 fdcd 	bl	800f2f6 <f_close>
					return H1BR6_OK;
 800a75c:	2000      	movs	r0, #0
}
 800a75e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			sprintf(tempName, "%s", logs[j].name);
 800a760:	0011      	movs	r1, r2
 800a762:	4810      	ldr	r0, [pc, #64]	; (800a7a4 <LogVar+0x110>)
 800a764:	f00a f9b6 	bl	8014ad4 <strcpy>
 800a768:	e7ab      	b.n	800a6c2 <LogVar+0x2e>
					else if (logs[j].delimiterFormat == FMT_TAB)
 800a76a:	2a02      	cmp	r2, #2
 800a76c:	d103      	bne.n	800a776 <LogVar+0xe2>
						f_write(&tempFile, "\t", 1, (void *)&byteswritten);
 800a76e:	0023      	movs	r3, r4
 800a770:	3a01      	subs	r2, #1
 800a772:	4912      	ldr	r1, [pc, #72]	; (800a7bc <LogVar+0x128>)
 800a774:	e7e3      	b.n	800a73e <LogVar+0xaa>
					else if (logs[j].delimiterFormat == FMT_COMMA)
 800a776:	2a03      	cmp	r2, #3
 800a778:	d1e4      	bne.n	800a744 <LogVar+0xb0>
						f_write(&tempFile, ",", 1, (void *)&byteswritten);
 800a77a:	0023      	movs	r3, r4
 800a77c:	3a02      	subs	r2, #2
 800a77e:	4910      	ldr	r1, [pc, #64]	; (800a7c0 <LogVar+0x12c>)
 800a780:	e7dd      	b.n	800a73e <LogVar+0xaa>
 800a782:	3301      	adds	r3, #1
			for( i=0 ; i<MAX_LOG_VARS ; i++)
 800a784:	2b1e      	cmp	r3, #30
 800a786:	d1a5      	bne.n	800a6d4 <LogVar+0x40>
			return H1BR6_ERR_MaxLogVars;
 800a788:	2006      	movs	r0, #6
 800a78a:	e7e8      	b.n	800a75e <LogVar+0xca>
 800a78c:	3401      	adds	r4, #1
	for( j=0 ; j<MAX_LOGS ; j++)
 800a78e:	2c0a      	cmp	r4, #10
 800a790:	d000      	beq.n	800a794 <LogVar+0x100>
 800a792:	e785      	b.n	800a6a0 <LogVar+0xc>
	return H1BR6_ERR_LogDoesNotExist;	
 800a794:	2007      	movs	r0, #7
 800a796:	e7e2      	b.n	800a75e <LogVar+0xca>
 800a798:	200017dc 	.word	0x200017dc
 800a79c:	2000166e 	.word	0x2000166e
 800a7a0:	0801b54f 	.word	0x0801b54f
 800a7a4:	2000191d 	.word	0x2000191d
 800a7a8:	20001674 	.word	0x20001674
 800a7ac:	080017ff 	.word	0x080017ff
 800a7b0:	200078f4 	.word	0x200078f4
 800a7b4:	2000714c 	.word	0x2000714c
 800a7b8:	08019df3 	.word	0x08019df3
 800a7bc:	080192c4 	.word	0x080192c4
 800a7c0:	0801b5df 	.word	0x0801b5df

0800a7c4 <logVarCommand>:
{
 800a7c4:	b5f0      	push	{r4, r5, r6, r7, lr}
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0, xParameterStringLength3 = 0; 
 800a7c6:	2400      	movs	r4, #0
{
 800a7c8:	b08d      	sub	sp, #52	; 0x34
 800a7ca:	0007      	movs	r7, r0
 800a7cc:	0016      	movs	r6, r2
	portBASE_TYPE xParameterStringLength1 = 0, xParameterStringLength2 = 0, xParameterStringLength3 = 0; 
 800a7ce:	9407      	str	r4, [sp, #28]
 800a7d0:	9408      	str	r4, [sp, #32]
 800a7d2:	9409      	str	r4, [sp, #36]	; 0x24
	portBASE_TYPE xParameterStringLength4 = 0, xParameterStringLength5 = 0;
 800a7d4:	940a      	str	r4, [sp, #40]	; 0x28
 800a7d6:	940b      	str	r4, [sp, #44]	; 0x2c
	configASSERT( pcWriteBuffer );
 800a7d8:	42a0      	cmp	r0, r4
 800a7da:	d101      	bne.n	800a7e0 <logVarCommand+0x1c>
 800a7dc:	b672      	cpsid	i
 800a7de:	e7fe      	b.n	800a7de <logVarCommand+0x1a>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800a7e0:	aa07      	add	r2, sp, #28
 800a7e2:	2101      	movs	r1, #1
 800a7e4:	0030      	movs	r0, r6
 800a7e6:	f005 f8b9 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800a7ea:	aa08      	add	r2, sp, #32
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800a7ec:	9004      	str	r0, [sp, #16]
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800a7ee:	2102      	movs	r1, #2
 800a7f0:	0030      	movs	r0, r6
 800a7f2:	f005 f8b3 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 800a7f6:	aa09      	add	r2, sp, #36	; 0x24
	pcParameterString2 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 2, &xParameterStringLength2);
 800a7f8:	9005      	str	r0, [sp, #20]
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 800a7fa:	2103      	movs	r1, #3
 800a7fc:	0030      	movs	r0, r6
 800a7fe:	f005 f8ad 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 800a802:	aa0a      	add	r2, sp, #40	; 0x28
 800a804:	2104      	movs	r1, #4
	pcParameterString3 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 3, &xParameterStringLength3);
 800a806:	0005      	movs	r5, r0
	pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 800a808:	0030      	movs	r0, r6
 800a80a:	f005 f8a7 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 800a80e:	aa0b      	add	r2, sp, #44	; 0x2c
	pcParameterString4 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 4, &xParameterStringLength4);
 800a810:	9001      	str	r0, [sp, #4]
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 800a812:	2105      	movs	r1, #5
 800a814:	0030      	movs	r0, r6
 800a816:	f005 f8a1 	bl	800f95c <FreeRTOS_CLIGetParameter>
	pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 800a81a:	9a07      	ldr	r2, [sp, #28]
 800a81c:	9b04      	ldr	r3, [sp, #16]
	pcParameterString5 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 5, &xParameterStringLength5);
 800a81e:	9002      	str	r0, [sp, #8]
	pcParameterString1[xParameterStringLength1] = 0;		// Get rid of the remaining parameters
 800a820:	549c      	strb	r4, [r3, r2]
	if (!strncmp((const char *)pcParameterString2, "port", xParameterStringLength2)) {
 800a822:	9c08      	ldr	r4, [sp, #32]
 800a824:	4968      	ldr	r1, [pc, #416]	; (800a9c8 <logVarCommand+0x204>)
 800a826:	0022      	movs	r2, r4
 800a828:	9805      	ldr	r0, [sp, #20]
 800a82a:	f00a f95b 	bl	8014ae4 <strncmp>
 800a82e:	2800      	cmp	r0, #0
 800a830:	d158      	bne.n	800a8e4 <logVarCommand+0x120>
		if (!strncmp((const char *)pcParameterString3, "digital", xParameterStringLength3)) {
 800a832:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800a834:	4965      	ldr	r1, [pc, #404]	; (800a9cc <logVarCommand+0x208>)
 800a836:	0032      	movs	r2, r6
 800a838:	0028      	movs	r0, r5
 800a83a:	f00a f953 	bl	8014ae4 <strncmp>
 800a83e:	2800      	cmp	r0, #0
 800a840:	d100      	bne.n	800a844 <logVarCommand+0x80>
 800a842:	e08c      	b.n	800a95e <logVarCommand+0x19a>
		} else if (!strncmp((const char *)pcParameterString3, "data", xParameterStringLength3)) {
 800a844:	0032      	movs	r2, r6
 800a846:	4962      	ldr	r1, [pc, #392]	; (800a9d0 <logVarCommand+0x20c>)
 800a848:	0028      	movs	r0, r5
 800a84a:	f00a f94b 	bl	8014ae4 <strncmp>
 800a84e:	2800      	cmp	r0, #0
 800a850:	d100      	bne.n	800a854 <logVarCommand+0x90>
 800a852:	e09d      	b.n	800a990 <logVarCommand+0x1cc>
		} else if (!strncmp((const char *)pcParameterString3, "button", xParameterStringLength3)) {
 800a854:	0032      	movs	r2, r6
 800a856:	495f      	ldr	r1, [pc, #380]	; (800a9d4 <logVarCommand+0x210>)
 800a858:	0028      	movs	r0, r5
 800a85a:	f00a f943 	bl	8014ae4 <strncmp>
 800a85e:	2800      	cmp	r0, #0
 800a860:	d07b      	beq.n	800a95a <logVarCommand+0x196>
 800a862:	2403      	movs	r4, #3
	if (type == PORT_BUTTON && pcParameterString4[0] == 'b')
 800a864:	2500      	movs	r5, #0
 800a866:	42a5      	cmp	r5, r4
 800a868:	d17b      	bne.n	800a962 <logVarCommand+0x19e>
 800a86a:	9b01      	ldr	r3, [sp, #4]
 800a86c:	2503      	movs	r5, #3
 800a86e:	781b      	ldrb	r3, [r3, #0]
 800a870:	b25b      	sxtb	r3, r3
 800a872:	2b62      	cmp	r3, #98	; 0x62
 800a874:	d175      	bne.n	800a962 <logVarCommand+0x19e>
		source = ( uint8_t ) atol( ( char * ) pcParameterString4+1 );
 800a876:	9801      	ldr	r0, [sp, #4]
 800a878:	3001      	adds	r0, #1
 800a87a:	f009 fc71 	bl	8014160 <atol>
 800a87e:	b2c3      	uxtb	r3, r0
 800a880:	9303      	str	r3, [sp, #12]
	pcParameterString5[xParameterStringLength5] = 0;		// Get rid of the remaining parameters
 800a882:	2100      	movs	r1, #0
 800a884:	9b02      	ldr	r3, [sp, #8]
 800a886:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	label = (char *)malloc(strlen((const char *)pcParameterString5) + 1);		// Move string out of the stack
 800a888:	0018      	movs	r0, r3
	pcParameterString5[xParameterStringLength5] = 0;		// Get rid of the remaining parameters
 800a88a:	5499      	strb	r1, [r3, r2]
	label = (char *)malloc(strlen((const char *)pcParameterString5) + 1);		// Move string out of the stack
 800a88c:	f7f5 fc44 	bl	8000118 <strlen>
 800a890:	3001      	adds	r0, #1
 800a892:	f009 fca1 	bl	80141d8 <malloc>
 800a896:	0006      	movs	r6, r0
	memset (label, 0, strlen((const char *)pcParameterString5) + 1);
 800a898:	9802      	ldr	r0, [sp, #8]
 800a89a:	f7f5 fc3d 	bl	8000118 <strlen>
 800a89e:	2100      	movs	r1, #0
 800a8a0:	1c42      	adds	r2, r0, #1
 800a8a2:	0030      	movs	r0, r6
 800a8a4:	f009 fedf 	bl	8014666 <memset>
		strcpy(label, (const char *)pcParameterString5);
 800a8a8:	9902      	ldr	r1, [sp, #8]
 800a8aa:	0030      	movs	r0, r6
 800a8ac:	f00a f912 	bl	8014ad4 <strcpy>
	if (result == H1BR6_OK) {
 800a8b0:	2c00      	cmp	r4, #0
 800a8b2:	d17d      	bne.n	800a9b0 <logVarCommand+0x1ec>
		result = LogVar((char *)pcParameterString1, type, source, label);	
 800a8b4:	0029      	movs	r1, r5
 800a8b6:	0033      	movs	r3, r6
 800a8b8:	9a03      	ldr	r2, [sp, #12]
 800a8ba:	9804      	ldr	r0, [sp, #16]
 800a8bc:	f7ff feea 	bl	800a694 <LogVar>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage);
 800a8c0:	4945      	ldr	r1, [pc, #276]	; (800a9d8 <logVarCommand+0x214>)
		result = LogVar((char *)pcParameterString1, type, source, label);	
 800a8c2:	1e04      	subs	r4, r0, #0
	if (result == H1BR6_OK) {
 800a8c4:	d07a      	beq.n	800a9bc <logVarCommand+0x1f8>
	} else if (result == H1BR6_ERR_WrongParams) {
 800a8c6:	2803      	cmp	r0, #3
 800a8c8:	d077      	beq.n	800a9ba <logVarCommand+0x1f6>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcLogDoesNotExist);
 800a8ca:	4944      	ldr	r1, [pc, #272]	; (800a9dc <logVarCommand+0x218>)
	} else if (result ==  H1BR6_ERR_LogDoesNotExist) {
 800a8cc:	2807      	cmp	r0, #7
 800a8ce:	d075      	beq.n	800a9bc <logVarCommand+0x1f8>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMemoryFull);
 800a8d0:	4943      	ldr	r1, [pc, #268]	; (800a9e0 <logVarCommand+0x21c>)
	} else if (result ==  H1BR6_ERR_MemoryFull) {
 800a8d2:	2c09      	cmp	r4, #9
 800a8d4:	d072      	beq.n	800a9bc <logVarCommand+0x1f8>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcMaxLogVars);
 800a8d6:	4943      	ldr	r1, [pc, #268]	; (800a9e4 <logVarCommand+0x220>)
	} else if (result ==  H1BR6_ERR_MaxLogVars) {
 800a8d8:	2c06      	cmp	r4, #6
 800a8da:	d06f      	beq.n	800a9bc <logVarCommand+0x1f8>
	} else if (result == H1BR6_ERR_WrongAddress) {
 800a8dc:	2c0a      	cmp	r4, #10
 800a8de:	d170      	bne.n	800a9c2 <logVarCommand+0x1fe>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcWrongAddress);
 800a8e0:	4941      	ldr	r1, [pc, #260]	; (800a9e8 <logVarCommand+0x224>)
 800a8e2:	e06b      	b.n	800a9bc <logVarCommand+0x1f8>
	} else if (!strncmp((const char *)pcParameterString2, "memory", xParameterStringLength2)) {
 800a8e4:	0022      	movs	r2, r4
 800a8e6:	4941      	ldr	r1, [pc, #260]	; (800a9ec <logVarCommand+0x228>)
 800a8e8:	9805      	ldr	r0, [sp, #20]
 800a8ea:	f00a f8fb 	bl	8014ae4 <strncmp>
 800a8ee:	2800      	cmp	r0, #0
 800a8f0:	d1b7      	bne.n	800a862 <logVarCommand+0x9e>
		if (!strncmp((const char *)pcParameterString3, "uint8", xParameterStringLength3)) {
 800a8f2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800a8f4:	493e      	ldr	r1, [pc, #248]	; (800a9f0 <logVarCommand+0x22c>)
 800a8f6:	0032      	movs	r2, r6
 800a8f8:	0028      	movs	r0, r5
 800a8fa:	f00a f8f3 	bl	8014ae4 <strncmp>
 800a8fe:	2800      	cmp	r0, #0
 800a900:	d048      	beq.n	800a994 <logVarCommand+0x1d0>
		} else if (!strncmp((const char *)pcParameterString3, "int8", xParameterStringLength3)) {
 800a902:	0032      	movs	r2, r6
 800a904:	493b      	ldr	r1, [pc, #236]	; (800a9f4 <logVarCommand+0x230>)
 800a906:	0028      	movs	r0, r5
 800a908:	f00a f8ec 	bl	8014ae4 <strncmp>
 800a90c:	2800      	cmp	r0, #0
 800a90e:	d043      	beq.n	800a998 <logVarCommand+0x1d4>
		} else if (!strncmp((const char *)pcParameterString3, "uint16", xParameterStringLength3)) {
 800a910:	0032      	movs	r2, r6
 800a912:	4939      	ldr	r1, [pc, #228]	; (800a9f8 <logVarCommand+0x234>)
 800a914:	0028      	movs	r0, r5
 800a916:	f00a f8e5 	bl	8014ae4 <strncmp>
 800a91a:	2800      	cmp	r0, #0
 800a91c:	d03e      	beq.n	800a99c <logVarCommand+0x1d8>
		} else if (!strncmp((const char *)pcParameterString3, "int16", xParameterStringLength3)) {
 800a91e:	0032      	movs	r2, r6
 800a920:	4936      	ldr	r1, [pc, #216]	; (800a9fc <logVarCommand+0x238>)
 800a922:	0028      	movs	r0, r5
 800a924:	f00a f8de 	bl	8014ae4 <strncmp>
 800a928:	2800      	cmp	r0, #0
 800a92a:	d039      	beq.n	800a9a0 <logVarCommand+0x1dc>
		} else if (!strncmp((const char *)pcParameterString3, "uint32", xParameterStringLength3)) {
 800a92c:	0032      	movs	r2, r6
 800a92e:	4934      	ldr	r1, [pc, #208]	; (800aa00 <logVarCommand+0x23c>)
 800a930:	0028      	movs	r0, r5
 800a932:	f00a f8d7 	bl	8014ae4 <strncmp>
 800a936:	2800      	cmp	r0, #0
 800a938:	d034      	beq.n	800a9a4 <logVarCommand+0x1e0>
		} else if (!strncmp((const char *)pcParameterString3, "int32", xParameterStringLength3)) {
 800a93a:	0032      	movs	r2, r6
 800a93c:	4931      	ldr	r1, [pc, #196]	; (800aa04 <logVarCommand+0x240>)
 800a93e:	0028      	movs	r0, r5
 800a940:	f00a f8d0 	bl	8014ae4 <strncmp>
 800a944:	2800      	cmp	r0, #0
 800a946:	d02f      	beq.n	800a9a8 <logVarCommand+0x1e4>
		} else if (!strncmp((const char *)pcParameterString3, "float", xParameterStringLength3)) {
 800a948:	0032      	movs	r2, r6
 800a94a:	492f      	ldr	r1, [pc, #188]	; (800aa08 <logVarCommand+0x244>)
 800a94c:	0028      	movs	r0, r5
 800a94e:	f00a f8c9 	bl	8014ae4 <strncmp>
 800a952:	2800      	cmp	r0, #0
 800a954:	d185      	bne.n	800a862 <logVarCommand+0x9e>
			type = MEMORY_DATA_FLOAT;
 800a956:	250a      	movs	r5, #10
 800a958:	e002      	b.n	800a960 <logVarCommand+0x19c>
	Module_Status result = H1BR6_OK;
 800a95a:	0004      	movs	r4, r0
 800a95c:	e785      	b.n	800a86a <logVarCommand+0xa6>
			type = PORT_DIGITAL;
 800a95e:	2501      	movs	r5, #1
	Module_Status result = H1BR6_OK;
 800a960:	2400      	movs	r4, #0
	else if ((type == PORT_DIGITAL || type == PORT_DATA) && pcParameterString4[0] == 'p')
 800a962:	1e6b      	subs	r3, r5, #1
 800a964:	b2db      	uxtb	r3, r3
 800a966:	2b01      	cmp	r3, #1
 800a968:	d805      	bhi.n	800a976 <logVarCommand+0x1b2>
 800a96a:	9b01      	ldr	r3, [sp, #4]
 800a96c:	781b      	ldrb	r3, [r3, #0]
 800a96e:	b25b      	sxtb	r3, r3
 800a970:	2b70      	cmp	r3, #112	; 0x70
 800a972:	d100      	bne.n	800a976 <logVarCommand+0x1b2>
 800a974:	e77f      	b.n	800a876 <logVarCommand+0xb2>
	else if (!strncmp((const char *)pcParameterString4, "0x", 2)) {
 800a976:	4925      	ldr	r1, [pc, #148]	; (800aa0c <logVarCommand+0x248>)
 800a978:	2202      	movs	r2, #2
 800a97a:	9801      	ldr	r0, [sp, #4]
 800a97c:	f00a f8b2 	bl	8014ae4 <strncmp>
 800a980:	1e01      	subs	r1, r0, #0
 800a982:	d113      	bne.n	800a9ac <logVarCommand+0x1e8>
		source = strtoul(( const char * ) pcParameterString4, NULL, 16);
 800a984:	2210      	movs	r2, #16
 800a986:	9801      	ldr	r0, [sp, #4]
 800a988:	f00b f876 	bl	8015a78 <strtoul>
 800a98c:	9003      	str	r0, [sp, #12]
 800a98e:	e778      	b.n	800a882 <logVarCommand+0xbe>
			type = PORT_DATA;
 800a990:	2502      	movs	r5, #2
 800a992:	e7e5      	b.n	800a960 <logVarCommand+0x19c>
			type = MEMORY_DATA_UINT8;
 800a994:	2504      	movs	r5, #4
 800a996:	e7e3      	b.n	800a960 <logVarCommand+0x19c>
			type = MEMORY_DATA_INT8;
 800a998:	2505      	movs	r5, #5
 800a99a:	e7e1      	b.n	800a960 <logVarCommand+0x19c>
			type = MEMORY_DATA_UINT16;
 800a99c:	2506      	movs	r5, #6
 800a99e:	e7df      	b.n	800a960 <logVarCommand+0x19c>
			type = MEMORY_DATA_INT16;
 800a9a0:	2507      	movs	r5, #7
 800a9a2:	e7dd      	b.n	800a960 <logVarCommand+0x19c>
			type = MEMORY_DATA_UINT32;
 800a9a4:	2508      	movs	r5, #8
 800a9a6:	e7db      	b.n	800a960 <logVarCommand+0x19c>
			type = MEMORY_DATA_INT32;
 800a9a8:	2509      	movs	r5, #9
 800a9aa:	e7d9      	b.n	800a960 <logVarCommand+0x19c>
		result = H1BR6_ERR_WrongParams;
 800a9ac:	2403      	movs	r4, #3
 800a9ae:	e768      	b.n	800a882 <logVarCommand+0xbe>
		free(label);
 800a9b0:	0030      	movs	r0, r6
 800a9b2:	f009 fc1b 	bl	80141ec <free>
	} else if (result == H1BR6_ERR_WrongParams) {
 800a9b6:	2c03      	cmp	r4, #3
 800a9b8:	d18a      	bne.n	800a8d0 <logVarCommand+0x10c>
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcWrongValue);
 800a9ba:	4915      	ldr	r1, [pc, #84]	; (800aa10 <logVarCommand+0x24c>)
		strcpy( ( char * ) pcWriteBuffer, ( char * ) pcWrongAddress);
 800a9bc:	0038      	movs	r0, r7
 800a9be:	f00a f889 	bl	8014ad4 <strcpy>
}
 800a9c2:	2000      	movs	r0, #0
 800a9c4:	b00d      	add	sp, #52	; 0x34
 800a9c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a9c8:	0801a659 	.word	0x0801a659
 800a9cc:	0801b8a5 	.word	0x0801b8a5
 800a9d0:	0801b8ad 	.word	0x0801b8ad
 800a9d4:	0801ab56 	.word	0x0801ab56
 800a9d8:	0801b8d6 	.word	0x0801b8d6
 800a9dc:	0801b92d 	.word	0x0801b92d
 800a9e0:	0801b6e5 	.word	0x0801b6e5
 800a9e4:	0801b961 	.word	0x0801b961
 800a9e8:	0801b9ad 	.word	0x0801b9ad
 800a9ec:	0801b8b2 	.word	0x0801b8b2
 800a9f0:	0801b8b9 	.word	0x0801b8b9
 800a9f4:	0801b8ba 	.word	0x0801b8ba
 800a9f8:	0801b8bf 	.word	0x0801b8bf
 800a9fc:	0801b8c0 	.word	0x0801b8c0
 800aa00:	0801b8c6 	.word	0x0801b8c6
 800aa04:	0801b8c7 	.word	0x0801b8c7
 800aa08:	0801b8cd 	.word	0x0801b8cd
 800aa0c:	0801b8d3 	.word	0x0801b8d3
 800aa10:	0801b8fb 	.word	0x0801b8fb

0800aa14 <StartLog>:
{
 800aa14:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800aa16:	0007      	movs	r7, r0
 800aa18:	2400      	movs	r4, #0
 800aa1a:	b2e3      	uxtb	r3, r4
		if((0U != logs[j].current_extension) && (true == enableSequential))
 800aa1c:	4e21      	ldr	r6, [pc, #132]	; (800aaa4 <StartLog+0x90>)
 800aa1e:	9301      	str	r3, [sp, #4]
 800aa20:	0163      	lsls	r3, r4, #5
 800aa22:	199a      	adds	r2, r3, r6
 800aa24:	9300      	str	r3, [sp, #0]
 800aa26:	7953      	ldrb	r3, [r2, #5]
 800aa28:	4d1f      	ldr	r5, [pc, #124]	; (800aaa8 <StartLog+0x94>)
 800aa2a:	6812      	ldr	r2, [r2, #0]
 800aa2c:	2b00      	cmp	r3, #0
 800aa2e:	d02e      	beq.n	800aa8e <StartLog+0x7a>
 800aa30:	491e      	ldr	r1, [pc, #120]	; (800aaac <StartLog+0x98>)
 800aa32:	7809      	ldrb	r1, [r1, #0]
 800aa34:	2900      	cmp	r1, #0
 800aa36:	d02a      	beq.n	800aa8e <StartLog+0x7a>
			sprintf(tempName, "%s_%d", logs[j].name, logs[j].current_extension);
 800aa38:	491d      	ldr	r1, [pc, #116]	; (800aab0 <StartLog+0x9c>)
 800aa3a:	0028      	movs	r0, r5
 800aa3c:	f00a f80e 	bl	8014a5c <sprintf>
		if (!strcmp(tempName, logName))
 800aa40:	0028      	movs	r0, r5
 800aa42:	0039      	movs	r1, r7
 800aa44:	f7f5 fb5e 	bl	8000104 <strcmp>
 800aa48:	1e05      	subs	r5, r0, #0
 800aa4a:	d125      	bne.n	800aa98 <StartLog+0x84>
			activeLogs |= (0x01 << j);
 800aa4c:	2701      	movs	r7, #1
 800aa4e:	003b      	movs	r3, r7
 800aa50:	40a3      	lsls	r3, r4
 800aa52:	4a18      	ldr	r2, [pc, #96]	; (800aab4 <StartLog+0xa0>)
 800aa54:	8811      	ldrh	r1, [r2, #0]
 800aa56:	430b      	orrs	r3, r1
 800aa58:	8013      	strh	r3, [r2, #0]
			logs[j].t0 = HAL_GetTick();
 800aa5a:	f006 fd51 	bl	8011500 <HAL_GetTick>
 800aa5e:	9b00      	ldr	r3, [sp, #0]
			OpenThisLog(j, &tempFile);
 800aa60:	4c15      	ldr	r4, [pc, #84]	; (800aab8 <StartLog+0xa4>)
			logs[j].t0 = HAL_GetTick();
 800aa62:	18f6      	adds	r6, r6, r3
			OpenThisLog(j, &tempFile);
 800aa64:	466b      	mov	r3, sp
 800aa66:	0021      	movs	r1, r4
			logs[j].t0 = HAL_GetTick();
 800aa68:	61b0      	str	r0, [r6, #24]
			logs[j].sampleCount = 1;
 800aa6a:	61f7      	str	r7, [r6, #28]
			OpenThisLog(j, &tempFile);
 800aa6c:	8898      	ldrh	r0, [r3, #4]
 800aa6e:	f7ff f8dd 	bl	8009c2c <OpenThisLog>
			f_sync (&tempFile);
 800aa72:	0020      	movs	r0, r4
 800aa74:	f004 fc04 	bl	800f280 <f_sync>
			f_write(&tempFile, "\n\r", 2, (void *)&byteswritten);		
 800aa78:	4b10      	ldr	r3, [pc, #64]	; (800aabc <StartLog+0xa8>)
 800aa7a:	2202      	movs	r2, #2
 800aa7c:	4910      	ldr	r1, [pc, #64]	; (800aac0 <StartLog+0xac>)
 800aa7e:	0020      	movs	r0, r4
 800aa80:	f004 fb27 	bl	800f0d2 <f_write>
			f_close(&tempFile);
 800aa84:	0020      	movs	r0, r4
 800aa86:	f004 fc36 	bl	800f2f6 <f_close>
			return H1BR6_OK;
 800aa8a:	0028      	movs	r0, r5
}
 800aa8c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			sprintf(tempName, "%s", logs[j].name);
 800aa8e:	0011      	movs	r1, r2
 800aa90:	0028      	movs	r0, r5
 800aa92:	f00a f81f 	bl	8014ad4 <strcpy>
 800aa96:	e7d3      	b.n	800aa40 <StartLog+0x2c>
 800aa98:	3401      	adds	r4, #1
	for( j=0 ; j<MAX_LOGS ; j++)
 800aa9a:	2c0a      	cmp	r4, #10
 800aa9c:	d1bd      	bne.n	800aa1a <StartLog+0x6>
	return H1BR6_ERR_LogDoesNotExist;	
 800aa9e:	2007      	movs	r0, #7
 800aaa0:	e7f4      	b.n	800aa8c <StartLog+0x78>
 800aaa2:	46c0      	nop			; (mov r8, r8)
 800aaa4:	200017dc 	.word	0x200017dc
 800aaa8:	2000191d 	.word	0x2000191d
 800aaac:	2000166e 	.word	0x2000166e
 800aab0:	0801b54f 	.word	0x0801b54f
 800aab4:	200077c8 	.word	0x200077c8
 800aab8:	200078f4 	.word	0x200078f4
 800aabc:	2000714c 	.word	0x2000714c
 800aac0:	08019a5f 	.word	0x08019a5f

0800aac4 <startCommand>:
	portBASE_TYPE xParameterStringLength1 = 0;  
 800aac4:	2300      	movs	r3, #0
{
 800aac6:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800aac8:	0004      	movs	r4, r0
	portBASE_TYPE xParameterStringLength1 = 0;  
 800aaca:	9301      	str	r3, [sp, #4]
{
 800aacc:	0010      	movs	r0, r2
	configASSERT( pcWriteBuffer );
 800aace:	429c      	cmp	r4, r3
 800aad0:	d101      	bne.n	800aad6 <startCommand+0x12>
 800aad2:	b672      	cpsid	i
 800aad4:	e7fe      	b.n	800aad4 <startCommand+0x10>
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800aad6:	aa01      	add	r2, sp, #4
 800aad8:	2101      	movs	r1, #1
 800aada:	f004 ff3f 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800aade:	0005      	movs	r5, r0
		result = StartLog((char *)pcParameterString1);	
 800aae0:	f7ff ff98 	bl	800aa14 <StartLog>
	if (result == H1BR6_OK) {
 800aae4:	2800      	cmp	r0, #0
 800aae6:	d106      	bne.n	800aaf6 <startCommand+0x32>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage, pcParameterString1);
 800aae8:	002a      	movs	r2, r5
 800aaea:	4906      	ldr	r1, [pc, #24]	; (800ab04 <startCommand+0x40>)
 800aaec:	0020      	movs	r0, r4
 800aaee:	f009 ffb5 	bl	8014a5c <sprintf>
}
 800aaf2:	2000      	movs	r0, #0
 800aaf4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	} else if (result ==  H1BR6_ERR_LogDoesNotExist) {
 800aaf6:	2807      	cmp	r0, #7
 800aaf8:	d1fb      	bne.n	800aaf2 <startCommand+0x2e>
 800aafa:	0020      	movs	r0, r4
 800aafc:	f7fe fdb6 	bl	800966c <pauseCommand.part.6>
 800ab00:	e7f7      	b.n	800aaf2 <startCommand+0x2e>
 800ab02:	46c0      	nop			; (mov r8, r8)
 800ab04:	0801ba8c 	.word	0x0801ba8c

0800ab08 <StopLog>:
{
 800ab08:	b573      	push	{r0, r1, r4, r5, r6, lr}
	volatile uint8_t j = 0;
 800ab0a:	466b      	mov	r3, sp
 800ab0c:	1ddc      	adds	r4, r3, #7
 800ab0e:	2300      	movs	r3, #0
{
 800ab10:	0005      	movs	r5, r0
	volatile uint8_t j = 0;
 800ab12:	7023      	strb	r3, [r4, #0]
	for( j=0 ; j<MAX_LOGS ; j++)
 800ab14:	7023      	strb	r3, [r4, #0]
 800ab16:	7823      	ldrb	r3, [r4, #0]
 800ab18:	2b09      	cmp	r3, #9
 800ab1a:	d901      	bls.n	800ab20 <StopLog+0x18>
	return H1BR6_ERR_LogDoesNotExist;	
 800ab1c:	2107      	movs	r1, #7
 800ab1e:	e02a      	b.n	800ab76 <StopLog+0x6e>
		if((0U != logs[j].current_extension) && (true == enableSequential))
 800ab20:	7823      	ldrb	r3, [r4, #0]
 800ab22:	4a1b      	ldr	r2, [pc, #108]	; (800ab90 <StopLog+0x88>)
 800ab24:	015b      	lsls	r3, r3, #5
 800ab26:	18d3      	adds	r3, r2, r3
 800ab28:	795b      	ldrb	r3, [r3, #5]
 800ab2a:	4e1a      	ldr	r6, [pc, #104]	; (800ab94 <StopLog+0x8c>)
 800ab2c:	2b00      	cmp	r3, #0
 800ab2e:	d024      	beq.n	800ab7a <StopLog+0x72>
 800ab30:	4b19      	ldr	r3, [pc, #100]	; (800ab98 <StopLog+0x90>)
 800ab32:	781b      	ldrb	r3, [r3, #0]
 800ab34:	2b00      	cmp	r3, #0
 800ab36:	d020      	beq.n	800ab7a <StopLog+0x72>
			sprintf(tempName, "%s_%d", logs[j].name, logs[j].current_extension);
 800ab38:	7821      	ldrb	r1, [r4, #0]
 800ab3a:	7823      	ldrb	r3, [r4, #0]
 800ab3c:	0149      	lsls	r1, r1, #5
 800ab3e:	015b      	lsls	r3, r3, #5
 800ab40:	18d3      	adds	r3, r2, r3
 800ab42:	795b      	ldrb	r3, [r3, #5]
 800ab44:	588a      	ldr	r2, [r1, r2]
 800ab46:	0030      	movs	r0, r6
 800ab48:	4914      	ldr	r1, [pc, #80]	; (800ab9c <StopLog+0x94>)
 800ab4a:	f009 ff87 	bl	8014a5c <sprintf>
		if (!strcmp(tempName, logName))
 800ab4e:	0029      	movs	r1, r5
 800ab50:	0030      	movs	r0, r6
 800ab52:	f7f5 fad7 	bl	8000104 <strcmp>
 800ab56:	2800      	cmp	r0, #0
 800ab58:	d116      	bne.n	800ab88 <StopLog+0x80>
			if ( (activeLogs >> j) & 0x01 )
 800ab5a:	4d11      	ldr	r5, [pc, #68]	; (800aba0 <StopLog+0x98>)
 800ab5c:	7822      	ldrb	r2, [r4, #0]
 800ab5e:	882b      	ldrh	r3, [r5, #0]
				return H1BR6_ERR_LogIsNotActive;
 800ab60:	2108      	movs	r1, #8
			if ( (activeLogs >> j) & 0x01 )
 800ab62:	001e      	movs	r6, r3
 800ab64:	4116      	asrs	r6, r2
 800ab66:	2201      	movs	r2, #1
 800ab68:	4216      	tst	r6, r2
 800ab6a:	d004      	beq.n	800ab76 <StopLog+0x6e>
				activeLogs &= ~(0x01 << j);
 800ab6c:	7821      	ldrb	r1, [r4, #0]
 800ab6e:	408a      	lsls	r2, r1
				return H1BR6_OK;
 800ab70:	0001      	movs	r1, r0
				activeLogs &= ~(0x01 << j);
 800ab72:	4393      	bics	r3, r2
 800ab74:	802b      	strh	r3, [r5, #0]
}
 800ab76:	0008      	movs	r0, r1
 800ab78:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
			sprintf(tempName, "%s", logs[j].name);
 800ab7a:	7823      	ldrb	r3, [r4, #0]
 800ab7c:	0030      	movs	r0, r6
 800ab7e:	015b      	lsls	r3, r3, #5
 800ab80:	58d1      	ldr	r1, [r2, r3]
 800ab82:	f009 ffa7 	bl	8014ad4 <strcpy>
 800ab86:	e7e2      	b.n	800ab4e <StopLog+0x46>
	for( j=0 ; j<MAX_LOGS ; j++)
 800ab88:	7823      	ldrb	r3, [r4, #0]
 800ab8a:	3301      	adds	r3, #1
 800ab8c:	b2db      	uxtb	r3, r3
 800ab8e:	e7c1      	b.n	800ab14 <StopLog+0xc>
 800ab90:	200017dc 	.word	0x200017dc
 800ab94:	2000191d 	.word	0x2000191d
 800ab98:	2000166e 	.word	0x2000166e
 800ab9c:	0801b54f 	.word	0x0801b54f
 800aba0:	200077c8 	.word	0x200077c8

0800aba4 <stopCommand>:
portBASE_TYPE stopCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
	Module_Status result = H1BR6_OK;
	
	int8_t *pcParameterString1; 
	portBASE_TYPE xParameterStringLength1 = 0;  
 800aba4:	2300      	movs	r3, #0
{
 800aba6:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800aba8:	0004      	movs	r4, r0
	portBASE_TYPE xParameterStringLength1 = 0;  
 800abaa:	9301      	str	r3, [sp, #4]
{
 800abac:	0010      	movs	r0, r2

	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 800abae:	429c      	cmp	r4, r3
 800abb0:	d101      	bne.n	800abb6 <stopCommand+0x12>
 800abb2:	b672      	cpsid	i
 800abb4:	e7fe      	b.n	800abb4 <stopCommand+0x10>
	
	/* Obtain the 1st parameter string: log name */
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800abb6:	aa01      	add	r2, sp, #4
 800abb8:	2101      	movs	r1, #1
 800abba:	f004 fecf 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800abbe:	0005      	movs	r5, r0

	/* Stop the log */
	if (result == H1BR6_OK) {
		result = StopLog((char *)pcParameterString1);	
 800abc0:	f7ff ffa2 	bl	800ab08 <StopLog>
	}
	
	/* Respond to the command */
	if (result == H1BR6_OK) {
 800abc4:	2800      	cmp	r0, #0
 800abc6:	d106      	bne.n	800abd6 <stopCommand+0x32>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage, pcParameterString1);
 800abc8:	002a      	movs	r2, r5
 800abca:	4908      	ldr	r1, [pc, #32]	; (800abec <stopCommand+0x48>)
	} else if (result ==  H1BR6_ERR_LogIsNotActive) {
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcIsNotActive, pcParameterString1);
 800abcc:	0020      	movs	r0, r4
 800abce:	f009 ff45 	bl	8014a5c <sprintf>
	} 
	
	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
 800abd2:	2000      	movs	r0, #0
 800abd4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	} else if (result ==  H1BR6_ERR_LogIsNotActive) {
 800abd6:	2808      	cmp	r0, #8
 800abd8:	d102      	bne.n	800abe0 <stopCommand+0x3c>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcIsNotActive, pcParameterString1);
 800abda:	002a      	movs	r2, r5
 800abdc:	4904      	ldr	r1, [pc, #16]	; (800abf0 <stopCommand+0x4c>)
 800abde:	e7f5      	b.n	800abcc <stopCommand+0x28>
	} else if (result ==  H1BR6_ERR_LogDoesNotExist) {
 800abe0:	2807      	cmp	r0, #7
 800abe2:	d1f6      	bne.n	800abd2 <stopCommand+0x2e>
 800abe4:	0020      	movs	r0, r4
 800abe6:	f7fe fd41 	bl	800966c <pauseCommand.part.6>
 800abea:	e7f2      	b.n	800abd2 <stopCommand+0x2e>
 800abec:	0801bab4 	.word	0x0801bab4
 800abf0:	0801bac8 	.word	0x0801bac8

0800abf4 <PauseLog>:
{
 800abf4:	b570      	push	{r4, r5, r6, lr}
 800abf6:	0005      	movs	r5, r0
 800abf8:	2400      	movs	r4, #0
		if((0U != logs[j].current_extension)  && (true == enableSequential))
 800abfa:	4b17      	ldr	r3, [pc, #92]	; (800ac58 <PauseLog+0x64>)
 800abfc:	0162      	lsls	r2, r4, #5
 800abfe:	18d2      	adds	r2, r2, r3
 800ac00:	7953      	ldrb	r3, [r2, #5]
 800ac02:	4e16      	ldr	r6, [pc, #88]	; (800ac5c <PauseLog+0x68>)
 800ac04:	6812      	ldr	r2, [r2, #0]
 800ac06:	2b00      	cmp	r3, #0
 800ac08:	d01b      	beq.n	800ac42 <PauseLog+0x4e>
 800ac0a:	4915      	ldr	r1, [pc, #84]	; (800ac60 <PauseLog+0x6c>)
 800ac0c:	7809      	ldrb	r1, [r1, #0]
 800ac0e:	2900      	cmp	r1, #0
 800ac10:	d017      	beq.n	800ac42 <PauseLog+0x4e>
			sprintf(tempName, "%s_%d", logs[j].name, logs[j].current_extension);
 800ac12:	4914      	ldr	r1, [pc, #80]	; (800ac64 <PauseLog+0x70>)
 800ac14:	0030      	movs	r0, r6
 800ac16:	f009 ff21 	bl	8014a5c <sprintf>
		if (!strcmp(tempName, logName))
 800ac1a:	0029      	movs	r1, r5
 800ac1c:	0030      	movs	r0, r6
 800ac1e:	f7f5 fa71 	bl	8000104 <strcmp>
 800ac22:	2800      	cmp	r0, #0
 800ac24:	d112      	bne.n	800ac4c <PauseLog+0x58>
			if ( (activeLogs >> j) & 0x01 )
 800ac26:	4d10      	ldr	r5, [pc, #64]	; (800ac68 <PauseLog+0x74>)
 800ac28:	2201      	movs	r2, #1
 800ac2a:	882b      	ldrh	r3, [r5, #0]
				return H1BR6_ERR_LogIsNotActive;
 800ac2c:	2108      	movs	r1, #8
			if ( (activeLogs >> j) & 0x01 )
 800ac2e:	001e      	movs	r6, r3
 800ac30:	4126      	asrs	r6, r4
 800ac32:	4216      	tst	r6, r2
 800ac34:	d003      	beq.n	800ac3e <PauseLog+0x4a>
				activeLogs &= ~(0x01 << j);
 800ac36:	40a2      	lsls	r2, r4
				return H1BR6_OK;
 800ac38:	0001      	movs	r1, r0
				activeLogs &= ~(0x01 << j);
 800ac3a:	4393      	bics	r3, r2
 800ac3c:	802b      	strh	r3, [r5, #0]
} 
 800ac3e:	0008      	movs	r0, r1
 800ac40:	bd70      	pop	{r4, r5, r6, pc}
			sprintf(tempName, "%s", logs[j].name);
 800ac42:	0011      	movs	r1, r2
 800ac44:	0030      	movs	r0, r6
 800ac46:	f009 ff45 	bl	8014ad4 <strcpy>
 800ac4a:	e7e6      	b.n	800ac1a <PauseLog+0x26>
 800ac4c:	3401      	adds	r4, #1
	for( j=0 ; j<MAX_LOGS ; j++)
 800ac4e:	2c0a      	cmp	r4, #10
 800ac50:	d1d3      	bne.n	800abfa <PauseLog+0x6>
	return H1BR6_ERR_LogDoesNotExist;	
 800ac52:	2107      	movs	r1, #7
 800ac54:	e7f3      	b.n	800ac3e <PauseLog+0x4a>
 800ac56:	46c0      	nop			; (mov r8, r8)
 800ac58:	200017dc 	.word	0x200017dc
 800ac5c:	2000191d 	.word	0x2000191d
 800ac60:	2000166e 	.word	0x2000166e
 800ac64:	0801b54f 	.word	0x0801b54f
 800ac68:	200077c8 	.word	0x200077c8

0800ac6c <pauseCommand>:
portBASE_TYPE pauseCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
	Module_Status result = H1BR6_OK;
	
	int8_t *pcParameterString1; 
	portBASE_TYPE xParameterStringLength1 = 0; 
 800ac6c:	2300      	movs	r3, #0
{
 800ac6e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800ac70:	0004      	movs	r4, r0
	portBASE_TYPE xParameterStringLength1 = 0; 
 800ac72:	9301      	str	r3, [sp, #4]
{
 800ac74:	0010      	movs	r0, r2

	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 800ac76:	429c      	cmp	r4, r3
 800ac78:	d101      	bne.n	800ac7e <pauseCommand+0x12>
 800ac7a:	b672      	cpsid	i
 800ac7c:	e7fe      	b.n	800ac7c <pauseCommand+0x10>
	
	/* Obtain the 1st parameter string: log name */
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800ac7e:	aa01      	add	r2, sp, #4
 800ac80:	2101      	movs	r1, #1
 800ac82:	f004 fe6b 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800ac86:	0005      	movs	r5, r0

	/* Pause the log */
	if (result == H1BR6_OK) {
		result = PauseLog((char *)pcParameterString1);	
 800ac88:	f7ff ffb4 	bl	800abf4 <PauseLog>
	}
	
	/* Respond to the command */
	if (result == H1BR6_OK) {
 800ac8c:	2800      	cmp	r0, #0
 800ac8e:	d106      	bne.n	800ac9e <pauseCommand+0x32>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage, pcParameterString1);
 800ac90:	002a      	movs	r2, r5
 800ac92:	4908      	ldr	r1, [pc, #32]	; (800acb4 <pauseCommand+0x48>)
	} else if (result ==  H1BR6_ERR_LogIsNotActive) {
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcIsNotActive, pcParameterString1);
 800ac94:	0020      	movs	r0, r4
 800ac96:	f009 fee1 	bl	8014a5c <sprintf>
	}  
	
	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
 800ac9a:	2000      	movs	r0, #0
 800ac9c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	} else if (result ==  H1BR6_ERR_LogIsNotActive) {
 800ac9e:	2808      	cmp	r0, #8
 800aca0:	d102      	bne.n	800aca8 <pauseCommand+0x3c>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcIsNotActive, pcParameterString1);
 800aca2:	002a      	movs	r2, r5
 800aca4:	4904      	ldr	r1, [pc, #16]	; (800acb8 <pauseCommand+0x4c>)
 800aca6:	e7f5      	b.n	800ac94 <pauseCommand+0x28>
	} else if (result ==  H1BR6_ERR_LogDoesNotExist) {
 800aca8:	2807      	cmp	r0, #7
 800acaa:	d1f6      	bne.n	800ac9a <pauseCommand+0x2e>
 800acac:	0020      	movs	r0, r4
 800acae:	f7fe fcdd 	bl	800966c <pauseCommand.part.6>
 800acb2:	e7f2      	b.n	800ac9a <pauseCommand+0x2e>
 800acb4:	0801ba3f 	.word	0x0801ba3f
 800acb8:	0801bac8 	.word	0x0801bac8

0800acbc <ResumeLog>:
{
 800acbc:	b570      	push	{r4, r5, r6, lr}
 800acbe:	0005      	movs	r5, r0
 800acc0:	2400      	movs	r4, #0
		if((0U != logs[j].current_extension)  && (true == enableSequential))
 800acc2:	4b13      	ldr	r3, [pc, #76]	; (800ad10 <ResumeLog+0x54>)
 800acc4:	0162      	lsls	r2, r4, #5
 800acc6:	18d2      	adds	r2, r2, r3
 800acc8:	7953      	ldrb	r3, [r2, #5]
 800acca:	4e12      	ldr	r6, [pc, #72]	; (800ad14 <ResumeLog+0x58>)
 800accc:	6812      	ldr	r2, [r2, #0]
 800acce:	2b00      	cmp	r3, #0
 800acd0:	d014      	beq.n	800acfc <ResumeLog+0x40>
 800acd2:	4911      	ldr	r1, [pc, #68]	; (800ad18 <ResumeLog+0x5c>)
 800acd4:	7809      	ldrb	r1, [r1, #0]
 800acd6:	2900      	cmp	r1, #0
 800acd8:	d010      	beq.n	800acfc <ResumeLog+0x40>
			sprintf(tempName, "%s_%d", logs[j].name, logs[j].current_extension);
 800acda:	4910      	ldr	r1, [pc, #64]	; (800ad1c <ResumeLog+0x60>)
 800acdc:	0030      	movs	r0, r6
 800acde:	f009 febd 	bl	8014a5c <sprintf>
		if (!strcmp(tempName, logName))
 800ace2:	0029      	movs	r1, r5
 800ace4:	0030      	movs	r0, r6
 800ace6:	f7f5 fa0d 	bl	8000104 <strcmp>
 800acea:	2800      	cmp	r0, #0
 800acec:	d10b      	bne.n	800ad06 <ResumeLog+0x4a>
			activeLogs |= (0x01 << j);
 800acee:	2301      	movs	r3, #1
 800acf0:	40a3      	lsls	r3, r4
 800acf2:	4a0b      	ldr	r2, [pc, #44]	; (800ad20 <ResumeLog+0x64>)
 800acf4:	8811      	ldrh	r1, [r2, #0]
 800acf6:	430b      	orrs	r3, r1
 800acf8:	8013      	strh	r3, [r2, #0]
} 
 800acfa:	bd70      	pop	{r4, r5, r6, pc}
			sprintf(tempName, "%s", logs[j].name);
 800acfc:	0011      	movs	r1, r2
 800acfe:	0030      	movs	r0, r6
 800ad00:	f009 fee8 	bl	8014ad4 <strcpy>
 800ad04:	e7ed      	b.n	800ace2 <ResumeLog+0x26>
 800ad06:	3401      	adds	r4, #1
	for( j=0 ; j<MAX_LOGS ; j++)
 800ad08:	2c0a      	cmp	r4, #10
 800ad0a:	d1da      	bne.n	800acc2 <ResumeLog+0x6>
	return H1BR6_ERR_LogDoesNotExist;	
 800ad0c:	2007      	movs	r0, #7
 800ad0e:	e7f4      	b.n	800acfa <ResumeLog+0x3e>
 800ad10:	200017dc 	.word	0x200017dc
 800ad14:	2000191d 	.word	0x2000191d
 800ad18:	2000166e 	.word	0x2000166e
 800ad1c:	0801b54f 	.word	0x0801b54f
 800ad20:	200077c8 	.word	0x200077c8

0800ad24 <resumeCommand>:
portBASE_TYPE resumeCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
	Module_Status result = H1BR6_OK;
	
	int8_t *pcParameterString1; 
	portBASE_TYPE xParameterStringLength1 = 0; 
 800ad24:	2300      	movs	r3, #0
{
 800ad26:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800ad28:	0004      	movs	r4, r0
	portBASE_TYPE xParameterStringLength1 = 0; 
 800ad2a:	9301      	str	r3, [sp, #4]
{
 800ad2c:	0010      	movs	r0, r2

	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 800ad2e:	429c      	cmp	r4, r3
 800ad30:	d101      	bne.n	800ad36 <resumeCommand+0x12>
 800ad32:	b672      	cpsid	i
 800ad34:	e7fe      	b.n	800ad34 <resumeCommand+0x10>
	
	/* Obtain the 1st parameter string: log name */
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800ad36:	aa01      	add	r2, sp, #4
 800ad38:	2101      	movs	r1, #1
 800ad3a:	f004 fe0f 	bl	800f95c <FreeRTOS_CLIGetParameter>
 800ad3e:	0005      	movs	r5, r0

	/* Resume the log */
	if (result == H1BR6_OK) {
		result = ResumeLog((char *)pcParameterString1);	
 800ad40:	f7ff ffbc 	bl	800acbc <ResumeLog>
	}
	
	/* Respond to the command */
	if (result == H1BR6_OK) {
 800ad44:	2800      	cmp	r0, #0
 800ad46:	d106      	bne.n	800ad56 <resumeCommand+0x32>
		sprintf( ( char * ) pcWriteBuffer, ( char * ) pcOKMessage, pcParameterString1);
 800ad48:	002a      	movs	r2, r5
 800ad4a:	4906      	ldr	r1, [pc, #24]	; (800ad64 <resumeCommand+0x40>)
 800ad4c:	0020      	movs	r0, r4
 800ad4e:	f009 fe85 	bl	8014a5c <sprintf>
	} 
	
	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
 800ad52:	2000      	movs	r0, #0
 800ad54:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	} else if (result ==  H1BR6_ERR_LogDoesNotExist) {
 800ad56:	2807      	cmp	r0, #7
 800ad58:	d1fb      	bne.n	800ad52 <resumeCommand+0x2e>
 800ad5a:	0020      	movs	r0, r4
 800ad5c:	f7fe fc86 	bl	800966c <pauseCommand.part.6>
 800ad60:	e7f7      	b.n	800ad52 <resumeCommand+0x2e>
 800ad62:	46c0      	nop			; (mov r8, r8)
 800ad64:	0801ba64 	.word	0x0801ba64

0800ad68 <StreamWaveToModule>:
{
 800ad68:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ad6a:	0004      	movs	r4, r0
 800ad6c:	000e      	movs	r6, r1
 800ad6e:	b087      	sub	sp, #28
	while(f_mount_ok==0){Delay_us(10);}		// Add a flag to allow card to be initialized on startup
 800ad70:	4b1d      	ldr	r3, [pc, #116]	; (800ade8 <StreamWaveToModule+0x80>)
 800ad72:	781b      	ldrb	r3, [r3, #0]
 800ad74:	2b00      	cmp	r3, #0
 800ad76:	d004      	beq.n	800ad82 <StreamWaveToModule+0x1a>
	if ( Wave_Full_Name != NULL )
 800ad78:	2c00      	cmp	r4, #0
 800ad7a:	d106      	bne.n	800ad8a <StreamWaveToModule+0x22>
	return WAVE_FILE_READ_FAILD;
 800ad7c:	2005      	movs	r0, #5
}
 800ad7e:	b007      	add	sp, #28
 800ad80:	bdf0      	pop	{r4, r5, r6, r7, pc}
	while(f_mount_ok==0){Delay_us(10);}		// Add a flag to allow card to be initialized on startup
 800ad82:	200a      	movs	r0, #10
 800ad84:	f002 f9c0 	bl	800d108 <StartMicroDelay>
 800ad88:	e7f2      	b.n	800ad70 <StreamWaveToModule+0x8>
			if (!WAVE_bytes)		// Read file header if it was not scanned before
 800ad8a:	4d18      	ldr	r5, [pc, #96]	; (800adec <StreamWaveToModule+0x84>)
 800ad8c:	682b      	ldr	r3, [r5, #0]
 800ad8e:	2b00      	cmp	r3, #0
 800ad90:	d10d      	bne.n	800adae <StreamWaveToModule+0x46>
				WAVE_STATE result = READ_WAVE_FILE_HEADER(Wave_Full_Name);
 800ad92:	0020      	movs	r0, r4
 800ad94:	f7fe ff86 	bl	8009ca4 <READ_WAVE_FILE_HEADER>
				if(result != HEADER_CHUNK_OK)	return WAVE_FILE_READ_FAILD;
 800ad98:	2802      	cmp	r0, #2
 800ad9a:	d1ef      	bne.n	800ad7c <StreamWaveToModule+0x14>
				WAVE_bytes	= WAVEFIL.SUBCHUNK2SIZE/((WAVEFIL.BITPERSAMPLE/8)*WAVEFIL.NO_CHANNEL);
 800ad9c:	4b14      	ldr	r3, [pc, #80]	; (800adf0 <StreamWaveToModule+0x88>)
 800ad9e:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 800ada0:	8ad9      	ldrh	r1, [r3, #22]
 800ada2:	08d2      	lsrs	r2, r2, #3
 800ada4:	4351      	muls	r1, r2
 800ada6:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800ada8:	f7f5 f9e6 	bl	8000178 <__udivsi3>
 800adac:	6028      	str	r0, [r5, #0]
			port = FindRoute(myID, H07R3x_ID); 
 800adae:	4f11      	ldr	r7, [pc, #68]	; (800adf4 <StreamWaveToModule+0x8c>)
 800adb0:	0031      	movs	r1, r6
 800adb2:	7838      	ldrb	r0, [r7, #0]
 800adb4:	f7f8 fc4e 	bl	8003654 <FindRoute>
			if ( StartScastDMAStream(0, myID, 0, H07R3x_ID, FORWARD, WAVE_bytes, 0xFFFFFFFF, 0) != BOS_OK )
 800adb8:	2301      	movs	r3, #1
			port = FindRoute(myID, H07R3x_ID); 
 800adba:	9005      	str	r0, [sp, #20]
			if ( StartScastDMAStream(0, myID, 0, H07R3x_ID, FORWARD, WAVE_bytes, 0xFFFFFFFF, 0) != BOS_OK )
 800adbc:	2000      	movs	r0, #0
 800adbe:	425b      	negs	r3, r3
 800adc0:	7839      	ldrb	r1, [r7, #0]
 800adc2:	9003      	str	r0, [sp, #12]
 800adc4:	9302      	str	r3, [sp, #8]
 800adc6:	682b      	ldr	r3, [r5, #0]
 800adc8:	0002      	movs	r2, r0
 800adca:	9301      	str	r3, [sp, #4]
 800adcc:	9000      	str	r0, [sp, #0]
 800adce:	0033      	movs	r3, r6
 800add0:	f7fd f8ce 	bl	8007f70 <StartScastDMAStream>
 800add4:	0003      	movs	r3, r0
					{return STREAM_WAVE_FAILD;}
 800add6:	20ff      	movs	r0, #255	; 0xff
			if ( StartScastDMAStream(0, myID, 0, H07R3x_ID, FORWARD, WAVE_bytes, 0xFFFFFFFF, 0) != BOS_OK )
 800add8:	2b00      	cmp	r3, #0
 800adda:	d1d0      	bne.n	800ad7e <StreamWaveToModule+0x16>
			return (StreamWaveToPort(Wave_Full_Name, port));
 800addc:	9905      	ldr	r1, [sp, #20]
 800adde:	0020      	movs	r0, r4
 800ade0:	f7ff f876 	bl	8009ed0 <StreamWaveToPort>
 800ade4:	e7cb      	b.n	800ad7e <StreamWaveToModule+0x16>
 800ade6:	46c0      	nop			; (mov r8, r8)
 800ade8:	20001670 	.word	0x20001670
 800adec:	20007150 	.word	0x20007150
 800adf0:	20007154 	.word	0x20007154
 800adf4:	20001039 	.word	0x20001039

0800adf8 <LogTask>:
{	
 800adf8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	MicroSD_Init();
 800adfa:	f7fe fe4f 	bl	8009a9c <MicroSD_Init>
							if (logVars[i].type && (logVars[i].logIndex == j))
 800adfe:	240c      	movs	r4, #12
		switch (SD_MODE)
 800ae00:	4dc0      	ldr	r5, [pc, #768]	; (800b104 <LogTask+0x30c>)
 800ae02:	782b      	ldrb	r3, [r5, #0]
 800ae04:	2b01      	cmp	r3, #1
 800ae06:	d00e      	beq.n	800ae26 <LogTask+0x2e>
 800ae08:	2b00      	cmp	r3, #0
 800ae0a:	d01c      	beq.n	800ae46 <LogTask+0x4e>
 800ae0c:	2b02      	cmp	r3, #2
 800ae0e:	d013      	beq.n	800ae38 <LogTask+0x40>
    if (resetButtonState)	
 800ae10:	4bbd      	ldr	r3, [pc, #756]	; (800b108 <LogTask+0x310>)
 800ae12:	781a      	ldrb	r2, [r3, #0]
 800ae14:	2a00      	cmp	r2, #0
 800ae16:	d003      	beq.n	800ae20 <LogTask+0x28>
      delayButtonStateReset = false;
 800ae18:	2200      	movs	r2, #0
 800ae1a:	49bc      	ldr	r1, [pc, #752]	; (800b10c <LogTask+0x314>)
      resetButtonState = 0;
 800ae1c:	701a      	strb	r2, [r3, #0]
      delayButtonStateReset = false;
 800ae1e:	700a      	strb	r2, [r1, #0]
	  taskYIELD(); 
 800ae20:	f006 fa18 	bl	8011254 <vPortYield>
		switch (SD_MODE)
 800ae24:	e7ec      	b.n	800ae00 <LogTask+0x8>
						ScanWaveFile(WAVE_NAME, temp_H07R3_ID);
 800ae26:	4bba      	ldr	r3, [pc, #744]	; (800b110 <LogTask+0x318>)
 800ae28:	7819      	ldrb	r1, [r3, #0]
 800ae2a:	4bba      	ldr	r3, [pc, #744]	; (800b114 <LogTask+0x31c>)
 800ae2c:	6818      	ldr	r0, [r3, #0]
 800ae2e:	f7ff f923 	bl	800a078 <ScanWaveFile>
						SD_MODE = LOG_MODE;
 800ae32:	2300      	movs	r3, #0
 800ae34:	702b      	strb	r3, [r5, #0]
						break;
 800ae36:	e7eb      	b.n	800ae10 <LogTask+0x18>
						StreamWaveToModule(WAVE_NAME, temp_H07R3_ID);
 800ae38:	4bb5      	ldr	r3, [pc, #724]	; (800b110 <LogTask+0x318>)
 800ae3a:	7819      	ldrb	r1, [r3, #0]
 800ae3c:	4bb5      	ldr	r3, [pc, #724]	; (800b114 <LogTask+0x31c>)
 800ae3e:	6818      	ldr	r0, [r3, #0]
 800ae40:	f7ff ff92 	bl	800ad68 <StreamWaveToModule>
 800ae44:	e7f5      	b.n	800ae32 <LogTask+0x3a>
				for( j=0 ; j<MAX_LOGS ; j++)
 800ae46:	4db4      	ldr	r5, [pc, #720]	; (800b118 <LogTask+0x320>)
 800ae48:	702b      	strb	r3, [r5, #0]
 800ae4a:	782b      	ldrb	r3, [r5, #0]
 800ae4c:	2b09      	cmp	r3, #9
 800ae4e:	d8df      	bhi.n	800ae10 <LogTask+0x18>
					u32lTick = HAL_GetTick()-logs[j].t0;
 800ae50:	f006 fb56 	bl	8011500 <HAL_GetTick>
 800ae54:	782b      	ldrb	r3, [r5, #0]
 800ae56:	4ab1      	ldr	r2, [pc, #708]	; (800b11c <LogTask+0x324>)
 800ae58:	015b      	lsls	r3, r3, #5
 800ae5a:	18d3      	adds	r3, r2, r3
 800ae5c:	699b      	ldr	r3, [r3, #24]
 800ae5e:	1ac0      	subs	r0, r0, r3
 800ae60:	4baf      	ldr	r3, [pc, #700]	; (800b120 <LogTask+0x328>)
 800ae62:	6018      	str	r0, [r3, #0]
					u32lRate = configTICK_RATE_HZ/logs[j].rate;
 800ae64:	782b      	ldrb	r3, [r5, #0]
 800ae66:	48af      	ldr	r0, [pc, #700]	; (800b124 <LogTask+0x32c>)
 800ae68:	015b      	lsls	r3, r3, #5
 800ae6a:	18d3      	adds	r3, r2, r3
 800ae6c:	6899      	ldr	r1, [r3, #8]
 800ae6e:	f7f5 fcbf 	bl	80007f0 <__aeabi_fdiv>
 800ae72:	f7f5 fbc5 	bl	8000600 <__aeabi_f2uiz>
 800ae76:	4bac      	ldr	r3, [pc, #688]	; (800b128 <LogTask+0x330>)
					if ( u32lTick >= u32lRate )
 800ae78:	4aa9      	ldr	r2, [pc, #676]	; (800b120 <LogTask+0x328>)
					u32lRate = configTICK_RATE_HZ/logs[j].rate;
 800ae7a:	6018      	str	r0, [r3, #0]
					if ( u32lTick >= u32lRate )
 800ae7c:	6812      	ldr	r2, [r2, #0]
 800ae7e:	681b      	ldr	r3, [r3, #0]
 800ae80:	429a      	cmp	r2, r3
 800ae82:	d306      	bcc.n	800ae92 <LogTask+0x9a>
						++logs[j].sampleCount;				// Advance one sample
 800ae84:	782b      	ldrb	r3, [r5, #0]
 800ae86:	4aa5      	ldr	r2, [pc, #660]	; (800b11c <LogTask+0x324>)
 800ae88:	015b      	lsls	r3, r3, #5
 800ae8a:	18d3      	adds	r3, r2, r3
 800ae8c:	69da      	ldr	r2, [r3, #28]
 800ae8e:	3201      	adds	r2, #1
 800ae90:	61da      	str	r2, [r3, #28]
					if ( (activeLogs >> j) & 0x01 )
 800ae92:	4ba6      	ldr	r3, [pc, #664]	; (800b12c <LogTask+0x334>)
 800ae94:	782a      	ldrb	r2, [r5, #0]
 800ae96:	881b      	ldrh	r3, [r3, #0]
 800ae98:	4113      	asrs	r3, r2
 800ae9a:	2201      	movs	r2, #1
 800ae9c:	4213      	tst	r3, r2
 800ae9e:	d030      	beq.n	800af02 <LogTask+0x10a>
						OpenThisLog(j, &MyFile);
 800aea0:	49a3      	ldr	r1, [pc, #652]	; (800b130 <LogTask+0x338>)
 800aea2:	7828      	ldrb	r0, [r5, #0]
 800aea4:	f7fe fec2 	bl	8009c2c <OpenThisLog>
						memset(lineBuffer, 0, sizeof(lineBuffer));
 800aea8:	2264      	movs	r2, #100	; 0x64
 800aeaa:	2100      	movs	r1, #0
 800aeac:	48a1      	ldr	r0, [pc, #644]	; (800b134 <LogTask+0x33c>)
 800aeae:	f009 fbda 	bl	8014666 <memset>
						for( i=0 ; i<MAX_LOG_VARS ; i++)
 800aeb2:	2200      	movs	r2, #0
											switch (button[logVars[i].source].state)
 800aeb4:	2609      	movs	r6, #9
						for( i=0 ; i<MAX_LOG_VARS ; i++)
 800aeb6:	4ba0      	ldr	r3, [pc, #640]	; (800b138 <LogTask+0x340>)
 800aeb8:	701a      	strb	r2, [r3, #0]
 800aeba:	4f9f      	ldr	r7, [pc, #636]	; (800b138 <LogTask+0x340>)
 800aebc:	783b      	ldrb	r3, [r7, #0]
 800aebe:	2b1d      	cmp	r3, #29
 800aec0:	d923      	bls.n	800af0a <LogTask+0x112>
						if (0 == newLine)
 800aec2:	4e9e      	ldr	r6, [pc, #632]	; (800b13c <LogTask+0x344>)
 800aec4:	7833      	ldrb	r3, [r6, #0]
 800aec6:	2b00      	cmp	r3, #0
 800aec8:	d10a      	bne.n	800aee0 <LogTask+0xe8>
							f_write(&MyFile, lineBuffer, strlen((const char *)lineBuffer), (void *)&byteswritten);
 800aeca:	489a      	ldr	r0, [pc, #616]	; (800b134 <LogTask+0x33c>)
 800aecc:	f7f5 f924 	bl	8000118 <strlen>
 800aed0:	4b9b      	ldr	r3, [pc, #620]	; (800b140 <LogTask+0x348>)
 800aed2:	0002      	movs	r2, r0
 800aed4:	4997      	ldr	r1, [pc, #604]	; (800b134 <LogTask+0x33c>)
 800aed6:	4896      	ldr	r0, [pc, #600]	; (800b130 <LogTask+0x338>)
 800aed8:	f004 f8fb 	bl	800f0d2 <f_write>
							newLine = 1;            /* Start a new line entry */
 800aedc:	2301      	movs	r3, #1
 800aede:	7033      	strb	r3, [r6, #0]
						f_close(&MyFile);
 800aee0:	4893      	ldr	r0, [pc, #588]	; (800b130 <LogTask+0x338>)
 800aee2:	f004 fa08 	bl	800f2f6 <f_close>
						if (u32lTick >= u32lRate)
 800aee6:	4b8e      	ldr	r3, [pc, #568]	; (800b120 <LogTask+0x328>)
 800aee8:	681a      	ldr	r2, [r3, #0]
 800aeea:	4b8f      	ldr	r3, [pc, #572]	; (800b128 <LogTask+0x330>)
 800aeec:	681b      	ldr	r3, [r3, #0]
 800aeee:	429a      	cmp	r2, r3
 800aef0:	d307      	bcc.n	800af02 <LogTask+0x10a>
							logs[j].t0 = HAL_GetTick();
 800aef2:	782e      	ldrb	r6, [r5, #0]
 800aef4:	f006 fb04 	bl	8011500 <HAL_GetTick>
 800aef8:	b2f6      	uxtb	r6, r6
 800aefa:	4b88      	ldr	r3, [pc, #544]	; (800b11c <LogTask+0x324>)
 800aefc:	0176      	lsls	r6, r6, #5
 800aefe:	199e      	adds	r6, r3, r6
 800af00:	61b0      	str	r0, [r6, #24]
				for( j=0 ; j<MAX_LOGS ; j++)
 800af02:	782b      	ldrb	r3, [r5, #0]
 800af04:	3301      	adds	r3, #1
 800af06:	b2db      	uxtb	r3, r3
 800af08:	e79e      	b.n	800ae48 <LogTask+0x50>
							if (logVars[i].type && (logVars[i].logIndex == j))
 800af0a:	783b      	ldrb	r3, [r7, #0]
 800af0c:	4a8d      	ldr	r2, [pc, #564]	; (800b144 <LogTask+0x34c>)
 800af0e:	4363      	muls	r3, r4
 800af10:	18d3      	adds	r3, r2, r3
 800af12:	785b      	ldrb	r3, [r3, #1]
 800af14:	2b00      	cmp	r3, #0
 800af16:	d03a      	beq.n	800af8e <LogTask+0x196>
 800af18:	783b      	ldrb	r3, [r7, #0]
 800af1a:	7829      	ldrb	r1, [r5, #0]
 800af1c:	4363      	muls	r3, r4
 800af1e:	5c9b      	ldrb	r3, [r3, r2]
 800af20:	428b      	cmp	r3, r1
 800af22:	d134      	bne.n	800af8e <LogTask+0x196>
								if ( ((RATE == logs[j].type) && (u32lTick >= u32lRate)) || CheckLogVarEvent(i) )
 800af24:	782b      	ldrb	r3, [r5, #0]
 800af26:	4a7d      	ldr	r2, [pc, #500]	; (800b11c <LogTask+0x324>)
 800af28:	015b      	lsls	r3, r3, #5
 800af2a:	18d3      	adds	r3, r2, r3
 800af2c:	799b      	ldrb	r3, [r3, #6]
 800af2e:	2b01      	cmp	r3, #1
 800af30:	d128      	bne.n	800af84 <LogTask+0x18c>
 800af32:	4b7b      	ldr	r3, [pc, #492]	; (800b120 <LogTask+0x328>)
 800af34:	681a      	ldr	r2, [r3, #0]
 800af36:	4b7c      	ldr	r3, [pc, #496]	; (800b128 <LogTask+0x330>)
 800af38:	681b      	ldr	r3, [r3, #0]
 800af3a:	429a      	cmp	r2, r3
 800af3c:	d322      	bcc.n	800af84 <LogTask+0x18c>
									if (newLine)
 800af3e:	4b7f      	ldr	r3, [pc, #508]	; (800b13c <LogTask+0x344>)
 800af40:	781a      	ldrb	r2, [r3, #0]
 800af42:	2a00      	cmp	r2, #0
 800af44:	d129      	bne.n	800af9a <LogTask+0x1a2>
									switch(logs[j].delimiterFormat)
 800af46:	782b      	ldrb	r3, [r5, #0]
 800af48:	4a74      	ldr	r2, [pc, #464]	; (800b11c <LogTask+0x324>)
 800af4a:	015b      	lsls	r3, r3, #5
 800af4c:	18d3      	adds	r3, r2, r3
 800af4e:	7b1b      	ldrb	r3, [r3, #12]
 800af50:	2b02      	cmp	r3, #2
 800af52:	d049      	beq.n	800afe8 <LogTask+0x1f0>
 800af54:	2b03      	cmp	r3, #3
 800af56:	d04c      	beq.n	800aff2 <LogTask+0x1fa>
											strcat(lineBuffer, " ");
 800af58:	497b      	ldr	r1, [pc, #492]	; (800b148 <LogTask+0x350>)
									switch(logs[j].delimiterFormat)
 800af5a:	2b01      	cmp	r3, #1
 800af5c:	d045      	beq.n	800afea <LogTask+0x1f2>
									switch (logVars[i].type)
 800af5e:	4b76      	ldr	r3, [pc, #472]	; (800b138 <LogTask+0x340>)
 800af60:	781a      	ldrb	r2, [r3, #0]
 800af62:	4b78      	ldr	r3, [pc, #480]	; (800b144 <LogTask+0x34c>)
 800af64:	4362      	muls	r2, r4
 800af66:	189a      	adds	r2, r3, r2
 800af68:	7850      	ldrb	r0, [r2, #1]
 800af6a:	3803      	subs	r0, #3
 800af6c:	2807      	cmp	r0, #7
 800af6e:	d80e      	bhi.n	800af8e <LogTask+0x196>
 800af70:	f7f5 f8f8 	bl	8000164 <__gnu_thumb1_case_uhi>
 800af74:	013c0041 	.word	0x013c0041
 800af78:	01520148 	.word	0x01520148
 800af7c:	01600159 	.word	0x01600159
 800af80:	016c0166 	.word	0x016c0166
								if ( ((RATE == logs[j].type) && (u32lTick >= u32lRate)) || CheckLogVarEvent(i) )
 800af84:	7838      	ldrb	r0, [r7, #0]
 800af86:	f7fe fddf 	bl	8009b48 <CheckLogVarEvent>
 800af8a:	2800      	cmp	r0, #0
 800af8c:	d1d7      	bne.n	800af3e <LogTask+0x146>
						for( i=0 ; i<MAX_LOG_VARS ; i++)
 800af8e:	4a6a      	ldr	r2, [pc, #424]	; (800b138 <LogTask+0x340>)
 800af90:	7813      	ldrb	r3, [r2, #0]
 800af92:	3301      	adds	r3, #1
 800af94:	b2db      	uxtb	r3, r3
 800af96:	7013      	strb	r3, [r2, #0]
 800af98:	e78f      	b.n	800aeba <LogTask+0xc2>
										newLine = 0;										// Event index written once per line     
 800af9a:	2200      	movs	r2, #0
 800af9c:	701a      	strb	r2, [r3, #0]
										if (logs[j].indexColumnFormat == FMT_TIME)
 800af9e:	782b      	ldrb	r3, [r5, #0]
 800afa0:	4a5e      	ldr	r2, [pc, #376]	; (800b11c <LogTask+0x324>)
 800afa2:	015b      	lsls	r3, r3, #5
 800afa4:	18d3      	adds	r3, r2, r3
 800afa6:	7b5b      	ldrb	r3, [r3, #13]
 800afa8:	2b02      	cmp	r3, #2
 800afaa:	d10d      	bne.n	800afc8 <LogTask+0x1d0>
											GetTimeDate();
 800afac:	f001 faf0 	bl	800c590 <GetTimeDate>
											sprintf(lineBuffer, "\n%02d:%02d:%02d-%03d", BOS.time.hours, BOS.time.minutes, BOS.time.seconds, BOS.time.msec);
 800afb0:	4966      	ldr	r1, [pc, #408]	; (800b14c <LogTask+0x354>)
 800afb2:	89c8      	ldrh	r0, [r1, #14]
 800afb4:	7c4b      	ldrb	r3, [r1, #17]
 800afb6:	7c8a      	ldrb	r2, [r1, #18]
 800afb8:	9001      	str	r0, [sp, #4]
 800afba:	7c09      	ldrb	r1, [r1, #16]
 800afbc:	485d      	ldr	r0, [pc, #372]	; (800b134 <LogTask+0x33c>)
 800afbe:	9100      	str	r1, [sp, #0]
 800afc0:	4963      	ldr	r1, [pc, #396]	; (800b150 <LogTask+0x358>)
 800afc2:	f009 fd4b 	bl	8014a5c <sprintf>
 800afc6:	e7be      	b.n	800af46 <LogTask+0x14e>
										else if (logs[j].indexColumnFormat == FMT_SAMPLE)
 800afc8:	782b      	ldrb	r3, [r5, #0]
 800afca:	4a54      	ldr	r2, [pc, #336]	; (800b11c <LogTask+0x324>)
 800afcc:	015b      	lsls	r3, r3, #5
 800afce:	18d3      	adds	r3, r2, r3
 800afd0:	7b5b      	ldrb	r3, [r3, #13]
 800afd2:	2b01      	cmp	r3, #1
 800afd4:	d1b7      	bne.n	800af46 <LogTask+0x14e>
											sprintf(lineBuffer, "\n%d", logs[j].sampleCount);
 800afd6:	782b      	ldrb	r3, [r5, #0]
 800afd8:	495e      	ldr	r1, [pc, #376]	; (800b154 <LogTask+0x35c>)
 800afda:	015b      	lsls	r3, r3, #5
 800afdc:	18d3      	adds	r3, r2, r3
 800afde:	69da      	ldr	r2, [r3, #28]
 800afe0:	4854      	ldr	r0, [pc, #336]	; (800b134 <LogTask+0x33c>)
 800afe2:	f009 fd3b 	bl	8014a5c <sprintf>
 800afe6:	e7ae      	b.n	800af46 <LogTask+0x14e>
											strcat(lineBuffer, "\t");
 800afe8:	495b      	ldr	r1, [pc, #364]	; (800b158 <LogTask+0x360>)
											strcat(lineBuffer, ",");
 800afea:	4852      	ldr	r0, [pc, #328]	; (800b134 <LogTask+0x33c>)
 800afec:	f009 fd56 	bl	8014a9c <strcat>
											break;
 800aff0:	e7b5      	b.n	800af5e <LogTask+0x166>
											strcat(lineBuffer, ",");
 800aff2:	495a      	ldr	r1, [pc, #360]	; (800b15c <LogTask+0x364>)
 800aff4:	e7f9      	b.n	800afea <LogTask+0x1f2>
											switch (button[logVars[i].source].state)
 800aff6:	7839      	ldrb	r1, [r7, #0]
 800aff8:	4a52      	ldr	r2, [pc, #328]	; (800b144 <LogTask+0x34c>)
 800affa:	4361      	muls	r1, r4
 800affc:	1852      	adds	r2, r2, r1
 800affe:	6892      	ldr	r2, [r2, #8]
 800b000:	4b57      	ldr	r3, [pc, #348]	; (800b160 <LogTask+0x368>)
 800b002:	4372      	muls	r2, r6
 800b004:	5cd0      	ldrb	r0, [r2, r3]
 800b006:	280e      	cmp	r0, #14
 800b008:	d833      	bhi.n	800b072 <LogTask+0x27a>
 800b00a:	4a4b      	ldr	r2, [pc, #300]	; (800b138 <LogTask+0x340>)
 800b00c:	f7f5 f896 	bl	800013c <__gnu_thumb1_case_uqi>
 800b010:	0f0d08e4 	.word	0x0f0d08e4
 800b014:	17151311 	.word	0x17151311
 800b018:	52401b19 	.word	0x52401b19
 800b01c:	be64      	.short	0xbe64
 800b01e:	d1          	.byte	0xd1
 800b01f:	00          	.byte	0x00
												case OFF:	strcat(lineBuffer, "OFF"); break; 
 800b020:	4950      	ldr	r1, [pc, #320]	; (800b164 <LogTask+0x36c>)
														strcat(lineBuffer, "NORMAL");
 800b022:	4844      	ldr	r0, [pc, #272]	; (800b134 <LogTask+0x33c>)
 800b024:	f009 fd3a 	bl	8014a9c <strcat>
 800b028:	e023      	b.n	800b072 <LogTask+0x27a>
												case ON:	strcat(lineBuffer, "ON"); break; 
 800b02a:	494f      	ldr	r1, [pc, #316]	; (800b168 <LogTask+0x370>)
 800b02c:	e7f9      	b.n	800b022 <LogTask+0x22a>
												case OPEN:	strcat(lineBuffer, "OPEN"); break; 
 800b02e:	494f      	ldr	r1, [pc, #316]	; (800b16c <LogTask+0x374>)
 800b030:	e7f7      	b.n	800b022 <LogTask+0x22a>
												case CLOSED:	strcat(lineBuffer, "CLOSED"); break; 
 800b032:	494f      	ldr	r1, [pc, #316]	; (800b170 <LogTask+0x378>)
 800b034:	e7f5      	b.n	800b022 <LogTask+0x22a>
												case CLICKED:	strcat(lineBuffer, "CLICKED"); break; 
 800b036:	494f      	ldr	r1, [pc, #316]	; (800b174 <LogTask+0x37c>)
 800b038:	e7f3      	b.n	800b022 <LogTask+0x22a>
												case DBL_CLICKED:	strcat(lineBuffer, "DBL_CLICKED"); break; 
 800b03a:	494f      	ldr	r1, [pc, #316]	; (800b178 <LogTask+0x380>)
 800b03c:	e7f1      	b.n	800b022 <LogTask+0x22a>
												case PRESSED:	strcat(lineBuffer, "PRESSED"); break; 
 800b03e:	494f      	ldr	r1, [pc, #316]	; (800b17c <LogTask+0x384>)
 800b040:	e7ef      	b.n	800b022 <LogTask+0x22a>
												case RELEASED:	strcat(lineBuffer, "RELEASED"); break; 
 800b042:	494f      	ldr	r1, [pc, #316]	; (800b180 <LogTask+0x388>)
 800b044:	e7ed      	b.n	800b022 <LogTask+0x22a>
													if (button[logVars[i].source].pressedX1Sec)
 800b046:	7811      	ldrb	r1, [r2, #0]
 800b048:	483e      	ldr	r0, [pc, #248]	; (800b144 <LogTask+0x34c>)
 800b04a:	4361      	muls	r1, r4
 800b04c:	1841      	adds	r1, r0, r1
 800b04e:	6889      	ldr	r1, [r1, #8]
 800b050:	4371      	muls	r1, r6
 800b052:	1859      	adds	r1, r3, r1
 800b054:	7889      	ldrb	r1, [r1, #2]
 800b056:	2900      	cmp	r1, #0
 800b058:	d00b      	beq.n	800b072 <LogTask+0x27a>
														sprintf((char *)lineBuffer, "%sPRESSED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].pressedX1Sec);
 800b05a:	7812      	ldrb	r2, [r2, #0]
 800b05c:	4362      	muls	r2, r4
 800b05e:	1880      	adds	r0, r0, r2
 800b060:	6882      	ldr	r2, [r0, #8]
 800b062:	4372      	muls	r2, r6
 800b064:	189b      	adds	r3, r3, r2
 800b066:	789b      	ldrb	r3, [r3, #2]
														sprintf((char *)lineBuffer, "%sPRESSED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].pressedX2Sec);
 800b068:	4832      	ldr	r0, [pc, #200]	; (800b134 <LogTask+0x33c>)
 800b06a:	4946      	ldr	r1, [pc, #280]	; (800b184 <LogTask+0x38c>)
 800b06c:	0002      	movs	r2, r0
														sprintf((char *)lineBuffer, "%sRELEASED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].releasedY3Sec); 
 800b06e:	f009 fcf5 	bl	8014a5c <sprintf>
											if (NONE != button[logVars[i].source].state)	
 800b072:	4b31      	ldr	r3, [pc, #196]	; (800b138 <LogTask+0x340>)
 800b074:	781a      	ldrb	r2, [r3, #0]
 800b076:	4b33      	ldr	r3, [pc, #204]	; (800b144 <LogTask+0x34c>)
 800b078:	4362      	muls	r2, r4
 800b07a:	189b      	adds	r3, r3, r2
 800b07c:	689b      	ldr	r3, [r3, #8]
 800b07e:	4a38      	ldr	r2, [pc, #224]	; (800b160 <LogTask+0x368>)
 800b080:	4373      	muls	r3, r6
 800b082:	5c9b      	ldrb	r3, [r3, r2]
 800b084:	2b00      	cmp	r3, #0
 800b086:	d082      	beq.n	800af8e <LogTask+0x196>
												resetButtonState = 1;
 800b088:	2201      	movs	r2, #1
 800b08a:	4b1f      	ldr	r3, [pc, #124]	; (800b108 <LogTask+0x310>)
 800b08c:	701a      	strb	r2, [r3, #0]
 800b08e:	e77e      	b.n	800af8e <LogTask+0x196>
													if (button[logVars[i].source].pressedX2Sec)
 800b090:	7811      	ldrb	r1, [r2, #0]
 800b092:	482c      	ldr	r0, [pc, #176]	; (800b144 <LogTask+0x34c>)
 800b094:	4361      	muls	r1, r4
 800b096:	1841      	adds	r1, r0, r1
 800b098:	6889      	ldr	r1, [r1, #8]
 800b09a:	4371      	muls	r1, r6
 800b09c:	1859      	adds	r1, r3, r1
 800b09e:	78c9      	ldrb	r1, [r1, #3]
 800b0a0:	2900      	cmp	r1, #0
 800b0a2:	d0e6      	beq.n	800b072 <LogTask+0x27a>
														sprintf((char *)lineBuffer, "%sPRESSED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].pressedX2Sec);
 800b0a4:	7812      	ldrb	r2, [r2, #0]
 800b0a6:	4362      	muls	r2, r4
 800b0a8:	1880      	adds	r0, r0, r2
 800b0aa:	6882      	ldr	r2, [r0, #8]
 800b0ac:	4372      	muls	r2, r6
 800b0ae:	189b      	adds	r3, r3, r2
 800b0b0:	78db      	ldrb	r3, [r3, #3]
 800b0b2:	e7d9      	b.n	800b068 <LogTask+0x270>
													if (button[logVars[i].source].pressedX3Sec)
 800b0b4:	7811      	ldrb	r1, [r2, #0]
 800b0b6:	4823      	ldr	r0, [pc, #140]	; (800b144 <LogTask+0x34c>)
 800b0b8:	4361      	muls	r1, r4
 800b0ba:	1841      	adds	r1, r0, r1
 800b0bc:	6889      	ldr	r1, [r1, #8]
 800b0be:	4371      	muls	r1, r6
 800b0c0:	1859      	adds	r1, r3, r1
 800b0c2:	7909      	ldrb	r1, [r1, #4]
 800b0c4:	2900      	cmp	r1, #0
 800b0c6:	d0d4      	beq.n	800b072 <LogTask+0x27a>
														sprintf((char *)lineBuffer, "%sPRESSED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].pressedX3Sec); 
 800b0c8:	7812      	ldrb	r2, [r2, #0]
 800b0ca:	4362      	muls	r2, r4
 800b0cc:	1880      	adds	r0, r0, r2
 800b0ce:	6882      	ldr	r2, [r0, #8]
 800b0d0:	4372      	muls	r2, r6
 800b0d2:	189b      	adds	r3, r3, r2
 800b0d4:	791b      	ldrb	r3, [r3, #4]
 800b0d6:	e7c7      	b.n	800b068 <LogTask+0x270>
													if (button[logVars[i].source].releasedY1Sec)
 800b0d8:	7811      	ldrb	r1, [r2, #0]
 800b0da:	481a      	ldr	r0, [pc, #104]	; (800b144 <LogTask+0x34c>)
 800b0dc:	4361      	muls	r1, r4
 800b0de:	1841      	adds	r1, r0, r1
 800b0e0:	6889      	ldr	r1, [r1, #8]
 800b0e2:	4371      	muls	r1, r6
 800b0e4:	1859      	adds	r1, r3, r1
 800b0e6:	7949      	ldrb	r1, [r1, #5]
 800b0e8:	2900      	cmp	r1, #0
 800b0ea:	d0c2      	beq.n	800b072 <LogTask+0x27a>
														sprintf((char *)lineBuffer, "%sRELEASED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].releasedY1Sec); 
 800b0ec:	7812      	ldrb	r2, [r2, #0]
 800b0ee:	4362      	muls	r2, r4
 800b0f0:	1880      	adds	r0, r0, r2
 800b0f2:	6882      	ldr	r2, [r0, #8]
 800b0f4:	4372      	muls	r2, r6
 800b0f6:	189b      	adds	r3, r3, r2
 800b0f8:	795b      	ldrb	r3, [r3, #5]
														sprintf((char *)lineBuffer, "%sRELEASED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].releasedY3Sec); 
 800b0fa:	480e      	ldr	r0, [pc, #56]	; (800b134 <LogTask+0x33c>)
 800b0fc:	4922      	ldr	r1, [pc, #136]	; (800b188 <LogTask+0x390>)
 800b0fe:	0002      	movs	r2, r0
 800b100:	e7b5      	b.n	800b06e <LogTask+0x276>
 800b102:	46c0      	nop			; (mov r8, r8)
 800b104:	2000166d 	.word	0x2000166d
 800b108:	2000191c 	.word	0x2000191c
 800b10c:	20001495 	.word	0x20001495
 800b110:	200070d9 	.word	0x200070d9
 800b114:	200073ac 	.word	0x200073ac
 800b118:	200070d8 	.word	0x200070d8
 800b11c:	200017dc 	.word	0x200017dc
 800b120:	2000193c 	.word	0x2000193c
 800b124:	447a0000 	.word	0x447a0000
 800b128:	20001938 	.word	0x20001938
 800b12c:	200077c8 	.word	0x200077c8
 800b130:	20007728 	.word	0x20007728
 800b134:	20007070 	.word	0x20007070
 800b138:	20007422 	.word	0x20007422
 800b13c:	20000098 	.word	0x20000098
 800b140:	2000714c 	.word	0x2000714c
 800b144:	20001674 	.word	0x20001674
 800b148:	08019df3 	.word	0x08019df3
 800b14c:	20006f70 	.word	0x20006f70
 800b150:	0801b555 	.word	0x0801b555
 800b154:	0801b56a 	.word	0x0801b56a
 800b158:	080192c4 	.word	0x080192c4
 800b15c:	0801b5df 	.word	0x0801b5df
 800b160:	20001458 	.word	0x20001458
 800b164:	0801b56e 	.word	0x0801b56e
 800b168:	0801b572 	.word	0x0801b572
 800b16c:	0801b575 	.word	0x0801b575
 800b170:	0801b57a 	.word	0x0801b57a
 800b174:	0801b585 	.word	0x0801b585
 800b178:	0801b581 	.word	0x0801b581
 800b17c:	0801b58d 	.word	0x0801b58d
 800b180:	0801b595 	.word	0x0801b595
 800b184:	0801b59e 	.word	0x0801b59e
 800b188:	0801b5b3 	.word	0x0801b5b3
													if (button[logVars[i].source].releasedY2Sec)
 800b18c:	7811      	ldrb	r1, [r2, #0]
 800b18e:	4837      	ldr	r0, [pc, #220]	; (800b26c <LogTask+0x474>)
 800b190:	4361      	muls	r1, r4
 800b192:	1841      	adds	r1, r0, r1
 800b194:	6889      	ldr	r1, [r1, #8]
 800b196:	4371      	muls	r1, r6
 800b198:	1859      	adds	r1, r3, r1
 800b19a:	7989      	ldrb	r1, [r1, #6]
 800b19c:	2900      	cmp	r1, #0
 800b19e:	d100      	bne.n	800b1a2 <LogTask+0x3aa>
 800b1a0:	e767      	b.n	800b072 <LogTask+0x27a>
														sprintf((char *)lineBuffer, "%sRELEASED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].releasedY2Sec); 
 800b1a2:	7812      	ldrb	r2, [r2, #0]
 800b1a4:	4362      	muls	r2, r4
 800b1a6:	1880      	adds	r0, r0, r2
 800b1a8:	6882      	ldr	r2, [r0, #8]
 800b1aa:	4372      	muls	r2, r6
 800b1ac:	189b      	adds	r3, r3, r2
 800b1ae:	799b      	ldrb	r3, [r3, #6]
 800b1b0:	e7a3      	b.n	800b0fa <LogTask+0x302>
													if (button[logVars[i].source].releasedY3Sec)
 800b1b2:	7811      	ldrb	r1, [r2, #0]
 800b1b4:	482d      	ldr	r0, [pc, #180]	; (800b26c <LogTask+0x474>)
 800b1b6:	4361      	muls	r1, r4
 800b1b8:	1841      	adds	r1, r0, r1
 800b1ba:	6889      	ldr	r1, [r1, #8]
 800b1bc:	4371      	muls	r1, r6
 800b1be:	1859      	adds	r1, r3, r1
 800b1c0:	79c9      	ldrb	r1, [r1, #7]
 800b1c2:	2900      	cmp	r1, #0
 800b1c4:	d100      	bne.n	800b1c8 <LogTask+0x3d0>
 800b1c6:	e754      	b.n	800b072 <LogTask+0x27a>
														sprintf((char *)lineBuffer, "%sRELEASED_FOR_%d_SEC", (char *) lineBuffer, button[logVars[i].source].releasedY3Sec); 
 800b1c8:	7812      	ldrb	r2, [r2, #0]
 800b1ca:	4362      	muls	r2, r4
 800b1cc:	1880      	adds	r0, r0, r2
 800b1ce:	6882      	ldr	r2, [r0, #8]
 800b1d0:	4372      	muls	r2, r6
 800b1d2:	189b      	adds	r3, r3, r2
 800b1d4:	79db      	ldrb	r3, [r3, #7]
 800b1d6:	e790      	b.n	800b0fa <LogTask+0x302>
													if (logs[j].type == RATE) 
 800b1d8:	782b      	ldrb	r3, [r5, #0]
 800b1da:	4a25      	ldr	r2, [pc, #148]	; (800b270 <LogTask+0x478>)
 800b1dc:	015b      	lsls	r3, r3, #5
 800b1de:	18d3      	adds	r3, r2, r3
 800b1e0:	799b      	ldrb	r3, [r3, #6]
 800b1e2:	2b01      	cmp	r3, #1
 800b1e4:	d000      	beq.n	800b1e8 <LogTask+0x3f0>
 800b1e6:	e744      	b.n	800b072 <LogTask+0x27a>
														strcat(lineBuffer, "NORMAL");
 800b1e8:	4922      	ldr	r1, [pc, #136]	; (800b274 <LogTask+0x47c>)
 800b1ea:	e71a      	b.n	800b022 <LogTask+0x22a>
											sprintf((char *)lineBuffer, "%s%u", (char *)lineBuffer, *(__IO uint8_t *)logVars[i].source);
 800b1ec:	783a      	ldrb	r2, [r7, #0]
 800b1ee:	4362      	muls	r2, r4
 800b1f0:	189b      	adds	r3, r3, r2
 800b1f2:	689b      	ldr	r3, [r3, #8]
 800b1f4:	781b      	ldrb	r3, [r3, #0]
 800b1f6:	b2db      	uxtb	r3, r3
											sprintf((char *)lineBuffer, "%s%u", (char *)lineBuffer, *(__IO uint32_t *)logVars[i].source); 
 800b1f8:	481f      	ldr	r0, [pc, #124]	; (800b278 <LogTask+0x480>)
 800b1fa:	4920      	ldr	r1, [pc, #128]	; (800b27c <LogTask+0x484>)
 800b1fc:	0002      	movs	r2, r0
											sprintf((char *)lineBuffer, "%s%d", (char *)lineBuffer, *(__IO int32_t *)logVars[i].source); 
 800b1fe:	f009 fc2d 	bl	8014a5c <sprintf>
											break;
 800b202:	e6c4      	b.n	800af8e <LogTask+0x196>
											sprintf((char *)lineBuffer, "%s%d", (char *)lineBuffer, *(__IO int8_t *)logVars[i].source); 
 800b204:	783a      	ldrb	r2, [r7, #0]
 800b206:	4362      	muls	r2, r4
 800b208:	189b      	adds	r3, r3, r2
 800b20a:	689b      	ldr	r3, [r3, #8]
 800b20c:	781b      	ldrb	r3, [r3, #0]
 800b20e:	b25b      	sxtb	r3, r3
											sprintf((char *)lineBuffer, "%s%d", (char *)lineBuffer, *(__IO int32_t *)logVars[i].source); 
 800b210:	4819      	ldr	r0, [pc, #100]	; (800b278 <LogTask+0x480>)
 800b212:	491b      	ldr	r1, [pc, #108]	; (800b280 <LogTask+0x488>)
 800b214:	0002      	movs	r2, r0
 800b216:	e7f2      	b.n	800b1fe <LogTask+0x406>
											sprintf((char *)lineBuffer, "%s%u", (char *)lineBuffer, *(__IO uint16_t *)logVars[i].source); 
 800b218:	783a      	ldrb	r2, [r7, #0]
 800b21a:	4362      	muls	r2, r4
 800b21c:	189b      	adds	r3, r3, r2
 800b21e:	689b      	ldr	r3, [r3, #8]
 800b220:	881b      	ldrh	r3, [r3, #0]
 800b222:	b29b      	uxth	r3, r3
 800b224:	e7e8      	b.n	800b1f8 <LogTask+0x400>
											sprintf((char *)lineBuffer, "%s%d", (char *)lineBuffer, *(__IO int16_t *)logVars[i].source); 
 800b226:	783a      	ldrb	r2, [r7, #0]
 800b228:	4362      	muls	r2, r4
 800b22a:	189b      	adds	r3, r3, r2
 800b22c:	689b      	ldr	r3, [r3, #8]
 800b22e:	881b      	ldrh	r3, [r3, #0]
 800b230:	b21b      	sxth	r3, r3
 800b232:	e7ed      	b.n	800b210 <LogTask+0x418>
											sprintf((char *)lineBuffer, "%s%u", (char *)lineBuffer, *(__IO uint32_t *)logVars[i].source); 
 800b234:	783a      	ldrb	r2, [r7, #0]
 800b236:	4362      	muls	r2, r4
 800b238:	189b      	adds	r3, r3, r2
 800b23a:	689b      	ldr	r3, [r3, #8]
 800b23c:	681b      	ldr	r3, [r3, #0]
 800b23e:	e7db      	b.n	800b1f8 <LogTask+0x400>
											sprintf((char *)lineBuffer, "%s%d", (char *)lineBuffer, *(__IO int32_t *)logVars[i].source); 
 800b240:	783a      	ldrb	r2, [r7, #0]
 800b242:	4362      	muls	r2, r4
 800b244:	189b      	adds	r3, r3, r2
 800b246:	689b      	ldr	r3, [r3, #8]
 800b248:	681b      	ldr	r3, [r3, #0]
 800b24a:	e7e1      	b.n	800b210 <LogTask+0x418>
											sprintf((char *)lineBuffer, "%s%f", (char *)lineBuffer, *(__IO float *)logVars[i].source);
 800b24c:	783a      	ldrb	r2, [r7, #0]
 800b24e:	4f0a      	ldr	r7, [pc, #40]	; (800b278 <LogTask+0x480>)
 800b250:	4362      	muls	r2, r4
 800b252:	189b      	adds	r3, r3, r2
 800b254:	689b      	ldr	r3, [r3, #8]
 800b256:	6818      	ldr	r0, [r3, #0]
 800b258:	f7f7 fc24 	bl	8002aa4 <__aeabi_f2d>
 800b25c:	003a      	movs	r2, r7
 800b25e:	9000      	str	r0, [sp, #0]
 800b260:	9101      	str	r1, [sp, #4]
 800b262:	4908      	ldr	r1, [pc, #32]	; (800b284 <LogTask+0x48c>)
 800b264:	0038      	movs	r0, r7
 800b266:	f009 fbf9 	bl	8014a5c <sprintf>
											break;
 800b26a:	e690      	b.n	800af8e <LogTask+0x196>
 800b26c:	20001674 	.word	0x20001674
 800b270:	200017dc 	.word	0x200017dc
 800b274:	0801b5c9 	.word	0x0801b5c9
 800b278:	20007070 	.word	0x20007070
 800b27c:	0801b5d0 	.word	0x0801b5d0
 800b280:	0801b5d5 	.word	0x0801b5d5
 800b284:	0801b5da 	.word	0x0801b5da

0800b288 <DMA_MSG_RX_CH_Init>:
/* Initialize a messaging RX DMA channel 
*/
void DMA_MSG_RX_CH_Init(DMA_HandleTypeDef *hDMA, DMA_Channel_TypeDef *ch)
{
	hDMA->Instance = ch;
	hDMA->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800b288:	2300      	movs	r3, #0
{
 800b28a:	b510      	push	{r4, lr}
	hDMA->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800b28c:	6043      	str	r3, [r0, #4]
	hDMA->Init.PeriphInc = DMA_PINC_DISABLE;
 800b28e:	6083      	str	r3, [r0, #8]
	hDMA->Init.MemInc = DMA_MINC_ENABLE;
	hDMA->Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800b290:	6103      	str	r3, [r0, #16]
	hDMA->Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800b292:	6143      	str	r3, [r0, #20]
	hDMA->Init.Mode = DMA_CIRCULAR; 
 800b294:	3320      	adds	r3, #32
 800b296:	6183      	str	r3, [r0, #24]
	hDMA->Init.Priority = MSG_DMA_PRIORITY;
 800b298:	2380      	movs	r3, #128	; 0x80
	hDMA->Init.MemInc = DMA_MINC_ENABLE;
 800b29a:	2280      	movs	r2, #128	; 0x80
	hDMA->Init.Priority = MSG_DMA_PRIORITY;
 800b29c:	019b      	lsls	r3, r3, #6
	hDMA->Instance = ch;
 800b29e:	6001      	str	r1, [r0, #0]
	hDMA->Init.MemInc = DMA_MINC_ENABLE;
 800b2a0:	60c2      	str	r2, [r0, #12]
	hDMA->Init.Priority = MSG_DMA_PRIORITY;
 800b2a2:	61c3      	str	r3, [r0, #28]
	
	HAL_DMA_Init(hDMA);		
 800b2a4:	f006 fac4 	bl	8011830 <HAL_DMA_Init>
}
 800b2a8:	bd10      	pop	{r4, pc}

0800b2aa <DMA_MSG_TX_CH_Init>:
/* Initialize a messaging TX DMA channel 
*/
void DMA_MSG_TX_CH_Init(DMA_HandleTypeDef *hDMA, DMA_Channel_TypeDef *ch)
{
	hDMA->Instance = ch;
	hDMA->Init.Direction = DMA_MEMORY_TO_PERIPH;
 800b2aa:	2310      	movs	r3, #16
{
 800b2ac:	b510      	push	{r4, lr}
	hDMA->Init.Direction = DMA_MEMORY_TO_PERIPH;
 800b2ae:	6043      	str	r3, [r0, #4]
	hDMA->Init.PeriphInc = DMA_PINC_DISABLE;
 800b2b0:	2300      	movs	r3, #0
 800b2b2:	6083      	str	r3, [r0, #8]
	hDMA->Init.MemInc = DMA_MINC_ENABLE;
	hDMA->Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800b2b4:	6103      	str	r3, [r0, #16]
	hDMA->Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800b2b6:	6143      	str	r3, [r0, #20]
	hDMA->Init.Mode = DMA_NORMAL; 
 800b2b8:	6183      	str	r3, [r0, #24]
	hDMA->Init.Priority = MSG_DMA_PRIORITY;
 800b2ba:	2380      	movs	r3, #128	; 0x80
	hDMA->Init.MemInc = DMA_MINC_ENABLE;
 800b2bc:	2280      	movs	r2, #128	; 0x80
	hDMA->Init.Priority = MSG_DMA_PRIORITY;
 800b2be:	019b      	lsls	r3, r3, #6
	hDMA->Instance = ch;
 800b2c0:	6001      	str	r1, [r0, #0]
	hDMA->Init.MemInc = DMA_MINC_ENABLE;
 800b2c2:	60c2      	str	r2, [r0, #12]
	hDMA->Init.Priority = MSG_DMA_PRIORITY;
 800b2c4:	61c3      	str	r3, [r0, #28]
	
	HAL_DMA_Init(hDMA);		
 800b2c6:	f006 fab3 	bl	8011830 <HAL_DMA_Init>
}
 800b2ca:	bd10      	pop	{r4, pc}

0800b2cc <DMA_Init>:
{
 800b2cc:	b507      	push	{r0, r1, r2, lr}
	__DMA1_CLK_ENABLE();
 800b2ce:	2001      	movs	r0, #1
 800b2d0:	4b18      	ldr	r3, [pc, #96]	; (800b334 <DMA_Init+0x68>)
 800b2d2:	6959      	ldr	r1, [r3, #20]
 800b2d4:	4301      	orrs	r1, r0
 800b2d6:	6159      	str	r1, [r3, #20]
	__DMA2_CLK_ENABLE();
 800b2d8:	2102      	movs	r1, #2
	__DMA1_CLK_ENABLE();
 800b2da:	695a      	ldr	r2, [r3, #20]
 800b2dc:	4002      	ands	r2, r0
 800b2de:	9200      	str	r2, [sp, #0]
 800b2e0:	9a00      	ldr	r2, [sp, #0]
	__DMA2_CLK_ENABLE();
 800b2e2:	695a      	ldr	r2, [r3, #20]
	DMA_MSG_RX_CH_Init(&msgRxDMA[0], DMA1_Channel1);
 800b2e4:	4814      	ldr	r0, [pc, #80]	; (800b338 <DMA_Init+0x6c>)
	__DMA2_CLK_ENABLE();
 800b2e6:	430a      	orrs	r2, r1
 800b2e8:	615a      	str	r2, [r3, #20]
 800b2ea:	695b      	ldr	r3, [r3, #20]
 800b2ec:	400b      	ands	r3, r1
 800b2ee:	9301      	str	r3, [sp, #4]
	DMA_MSG_RX_CH_Init(&msgRxDMA[0], DMA1_Channel1);
 800b2f0:	4912      	ldr	r1, [pc, #72]	; (800b33c <DMA_Init+0x70>)
	__DMA2_CLK_ENABLE();
 800b2f2:	9b01      	ldr	r3, [sp, #4]
	DMA_MSG_RX_CH_Init(&msgRxDMA[0], DMA1_Channel1);
 800b2f4:	f7ff ffc8 	bl	800b288 <DMA_MSG_RX_CH_Init>
	DMA_MSG_RX_CH_Init(&msgRxDMA[1], DMA1_Channel3);
 800b2f8:	4911      	ldr	r1, [pc, #68]	; (800b340 <DMA_Init+0x74>)
 800b2fa:	4812      	ldr	r0, [pc, #72]	; (800b344 <DMA_Init+0x78>)
 800b2fc:	f7ff ffc4 	bl	800b288 <DMA_MSG_RX_CH_Init>
	DMA_MSG_RX_CH_Init(&msgRxDMA[2], DMA1_Channel5);
 800b300:	4911      	ldr	r1, [pc, #68]	; (800b348 <DMA_Init+0x7c>)
 800b302:	4812      	ldr	r0, [pc, #72]	; (800b34c <DMA_Init+0x80>)
 800b304:	f7ff ffc0 	bl	800b288 <DMA_MSG_RX_CH_Init>
	DMA_MSG_RX_CH_Init(&msgRxDMA[3], DMA1_Channel6);
 800b308:	4911      	ldr	r1, [pc, #68]	; (800b350 <DMA_Init+0x84>)
 800b30a:	4812      	ldr	r0, [pc, #72]	; (800b354 <DMA_Init+0x88>)
 800b30c:	f7ff ffbc 	bl	800b288 <DMA_MSG_RX_CH_Init>
	DMA_MSG_RX_CH_Init(&msgRxDMA[4], DMA2_Channel2);
 800b310:	4911      	ldr	r1, [pc, #68]	; (800b358 <DMA_Init+0x8c>)
 800b312:	4812      	ldr	r0, [pc, #72]	; (800b35c <DMA_Init+0x90>)
 800b314:	f7ff ffb8 	bl	800b288 <DMA_MSG_RX_CH_Init>
	DMA_MSG_TX_CH_Init(&msgTxDMA[0], DMA1_Channel2);
 800b318:	4911      	ldr	r1, [pc, #68]	; (800b360 <DMA_Init+0x94>)
 800b31a:	4812      	ldr	r0, [pc, #72]	; (800b364 <DMA_Init+0x98>)
 800b31c:	f7ff ffc5 	bl	800b2aa <DMA_MSG_TX_CH_Init>
	DMA_MSG_TX_CH_Init(&msgTxDMA[1], DMA1_Channel4);
 800b320:	4911      	ldr	r1, [pc, #68]	; (800b368 <DMA_Init+0x9c>)
 800b322:	4812      	ldr	r0, [pc, #72]	; (800b36c <DMA_Init+0xa0>)
 800b324:	f7ff ffc1 	bl	800b2aa <DMA_MSG_TX_CH_Init>
	DMA_MSG_TX_CH_Init(&msgTxDMA[2], DMA1_Channel7);	
 800b328:	4911      	ldr	r1, [pc, #68]	; (800b370 <DMA_Init+0xa4>)
 800b32a:	4812      	ldr	r0, [pc, #72]	; (800b374 <DMA_Init+0xa8>)
 800b32c:	f7ff ffbd 	bl	800b2aa <DMA_MSG_TX_CH_Init>
}
 800b330:	bd07      	pop	{r0, r1, r2, pc}
 800b332:	46c0      	nop			; (mov r8, r8)
 800b334:	40021000 	.word	0x40021000
 800b338:	20001940 	.word	0x20001940
 800b33c:	40020008 	.word	0x40020008
 800b340:	40020030 	.word	0x40020030
 800b344:	20001978 	.word	0x20001978
 800b348:	40020058 	.word	0x40020058
 800b34c:	200019b0 	.word	0x200019b0
 800b350:	4002006c 	.word	0x4002006c
 800b354:	200019e8 	.word	0x200019e8
 800b358:	4002041c 	.word	0x4002041c
 800b35c:	20001a20 	.word	0x20001a20
 800b360:	4002001c 	.word	0x4002001c
 800b364:	20001a90 	.word	0x20001a90
 800b368:	40020044 	.word	0x40020044
 800b36c:	20001ac8 	.word	0x20001ac8
 800b370:	40020080 	.word	0x40020080
 800b374:	20001b00 	.word	0x20001b00

0800b378 <DMA_STREAM_CH_Init>:
/* Initialize a streaming DMA channel (RX only) 
*/
void DMA_STREAM_CH_Init(DMA_HandleTypeDef *hDMA, DMA_Channel_TypeDef *ch)
{
	hDMA->Instance = ch;
	hDMA->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800b378:	2300      	movs	r3, #0
{
 800b37a:	b510      	push	{r4, lr}
	hDMA->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800b37c:	6043      	str	r3, [r0, #4]
	hDMA->Init.PeriphInc = DMA_PINC_DISABLE;
 800b37e:	6083      	str	r3, [r0, #8]
	hDMA->Init.MemInc = DMA_MINC_DISABLE;
 800b380:	60c3      	str	r3, [r0, #12]
	hDMA->Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800b382:	6103      	str	r3, [r0, #16]
	hDMA->Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800b384:	6143      	str	r3, [r0, #20]
	hDMA->Init.Mode = DMA_CIRCULAR; 
 800b386:	3320      	adds	r3, #32
 800b388:	6183      	str	r3, [r0, #24]
	hDMA->Init.Priority = STREAM_DMA_PRIORITY;
 800b38a:	2380      	movs	r3, #128	; 0x80
 800b38c:	015b      	lsls	r3, r3, #5
	hDMA->Instance = ch;
 800b38e:	6001      	str	r1, [r0, #0]
	hDMA->Init.Priority = STREAM_DMA_PRIORITY;
 800b390:	61c3      	str	r3, [r0, #28]
	
	HAL_DMA_Init(hDMA);		
 800b392:	f006 fa4d 	bl	8011830 <HAL_DMA_Init>
}
 800b396:	bd10      	pop	{r4, pc}

0800b398 <SetupDMAInterrupts>:
/*-----------------------------------------------------------*/

/* Setup DMA interrupts  
*/
void SetupDMAInterrupts(DMA_HandleTypeDef *hDMA, uint8_t priority)
{
 800b398:	b510      	push	{r4, lr}
	switch ((uint32_t)hDMA->Instance)
 800b39a:	4a1d      	ldr	r2, [pc, #116]	; (800b410 <SetupDMAInterrupts+0x78>)
 800b39c:	6803      	ldr	r3, [r0, #0]
 800b39e:	4293      	cmp	r3, r2
 800b3a0:	d011      	beq.n	800b3c6 <SetupDMAInterrupts+0x2e>
 800b3a2:	d816      	bhi.n	800b3d2 <SetupDMAInterrupts+0x3a>
 800b3a4:	4a1b      	ldr	r2, [pc, #108]	; (800b414 <SetupDMAInterrupts+0x7c>)
 800b3a6:	4293      	cmp	r3, r2
 800b3a8:	d02c      	beq.n	800b404 <SetupDMAInterrupts+0x6c>
 800b3aa:	d806      	bhi.n	800b3ba <SetupDMAInterrupts+0x22>
 800b3ac:	4a1a      	ldr	r2, [pc, #104]	; (800b418 <SetupDMAInterrupts+0x80>)
 800b3ae:	4293      	cmp	r3, r2
 800b3b0:	d020      	beq.n	800b3f4 <SetupDMAInterrupts+0x5c>
 800b3b2:	4a1a      	ldr	r2, [pc, #104]	; (800b41c <SetupDMAInterrupts+0x84>)
 800b3b4:	4293      	cmp	r3, r2
 800b3b6:	d025      	beq.n	800b404 <SetupDMAInterrupts+0x6c>
			break;
		
		default:
			break;
	}			
}
 800b3b8:	bd10      	pop	{r4, pc}
	switch ((uint32_t)hDMA->Instance)
 800b3ba:	4a19      	ldr	r2, [pc, #100]	; (800b420 <SetupDMAInterrupts+0x88>)
 800b3bc:	4293      	cmp	r3, r2
 800b3be:	d002      	beq.n	800b3c6 <SetupDMAInterrupts+0x2e>
 800b3c0:	4a18      	ldr	r2, [pc, #96]	; (800b424 <SetupDMAInterrupts+0x8c>)
 800b3c2:	4293      	cmp	r3, r2
 800b3c4:	d1f8      	bne.n	800b3b8 <SetupDMAInterrupts+0x20>
			HAL_NVIC_SetPriority(DMA1_Ch4_7_DMA2_Ch3_5_IRQn, priority, 0);
 800b3c6:	200b      	movs	r0, #11
 800b3c8:	2200      	movs	r2, #0
 800b3ca:	f006 f8b9 	bl	8011540 <HAL_NVIC_SetPriority>
			HAL_NVIC_EnableIRQ(DMA1_Ch4_7_DMA2_Ch3_5_IRQn);			
 800b3ce:	200b      	movs	r0, #11
 800b3d0:	e015      	b.n	800b3fe <SetupDMAInterrupts+0x66>
	switch ((uint32_t)hDMA->Instance)
 800b3d2:	4a15      	ldr	r2, [pc, #84]	; (800b428 <SetupDMAInterrupts+0x90>)
 800b3d4:	4293      	cmp	r3, r2
 800b3d6:	d015      	beq.n	800b404 <SetupDMAInterrupts+0x6c>
 800b3d8:	d804      	bhi.n	800b3e4 <SetupDMAInterrupts+0x4c>
 800b3da:	4a14      	ldr	r2, [pc, #80]	; (800b42c <SetupDMAInterrupts+0x94>)
 800b3dc:	4293      	cmp	r3, r2
 800b3de:	d0f2      	beq.n	800b3c6 <SetupDMAInterrupts+0x2e>
 800b3e0:	4a13      	ldr	r2, [pc, #76]	; (800b430 <SetupDMAInterrupts+0x98>)
 800b3e2:	e7e7      	b.n	800b3b4 <SetupDMAInterrupts+0x1c>
 800b3e4:	4a13      	ldr	r2, [pc, #76]	; (800b434 <SetupDMAInterrupts+0x9c>)
 800b3e6:	4293      	cmp	r3, r2
 800b3e8:	d0ed      	beq.n	800b3c6 <SetupDMAInterrupts+0x2e>
 800b3ea:	4a13      	ldr	r2, [pc, #76]	; (800b438 <SetupDMAInterrupts+0xa0>)
 800b3ec:	4293      	cmp	r3, r2
 800b3ee:	d0ea      	beq.n	800b3c6 <SetupDMAInterrupts+0x2e>
 800b3f0:	4a12      	ldr	r2, [pc, #72]	; (800b43c <SetupDMAInterrupts+0xa4>)
 800b3f2:	e7e6      	b.n	800b3c2 <SetupDMAInterrupts+0x2a>
			HAL_NVIC_SetPriority(DMA1_Ch1_IRQn, priority, 0);
 800b3f4:	2009      	movs	r0, #9
 800b3f6:	2200      	movs	r2, #0
 800b3f8:	f006 f8a2 	bl	8011540 <HAL_NVIC_SetPriority>
			HAL_NVIC_EnableIRQ(DMA1_Ch1_IRQn);	
 800b3fc:	2009      	movs	r0, #9
			HAL_NVIC_EnableIRQ(DMA1_Ch4_7_DMA2_Ch3_5_IRQn);			
 800b3fe:	f006 f8c9 	bl	8011594 <HAL_NVIC_EnableIRQ>
}
 800b402:	e7d9      	b.n	800b3b8 <SetupDMAInterrupts+0x20>
			HAL_NVIC_SetPriority(DMA1_Ch2_3_DMA2_Ch1_2_IRQn, priority, 0);
 800b404:	200a      	movs	r0, #10
 800b406:	2200      	movs	r2, #0
 800b408:	f006 f89a 	bl	8011540 <HAL_NVIC_SetPriority>
			HAL_NVIC_EnableIRQ(DMA1_Ch2_3_DMA2_Ch1_2_IRQn);				
 800b40c:	200a      	movs	r0, #10
 800b40e:	e7f6      	b.n	800b3fe <SetupDMAInterrupts+0x66>
 800b410:	4002006c 	.word	0x4002006c
 800b414:	40020030 	.word	0x40020030
 800b418:	40020008 	.word	0x40020008
 800b41c:	4002001c 	.word	0x4002001c
 800b420:	40020044 	.word	0x40020044
 800b424:	40020058 	.word	0x40020058
 800b428:	4002041c 	.word	0x4002041c
 800b42c:	40020080 	.word	0x40020080
 800b430:	40020408 	.word	0x40020408
 800b434:	40020444 	.word	0x40020444
 800b438:	40020458 	.word	0x40020458
 800b43c:	40020430 	.word	0x40020430

0800b440 <UnSetupDMAInterrupts>:
/*-----------------------------------------------------------*/

/* UnSetup DMA interrupts  
*/
void UnSetupDMAInterrupts(DMA_HandleTypeDef *hDMA)
{
 800b440:	b510      	push	{r4, lr}
	switch ((uint32_t)hDMA->Instance)
 800b442:	4a17      	ldr	r2, [pc, #92]	; (800b4a0 <UnSetupDMAInterrupts+0x60>)
 800b444:	6803      	ldr	r3, [r0, #0]
 800b446:	4293      	cmp	r3, r2
 800b448:	d012      	beq.n	800b470 <UnSetupDMAInterrupts+0x30>
 800b44a:	d813      	bhi.n	800b474 <UnSetupDMAInterrupts+0x34>
 800b44c:	4a15      	ldr	r2, [pc, #84]	; (800b4a4 <UnSetupDMAInterrupts+0x64>)
 800b44e:	4293      	cmp	r3, r2
 800b450:	d021      	beq.n	800b496 <UnSetupDMAInterrupts+0x56>
 800b452:	d807      	bhi.n	800b464 <UnSetupDMAInterrupts+0x24>
 800b454:	4a14      	ldr	r2, [pc, #80]	; (800b4a8 <UnSetupDMAInterrupts+0x68>)
	{
		case (uint32_t)DMA1_Channel1:
			HAL_NVIC_DisableIRQ(DMA1_Ch1_IRQn);	
 800b456:	2009      	movs	r0, #9
	switch ((uint32_t)hDMA->Instance)
 800b458:	4293      	cmp	r3, r2
 800b45a:	d01d      	beq.n	800b498 <UnSetupDMAInterrupts+0x58>
 800b45c:	4a13      	ldr	r2, [pc, #76]	; (800b4ac <UnSetupDMAInterrupts+0x6c>)
 800b45e:	4293      	cmp	r3, r2
 800b460:	d019      	beq.n	800b496 <UnSetupDMAInterrupts+0x56>
			break;
		
		default:
			break;
	}			
}
 800b462:	bd10      	pop	{r4, pc}
	switch ((uint32_t)hDMA->Instance)
 800b464:	4a12      	ldr	r2, [pc, #72]	; (800b4b0 <UnSetupDMAInterrupts+0x70>)
 800b466:	4293      	cmp	r3, r2
 800b468:	d002      	beq.n	800b470 <UnSetupDMAInterrupts+0x30>
 800b46a:	4a12      	ldr	r2, [pc, #72]	; (800b4b4 <UnSetupDMAInterrupts+0x74>)
 800b46c:	4293      	cmp	r3, r2
 800b46e:	d1f8      	bne.n	800b462 <UnSetupDMAInterrupts+0x22>
			HAL_NVIC_DisableIRQ(DMA1_Ch4_7_DMA2_Ch3_5_IRQn);			
 800b470:	200b      	movs	r0, #11
 800b472:	e011      	b.n	800b498 <UnSetupDMAInterrupts+0x58>
	switch ((uint32_t)hDMA->Instance)
 800b474:	4a10      	ldr	r2, [pc, #64]	; (800b4b8 <UnSetupDMAInterrupts+0x78>)
 800b476:	4293      	cmp	r3, r2
 800b478:	d00d      	beq.n	800b496 <UnSetupDMAInterrupts+0x56>
 800b47a:	d804      	bhi.n	800b486 <UnSetupDMAInterrupts+0x46>
 800b47c:	4a0f      	ldr	r2, [pc, #60]	; (800b4bc <UnSetupDMAInterrupts+0x7c>)
 800b47e:	4293      	cmp	r3, r2
 800b480:	d0f6      	beq.n	800b470 <UnSetupDMAInterrupts+0x30>
 800b482:	4a0f      	ldr	r2, [pc, #60]	; (800b4c0 <UnSetupDMAInterrupts+0x80>)
 800b484:	e7eb      	b.n	800b45e <UnSetupDMAInterrupts+0x1e>
 800b486:	4a0f      	ldr	r2, [pc, #60]	; (800b4c4 <UnSetupDMAInterrupts+0x84>)
 800b488:	4293      	cmp	r3, r2
 800b48a:	d0f1      	beq.n	800b470 <UnSetupDMAInterrupts+0x30>
 800b48c:	4a0e      	ldr	r2, [pc, #56]	; (800b4c8 <UnSetupDMAInterrupts+0x88>)
 800b48e:	4293      	cmp	r3, r2
 800b490:	d0ee      	beq.n	800b470 <UnSetupDMAInterrupts+0x30>
 800b492:	4a0e      	ldr	r2, [pc, #56]	; (800b4cc <UnSetupDMAInterrupts+0x8c>)
 800b494:	e7ea      	b.n	800b46c <UnSetupDMAInterrupts+0x2c>
			HAL_NVIC_DisableIRQ(DMA1_Ch2_3_DMA2_Ch1_2_IRQn);				
 800b496:	200a      	movs	r0, #10
			HAL_NVIC_DisableIRQ(DMA1_Ch4_7_DMA2_Ch3_5_IRQn);			
 800b498:	f006 f886 	bl	80115a8 <HAL_NVIC_DisableIRQ>
}
 800b49c:	e7e1      	b.n	800b462 <UnSetupDMAInterrupts+0x22>
 800b49e:	46c0      	nop			; (mov r8, r8)
 800b4a0:	4002006c 	.word	0x4002006c
 800b4a4:	40020030 	.word	0x40020030
 800b4a8:	40020008 	.word	0x40020008
 800b4ac:	4002001c 	.word	0x4002001c
 800b4b0:	40020044 	.word	0x40020044
 800b4b4:	40020058 	.word	0x40020058
 800b4b8:	4002041c 	.word	0x4002041c
 800b4bc:	40020080 	.word	0x40020080
 800b4c0:	40020408 	.word	0x40020408
 800b4c4:	40020444 	.word	0x40020444
 800b4c8:	40020458 	.word	0x40020458
 800b4cc:	40020430 	.word	0x40020430

0800b4d0 <DMA_MSG_TX_UnSetup>:
{	
 800b4d0:	b510      	push	{r4, lr}
 800b4d2:	0004      	movs	r4, r0
	UnSetupDMAInterrupts(huart->hdmatx);
 800b4d4:	6e00      	ldr	r0, [r0, #96]	; 0x60
 800b4d6:	f7ff ffb3 	bl	800b440 <UnSetupDMAInterrupts>
	huart->hdmatx->Parent = NULL;
 800b4da:	2300      	movs	r3, #0
 800b4dc:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800b4de:	6253      	str	r3, [r2, #36]	; 0x24
	huart->hdmatx = NULL;
 800b4e0:	6623      	str	r3, [r4, #96]	; 0x60
}
 800b4e2:	bd10      	pop	{r4, pc}

0800b4e4 <RemapAndLinkDMAtoUARTRx>:
/* Remap and link the UART RX and DMA structs 
*/
void RemapAndLinkDMAtoUARTRx(UART_HandleTypeDef *huart, DMA_HandleTypeDef *hDMA)
{
	// USART 1
	if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel1) {
 800b4e4:	6803      	ldr	r3, [r0, #0]
 800b4e6:	4ab8      	ldr	r2, [pc, #736]	; (800b7c8 <RemapAndLinkDMAtoUARTRx+0x2e4>)
{
 800b4e8:	b510      	push	{r4, lr}
	if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel1) {
 800b4ea:	4293      	cmp	r3, r2
 800b4ec:	d143      	bne.n	800b576 <RemapAndLinkDMAtoUARTRx+0x92>
 800b4ee:	680b      	ldr	r3, [r1, #0]
 800b4f0:	4ab6      	ldr	r2, [pc, #728]	; (800b7cc <RemapAndLinkDMAtoUARTRx+0x2e8>)
 800b4f2:	4293      	cmp	r3, r2
 800b4f4:	d10b      	bne.n	800b50e <RemapAndLinkDMAtoUARTRx+0x2a>
		__HAL_DMA1_REMAP(HAL_DMA1_CH1_USART1_RX);
 800b4f6:	240f      	movs	r4, #15
 800b4f8:	4bb5      	ldr	r3, [pc, #724]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b4fa:	681a      	ldr	r2, [r3, #0]
 800b4fc:	43a2      	bics	r2, r4
 800b4fe:	601a      	str	r2, [r3, #0]
 800b500:	2208      	movs	r2, #8
 800b502:	681c      	ldr	r4, [r3, #0]
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA1_Channel6) {
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART8_RX);	
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel2) {
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART8_RX);	
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel3) {
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART8_RX);					
 800b504:	4322      	orrs	r2, r4
 800b506:	601a      	str	r2, [r3, #0]
	}		
	
	__HAL_LINKDMA(huart,hdmarx,*hDMA);	
 800b508:	6641      	str	r1, [r0, #100]	; 0x64
 800b50a:	6248      	str	r0, [r1, #36]	; 0x24
}
 800b50c:	bd10      	pop	{r4, pc}
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel3) {
 800b50e:	4ab1      	ldr	r2, [pc, #708]	; (800b7d4 <RemapAndLinkDMAtoUARTRx+0x2f0>)
 800b510:	4293      	cmp	r3, r2
 800b512:	d108      	bne.n	800b526 <RemapAndLinkDMAtoUARTRx+0x42>
		__HAL_DMA1_REMAP(HAL_DMA1_CH3_USART1_RX);
 800b514:	4bae      	ldr	r3, [pc, #696]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART1_RX);	
 800b516:	681a      	ldr	r2, [r3, #0]
 800b518:	4caf      	ldr	r4, [pc, #700]	; (800b7d8 <RemapAndLinkDMAtoUARTRx+0x2f4>)
 800b51a:	4022      	ands	r2, r4
 800b51c:	601a      	str	r2, [r3, #0]
 800b51e:	2280      	movs	r2, #128	; 0x80
 800b520:	681c      	ldr	r4, [r3, #0]
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART8_RX);					
 800b522:	0112      	lsls	r2, r2, #4
 800b524:	e7ee      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel5) {
 800b526:	4aad      	ldr	r2, [pc, #692]	; (800b7dc <RemapAndLinkDMAtoUARTRx+0x2f8>)
 800b528:	4293      	cmp	r3, r2
 800b52a:	d108      	bne.n	800b53e <RemapAndLinkDMAtoUARTRx+0x5a>
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART1_RX);		
 800b52c:	4ba8      	ldr	r3, [pc, #672]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b52e:	4cac      	ldr	r4, [pc, #688]	; (800b7e0 <RemapAndLinkDMAtoUARTRx+0x2fc>)
 800b530:	681a      	ldr	r2, [r3, #0]
 800b532:	4022      	ands	r2, r4
 800b534:	601a      	str	r2, [r3, #0]
 800b536:	2280      	movs	r2, #128	; 0x80
 800b538:	681c      	ldr	r4, [r3, #0]
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART2_RX);		
 800b53a:	0312      	lsls	r2, r2, #12
 800b53c:	e7e2      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel6) {
 800b53e:	4aa9      	ldr	r2, [pc, #676]	; (800b7e4 <RemapAndLinkDMAtoUARTRx+0x300>)
 800b540:	4293      	cmp	r3, r2
 800b542:	d108      	bne.n	800b556 <RemapAndLinkDMAtoUARTRx+0x72>
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART1_RX);	
 800b544:	4ba2      	ldr	r3, [pc, #648]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b546:	4ca8      	ldr	r4, [pc, #672]	; (800b7e8 <RemapAndLinkDMAtoUARTRx+0x304>)
 800b548:	681a      	ldr	r2, [r3, #0]
 800b54a:	4022      	ands	r2, r4
 800b54c:	601a      	str	r2, [r3, #0]
 800b54e:	2280      	movs	r2, #128	; 0x80
 800b550:	681c      	ldr	r4, [r3, #0]
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART2_RX);	
 800b552:	0412      	lsls	r2, r2, #16
 800b554:	e7d6      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA2_Channel2) {
 800b556:	4aa5      	ldr	r2, [pc, #660]	; (800b7ec <RemapAndLinkDMAtoUARTRx+0x308>)
 800b558:	4293      	cmp	r3, r2
 800b55a:	d107      	bne.n	800b56c <RemapAndLinkDMAtoUARTRx+0x88>
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART1_RX);	
 800b55c:	24f0      	movs	r4, #240	; 0xf0
 800b55e:	4ba4      	ldr	r3, [pc, #656]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b560:	681a      	ldr	r2, [r3, #0]
 800b562:	43a2      	bics	r2, r4
 800b564:	601a      	str	r2, [r3, #0]
 800b566:	681c      	ldr	r4, [r3, #0]
 800b568:	2280      	movs	r2, #128	; 0x80
 800b56a:	e7cb      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA2_Channel3) {
 800b56c:	4aa1      	ldr	r2, [pc, #644]	; (800b7f4 <RemapAndLinkDMAtoUARTRx+0x310>)
 800b56e:	4293      	cmp	r3, r2
 800b570:	d1ca      	bne.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART1_RX);	
 800b572:	4b9f      	ldr	r3, [pc, #636]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b574:	e7cf      	b.n	800b516 <RemapAndLinkDMAtoUARTRx+0x32>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA1_Channel1) {
 800b576:	4aa0      	ldr	r2, [pc, #640]	; (800b7f8 <RemapAndLinkDMAtoUARTRx+0x314>)
 800b578:	4293      	cmp	r3, r2
 800b57a:	d13d      	bne.n	800b5f8 <RemapAndLinkDMAtoUARTRx+0x114>
 800b57c:	680b      	ldr	r3, [r1, #0]
 800b57e:	4a93      	ldr	r2, [pc, #588]	; (800b7cc <RemapAndLinkDMAtoUARTRx+0x2e8>)
 800b580:	4293      	cmp	r3, r2
 800b582:	d107      	bne.n	800b594 <RemapAndLinkDMAtoUARTRx+0xb0>
		__HAL_DMA1_REMAP(HAL_DMA1_CH1_USART2_RX);
 800b584:	240f      	movs	r4, #15
 800b586:	4b92      	ldr	r3, [pc, #584]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b588:	681a      	ldr	r2, [r3, #0]
 800b58a:	43a2      	bics	r2, r4
 800b58c:	601a      	str	r2, [r3, #0]
 800b58e:	681c      	ldr	r4, [r3, #0]
 800b590:	2209      	movs	r2, #9
 800b592:	e7b7      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA1_Channel3) {
 800b594:	4a8f      	ldr	r2, [pc, #572]	; (800b7d4 <RemapAndLinkDMAtoUARTRx+0x2f0>)
 800b596:	4293      	cmp	r3, r2
 800b598:	d107      	bne.n	800b5aa <RemapAndLinkDMAtoUARTRx+0xc6>
		__HAL_DMA1_REMAP(HAL_DMA1_CH3_USART2_RX);
 800b59a:	4b8d      	ldr	r3, [pc, #564]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART2_RX);	
 800b59c:	681a      	ldr	r2, [r3, #0]
 800b59e:	4c8e      	ldr	r4, [pc, #568]	; (800b7d8 <RemapAndLinkDMAtoUARTRx+0x2f4>)
 800b5a0:	4022      	ands	r2, r4
 800b5a2:	601a      	str	r2, [r3, #0]
 800b5a4:	681c      	ldr	r4, [r3, #0]
 800b5a6:	2290      	movs	r2, #144	; 0x90
 800b5a8:	e7bb      	b.n	800b522 <RemapAndLinkDMAtoUARTRx+0x3e>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA1_Channel5) {
 800b5aa:	4a8c      	ldr	r2, [pc, #560]	; (800b7dc <RemapAndLinkDMAtoUARTRx+0x2f8>)
 800b5ac:	4293      	cmp	r3, r2
 800b5ae:	d107      	bne.n	800b5c0 <RemapAndLinkDMAtoUARTRx+0xdc>
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART2_RX);		
 800b5b0:	4b87      	ldr	r3, [pc, #540]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b5b2:	4c8b      	ldr	r4, [pc, #556]	; (800b7e0 <RemapAndLinkDMAtoUARTRx+0x2fc>)
 800b5b4:	681a      	ldr	r2, [r3, #0]
 800b5b6:	4022      	ands	r2, r4
 800b5b8:	601a      	str	r2, [r3, #0]
 800b5ba:	681c      	ldr	r4, [r3, #0]
 800b5bc:	2290      	movs	r2, #144	; 0x90
 800b5be:	e7bc      	b.n	800b53a <RemapAndLinkDMAtoUARTRx+0x56>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA1_Channel6) {
 800b5c0:	4a88      	ldr	r2, [pc, #544]	; (800b7e4 <RemapAndLinkDMAtoUARTRx+0x300>)
 800b5c2:	4293      	cmp	r3, r2
 800b5c4:	d107      	bne.n	800b5d6 <RemapAndLinkDMAtoUARTRx+0xf2>
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART2_RX);	
 800b5c6:	4b82      	ldr	r3, [pc, #520]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b5c8:	4c87      	ldr	r4, [pc, #540]	; (800b7e8 <RemapAndLinkDMAtoUARTRx+0x304>)
 800b5ca:	681a      	ldr	r2, [r3, #0]
 800b5cc:	4022      	ands	r2, r4
 800b5ce:	601a      	str	r2, [r3, #0]
 800b5d0:	681c      	ldr	r4, [r3, #0]
 800b5d2:	2290      	movs	r2, #144	; 0x90
 800b5d4:	e7bd      	b.n	800b552 <RemapAndLinkDMAtoUARTRx+0x6e>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA2_Channel2) {
 800b5d6:	4a85      	ldr	r2, [pc, #532]	; (800b7ec <RemapAndLinkDMAtoUARTRx+0x308>)
 800b5d8:	4293      	cmp	r3, r2
 800b5da:	d107      	bne.n	800b5ec <RemapAndLinkDMAtoUARTRx+0x108>
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART2_RX);	
 800b5dc:	24f0      	movs	r4, #240	; 0xf0
 800b5de:	4b84      	ldr	r3, [pc, #528]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b5e0:	681a      	ldr	r2, [r3, #0]
 800b5e2:	43a2      	bics	r2, r4
 800b5e4:	601a      	str	r2, [r3, #0]
 800b5e6:	681c      	ldr	r4, [r3, #0]
 800b5e8:	2290      	movs	r2, #144	; 0x90
 800b5ea:	e78b      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA2_Channel3) {
 800b5ec:	4a81      	ldr	r2, [pc, #516]	; (800b7f4 <RemapAndLinkDMAtoUARTRx+0x310>)
 800b5ee:	4293      	cmp	r3, r2
 800b5f0:	d000      	beq.n	800b5f4 <RemapAndLinkDMAtoUARTRx+0x110>
 800b5f2:	e789      	b.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART2_RX);	
 800b5f4:	4b7e      	ldr	r3, [pc, #504]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b5f6:	e7d1      	b.n	800b59c <RemapAndLinkDMAtoUARTRx+0xb8>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA1_Channel1) {
 800b5f8:	4a80      	ldr	r2, [pc, #512]	; (800b7fc <RemapAndLinkDMAtoUARTRx+0x318>)
 800b5fa:	4293      	cmp	r3, r2
 800b5fc:	d13d      	bne.n	800b67a <RemapAndLinkDMAtoUARTRx+0x196>
 800b5fe:	680b      	ldr	r3, [r1, #0]
 800b600:	4a72      	ldr	r2, [pc, #456]	; (800b7cc <RemapAndLinkDMAtoUARTRx+0x2e8>)
 800b602:	4293      	cmp	r3, r2
 800b604:	d107      	bne.n	800b616 <RemapAndLinkDMAtoUARTRx+0x132>
		__HAL_DMA1_REMAP(HAL_DMA1_CH1_USART3_RX);
 800b606:	240f      	movs	r4, #15
 800b608:	4b71      	ldr	r3, [pc, #452]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b60a:	681a      	ldr	r2, [r3, #0]
 800b60c:	43a2      	bics	r2, r4
 800b60e:	601a      	str	r2, [r3, #0]
 800b610:	681c      	ldr	r4, [r3, #0]
 800b612:	220a      	movs	r2, #10
 800b614:	e776      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA1_Channel3) {
 800b616:	4a6f      	ldr	r2, [pc, #444]	; (800b7d4 <RemapAndLinkDMAtoUARTRx+0x2f0>)
 800b618:	4293      	cmp	r3, r2
 800b61a:	d107      	bne.n	800b62c <RemapAndLinkDMAtoUARTRx+0x148>
		__HAL_DMA1_REMAP(HAL_DMA1_CH3_USART3_RX);
 800b61c:	4b6c      	ldr	r3, [pc, #432]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART3_RX);			
 800b61e:	681a      	ldr	r2, [r3, #0]
 800b620:	4c6d      	ldr	r4, [pc, #436]	; (800b7d8 <RemapAndLinkDMAtoUARTRx+0x2f4>)
 800b622:	4022      	ands	r2, r4
 800b624:	601a      	str	r2, [r3, #0]
 800b626:	681c      	ldr	r4, [r3, #0]
 800b628:	22a0      	movs	r2, #160	; 0xa0
 800b62a:	e77a      	b.n	800b522 <RemapAndLinkDMAtoUARTRx+0x3e>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA1_Channel5) {
 800b62c:	4a6b      	ldr	r2, [pc, #428]	; (800b7dc <RemapAndLinkDMAtoUARTRx+0x2f8>)
 800b62e:	4293      	cmp	r3, r2
 800b630:	d107      	bne.n	800b642 <RemapAndLinkDMAtoUARTRx+0x15e>
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART3_RX);		
 800b632:	4b67      	ldr	r3, [pc, #412]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b634:	4c6a      	ldr	r4, [pc, #424]	; (800b7e0 <RemapAndLinkDMAtoUARTRx+0x2fc>)
 800b636:	681a      	ldr	r2, [r3, #0]
 800b638:	4022      	ands	r2, r4
 800b63a:	601a      	str	r2, [r3, #0]
 800b63c:	681c      	ldr	r4, [r3, #0]
 800b63e:	22a0      	movs	r2, #160	; 0xa0
 800b640:	e77b      	b.n	800b53a <RemapAndLinkDMAtoUARTRx+0x56>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA1_Channel6) {
 800b642:	4a68      	ldr	r2, [pc, #416]	; (800b7e4 <RemapAndLinkDMAtoUARTRx+0x300>)
 800b644:	4293      	cmp	r3, r2
 800b646:	d107      	bne.n	800b658 <RemapAndLinkDMAtoUARTRx+0x174>
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART3_RX);	
 800b648:	4b61      	ldr	r3, [pc, #388]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b64a:	4c67      	ldr	r4, [pc, #412]	; (800b7e8 <RemapAndLinkDMAtoUARTRx+0x304>)
 800b64c:	681a      	ldr	r2, [r3, #0]
 800b64e:	4022      	ands	r2, r4
 800b650:	601a      	str	r2, [r3, #0]
 800b652:	681c      	ldr	r4, [r3, #0]
 800b654:	22a0      	movs	r2, #160	; 0xa0
 800b656:	e77c      	b.n	800b552 <RemapAndLinkDMAtoUARTRx+0x6e>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA2_Channel2) {
 800b658:	4a64      	ldr	r2, [pc, #400]	; (800b7ec <RemapAndLinkDMAtoUARTRx+0x308>)
 800b65a:	4293      	cmp	r3, r2
 800b65c:	d107      	bne.n	800b66e <RemapAndLinkDMAtoUARTRx+0x18a>
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART3_RX);	
 800b65e:	24f0      	movs	r4, #240	; 0xf0
 800b660:	4b63      	ldr	r3, [pc, #396]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b662:	681a      	ldr	r2, [r3, #0]
 800b664:	43a2      	bics	r2, r4
 800b666:	601a      	str	r2, [r3, #0]
 800b668:	681c      	ldr	r4, [r3, #0]
 800b66a:	22a0      	movs	r2, #160	; 0xa0
 800b66c:	e74a      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA2_Channel3) {
 800b66e:	4a61      	ldr	r2, [pc, #388]	; (800b7f4 <RemapAndLinkDMAtoUARTRx+0x310>)
 800b670:	4293      	cmp	r3, r2
 800b672:	d000      	beq.n	800b676 <RemapAndLinkDMAtoUARTRx+0x192>
 800b674:	e748      	b.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART3_RX);			
 800b676:	4b5e      	ldr	r3, [pc, #376]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b678:	e7d1      	b.n	800b61e <RemapAndLinkDMAtoUARTRx+0x13a>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA1_Channel1) {
 800b67a:	4a61      	ldr	r2, [pc, #388]	; (800b800 <RemapAndLinkDMAtoUARTRx+0x31c>)
 800b67c:	4293      	cmp	r3, r2
 800b67e:	d13d      	bne.n	800b6fc <RemapAndLinkDMAtoUARTRx+0x218>
 800b680:	680b      	ldr	r3, [r1, #0]
 800b682:	4a52      	ldr	r2, [pc, #328]	; (800b7cc <RemapAndLinkDMAtoUARTRx+0x2e8>)
 800b684:	4293      	cmp	r3, r2
 800b686:	d107      	bne.n	800b698 <RemapAndLinkDMAtoUARTRx+0x1b4>
		__HAL_DMA1_REMAP(HAL_DMA1_CH1_USART4_RX);
 800b688:	240f      	movs	r4, #15
 800b68a:	4b51      	ldr	r3, [pc, #324]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b68c:	681a      	ldr	r2, [r3, #0]
 800b68e:	43a2      	bics	r2, r4
 800b690:	601a      	str	r2, [r3, #0]
 800b692:	681c      	ldr	r4, [r3, #0]
 800b694:	220b      	movs	r2, #11
 800b696:	e735      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA1_Channel3) {
 800b698:	4a4e      	ldr	r2, [pc, #312]	; (800b7d4 <RemapAndLinkDMAtoUARTRx+0x2f0>)
 800b69a:	4293      	cmp	r3, r2
 800b69c:	d107      	bne.n	800b6ae <RemapAndLinkDMAtoUARTRx+0x1ca>
		__HAL_DMA1_REMAP(HAL_DMA1_CH3_USART4_RX);
 800b69e:	4b4c      	ldr	r3, [pc, #304]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART4_RX);				
 800b6a0:	681a      	ldr	r2, [r3, #0]
 800b6a2:	4c4d      	ldr	r4, [pc, #308]	; (800b7d8 <RemapAndLinkDMAtoUARTRx+0x2f4>)
 800b6a4:	4022      	ands	r2, r4
 800b6a6:	601a      	str	r2, [r3, #0]
 800b6a8:	681c      	ldr	r4, [r3, #0]
 800b6aa:	22b0      	movs	r2, #176	; 0xb0
 800b6ac:	e739      	b.n	800b522 <RemapAndLinkDMAtoUARTRx+0x3e>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA1_Channel5) {
 800b6ae:	4a4b      	ldr	r2, [pc, #300]	; (800b7dc <RemapAndLinkDMAtoUARTRx+0x2f8>)
 800b6b0:	4293      	cmp	r3, r2
 800b6b2:	d107      	bne.n	800b6c4 <RemapAndLinkDMAtoUARTRx+0x1e0>
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART4_RX);		
 800b6b4:	4b46      	ldr	r3, [pc, #280]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b6b6:	4c4a      	ldr	r4, [pc, #296]	; (800b7e0 <RemapAndLinkDMAtoUARTRx+0x2fc>)
 800b6b8:	681a      	ldr	r2, [r3, #0]
 800b6ba:	4022      	ands	r2, r4
 800b6bc:	601a      	str	r2, [r3, #0]
 800b6be:	681c      	ldr	r4, [r3, #0]
 800b6c0:	22b0      	movs	r2, #176	; 0xb0
 800b6c2:	e73a      	b.n	800b53a <RemapAndLinkDMAtoUARTRx+0x56>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA1_Channel6) {
 800b6c4:	4a47      	ldr	r2, [pc, #284]	; (800b7e4 <RemapAndLinkDMAtoUARTRx+0x300>)
 800b6c6:	4293      	cmp	r3, r2
 800b6c8:	d107      	bne.n	800b6da <RemapAndLinkDMAtoUARTRx+0x1f6>
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART4_RX);	
 800b6ca:	4b41      	ldr	r3, [pc, #260]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b6cc:	4c46      	ldr	r4, [pc, #280]	; (800b7e8 <RemapAndLinkDMAtoUARTRx+0x304>)
 800b6ce:	681a      	ldr	r2, [r3, #0]
 800b6d0:	4022      	ands	r2, r4
 800b6d2:	601a      	str	r2, [r3, #0]
 800b6d4:	681c      	ldr	r4, [r3, #0]
 800b6d6:	22b0      	movs	r2, #176	; 0xb0
 800b6d8:	e73b      	b.n	800b552 <RemapAndLinkDMAtoUARTRx+0x6e>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA2_Channel2) {
 800b6da:	4a44      	ldr	r2, [pc, #272]	; (800b7ec <RemapAndLinkDMAtoUARTRx+0x308>)
 800b6dc:	4293      	cmp	r3, r2
 800b6de:	d107      	bne.n	800b6f0 <RemapAndLinkDMAtoUARTRx+0x20c>
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART4_RX);	
 800b6e0:	24f0      	movs	r4, #240	; 0xf0
 800b6e2:	4b43      	ldr	r3, [pc, #268]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b6e4:	681a      	ldr	r2, [r3, #0]
 800b6e6:	43a2      	bics	r2, r4
 800b6e8:	601a      	str	r2, [r3, #0]
 800b6ea:	681c      	ldr	r4, [r3, #0]
 800b6ec:	22b0      	movs	r2, #176	; 0xb0
 800b6ee:	e709      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA2_Channel3) {
 800b6f0:	4a40      	ldr	r2, [pc, #256]	; (800b7f4 <RemapAndLinkDMAtoUARTRx+0x310>)
 800b6f2:	4293      	cmp	r3, r2
 800b6f4:	d000      	beq.n	800b6f8 <RemapAndLinkDMAtoUARTRx+0x214>
 800b6f6:	e707      	b.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART4_RX);				
 800b6f8:	4b3d      	ldr	r3, [pc, #244]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b6fa:	e7d1      	b.n	800b6a0 <RemapAndLinkDMAtoUARTRx+0x1bc>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA1_Channel1) {
 800b6fc:	4a41      	ldr	r2, [pc, #260]	; (800b804 <RemapAndLinkDMAtoUARTRx+0x320>)
 800b6fe:	4293      	cmp	r3, r2
 800b700:	d13d      	bne.n	800b77e <RemapAndLinkDMAtoUARTRx+0x29a>
 800b702:	680b      	ldr	r3, [r1, #0]
 800b704:	4a31      	ldr	r2, [pc, #196]	; (800b7cc <RemapAndLinkDMAtoUARTRx+0x2e8>)
 800b706:	4293      	cmp	r3, r2
 800b708:	d107      	bne.n	800b71a <RemapAndLinkDMAtoUARTRx+0x236>
		__HAL_DMA1_REMAP(HAL_DMA1_CH1_USART5_RX);
 800b70a:	240f      	movs	r4, #15
 800b70c:	4b30      	ldr	r3, [pc, #192]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b70e:	681a      	ldr	r2, [r3, #0]
 800b710:	43a2      	bics	r2, r4
 800b712:	601a      	str	r2, [r3, #0]
 800b714:	681c      	ldr	r4, [r3, #0]
 800b716:	220c      	movs	r2, #12
 800b718:	e6f4      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA1_Channel3) {
 800b71a:	4a2e      	ldr	r2, [pc, #184]	; (800b7d4 <RemapAndLinkDMAtoUARTRx+0x2f0>)
 800b71c:	4293      	cmp	r3, r2
 800b71e:	d107      	bne.n	800b730 <RemapAndLinkDMAtoUARTRx+0x24c>
		__HAL_DMA1_REMAP(HAL_DMA1_CH3_USART5_RX);
 800b720:	4b2b      	ldr	r3, [pc, #172]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART5_RX);					
 800b722:	681a      	ldr	r2, [r3, #0]
 800b724:	4c2c      	ldr	r4, [pc, #176]	; (800b7d8 <RemapAndLinkDMAtoUARTRx+0x2f4>)
 800b726:	4022      	ands	r2, r4
 800b728:	601a      	str	r2, [r3, #0]
 800b72a:	681c      	ldr	r4, [r3, #0]
 800b72c:	22c0      	movs	r2, #192	; 0xc0
 800b72e:	e6f8      	b.n	800b522 <RemapAndLinkDMAtoUARTRx+0x3e>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA1_Channel5) {
 800b730:	4a2a      	ldr	r2, [pc, #168]	; (800b7dc <RemapAndLinkDMAtoUARTRx+0x2f8>)
 800b732:	4293      	cmp	r3, r2
 800b734:	d107      	bne.n	800b746 <RemapAndLinkDMAtoUARTRx+0x262>
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART5_RX);		
 800b736:	4b26      	ldr	r3, [pc, #152]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b738:	4c29      	ldr	r4, [pc, #164]	; (800b7e0 <RemapAndLinkDMAtoUARTRx+0x2fc>)
 800b73a:	681a      	ldr	r2, [r3, #0]
 800b73c:	4022      	ands	r2, r4
 800b73e:	601a      	str	r2, [r3, #0]
 800b740:	681c      	ldr	r4, [r3, #0]
 800b742:	22c0      	movs	r2, #192	; 0xc0
 800b744:	e6f9      	b.n	800b53a <RemapAndLinkDMAtoUARTRx+0x56>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA1_Channel6) {
 800b746:	4a27      	ldr	r2, [pc, #156]	; (800b7e4 <RemapAndLinkDMAtoUARTRx+0x300>)
 800b748:	4293      	cmp	r3, r2
 800b74a:	d107      	bne.n	800b75c <RemapAndLinkDMAtoUARTRx+0x278>
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART5_RX);	
 800b74c:	4b20      	ldr	r3, [pc, #128]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b74e:	4c26      	ldr	r4, [pc, #152]	; (800b7e8 <RemapAndLinkDMAtoUARTRx+0x304>)
 800b750:	681a      	ldr	r2, [r3, #0]
 800b752:	4022      	ands	r2, r4
 800b754:	601a      	str	r2, [r3, #0]
 800b756:	681c      	ldr	r4, [r3, #0]
 800b758:	22c0      	movs	r2, #192	; 0xc0
 800b75a:	e6fa      	b.n	800b552 <RemapAndLinkDMAtoUARTRx+0x6e>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA2_Channel2) {
 800b75c:	4a23      	ldr	r2, [pc, #140]	; (800b7ec <RemapAndLinkDMAtoUARTRx+0x308>)
 800b75e:	4293      	cmp	r3, r2
 800b760:	d107      	bne.n	800b772 <RemapAndLinkDMAtoUARTRx+0x28e>
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART5_RX);	
 800b762:	24f0      	movs	r4, #240	; 0xf0
 800b764:	4b22      	ldr	r3, [pc, #136]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b766:	681a      	ldr	r2, [r3, #0]
 800b768:	43a2      	bics	r2, r4
 800b76a:	601a      	str	r2, [r3, #0]
 800b76c:	681c      	ldr	r4, [r3, #0]
 800b76e:	22c0      	movs	r2, #192	; 0xc0
 800b770:	e6c8      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA2_Channel3) {
 800b772:	4a20      	ldr	r2, [pc, #128]	; (800b7f4 <RemapAndLinkDMAtoUARTRx+0x310>)
 800b774:	4293      	cmp	r3, r2
 800b776:	d000      	beq.n	800b77a <RemapAndLinkDMAtoUARTRx+0x296>
 800b778:	e6c6      	b.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART5_RX);					
 800b77a:	4b1d      	ldr	r3, [pc, #116]	; (800b7f0 <RemapAndLinkDMAtoUARTRx+0x30c>)
 800b77c:	e7d1      	b.n	800b722 <RemapAndLinkDMAtoUARTRx+0x23e>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA1_Channel1) {
 800b77e:	4a22      	ldr	r2, [pc, #136]	; (800b808 <RemapAndLinkDMAtoUARTRx+0x324>)
 800b780:	4293      	cmp	r3, r2
 800b782:	d15f      	bne.n	800b844 <RemapAndLinkDMAtoUARTRx+0x360>
 800b784:	680b      	ldr	r3, [r1, #0]
 800b786:	4a11      	ldr	r2, [pc, #68]	; (800b7cc <RemapAndLinkDMAtoUARTRx+0x2e8>)
 800b788:	4293      	cmp	r3, r2
 800b78a:	d107      	bne.n	800b79c <RemapAndLinkDMAtoUARTRx+0x2b8>
		__HAL_DMA1_REMAP(HAL_DMA1_CH1_USART6_RX);
 800b78c:	240f      	movs	r4, #15
 800b78e:	4b10      	ldr	r3, [pc, #64]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b790:	681a      	ldr	r2, [r3, #0]
 800b792:	43a2      	bics	r2, r4
 800b794:	601a      	str	r2, [r3, #0]
 800b796:	681c      	ldr	r4, [r3, #0]
 800b798:	220d      	movs	r2, #13
 800b79a:	e6b3      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA1_Channel3) {
 800b79c:	4a0d      	ldr	r2, [pc, #52]	; (800b7d4 <RemapAndLinkDMAtoUARTRx+0x2f0>)
 800b79e:	4293      	cmp	r3, r2
 800b7a0:	d107      	bne.n	800b7b2 <RemapAndLinkDMAtoUARTRx+0x2ce>
		__HAL_DMA1_REMAP(HAL_DMA1_CH3_USART6_RX);
 800b7a2:	4b0b      	ldr	r3, [pc, #44]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART6_RX);					
 800b7a4:	681a      	ldr	r2, [r3, #0]
 800b7a6:	4c0c      	ldr	r4, [pc, #48]	; (800b7d8 <RemapAndLinkDMAtoUARTRx+0x2f4>)
 800b7a8:	4022      	ands	r2, r4
 800b7aa:	601a      	str	r2, [r3, #0]
 800b7ac:	681c      	ldr	r4, [r3, #0]
 800b7ae:	22d0      	movs	r2, #208	; 0xd0
 800b7b0:	e6b7      	b.n	800b522 <RemapAndLinkDMAtoUARTRx+0x3e>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA1_Channel5) {
 800b7b2:	4a0a      	ldr	r2, [pc, #40]	; (800b7dc <RemapAndLinkDMAtoUARTRx+0x2f8>)
 800b7b4:	4293      	cmp	r3, r2
 800b7b6:	d129      	bne.n	800b80c <RemapAndLinkDMAtoUARTRx+0x328>
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART6_RX);		
 800b7b8:	4b05      	ldr	r3, [pc, #20]	; (800b7d0 <RemapAndLinkDMAtoUARTRx+0x2ec>)
 800b7ba:	4c09      	ldr	r4, [pc, #36]	; (800b7e0 <RemapAndLinkDMAtoUARTRx+0x2fc>)
 800b7bc:	681a      	ldr	r2, [r3, #0]
 800b7be:	4022      	ands	r2, r4
 800b7c0:	601a      	str	r2, [r3, #0]
 800b7c2:	681c      	ldr	r4, [r3, #0]
 800b7c4:	22d0      	movs	r2, #208	; 0xd0
 800b7c6:	e6b8      	b.n	800b53a <RemapAndLinkDMAtoUARTRx+0x56>
 800b7c8:	40013800 	.word	0x40013800
 800b7cc:	40020008 	.word	0x40020008
 800b7d0:	400200a8 	.word	0x400200a8
 800b7d4:	40020030 	.word	0x40020030
 800b7d8:	fffff0ff 	.word	0xfffff0ff
 800b7dc:	40020058 	.word	0x40020058
 800b7e0:	fff0ffff 	.word	0xfff0ffff
 800b7e4:	4002006c 	.word	0x4002006c
 800b7e8:	ff0fffff 	.word	0xff0fffff
 800b7ec:	4002041c 	.word	0x4002041c
 800b7f0:	400204a8 	.word	0x400204a8
 800b7f4:	40020430 	.word	0x40020430
 800b7f8:	40004400 	.word	0x40004400
 800b7fc:	40004800 	.word	0x40004800
 800b800:	40004c00 	.word	0x40004c00
 800b804:	40005000 	.word	0x40005000
 800b808:	40011400 	.word	0x40011400
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA1_Channel6) {
 800b80c:	4a4c      	ldr	r2, [pc, #304]	; (800b940 <RemapAndLinkDMAtoUARTRx+0x45c>)
 800b80e:	4293      	cmp	r3, r2
 800b810:	d107      	bne.n	800b822 <RemapAndLinkDMAtoUARTRx+0x33e>
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART6_RX);	
 800b812:	4b4c      	ldr	r3, [pc, #304]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
 800b814:	4c4c      	ldr	r4, [pc, #304]	; (800b948 <RemapAndLinkDMAtoUARTRx+0x464>)
 800b816:	681a      	ldr	r2, [r3, #0]
 800b818:	4022      	ands	r2, r4
 800b81a:	601a      	str	r2, [r3, #0]
 800b81c:	681c      	ldr	r4, [r3, #0]
 800b81e:	22d0      	movs	r2, #208	; 0xd0
 800b820:	e697      	b.n	800b552 <RemapAndLinkDMAtoUARTRx+0x6e>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA2_Channel2) {
 800b822:	4a4a      	ldr	r2, [pc, #296]	; (800b94c <RemapAndLinkDMAtoUARTRx+0x468>)
 800b824:	4293      	cmp	r3, r2
 800b826:	d107      	bne.n	800b838 <RemapAndLinkDMAtoUARTRx+0x354>
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART6_RX);	
 800b828:	24f0      	movs	r4, #240	; 0xf0
 800b82a:	4b49      	ldr	r3, [pc, #292]	; (800b950 <RemapAndLinkDMAtoUARTRx+0x46c>)
 800b82c:	681a      	ldr	r2, [r3, #0]
 800b82e:	43a2      	bics	r2, r4
 800b830:	601a      	str	r2, [r3, #0]
 800b832:	681c      	ldr	r4, [r3, #0]
 800b834:	22d0      	movs	r2, #208	; 0xd0
 800b836:	e665      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA2_Channel3) {
 800b838:	4a46      	ldr	r2, [pc, #280]	; (800b954 <RemapAndLinkDMAtoUARTRx+0x470>)
 800b83a:	4293      	cmp	r3, r2
 800b83c:	d000      	beq.n	800b840 <RemapAndLinkDMAtoUARTRx+0x35c>
 800b83e:	e663      	b.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART6_RX);					
 800b840:	4b43      	ldr	r3, [pc, #268]	; (800b950 <RemapAndLinkDMAtoUARTRx+0x46c>)
 800b842:	e7af      	b.n	800b7a4 <RemapAndLinkDMAtoUARTRx+0x2c0>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA1_Channel1) {
 800b844:	4a44      	ldr	r2, [pc, #272]	; (800b958 <RemapAndLinkDMAtoUARTRx+0x474>)
 800b846:	4293      	cmp	r3, r2
 800b848:	d13d      	bne.n	800b8c6 <RemapAndLinkDMAtoUARTRx+0x3e2>
 800b84a:	680b      	ldr	r3, [r1, #0]
 800b84c:	4a43      	ldr	r2, [pc, #268]	; (800b95c <RemapAndLinkDMAtoUARTRx+0x478>)
 800b84e:	4293      	cmp	r3, r2
 800b850:	d107      	bne.n	800b862 <RemapAndLinkDMAtoUARTRx+0x37e>
		__HAL_DMA1_REMAP(HAL_DMA1_CH1_USART7_RX);
 800b852:	240f      	movs	r4, #15
 800b854:	4b3b      	ldr	r3, [pc, #236]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
 800b856:	681a      	ldr	r2, [r3, #0]
 800b858:	43a2      	bics	r2, r4
 800b85a:	601a      	str	r2, [r3, #0]
 800b85c:	681c      	ldr	r4, [r3, #0]
 800b85e:	220e      	movs	r2, #14
 800b860:	e650      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA1_Channel3) {
 800b862:	4a3f      	ldr	r2, [pc, #252]	; (800b960 <RemapAndLinkDMAtoUARTRx+0x47c>)
 800b864:	4293      	cmp	r3, r2
 800b866:	d107      	bne.n	800b878 <RemapAndLinkDMAtoUARTRx+0x394>
		__HAL_DMA1_REMAP(HAL_DMA1_CH3_USART7_RX);
 800b868:	4b36      	ldr	r3, [pc, #216]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART7_RX);				
 800b86a:	681a      	ldr	r2, [r3, #0]
 800b86c:	4c3d      	ldr	r4, [pc, #244]	; (800b964 <RemapAndLinkDMAtoUARTRx+0x480>)
 800b86e:	4022      	ands	r2, r4
 800b870:	601a      	str	r2, [r3, #0]
 800b872:	681c      	ldr	r4, [r3, #0]
 800b874:	22e0      	movs	r2, #224	; 0xe0
 800b876:	e654      	b.n	800b522 <RemapAndLinkDMAtoUARTRx+0x3e>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA1_Channel5) {
 800b878:	4a3b      	ldr	r2, [pc, #236]	; (800b968 <RemapAndLinkDMAtoUARTRx+0x484>)
 800b87a:	4293      	cmp	r3, r2
 800b87c:	d107      	bne.n	800b88e <RemapAndLinkDMAtoUARTRx+0x3aa>
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART7_RX);		
 800b87e:	4b31      	ldr	r3, [pc, #196]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
 800b880:	4c3a      	ldr	r4, [pc, #232]	; (800b96c <RemapAndLinkDMAtoUARTRx+0x488>)
 800b882:	681a      	ldr	r2, [r3, #0]
 800b884:	4022      	ands	r2, r4
 800b886:	601a      	str	r2, [r3, #0]
 800b888:	681c      	ldr	r4, [r3, #0]
 800b88a:	22e0      	movs	r2, #224	; 0xe0
 800b88c:	e655      	b.n	800b53a <RemapAndLinkDMAtoUARTRx+0x56>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA1_Channel6) {
 800b88e:	4a2c      	ldr	r2, [pc, #176]	; (800b940 <RemapAndLinkDMAtoUARTRx+0x45c>)
 800b890:	4293      	cmp	r3, r2
 800b892:	d107      	bne.n	800b8a4 <RemapAndLinkDMAtoUARTRx+0x3c0>
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART7_RX);	
 800b894:	4b2b      	ldr	r3, [pc, #172]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
 800b896:	4c2c      	ldr	r4, [pc, #176]	; (800b948 <RemapAndLinkDMAtoUARTRx+0x464>)
 800b898:	681a      	ldr	r2, [r3, #0]
 800b89a:	4022      	ands	r2, r4
 800b89c:	601a      	str	r2, [r3, #0]
 800b89e:	681c      	ldr	r4, [r3, #0]
 800b8a0:	22e0      	movs	r2, #224	; 0xe0
 800b8a2:	e656      	b.n	800b552 <RemapAndLinkDMAtoUARTRx+0x6e>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA2_Channel2) {
 800b8a4:	4a29      	ldr	r2, [pc, #164]	; (800b94c <RemapAndLinkDMAtoUARTRx+0x468>)
 800b8a6:	4293      	cmp	r3, r2
 800b8a8:	d107      	bne.n	800b8ba <RemapAndLinkDMAtoUARTRx+0x3d6>
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART7_RX);	
 800b8aa:	24f0      	movs	r4, #240	; 0xf0
 800b8ac:	4b28      	ldr	r3, [pc, #160]	; (800b950 <RemapAndLinkDMAtoUARTRx+0x46c>)
 800b8ae:	681a      	ldr	r2, [r3, #0]
 800b8b0:	43a2      	bics	r2, r4
 800b8b2:	601a      	str	r2, [r3, #0]
 800b8b4:	681c      	ldr	r4, [r3, #0]
 800b8b6:	22e0      	movs	r2, #224	; 0xe0
 800b8b8:	e624      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA2_Channel3) {
 800b8ba:	4a26      	ldr	r2, [pc, #152]	; (800b954 <RemapAndLinkDMAtoUARTRx+0x470>)
 800b8bc:	4293      	cmp	r3, r2
 800b8be:	d000      	beq.n	800b8c2 <RemapAndLinkDMAtoUARTRx+0x3de>
 800b8c0:	e622      	b.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART7_RX);				
 800b8c2:	4b23      	ldr	r3, [pc, #140]	; (800b950 <RemapAndLinkDMAtoUARTRx+0x46c>)
 800b8c4:	e7d1      	b.n	800b86a <RemapAndLinkDMAtoUARTRx+0x386>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA1_Channel1) {
 800b8c6:	4a2a      	ldr	r2, [pc, #168]	; (800b970 <RemapAndLinkDMAtoUARTRx+0x48c>)
 800b8c8:	4293      	cmp	r3, r2
 800b8ca:	d000      	beq.n	800b8ce <RemapAndLinkDMAtoUARTRx+0x3ea>
 800b8cc:	e61c      	b.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
 800b8ce:	680b      	ldr	r3, [r1, #0]
 800b8d0:	4a22      	ldr	r2, [pc, #136]	; (800b95c <RemapAndLinkDMAtoUARTRx+0x478>)
 800b8d2:	4293      	cmp	r3, r2
 800b8d4:	d106      	bne.n	800b8e4 <RemapAndLinkDMAtoUARTRx+0x400>
		__HAL_DMA1_REMAP(HAL_DMA1_CH1_USART8_RX);
 800b8d6:	220f      	movs	r2, #15
 800b8d8:	4b1a      	ldr	r3, [pc, #104]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
 800b8da:	681c      	ldr	r4, [r3, #0]
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART8_RX);	
 800b8dc:	4394      	bics	r4, r2
 800b8de:	601c      	str	r4, [r3, #0]
 800b8e0:	681c      	ldr	r4, [r3, #0]
 800b8e2:	e60f      	b.n	800b504 <RemapAndLinkDMAtoUARTRx+0x20>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA1_Channel3) {
 800b8e4:	4a1e      	ldr	r2, [pc, #120]	; (800b960 <RemapAndLinkDMAtoUARTRx+0x47c>)
 800b8e6:	4293      	cmp	r3, r2
 800b8e8:	d107      	bne.n	800b8fa <RemapAndLinkDMAtoUARTRx+0x416>
		__HAL_DMA1_REMAP(HAL_DMA1_CH3_USART8_RX);
 800b8ea:	4b16      	ldr	r3, [pc, #88]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART8_RX);					
 800b8ec:	681a      	ldr	r2, [r3, #0]
 800b8ee:	4c1d      	ldr	r4, [pc, #116]	; (800b964 <RemapAndLinkDMAtoUARTRx+0x480>)
 800b8f0:	4022      	ands	r2, r4
 800b8f2:	601a      	str	r2, [r3, #0]
 800b8f4:	681c      	ldr	r4, [r3, #0]
 800b8f6:	22f0      	movs	r2, #240	; 0xf0
 800b8f8:	e613      	b.n	800b522 <RemapAndLinkDMAtoUARTRx+0x3e>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA1_Channel5) {
 800b8fa:	4a1b      	ldr	r2, [pc, #108]	; (800b968 <RemapAndLinkDMAtoUARTRx+0x484>)
 800b8fc:	4293      	cmp	r3, r2
 800b8fe:	d107      	bne.n	800b910 <RemapAndLinkDMAtoUARTRx+0x42c>
		__HAL_DMA1_REMAP(HAL_DMA1_CH5_USART8_RX);		
 800b900:	4b10      	ldr	r3, [pc, #64]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
 800b902:	4c1a      	ldr	r4, [pc, #104]	; (800b96c <RemapAndLinkDMAtoUARTRx+0x488>)
 800b904:	681a      	ldr	r2, [r3, #0]
 800b906:	4022      	ands	r2, r4
 800b908:	601a      	str	r2, [r3, #0]
 800b90a:	681c      	ldr	r4, [r3, #0]
 800b90c:	22f0      	movs	r2, #240	; 0xf0
 800b90e:	e614      	b.n	800b53a <RemapAndLinkDMAtoUARTRx+0x56>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA1_Channel6) {
 800b910:	4a0b      	ldr	r2, [pc, #44]	; (800b940 <RemapAndLinkDMAtoUARTRx+0x45c>)
 800b912:	4293      	cmp	r3, r2
 800b914:	d107      	bne.n	800b926 <RemapAndLinkDMAtoUARTRx+0x442>
		__HAL_DMA1_REMAP(HAL_DMA1_CH6_USART8_RX);	
 800b916:	4b0b      	ldr	r3, [pc, #44]	; (800b944 <RemapAndLinkDMAtoUARTRx+0x460>)
 800b918:	4c0b      	ldr	r4, [pc, #44]	; (800b948 <RemapAndLinkDMAtoUARTRx+0x464>)
 800b91a:	681a      	ldr	r2, [r3, #0]
 800b91c:	4022      	ands	r2, r4
 800b91e:	601a      	str	r2, [r3, #0]
 800b920:	681c      	ldr	r4, [r3, #0]
 800b922:	22f0      	movs	r2, #240	; 0xf0
 800b924:	e615      	b.n	800b552 <RemapAndLinkDMAtoUARTRx+0x6e>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel2) {
 800b926:	4a09      	ldr	r2, [pc, #36]	; (800b94c <RemapAndLinkDMAtoUARTRx+0x468>)
 800b928:	4293      	cmp	r3, r2
 800b92a:	d103      	bne.n	800b934 <RemapAndLinkDMAtoUARTRx+0x450>
		__HAL_DMA2_REMAP(HAL_DMA2_CH2_USART8_RX);	
 800b92c:	4b08      	ldr	r3, [pc, #32]	; (800b950 <RemapAndLinkDMAtoUARTRx+0x46c>)
 800b92e:	22f0      	movs	r2, #240	; 0xf0
 800b930:	681c      	ldr	r4, [r3, #0]
 800b932:	e7d3      	b.n	800b8dc <RemapAndLinkDMAtoUARTRx+0x3f8>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel3) {
 800b934:	4a07      	ldr	r2, [pc, #28]	; (800b954 <RemapAndLinkDMAtoUARTRx+0x470>)
 800b936:	4293      	cmp	r3, r2
 800b938:	d000      	beq.n	800b93c <RemapAndLinkDMAtoUARTRx+0x458>
 800b93a:	e5e5      	b.n	800b508 <RemapAndLinkDMAtoUARTRx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH3_USART8_RX);					
 800b93c:	4b04      	ldr	r3, [pc, #16]	; (800b950 <RemapAndLinkDMAtoUARTRx+0x46c>)
 800b93e:	e7d5      	b.n	800b8ec <RemapAndLinkDMAtoUARTRx+0x408>
 800b940:	4002006c 	.word	0x4002006c
 800b944:	400200a8 	.word	0x400200a8
 800b948:	ff0fffff 	.word	0xff0fffff
 800b94c:	4002041c 	.word	0x4002041c
 800b950:	400204a8 	.word	0x400204a8
 800b954:	40020430 	.word	0x40020430
 800b958:	40011800 	.word	0x40011800
 800b95c:	40020008 	.word	0x40020008
 800b960:	40020030 	.word	0x40020030
 800b964:	fffff0ff 	.word	0xfffff0ff
 800b968:	40020058 	.word	0x40020058
 800b96c:	fff0ffff 	.word	0xfff0ffff
 800b970:	40011c00 	.word	0x40011c00

0800b974 <DMA_MSG_RX_Setup>:
{	
 800b974:	b570      	push	{r4, r5, r6, lr}
 800b976:	000d      	movs	r5, r1
 800b978:	0004      	movs	r4, r0
	RemapAndLinkDMAtoUARTRx(huart, hDMA);
 800b97a:	f7ff fdb3 	bl	800b4e4 <RemapAndLinkDMAtoUARTRx>
	SetupDMAInterrupts(hDMA, MSG_DMA_INT_PRIORITY);
 800b97e:	0028      	movs	r0, r5
 800b980:	2100      	movs	r1, #0
 800b982:	f7ff fd09 	bl	800b398 <SetupDMAInterrupts>
	HAL_UART_Receive_DMA(huart, (uint8_t *)&UARTRxBuf[GetPort(huart)-1], MSG_RX_BUF_SIZE);			
 800b986:	0020      	movs	r0, r4
 800b988:	f7fe f866 	bl	8009a58 <GetPort>
 800b98c:	1e41      	subs	r1, r0, #1
 800b98e:	4804      	ldr	r0, [pc, #16]	; (800b9a0 <DMA_MSG_RX_Setup+0x2c>)
 800b990:	0189      	lsls	r1, r1, #6
 800b992:	1809      	adds	r1, r1, r0
 800b994:	2240      	movs	r2, #64	; 0x40
 800b996:	0020      	movs	r0, r4
 800b998:	f007 ffba 	bl	8013910 <HAL_UART_Receive_DMA>
}
 800b99c:	bd70      	pop	{r4, r5, r6, pc}
 800b99e:	46c0      	nop			; (mov r8, r8)
 800b9a0:	20001271 	.word	0x20001271

0800b9a4 <SetupMessagingRxDMAs>:
{	
 800b9a4:	b510      	push	{r4, lr}
	if (portStatus[P1] == FREE)
 800b9a6:	4c12      	ldr	r4, [pc, #72]	; (800b9f0 <SetupMessagingRxDMAs+0x4c>)
 800b9a8:	7863      	ldrb	r3, [r4, #1]
 800b9aa:	2b00      	cmp	r3, #0
 800b9ac:	d103      	bne.n	800b9b6 <SetupMessagingRxDMAs+0x12>
		DMA_MSG_RX_Setup(P1uart, &msgRxDMA[0]);
 800b9ae:	4911      	ldr	r1, [pc, #68]	; (800b9f4 <SetupMessagingRxDMAs+0x50>)
 800b9b0:	4811      	ldr	r0, [pc, #68]	; (800b9f8 <SetupMessagingRxDMAs+0x54>)
 800b9b2:	f7ff ffdf 	bl	800b974 <DMA_MSG_RX_Setup>
	if (portStatus[P2] == FREE)	
 800b9b6:	78a3      	ldrb	r3, [r4, #2]
 800b9b8:	2b00      	cmp	r3, #0
 800b9ba:	d103      	bne.n	800b9c4 <SetupMessagingRxDMAs+0x20>
		DMA_MSG_RX_Setup(P2uart, &msgRxDMA[1]);
 800b9bc:	490f      	ldr	r1, [pc, #60]	; (800b9fc <SetupMessagingRxDMAs+0x58>)
 800b9be:	4810      	ldr	r0, [pc, #64]	; (800ba00 <SetupMessagingRxDMAs+0x5c>)
 800b9c0:	f7ff ffd8 	bl	800b974 <DMA_MSG_RX_Setup>
	if (portStatus[P3] == FREE)
 800b9c4:	78e3      	ldrb	r3, [r4, #3]
 800b9c6:	2b00      	cmp	r3, #0
 800b9c8:	d103      	bne.n	800b9d2 <SetupMessagingRxDMAs+0x2e>
		DMA_MSG_RX_Setup(P3uart, &msgRxDMA[2]);
 800b9ca:	490e      	ldr	r1, [pc, #56]	; (800ba04 <SetupMessagingRxDMAs+0x60>)
 800b9cc:	480e      	ldr	r0, [pc, #56]	; (800ba08 <SetupMessagingRxDMAs+0x64>)
 800b9ce:	f7ff ffd1 	bl	800b974 <DMA_MSG_RX_Setup>
	if (portStatus[P4] == FREE)
 800b9d2:	7923      	ldrb	r3, [r4, #4]
 800b9d4:	2b00      	cmp	r3, #0
 800b9d6:	d103      	bne.n	800b9e0 <SetupMessagingRxDMAs+0x3c>
		DMA_MSG_RX_Setup(P4uart, &msgRxDMA[3]);
 800b9d8:	490c      	ldr	r1, [pc, #48]	; (800ba0c <SetupMessagingRxDMAs+0x68>)
 800b9da:	480d      	ldr	r0, [pc, #52]	; (800ba10 <SetupMessagingRxDMAs+0x6c>)
 800b9dc:	f7ff ffca 	bl	800b974 <DMA_MSG_RX_Setup>
	if (portStatus[P5] == FREE)
 800b9e0:	7963      	ldrb	r3, [r4, #5]
 800b9e2:	2b00      	cmp	r3, #0
 800b9e4:	d103      	bne.n	800b9ee <SetupMessagingRxDMAs+0x4a>
		DMA_MSG_RX_Setup(P5uart, &msgRxDMA[4]);
 800b9e6:	490b      	ldr	r1, [pc, #44]	; (800ba14 <SetupMessagingRxDMAs+0x70>)
 800b9e8:	480b      	ldr	r0, [pc, #44]	; (800ba18 <SetupMessagingRxDMAs+0x74>)
 800b9ea:	f7ff ffc3 	bl	800b974 <DMA_MSG_RX_Setup>
}
 800b9ee:	bd10      	pop	{r4, pc}
 800b9f0:	200010b2 	.word	0x200010b2
 800b9f4:	20001940 	.word	0x20001940
 800b9f8:	20007758 	.word	0x20007758
 800b9fc:	20001978 	.word	0x20001978
 800ba00:	200077d0 	.word	0x200077d0
 800ba04:	200019b0 	.word	0x200019b0
 800ba08:	200070dc 	.word	0x200070dc
 800ba0c:	200019e8 	.word	0x200019e8
 800ba10:	20007424 	.word	0x20007424
 800ba14:	20001a20 	.word	0x20001a20
 800ba18:	200073b0 	.word	0x200073b0

0800ba1c <DMA_STREAM_Setup>:
{	
 800ba1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ba1e:	0016      	movs	r6, r2
 800ba20:	0005      	movs	r5, r0
 800ba22:	000f      	movs	r7, r1
	uint8_t port = GetPort(huartSrc);
 800ba24:	f7fe f818 	bl	8009a58 <GetPort>
	hDMA = &streamDMA[port-1];
 800ba28:	2438      	movs	r4, #56	; 0x38
 800ba2a:	3801      	subs	r0, #1
 800ba2c:	4344      	muls	r4, r0
 800ba2e:	480a      	ldr	r0, [pc, #40]	; (800ba58 <DMA_STREAM_Setup+0x3c>)
 800ba30:	1824      	adds	r4, r4, r0
	RemapAndLinkDMAtoUARTRx(huartSrc, hDMA);
 800ba32:	0021      	movs	r1, r4
 800ba34:	0028      	movs	r0, r5
 800ba36:	f7ff fd55 	bl	800b4e4 <RemapAndLinkDMAtoUARTRx>
	SetupDMAInterrupts(hDMA, STREAM_DMA_INT_PRIORITY);
 800ba3a:	0020      	movs	r0, r4
 800ba3c:	2101      	movs	r1, #1
 800ba3e:	f7ff fcab 	bl	800b398 <SetupDMAInterrupts>
	huartSrc->State = HAL_UART_STATE_READY;
 800ba42:	002b      	movs	r3, r5
 800ba44:	2201      	movs	r2, #1
 800ba46:	3369      	adds	r3, #105	; 0x69
 800ba48:	701a      	strb	r2, [r3, #0]
	HAL_UART_Receive_DMA(huartSrc, (uint8_t *)(&(huartDst->Instance->TDR)), num);
 800ba4a:	6839      	ldr	r1, [r7, #0]
 800ba4c:	0032      	movs	r2, r6
 800ba4e:	0028      	movs	r0, r5
 800ba50:	3128      	adds	r1, #40	; 0x28
 800ba52:	f007 ff5d 	bl	8013910 <HAL_UART_Receive_DMA>
}
 800ba56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ba58:	20001b38 	.word	0x20001b38

0800ba5c <RemapAndLinkDMAtoUARTTx>:
/* Remap and link the UART TX and DMA structs 
*/
void RemapAndLinkDMAtoUARTTx(UART_HandleTypeDef *huart, DMA_HandleTypeDef *hDMA)
{
	// USART 1
	if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel2) {
 800ba5c:	6803      	ldr	r3, [r0, #0]
 800ba5e:	4ab8      	ldr	r2, [pc, #736]	; (800bd40 <RemapAndLinkDMAtoUARTTx+0x2e4>)
{
 800ba60:	b510      	push	{r4, lr}
	if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel2) {
 800ba62:	4293      	cmp	r3, r2
 800ba64:	d143      	bne.n	800baee <RemapAndLinkDMAtoUARTTx+0x92>
 800ba66:	680b      	ldr	r3, [r1, #0]
 800ba68:	4ab6      	ldr	r2, [pc, #728]	; (800bd44 <RemapAndLinkDMAtoUARTTx+0x2e8>)
 800ba6a:	4293      	cmp	r3, r2
 800ba6c:	d10b      	bne.n	800ba86 <RemapAndLinkDMAtoUARTTx+0x2a>
		__HAL_DMA1_REMAP(HAL_DMA1_CH2_USART1_TX);
 800ba6e:	24f0      	movs	r4, #240	; 0xf0
 800ba70:	4bb5      	ldr	r3, [pc, #724]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800ba72:	681a      	ldr	r2, [r3, #0]
 800ba74:	43a2      	bics	r2, r4
 800ba76:	601a      	str	r2, [r3, #0]
 800ba78:	2280      	movs	r2, #128	; 0x80
 800ba7a:	681c      	ldr	r4, [r3, #0]
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel1) {
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART8_TX);	
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel4) {
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART8_TX);	
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel5) {
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART8_TX);					
 800ba7c:	4322      	orrs	r2, r4
 800ba7e:	601a      	str	r2, [r3, #0]
	}		
	
	__HAL_LINKDMA(huart,hdmatx,*hDMA);	
 800ba80:	6601      	str	r1, [r0, #96]	; 0x60
 800ba82:	6248      	str	r0, [r1, #36]	; 0x24
}
 800ba84:	bd10      	pop	{r4, pc}
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel4) {
 800ba86:	4ab1      	ldr	r2, [pc, #708]	; (800bd4c <RemapAndLinkDMAtoUARTTx+0x2f0>)
 800ba88:	4293      	cmp	r3, r2
 800ba8a:	d108      	bne.n	800ba9e <RemapAndLinkDMAtoUARTTx+0x42>
		__HAL_DMA1_REMAP(HAL_DMA1_CH4_USART1_TX);
 800ba8c:	4bae      	ldr	r3, [pc, #696]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART1_TX);	
 800ba8e:	681a      	ldr	r2, [r3, #0]
 800ba90:	4caf      	ldr	r4, [pc, #700]	; (800bd50 <RemapAndLinkDMAtoUARTTx+0x2f4>)
 800ba92:	4022      	ands	r2, r4
 800ba94:	601a      	str	r2, [r3, #0]
 800ba96:	2280      	movs	r2, #128	; 0x80
 800ba98:	681c      	ldr	r4, [r3, #0]
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART8_TX);	
 800ba9a:	0212      	lsls	r2, r2, #8
 800ba9c:	e7ee      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA1_Channel7) {
 800ba9e:	4aad      	ldr	r2, [pc, #692]	; (800bd54 <RemapAndLinkDMAtoUARTTx+0x2f8>)
 800baa0:	4293      	cmp	r3, r2
 800baa2:	d108      	bne.n	800bab6 <RemapAndLinkDMAtoUARTTx+0x5a>
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART1_TX);		
 800baa4:	4ba8      	ldr	r3, [pc, #672]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800baa6:	4cac      	ldr	r4, [pc, #688]	; (800bd58 <RemapAndLinkDMAtoUARTTx+0x2fc>)
 800baa8:	681a      	ldr	r2, [r3, #0]
 800baaa:	4022      	ands	r2, r4
 800baac:	601a      	str	r2, [r3, #0]
 800baae:	2280      	movs	r2, #128	; 0x80
 800bab0:	681c      	ldr	r4, [r3, #0]
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART2_TX);		
 800bab2:	0512      	lsls	r2, r2, #20
 800bab4:	e7e2      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA2_Channel1) {
 800bab6:	4aa9      	ldr	r2, [pc, #676]	; (800bd5c <RemapAndLinkDMAtoUARTTx+0x300>)
 800bab8:	4293      	cmp	r3, r2
 800baba:	d107      	bne.n	800bacc <RemapAndLinkDMAtoUARTTx+0x70>
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART1_TX);	
 800babc:	240f      	movs	r4, #15
 800babe:	4ba8      	ldr	r3, [pc, #672]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bac0:	681a      	ldr	r2, [r3, #0]
 800bac2:	43a2      	bics	r2, r4
 800bac4:	601a      	str	r2, [r3, #0]
 800bac6:	681c      	ldr	r4, [r3, #0]
 800bac8:	2208      	movs	r2, #8
 800baca:	e7d7      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA2_Channel4) {
 800bacc:	4aa5      	ldr	r2, [pc, #660]	; (800bd64 <RemapAndLinkDMAtoUARTTx+0x308>)
 800bace:	4293      	cmp	r3, r2
 800bad0:	d101      	bne.n	800bad6 <RemapAndLinkDMAtoUARTTx+0x7a>
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART1_TX);	
 800bad2:	4ba3      	ldr	r3, [pc, #652]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bad4:	e7db      	b.n	800ba8e <RemapAndLinkDMAtoUARTTx+0x32>
	} else if (huart->Instance == USART1 && hDMA->Instance == DMA2_Channel5) {
 800bad6:	4aa4      	ldr	r2, [pc, #656]	; (800bd68 <RemapAndLinkDMAtoUARTTx+0x30c>)
 800bad8:	4293      	cmp	r3, r2
 800bada:	d1d1      	bne.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART1_TX);	
 800badc:	4ba0      	ldr	r3, [pc, #640]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bade:	4ca3      	ldr	r4, [pc, #652]	; (800bd6c <RemapAndLinkDMAtoUARTTx+0x310>)
 800bae0:	681a      	ldr	r2, [r3, #0]
 800bae2:	4022      	ands	r2, r4
 800bae4:	601a      	str	r2, [r3, #0]
 800bae6:	2280      	movs	r2, #128	; 0x80
 800bae8:	681c      	ldr	r4, [r3, #0]
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART8_TX);					
 800baea:	0312      	lsls	r2, r2, #12
 800baec:	e7c6      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA1_Channel2) {
 800baee:	4aa0      	ldr	r2, [pc, #640]	; (800bd70 <RemapAndLinkDMAtoUARTTx+0x314>)
 800baf0:	4293      	cmp	r3, r2
 800baf2:	d13d      	bne.n	800bb70 <RemapAndLinkDMAtoUARTTx+0x114>
 800baf4:	680b      	ldr	r3, [r1, #0]
 800baf6:	4a93      	ldr	r2, [pc, #588]	; (800bd44 <RemapAndLinkDMAtoUARTTx+0x2e8>)
 800baf8:	4293      	cmp	r3, r2
 800bafa:	d107      	bne.n	800bb0c <RemapAndLinkDMAtoUARTTx+0xb0>
		__HAL_DMA1_REMAP(HAL_DMA1_CH2_USART2_TX);
 800bafc:	24f0      	movs	r4, #240	; 0xf0
 800bafe:	4b92      	ldr	r3, [pc, #584]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bb00:	681a      	ldr	r2, [r3, #0]
 800bb02:	43a2      	bics	r2, r4
 800bb04:	601a      	str	r2, [r3, #0]
 800bb06:	681c      	ldr	r4, [r3, #0]
 800bb08:	2290      	movs	r2, #144	; 0x90
 800bb0a:	e7b7      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA1_Channel4) {
 800bb0c:	4a8f      	ldr	r2, [pc, #572]	; (800bd4c <RemapAndLinkDMAtoUARTTx+0x2f0>)
 800bb0e:	4293      	cmp	r3, r2
 800bb10:	d107      	bne.n	800bb22 <RemapAndLinkDMAtoUARTTx+0xc6>
		__HAL_DMA1_REMAP(HAL_DMA1_CH4_USART2_TX);
 800bb12:	4b8d      	ldr	r3, [pc, #564]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART2_TX);	
 800bb14:	681a      	ldr	r2, [r3, #0]
 800bb16:	4c8e      	ldr	r4, [pc, #568]	; (800bd50 <RemapAndLinkDMAtoUARTTx+0x2f4>)
 800bb18:	4022      	ands	r2, r4
 800bb1a:	601a      	str	r2, [r3, #0]
 800bb1c:	681c      	ldr	r4, [r3, #0]
 800bb1e:	2290      	movs	r2, #144	; 0x90
 800bb20:	e7bb      	b.n	800ba9a <RemapAndLinkDMAtoUARTTx+0x3e>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA1_Channel7) {
 800bb22:	4a8c      	ldr	r2, [pc, #560]	; (800bd54 <RemapAndLinkDMAtoUARTTx+0x2f8>)
 800bb24:	4293      	cmp	r3, r2
 800bb26:	d107      	bne.n	800bb38 <RemapAndLinkDMAtoUARTTx+0xdc>
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART2_TX);		
 800bb28:	4b87      	ldr	r3, [pc, #540]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bb2a:	4c8b      	ldr	r4, [pc, #556]	; (800bd58 <RemapAndLinkDMAtoUARTTx+0x2fc>)
 800bb2c:	681a      	ldr	r2, [r3, #0]
 800bb2e:	4022      	ands	r2, r4
 800bb30:	601a      	str	r2, [r3, #0]
 800bb32:	681c      	ldr	r4, [r3, #0]
 800bb34:	2290      	movs	r2, #144	; 0x90
 800bb36:	e7bc      	b.n	800bab2 <RemapAndLinkDMAtoUARTTx+0x56>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA2_Channel1) {
 800bb38:	4a88      	ldr	r2, [pc, #544]	; (800bd5c <RemapAndLinkDMAtoUARTTx+0x300>)
 800bb3a:	4293      	cmp	r3, r2
 800bb3c:	d107      	bne.n	800bb4e <RemapAndLinkDMAtoUARTTx+0xf2>
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART2_TX);	
 800bb3e:	240f      	movs	r4, #15
 800bb40:	4b87      	ldr	r3, [pc, #540]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bb42:	681a      	ldr	r2, [r3, #0]
 800bb44:	43a2      	bics	r2, r4
 800bb46:	601a      	str	r2, [r3, #0]
 800bb48:	681c      	ldr	r4, [r3, #0]
 800bb4a:	2209      	movs	r2, #9
 800bb4c:	e796      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA2_Channel4) {
 800bb4e:	4a85      	ldr	r2, [pc, #532]	; (800bd64 <RemapAndLinkDMAtoUARTTx+0x308>)
 800bb50:	4293      	cmp	r3, r2
 800bb52:	d101      	bne.n	800bb58 <RemapAndLinkDMAtoUARTTx+0xfc>
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART2_TX);	
 800bb54:	4b82      	ldr	r3, [pc, #520]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bb56:	e7dd      	b.n	800bb14 <RemapAndLinkDMAtoUARTTx+0xb8>
	} else if (huart->Instance == USART2 && hDMA->Instance == DMA2_Channel5) {
 800bb58:	4a83      	ldr	r2, [pc, #524]	; (800bd68 <RemapAndLinkDMAtoUARTTx+0x30c>)
 800bb5a:	4293      	cmp	r3, r2
 800bb5c:	d000      	beq.n	800bb60 <RemapAndLinkDMAtoUARTTx+0x104>
 800bb5e:	e78f      	b.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART2_TX);	
 800bb60:	4b7f      	ldr	r3, [pc, #508]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bb62:	4c82      	ldr	r4, [pc, #520]	; (800bd6c <RemapAndLinkDMAtoUARTTx+0x310>)
 800bb64:	681a      	ldr	r2, [r3, #0]
 800bb66:	4022      	ands	r2, r4
 800bb68:	601a      	str	r2, [r3, #0]
 800bb6a:	681c      	ldr	r4, [r3, #0]
 800bb6c:	2290      	movs	r2, #144	; 0x90
 800bb6e:	e7bc      	b.n	800baea <RemapAndLinkDMAtoUARTTx+0x8e>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA1_Channel2) {
 800bb70:	4a80      	ldr	r2, [pc, #512]	; (800bd74 <RemapAndLinkDMAtoUARTTx+0x318>)
 800bb72:	4293      	cmp	r3, r2
 800bb74:	d13d      	bne.n	800bbf2 <RemapAndLinkDMAtoUARTTx+0x196>
 800bb76:	680b      	ldr	r3, [r1, #0]
 800bb78:	4a72      	ldr	r2, [pc, #456]	; (800bd44 <RemapAndLinkDMAtoUARTTx+0x2e8>)
 800bb7a:	4293      	cmp	r3, r2
 800bb7c:	d107      	bne.n	800bb8e <RemapAndLinkDMAtoUARTTx+0x132>
		__HAL_DMA1_REMAP(HAL_DMA1_CH2_USART3_TX);
 800bb7e:	24f0      	movs	r4, #240	; 0xf0
 800bb80:	4b71      	ldr	r3, [pc, #452]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bb82:	681a      	ldr	r2, [r3, #0]
 800bb84:	43a2      	bics	r2, r4
 800bb86:	601a      	str	r2, [r3, #0]
 800bb88:	681c      	ldr	r4, [r3, #0]
 800bb8a:	22a0      	movs	r2, #160	; 0xa0
 800bb8c:	e776      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA1_Channel4) {
 800bb8e:	4a6f      	ldr	r2, [pc, #444]	; (800bd4c <RemapAndLinkDMAtoUARTTx+0x2f0>)
 800bb90:	4293      	cmp	r3, r2
 800bb92:	d107      	bne.n	800bba4 <RemapAndLinkDMAtoUARTTx+0x148>
		__HAL_DMA1_REMAP(HAL_DMA1_CH4_USART3_TX);
 800bb94:	4b6c      	ldr	r3, [pc, #432]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART3_TX);	
 800bb96:	681a      	ldr	r2, [r3, #0]
 800bb98:	4c6d      	ldr	r4, [pc, #436]	; (800bd50 <RemapAndLinkDMAtoUARTTx+0x2f4>)
 800bb9a:	4022      	ands	r2, r4
 800bb9c:	601a      	str	r2, [r3, #0]
 800bb9e:	681c      	ldr	r4, [r3, #0]
 800bba0:	22a0      	movs	r2, #160	; 0xa0
 800bba2:	e77a      	b.n	800ba9a <RemapAndLinkDMAtoUARTTx+0x3e>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA1_Channel7) {
 800bba4:	4a6b      	ldr	r2, [pc, #428]	; (800bd54 <RemapAndLinkDMAtoUARTTx+0x2f8>)
 800bba6:	4293      	cmp	r3, r2
 800bba8:	d107      	bne.n	800bbba <RemapAndLinkDMAtoUARTTx+0x15e>
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART3_TX);		
 800bbaa:	4b67      	ldr	r3, [pc, #412]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bbac:	4c6a      	ldr	r4, [pc, #424]	; (800bd58 <RemapAndLinkDMAtoUARTTx+0x2fc>)
 800bbae:	681a      	ldr	r2, [r3, #0]
 800bbb0:	4022      	ands	r2, r4
 800bbb2:	601a      	str	r2, [r3, #0]
 800bbb4:	681c      	ldr	r4, [r3, #0]
 800bbb6:	22a0      	movs	r2, #160	; 0xa0
 800bbb8:	e77b      	b.n	800bab2 <RemapAndLinkDMAtoUARTTx+0x56>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA2_Channel1) {
 800bbba:	4a68      	ldr	r2, [pc, #416]	; (800bd5c <RemapAndLinkDMAtoUARTTx+0x300>)
 800bbbc:	4293      	cmp	r3, r2
 800bbbe:	d107      	bne.n	800bbd0 <RemapAndLinkDMAtoUARTTx+0x174>
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART3_TX);	
 800bbc0:	240f      	movs	r4, #15
 800bbc2:	4b67      	ldr	r3, [pc, #412]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bbc4:	681a      	ldr	r2, [r3, #0]
 800bbc6:	43a2      	bics	r2, r4
 800bbc8:	601a      	str	r2, [r3, #0]
 800bbca:	681c      	ldr	r4, [r3, #0]
 800bbcc:	220a      	movs	r2, #10
 800bbce:	e755      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA2_Channel4) {
 800bbd0:	4a64      	ldr	r2, [pc, #400]	; (800bd64 <RemapAndLinkDMAtoUARTTx+0x308>)
 800bbd2:	4293      	cmp	r3, r2
 800bbd4:	d101      	bne.n	800bbda <RemapAndLinkDMAtoUARTTx+0x17e>
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART3_TX);	
 800bbd6:	4b62      	ldr	r3, [pc, #392]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bbd8:	e7dd      	b.n	800bb96 <RemapAndLinkDMAtoUARTTx+0x13a>
	} else if (huart->Instance == USART3 && hDMA->Instance == DMA2_Channel5) {
 800bbda:	4a63      	ldr	r2, [pc, #396]	; (800bd68 <RemapAndLinkDMAtoUARTTx+0x30c>)
 800bbdc:	4293      	cmp	r3, r2
 800bbde:	d000      	beq.n	800bbe2 <RemapAndLinkDMAtoUARTTx+0x186>
 800bbe0:	e74e      	b.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART3_TX);			
 800bbe2:	4b5f      	ldr	r3, [pc, #380]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bbe4:	4c61      	ldr	r4, [pc, #388]	; (800bd6c <RemapAndLinkDMAtoUARTTx+0x310>)
 800bbe6:	681a      	ldr	r2, [r3, #0]
 800bbe8:	4022      	ands	r2, r4
 800bbea:	601a      	str	r2, [r3, #0]
 800bbec:	681c      	ldr	r4, [r3, #0]
 800bbee:	22a0      	movs	r2, #160	; 0xa0
 800bbf0:	e77b      	b.n	800baea <RemapAndLinkDMAtoUARTTx+0x8e>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA1_Channel2) {
 800bbf2:	4a61      	ldr	r2, [pc, #388]	; (800bd78 <RemapAndLinkDMAtoUARTTx+0x31c>)
 800bbf4:	4293      	cmp	r3, r2
 800bbf6:	d13d      	bne.n	800bc74 <RemapAndLinkDMAtoUARTTx+0x218>
 800bbf8:	680b      	ldr	r3, [r1, #0]
 800bbfa:	4a52      	ldr	r2, [pc, #328]	; (800bd44 <RemapAndLinkDMAtoUARTTx+0x2e8>)
 800bbfc:	4293      	cmp	r3, r2
 800bbfe:	d107      	bne.n	800bc10 <RemapAndLinkDMAtoUARTTx+0x1b4>
		__HAL_DMA1_REMAP(HAL_DMA1_CH2_USART4_TX);
 800bc00:	24f0      	movs	r4, #240	; 0xf0
 800bc02:	4b51      	ldr	r3, [pc, #324]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bc04:	681a      	ldr	r2, [r3, #0]
 800bc06:	43a2      	bics	r2, r4
 800bc08:	601a      	str	r2, [r3, #0]
 800bc0a:	681c      	ldr	r4, [r3, #0]
 800bc0c:	22b0      	movs	r2, #176	; 0xb0
 800bc0e:	e735      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA1_Channel4) {
 800bc10:	4a4e      	ldr	r2, [pc, #312]	; (800bd4c <RemapAndLinkDMAtoUARTTx+0x2f0>)
 800bc12:	4293      	cmp	r3, r2
 800bc14:	d107      	bne.n	800bc26 <RemapAndLinkDMAtoUARTTx+0x1ca>
		__HAL_DMA1_REMAP(HAL_DMA1_CH4_USART4_TX);
 800bc16:	4b4c      	ldr	r3, [pc, #304]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART4_TX);	
 800bc18:	681a      	ldr	r2, [r3, #0]
 800bc1a:	4c4d      	ldr	r4, [pc, #308]	; (800bd50 <RemapAndLinkDMAtoUARTTx+0x2f4>)
 800bc1c:	4022      	ands	r2, r4
 800bc1e:	601a      	str	r2, [r3, #0]
 800bc20:	681c      	ldr	r4, [r3, #0]
 800bc22:	22b0      	movs	r2, #176	; 0xb0
 800bc24:	e739      	b.n	800ba9a <RemapAndLinkDMAtoUARTTx+0x3e>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA1_Channel7) {
 800bc26:	4a4b      	ldr	r2, [pc, #300]	; (800bd54 <RemapAndLinkDMAtoUARTTx+0x2f8>)
 800bc28:	4293      	cmp	r3, r2
 800bc2a:	d107      	bne.n	800bc3c <RemapAndLinkDMAtoUARTTx+0x1e0>
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART4_TX);		
 800bc2c:	4b46      	ldr	r3, [pc, #280]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bc2e:	4c4a      	ldr	r4, [pc, #296]	; (800bd58 <RemapAndLinkDMAtoUARTTx+0x2fc>)
 800bc30:	681a      	ldr	r2, [r3, #0]
 800bc32:	4022      	ands	r2, r4
 800bc34:	601a      	str	r2, [r3, #0]
 800bc36:	681c      	ldr	r4, [r3, #0]
 800bc38:	22b0      	movs	r2, #176	; 0xb0
 800bc3a:	e73a      	b.n	800bab2 <RemapAndLinkDMAtoUARTTx+0x56>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA2_Channel1) {
 800bc3c:	4a47      	ldr	r2, [pc, #284]	; (800bd5c <RemapAndLinkDMAtoUARTTx+0x300>)
 800bc3e:	4293      	cmp	r3, r2
 800bc40:	d107      	bne.n	800bc52 <RemapAndLinkDMAtoUARTTx+0x1f6>
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART4_TX);	
 800bc42:	240f      	movs	r4, #15
 800bc44:	4b46      	ldr	r3, [pc, #280]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bc46:	681a      	ldr	r2, [r3, #0]
 800bc48:	43a2      	bics	r2, r4
 800bc4a:	601a      	str	r2, [r3, #0]
 800bc4c:	681c      	ldr	r4, [r3, #0]
 800bc4e:	220b      	movs	r2, #11
 800bc50:	e714      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA2_Channel4) {
 800bc52:	4a44      	ldr	r2, [pc, #272]	; (800bd64 <RemapAndLinkDMAtoUARTTx+0x308>)
 800bc54:	4293      	cmp	r3, r2
 800bc56:	d101      	bne.n	800bc5c <RemapAndLinkDMAtoUARTTx+0x200>
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART4_TX);	
 800bc58:	4b41      	ldr	r3, [pc, #260]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bc5a:	e7dd      	b.n	800bc18 <RemapAndLinkDMAtoUARTTx+0x1bc>
	} else if (huart->Instance == USART4 && hDMA->Instance == DMA2_Channel5) {
 800bc5c:	4a42      	ldr	r2, [pc, #264]	; (800bd68 <RemapAndLinkDMAtoUARTTx+0x30c>)
 800bc5e:	4293      	cmp	r3, r2
 800bc60:	d000      	beq.n	800bc64 <RemapAndLinkDMAtoUARTTx+0x208>
 800bc62:	e70d      	b.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART4_TX);				
 800bc64:	4b3e      	ldr	r3, [pc, #248]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bc66:	4c41      	ldr	r4, [pc, #260]	; (800bd6c <RemapAndLinkDMAtoUARTTx+0x310>)
 800bc68:	681a      	ldr	r2, [r3, #0]
 800bc6a:	4022      	ands	r2, r4
 800bc6c:	601a      	str	r2, [r3, #0]
 800bc6e:	681c      	ldr	r4, [r3, #0]
 800bc70:	22b0      	movs	r2, #176	; 0xb0
 800bc72:	e73a      	b.n	800baea <RemapAndLinkDMAtoUARTTx+0x8e>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA1_Channel2) {
 800bc74:	4a41      	ldr	r2, [pc, #260]	; (800bd7c <RemapAndLinkDMAtoUARTTx+0x320>)
 800bc76:	4293      	cmp	r3, r2
 800bc78:	d13d      	bne.n	800bcf6 <RemapAndLinkDMAtoUARTTx+0x29a>
 800bc7a:	680b      	ldr	r3, [r1, #0]
 800bc7c:	4a31      	ldr	r2, [pc, #196]	; (800bd44 <RemapAndLinkDMAtoUARTTx+0x2e8>)
 800bc7e:	4293      	cmp	r3, r2
 800bc80:	d107      	bne.n	800bc92 <RemapAndLinkDMAtoUARTTx+0x236>
		__HAL_DMA1_REMAP(HAL_DMA1_CH2_USART5_TX);
 800bc82:	24f0      	movs	r4, #240	; 0xf0
 800bc84:	4b30      	ldr	r3, [pc, #192]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bc86:	681a      	ldr	r2, [r3, #0]
 800bc88:	43a2      	bics	r2, r4
 800bc8a:	601a      	str	r2, [r3, #0]
 800bc8c:	681c      	ldr	r4, [r3, #0]
 800bc8e:	22c0      	movs	r2, #192	; 0xc0
 800bc90:	e6f4      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA1_Channel4) {
 800bc92:	4a2e      	ldr	r2, [pc, #184]	; (800bd4c <RemapAndLinkDMAtoUARTTx+0x2f0>)
 800bc94:	4293      	cmp	r3, r2
 800bc96:	d107      	bne.n	800bca8 <RemapAndLinkDMAtoUARTTx+0x24c>
		__HAL_DMA1_REMAP(HAL_DMA1_CH4_USART5_TX);
 800bc98:	4b2b      	ldr	r3, [pc, #172]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART5_TX);	
 800bc9a:	681a      	ldr	r2, [r3, #0]
 800bc9c:	4c2c      	ldr	r4, [pc, #176]	; (800bd50 <RemapAndLinkDMAtoUARTTx+0x2f4>)
 800bc9e:	4022      	ands	r2, r4
 800bca0:	601a      	str	r2, [r3, #0]
 800bca2:	681c      	ldr	r4, [r3, #0]
 800bca4:	22c0      	movs	r2, #192	; 0xc0
 800bca6:	e6f8      	b.n	800ba9a <RemapAndLinkDMAtoUARTTx+0x3e>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA1_Channel7) {
 800bca8:	4a2a      	ldr	r2, [pc, #168]	; (800bd54 <RemapAndLinkDMAtoUARTTx+0x2f8>)
 800bcaa:	4293      	cmp	r3, r2
 800bcac:	d107      	bne.n	800bcbe <RemapAndLinkDMAtoUARTTx+0x262>
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART5_TX);		
 800bcae:	4b26      	ldr	r3, [pc, #152]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bcb0:	4c29      	ldr	r4, [pc, #164]	; (800bd58 <RemapAndLinkDMAtoUARTTx+0x2fc>)
 800bcb2:	681a      	ldr	r2, [r3, #0]
 800bcb4:	4022      	ands	r2, r4
 800bcb6:	601a      	str	r2, [r3, #0]
 800bcb8:	681c      	ldr	r4, [r3, #0]
 800bcba:	22c0      	movs	r2, #192	; 0xc0
 800bcbc:	e6f9      	b.n	800bab2 <RemapAndLinkDMAtoUARTTx+0x56>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA2_Channel1) {
 800bcbe:	4a27      	ldr	r2, [pc, #156]	; (800bd5c <RemapAndLinkDMAtoUARTTx+0x300>)
 800bcc0:	4293      	cmp	r3, r2
 800bcc2:	d107      	bne.n	800bcd4 <RemapAndLinkDMAtoUARTTx+0x278>
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART5_TX);	
 800bcc4:	240f      	movs	r4, #15
 800bcc6:	4b26      	ldr	r3, [pc, #152]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bcc8:	681a      	ldr	r2, [r3, #0]
 800bcca:	43a2      	bics	r2, r4
 800bccc:	601a      	str	r2, [r3, #0]
 800bcce:	681c      	ldr	r4, [r3, #0]
 800bcd0:	220c      	movs	r2, #12
 800bcd2:	e6d3      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA2_Channel4) {
 800bcd4:	4a23      	ldr	r2, [pc, #140]	; (800bd64 <RemapAndLinkDMAtoUARTTx+0x308>)
 800bcd6:	4293      	cmp	r3, r2
 800bcd8:	d101      	bne.n	800bcde <RemapAndLinkDMAtoUARTTx+0x282>
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART5_TX);	
 800bcda:	4b21      	ldr	r3, [pc, #132]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bcdc:	e7dd      	b.n	800bc9a <RemapAndLinkDMAtoUARTTx+0x23e>
	} else if (huart->Instance == USART5 && hDMA->Instance == DMA2_Channel5) {
 800bcde:	4a22      	ldr	r2, [pc, #136]	; (800bd68 <RemapAndLinkDMAtoUARTTx+0x30c>)
 800bce0:	4293      	cmp	r3, r2
 800bce2:	d000      	beq.n	800bce6 <RemapAndLinkDMAtoUARTTx+0x28a>
 800bce4:	e6cc      	b.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART5_TX);					
 800bce6:	4b1e      	ldr	r3, [pc, #120]	; (800bd60 <RemapAndLinkDMAtoUARTTx+0x304>)
 800bce8:	4c20      	ldr	r4, [pc, #128]	; (800bd6c <RemapAndLinkDMAtoUARTTx+0x310>)
 800bcea:	681a      	ldr	r2, [r3, #0]
 800bcec:	4022      	ands	r2, r4
 800bcee:	601a      	str	r2, [r3, #0]
 800bcf0:	681c      	ldr	r4, [r3, #0]
 800bcf2:	22c0      	movs	r2, #192	; 0xc0
 800bcf4:	e6f9      	b.n	800baea <RemapAndLinkDMAtoUARTTx+0x8e>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA1_Channel2) {
 800bcf6:	4a22      	ldr	r2, [pc, #136]	; (800bd80 <RemapAndLinkDMAtoUARTTx+0x324>)
 800bcf8:	4293      	cmp	r3, r2
 800bcfa:	d15f      	bne.n	800bdbc <RemapAndLinkDMAtoUARTTx+0x360>
 800bcfc:	680b      	ldr	r3, [r1, #0]
 800bcfe:	4a11      	ldr	r2, [pc, #68]	; (800bd44 <RemapAndLinkDMAtoUARTTx+0x2e8>)
 800bd00:	4293      	cmp	r3, r2
 800bd02:	d107      	bne.n	800bd14 <RemapAndLinkDMAtoUARTTx+0x2b8>
		__HAL_DMA1_REMAP(HAL_DMA1_CH2_USART6_TX);
 800bd04:	24f0      	movs	r4, #240	; 0xf0
 800bd06:	4b10      	ldr	r3, [pc, #64]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bd08:	681a      	ldr	r2, [r3, #0]
 800bd0a:	43a2      	bics	r2, r4
 800bd0c:	601a      	str	r2, [r3, #0]
 800bd0e:	681c      	ldr	r4, [r3, #0]
 800bd10:	22d0      	movs	r2, #208	; 0xd0
 800bd12:	e6b3      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA1_Channel4) {
 800bd14:	4a0d      	ldr	r2, [pc, #52]	; (800bd4c <RemapAndLinkDMAtoUARTTx+0x2f0>)
 800bd16:	4293      	cmp	r3, r2
 800bd18:	d107      	bne.n	800bd2a <RemapAndLinkDMAtoUARTTx+0x2ce>
		__HAL_DMA1_REMAP(HAL_DMA1_CH4_USART6_TX);
 800bd1a:	4b0b      	ldr	r3, [pc, #44]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART6_TX);	
 800bd1c:	681a      	ldr	r2, [r3, #0]
 800bd1e:	4c0c      	ldr	r4, [pc, #48]	; (800bd50 <RemapAndLinkDMAtoUARTTx+0x2f4>)
 800bd20:	4022      	ands	r2, r4
 800bd22:	601a      	str	r2, [r3, #0]
 800bd24:	681c      	ldr	r4, [r3, #0]
 800bd26:	22d0      	movs	r2, #208	; 0xd0
 800bd28:	e6b7      	b.n	800ba9a <RemapAndLinkDMAtoUARTTx+0x3e>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA1_Channel7) {
 800bd2a:	4a0a      	ldr	r2, [pc, #40]	; (800bd54 <RemapAndLinkDMAtoUARTTx+0x2f8>)
 800bd2c:	4293      	cmp	r3, r2
 800bd2e:	d129      	bne.n	800bd84 <RemapAndLinkDMAtoUARTTx+0x328>
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART6_TX);		
 800bd30:	4b05      	ldr	r3, [pc, #20]	; (800bd48 <RemapAndLinkDMAtoUARTTx+0x2ec>)
 800bd32:	4c09      	ldr	r4, [pc, #36]	; (800bd58 <RemapAndLinkDMAtoUARTTx+0x2fc>)
 800bd34:	681a      	ldr	r2, [r3, #0]
 800bd36:	4022      	ands	r2, r4
 800bd38:	601a      	str	r2, [r3, #0]
 800bd3a:	681c      	ldr	r4, [r3, #0]
 800bd3c:	22d0      	movs	r2, #208	; 0xd0
 800bd3e:	e6b8      	b.n	800bab2 <RemapAndLinkDMAtoUARTTx+0x56>
 800bd40:	40013800 	.word	0x40013800
 800bd44:	4002001c 	.word	0x4002001c
 800bd48:	400200a8 	.word	0x400200a8
 800bd4c:	40020044 	.word	0x40020044
 800bd50:	ffff0fff 	.word	0xffff0fff
 800bd54:	40020080 	.word	0x40020080
 800bd58:	f0ffffff 	.word	0xf0ffffff
 800bd5c:	40020408 	.word	0x40020408
 800bd60:	400204a8 	.word	0x400204a8
 800bd64:	40020444 	.word	0x40020444
 800bd68:	40020458 	.word	0x40020458
 800bd6c:	fff0ffff 	.word	0xfff0ffff
 800bd70:	40004400 	.word	0x40004400
 800bd74:	40004800 	.word	0x40004800
 800bd78:	40004c00 	.word	0x40004c00
 800bd7c:	40005000 	.word	0x40005000
 800bd80:	40011400 	.word	0x40011400
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA2_Channel1) {
 800bd84:	4a4c      	ldr	r2, [pc, #304]	; (800beb8 <RemapAndLinkDMAtoUARTTx+0x45c>)
 800bd86:	4293      	cmp	r3, r2
 800bd88:	d107      	bne.n	800bd9a <RemapAndLinkDMAtoUARTTx+0x33e>
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART6_TX);	
 800bd8a:	240f      	movs	r4, #15
 800bd8c:	4b4b      	ldr	r3, [pc, #300]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800bd8e:	681a      	ldr	r2, [r3, #0]
 800bd90:	43a2      	bics	r2, r4
 800bd92:	601a      	str	r2, [r3, #0]
 800bd94:	681c      	ldr	r4, [r3, #0]
 800bd96:	220d      	movs	r2, #13
 800bd98:	e670      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA2_Channel4) {
 800bd9a:	4a49      	ldr	r2, [pc, #292]	; (800bec0 <RemapAndLinkDMAtoUARTTx+0x464>)
 800bd9c:	4293      	cmp	r3, r2
 800bd9e:	d101      	bne.n	800bda4 <RemapAndLinkDMAtoUARTTx+0x348>
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART6_TX);	
 800bda0:	4b46      	ldr	r3, [pc, #280]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800bda2:	e7bb      	b.n	800bd1c <RemapAndLinkDMAtoUARTTx+0x2c0>
	} else if (huart->Instance == USART6 && hDMA->Instance == DMA2_Channel5) {
 800bda4:	4a47      	ldr	r2, [pc, #284]	; (800bec4 <RemapAndLinkDMAtoUARTTx+0x468>)
 800bda6:	4293      	cmp	r3, r2
 800bda8:	d000      	beq.n	800bdac <RemapAndLinkDMAtoUARTTx+0x350>
 800bdaa:	e669      	b.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART6_TX);					
 800bdac:	4b43      	ldr	r3, [pc, #268]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800bdae:	4c46      	ldr	r4, [pc, #280]	; (800bec8 <RemapAndLinkDMAtoUARTTx+0x46c>)
 800bdb0:	681a      	ldr	r2, [r3, #0]
 800bdb2:	4022      	ands	r2, r4
 800bdb4:	601a      	str	r2, [r3, #0]
 800bdb6:	681c      	ldr	r4, [r3, #0]
 800bdb8:	22d0      	movs	r2, #208	; 0xd0
 800bdba:	e696      	b.n	800baea <RemapAndLinkDMAtoUARTTx+0x8e>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA1_Channel2) {
 800bdbc:	4a43      	ldr	r2, [pc, #268]	; (800becc <RemapAndLinkDMAtoUARTTx+0x470>)
 800bdbe:	4293      	cmp	r3, r2
 800bdc0:	d13d      	bne.n	800be3e <RemapAndLinkDMAtoUARTTx+0x3e2>
 800bdc2:	680b      	ldr	r3, [r1, #0]
 800bdc4:	4a42      	ldr	r2, [pc, #264]	; (800bed0 <RemapAndLinkDMAtoUARTTx+0x474>)
 800bdc6:	4293      	cmp	r3, r2
 800bdc8:	d107      	bne.n	800bdda <RemapAndLinkDMAtoUARTTx+0x37e>
		__HAL_DMA1_REMAP(HAL_DMA1_CH2_USART7_TX);
 800bdca:	24f0      	movs	r4, #240	; 0xf0
 800bdcc:	4b41      	ldr	r3, [pc, #260]	; (800bed4 <RemapAndLinkDMAtoUARTTx+0x478>)
 800bdce:	681a      	ldr	r2, [r3, #0]
 800bdd0:	43a2      	bics	r2, r4
 800bdd2:	601a      	str	r2, [r3, #0]
 800bdd4:	681c      	ldr	r4, [r3, #0]
 800bdd6:	22e0      	movs	r2, #224	; 0xe0
 800bdd8:	e650      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA1_Channel4) {
 800bdda:	4a3f      	ldr	r2, [pc, #252]	; (800bed8 <RemapAndLinkDMAtoUARTTx+0x47c>)
 800bddc:	4293      	cmp	r3, r2
 800bdde:	d107      	bne.n	800bdf0 <RemapAndLinkDMAtoUARTTx+0x394>
		__HAL_DMA1_REMAP(HAL_DMA1_CH4_USART7_TX);
 800bde0:	4b3c      	ldr	r3, [pc, #240]	; (800bed4 <RemapAndLinkDMAtoUARTTx+0x478>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART7_TX);	
 800bde2:	681a      	ldr	r2, [r3, #0]
 800bde4:	4c3d      	ldr	r4, [pc, #244]	; (800bedc <RemapAndLinkDMAtoUARTTx+0x480>)
 800bde6:	4022      	ands	r2, r4
 800bde8:	601a      	str	r2, [r3, #0]
 800bdea:	681c      	ldr	r4, [r3, #0]
 800bdec:	22e0      	movs	r2, #224	; 0xe0
 800bdee:	e654      	b.n	800ba9a <RemapAndLinkDMAtoUARTTx+0x3e>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA1_Channel7) {
 800bdf0:	4a3b      	ldr	r2, [pc, #236]	; (800bee0 <RemapAndLinkDMAtoUARTTx+0x484>)
 800bdf2:	4293      	cmp	r3, r2
 800bdf4:	d107      	bne.n	800be06 <RemapAndLinkDMAtoUARTTx+0x3aa>
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART7_TX);		
 800bdf6:	4b37      	ldr	r3, [pc, #220]	; (800bed4 <RemapAndLinkDMAtoUARTTx+0x478>)
 800bdf8:	4c3a      	ldr	r4, [pc, #232]	; (800bee4 <RemapAndLinkDMAtoUARTTx+0x488>)
 800bdfa:	681a      	ldr	r2, [r3, #0]
 800bdfc:	4022      	ands	r2, r4
 800bdfe:	601a      	str	r2, [r3, #0]
 800be00:	681c      	ldr	r4, [r3, #0]
 800be02:	22e0      	movs	r2, #224	; 0xe0
 800be04:	e655      	b.n	800bab2 <RemapAndLinkDMAtoUARTTx+0x56>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA2_Channel1) {
 800be06:	4a2c      	ldr	r2, [pc, #176]	; (800beb8 <RemapAndLinkDMAtoUARTTx+0x45c>)
 800be08:	4293      	cmp	r3, r2
 800be0a:	d107      	bne.n	800be1c <RemapAndLinkDMAtoUARTTx+0x3c0>
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART7_TX);	
 800be0c:	240f      	movs	r4, #15
 800be0e:	4b2b      	ldr	r3, [pc, #172]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800be10:	681a      	ldr	r2, [r3, #0]
 800be12:	43a2      	bics	r2, r4
 800be14:	601a      	str	r2, [r3, #0]
 800be16:	681c      	ldr	r4, [r3, #0]
 800be18:	220e      	movs	r2, #14
 800be1a:	e62f      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA2_Channel4) {
 800be1c:	4a28      	ldr	r2, [pc, #160]	; (800bec0 <RemapAndLinkDMAtoUARTTx+0x464>)
 800be1e:	4293      	cmp	r3, r2
 800be20:	d101      	bne.n	800be26 <RemapAndLinkDMAtoUARTTx+0x3ca>
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART7_TX);	
 800be22:	4b26      	ldr	r3, [pc, #152]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800be24:	e7dd      	b.n	800bde2 <RemapAndLinkDMAtoUARTTx+0x386>
	} else if (huart->Instance == USART7 && hDMA->Instance == DMA2_Channel5) {
 800be26:	4a27      	ldr	r2, [pc, #156]	; (800bec4 <RemapAndLinkDMAtoUARTTx+0x468>)
 800be28:	4293      	cmp	r3, r2
 800be2a:	d000      	beq.n	800be2e <RemapAndLinkDMAtoUARTTx+0x3d2>
 800be2c:	e628      	b.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART7_TX);				
 800be2e:	4b23      	ldr	r3, [pc, #140]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800be30:	4c25      	ldr	r4, [pc, #148]	; (800bec8 <RemapAndLinkDMAtoUARTTx+0x46c>)
 800be32:	681a      	ldr	r2, [r3, #0]
 800be34:	4022      	ands	r2, r4
 800be36:	601a      	str	r2, [r3, #0]
 800be38:	681c      	ldr	r4, [r3, #0]
 800be3a:	22e0      	movs	r2, #224	; 0xe0
 800be3c:	e655      	b.n	800baea <RemapAndLinkDMAtoUARTTx+0x8e>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA1_Channel2) {
 800be3e:	4a2a      	ldr	r2, [pc, #168]	; (800bee8 <RemapAndLinkDMAtoUARTTx+0x48c>)
 800be40:	4293      	cmp	r3, r2
 800be42:	d000      	beq.n	800be46 <RemapAndLinkDMAtoUARTTx+0x3ea>
 800be44:	e61c      	b.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
 800be46:	680b      	ldr	r3, [r1, #0]
 800be48:	4a21      	ldr	r2, [pc, #132]	; (800bed0 <RemapAndLinkDMAtoUARTTx+0x474>)
 800be4a:	4293      	cmp	r3, r2
 800be4c:	d106      	bne.n	800be5c <RemapAndLinkDMAtoUARTTx+0x400>
		__HAL_DMA1_REMAP(HAL_DMA1_CH2_USART8_TX);
 800be4e:	22f0      	movs	r2, #240	; 0xf0
 800be50:	4b20      	ldr	r3, [pc, #128]	; (800bed4 <RemapAndLinkDMAtoUARTTx+0x478>)
 800be52:	681c      	ldr	r4, [r3, #0]
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART8_TX);	
 800be54:	4394      	bics	r4, r2
 800be56:	601c      	str	r4, [r3, #0]
 800be58:	681c      	ldr	r4, [r3, #0]
 800be5a:	e60f      	b.n	800ba7c <RemapAndLinkDMAtoUARTTx+0x20>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA1_Channel4) {
 800be5c:	4a1e      	ldr	r2, [pc, #120]	; (800bed8 <RemapAndLinkDMAtoUARTTx+0x47c>)
 800be5e:	4293      	cmp	r3, r2
 800be60:	d107      	bne.n	800be72 <RemapAndLinkDMAtoUARTTx+0x416>
		__HAL_DMA1_REMAP(HAL_DMA1_CH4_USART8_TX);
 800be62:	4b1c      	ldr	r3, [pc, #112]	; (800bed4 <RemapAndLinkDMAtoUARTTx+0x478>)
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART8_TX);	
 800be64:	681a      	ldr	r2, [r3, #0]
 800be66:	4c1d      	ldr	r4, [pc, #116]	; (800bedc <RemapAndLinkDMAtoUARTTx+0x480>)
 800be68:	4022      	ands	r2, r4
 800be6a:	601a      	str	r2, [r3, #0]
 800be6c:	681c      	ldr	r4, [r3, #0]
 800be6e:	22f0      	movs	r2, #240	; 0xf0
 800be70:	e613      	b.n	800ba9a <RemapAndLinkDMAtoUARTTx+0x3e>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA1_Channel7) {
 800be72:	4a1b      	ldr	r2, [pc, #108]	; (800bee0 <RemapAndLinkDMAtoUARTTx+0x484>)
 800be74:	4293      	cmp	r3, r2
 800be76:	d107      	bne.n	800be88 <RemapAndLinkDMAtoUARTTx+0x42c>
		__HAL_DMA1_REMAP(HAL_DMA1_CH7_USART8_TX);		
 800be78:	4b16      	ldr	r3, [pc, #88]	; (800bed4 <RemapAndLinkDMAtoUARTTx+0x478>)
 800be7a:	4c1a      	ldr	r4, [pc, #104]	; (800bee4 <RemapAndLinkDMAtoUARTTx+0x488>)
 800be7c:	681a      	ldr	r2, [r3, #0]
 800be7e:	4022      	ands	r2, r4
 800be80:	601a      	str	r2, [r3, #0]
 800be82:	681c      	ldr	r4, [r3, #0]
 800be84:	22f0      	movs	r2, #240	; 0xf0
 800be86:	e614      	b.n	800bab2 <RemapAndLinkDMAtoUARTTx+0x56>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel1) {
 800be88:	4a0b      	ldr	r2, [pc, #44]	; (800beb8 <RemapAndLinkDMAtoUARTTx+0x45c>)
 800be8a:	4293      	cmp	r3, r2
 800be8c:	d103      	bne.n	800be96 <RemapAndLinkDMAtoUARTTx+0x43a>
		__HAL_DMA2_REMAP(HAL_DMA2_CH1_USART8_TX);	
 800be8e:	4b0b      	ldr	r3, [pc, #44]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800be90:	220f      	movs	r2, #15
 800be92:	681c      	ldr	r4, [r3, #0]
 800be94:	e7de      	b.n	800be54 <RemapAndLinkDMAtoUARTTx+0x3f8>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel4) {
 800be96:	4a0a      	ldr	r2, [pc, #40]	; (800bec0 <RemapAndLinkDMAtoUARTTx+0x464>)
 800be98:	4293      	cmp	r3, r2
 800be9a:	d101      	bne.n	800bea0 <RemapAndLinkDMAtoUARTTx+0x444>
		__HAL_DMA2_REMAP(HAL_DMA2_CH4_USART8_TX);	
 800be9c:	4b07      	ldr	r3, [pc, #28]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800be9e:	e7e1      	b.n	800be64 <RemapAndLinkDMAtoUARTTx+0x408>
	} else if (huart->Instance == USART8 && hDMA->Instance == DMA2_Channel5) {
 800bea0:	4a08      	ldr	r2, [pc, #32]	; (800bec4 <RemapAndLinkDMAtoUARTTx+0x468>)
 800bea2:	4293      	cmp	r3, r2
 800bea4:	d000      	beq.n	800bea8 <RemapAndLinkDMAtoUARTTx+0x44c>
 800bea6:	e5eb      	b.n	800ba80 <RemapAndLinkDMAtoUARTTx+0x24>
		__HAL_DMA2_REMAP(HAL_DMA2_CH5_USART8_TX);					
 800bea8:	4b04      	ldr	r3, [pc, #16]	; (800bebc <RemapAndLinkDMAtoUARTTx+0x460>)
 800beaa:	4c07      	ldr	r4, [pc, #28]	; (800bec8 <RemapAndLinkDMAtoUARTTx+0x46c>)
 800beac:	681a      	ldr	r2, [r3, #0]
 800beae:	4022      	ands	r2, r4
 800beb0:	601a      	str	r2, [r3, #0]
 800beb2:	681c      	ldr	r4, [r3, #0]
 800beb4:	22f0      	movs	r2, #240	; 0xf0
 800beb6:	e618      	b.n	800baea <RemapAndLinkDMAtoUARTTx+0x8e>
 800beb8:	40020408 	.word	0x40020408
 800bebc:	400204a8 	.word	0x400204a8
 800bec0:	40020444 	.word	0x40020444
 800bec4:	40020458 	.word	0x40020458
 800bec8:	fff0ffff 	.word	0xfff0ffff
 800becc:	40011800 	.word	0x40011800
 800bed0:	4002001c 	.word	0x4002001c
 800bed4:	400200a8 	.word	0x400200a8
 800bed8:	40020044 	.word	0x40020044
 800bedc:	ffff0fff 	.word	0xffff0fff
 800bee0:	40020080 	.word	0x40020080
 800bee4:	f0ffffff 	.word	0xf0ffffff
 800bee8:	40011c00 	.word	0x40011c00

0800beec <DMA_MSG_TX_Setup>:
{	
 800beec:	b510      	push	{r4, lr}
	if (msgTxDMA[0].Parent == NULL)
 800beee:	4b0b      	ldr	r3, [pc, #44]	; (800bf1c <DMA_MSG_TX_Setup+0x30>)
 800bef0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
		hDMA = &msgTxDMA[0];
 800bef2:	001c      	movs	r4, r3
	if (msgTxDMA[0].Parent == NULL)
 800bef4:	2a00      	cmp	r2, #0
 800bef6:	d007      	beq.n	800bf08 <DMA_MSG_TX_Setup+0x1c>
	else if (msgTxDMA[1].Parent == NULL)
 800bef8:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800befa:	2a00      	cmp	r2, #0
 800befc:	d00c      	beq.n	800bf18 <DMA_MSG_TX_Setup+0x2c>
	else if (msgTxDMA[2].Parent == NULL)
 800befe:	3394      	adds	r3, #148	; 0x94
 800bf00:	681b      	ldr	r3, [r3, #0]
 800bf02:	2b00      	cmp	r3, #0
 800bf04:	d100      	bne.n	800bf08 <DMA_MSG_TX_Setup+0x1c>
		hDMA = &msgTxDMA[2];  
 800bf06:	4c06      	ldr	r4, [pc, #24]	; (800bf20 <DMA_MSG_TX_Setup+0x34>)
	RemapAndLinkDMAtoUARTTx(huart, hDMA);
 800bf08:	0021      	movs	r1, r4
 800bf0a:	f7ff fda7 	bl	800ba5c <RemapAndLinkDMAtoUARTTx>
	SetupDMAInterrupts(hDMA, MSG_DMA_INT_PRIORITY);
 800bf0e:	2100      	movs	r1, #0
 800bf10:	0020      	movs	r0, r4
 800bf12:	f7ff fa41 	bl	800b398 <SetupDMAInterrupts>
}
 800bf16:	bd10      	pop	{r4, pc}
		hDMA = &msgTxDMA[1];
 800bf18:	4c02      	ldr	r4, [pc, #8]	; (800bf24 <DMA_MSG_TX_Setup+0x38>)
 800bf1a:	e7f5      	b.n	800bf08 <DMA_MSG_TX_Setup+0x1c>
 800bf1c:	20001a90 	.word	0x20001a90
 800bf20:	20001b00 	.word	0x20001b00
 800bf24:	20001ac8 	.word	0x20001ac8

0800bf28 <CRC_Init>:
/*-----------------------------------------------------------*/

void CRC_Init(void)
{
  hcrc.Instance = CRC;
	hcrc.Init.CRCLength = CRC_POLYLENGTH_8B;		// Do not change this since it is used for message CRC8
 800bf28:	2310      	movs	r3, #16
 800bf2a:	4807      	ldr	r0, [pc, #28]	; (800bf48 <CRC_Init+0x20>)
{
 800bf2c:	b510      	push	{r4, lr}
	hcrc.Init.CRCLength = CRC_POLYLENGTH_8B;		// Do not change this since it is used for message CRC8
 800bf2e:	60c3      	str	r3, [r0, #12]
  hcrc.Instance = CRC;
 800bf30:	4b06      	ldr	r3, [pc, #24]	; (800bf4c <CRC_Init+0x24>)
 800bf32:	6003      	str	r3, [r0, #0]
 800bf34:	2300      	movs	r3, #0
 800bf36:	8083      	strh	r3, [r0, #4]
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;    
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;    
 800bf38:	6143      	str	r3, [r0, #20]
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;    
 800bf3a:	6183      	str	r3, [r0, #24]
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_WORDS;
 800bf3c:	3303      	adds	r3, #3
 800bf3e:	6203      	str	r3, [r0, #32]
	HAL_CRC_Init(&hcrc);
 800bf40:	f005 fbaf 	bl	80116a2 <HAL_CRC_Init>
}
 800bf44:	bd10      	pop	{r4, pc}
 800bf46:	46c0      	nop			; (mov r8, r8)
 800bf48:	20007924 	.word	0x20007924
 800bf4c:	40023000 	.word	0x40023000

0800bf50 <HAL_CRC_MspInit>:

void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
	/* Enable peripheral clock */
	__HAL_RCC_CRC_CLK_ENABLE();
 800bf50:	2040      	movs	r0, #64	; 0x40
 800bf52:	4a05      	ldr	r2, [pc, #20]	; (800bf68 <HAL_CRC_MspInit+0x18>)
{
 800bf54:	b082      	sub	sp, #8
	__HAL_RCC_CRC_CLK_ENABLE();
 800bf56:	6951      	ldr	r1, [r2, #20]
 800bf58:	4301      	orrs	r1, r0
 800bf5a:	6151      	str	r1, [r2, #20]
 800bf5c:	6953      	ldr	r3, [r2, #20]
 800bf5e:	4003      	ands	r3, r0
 800bf60:	9301      	str	r3, [sp, #4]
 800bf62:	9b01      	ldr	r3, [sp, #4]
}
 800bf64:	b002      	add	sp, #8
 800bf66:	4770      	bx	lr
 800bf68:	40021000 	.word	0x40021000

0800bf6c <CalculateCRC8>:
{
	/* Disable peripheral clock */
	__HAL_RCC_CRC_CLK_DISABLE();
}
uint8_t  CalculateCRC8(uint32_t pBuffer[], uint16_t size)
{
 800bf6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bf6e:	0004      	movs	r4, r0
 800bf70:	000e      	movs	r6, r1
	uint8_t pTemp;
	//uint32_t crcBuffer[size]=*pData;
	/* check if the passed variables are null */
	if (NULL!=pBuffer && 0!=size)
 800bf72:	2800      	cmp	r0, #0
 800bf74:	d00c      	beq.n	800bf90 <CalculateCRC8+0x24>
			pTemp=HAL_CRC_Accumulate(&hcrc, &pBuffer[(size/4)*4], 1);
		}
		return pTemp;
	}
	else
	return 0;
 800bf76:	2000      	movs	r0, #0
	if (NULL!=pBuffer && 0!=size)
 800bf78:	4281      	cmp	r1, r0
 800bf7a:	d009      	beq.n	800bf90 <CalculateCRC8+0x24>
		pTemp=HAL_CRC_Calculate(&hcrc, pBuffer, size/4);
 800bf7c:	4f08      	ldr	r7, [pc, #32]	; (800bfa0 <CalculateCRC8+0x34>)
 800bf7e:	088d      	lsrs	r5, r1, #2
 800bf80:	002a      	movs	r2, r5
 800bf82:	0021      	movs	r1, r4
 800bf84:	0038      	movs	r0, r7
 800bf86:	f005 fbe1 	bl	801174c <HAL_CRC_Calculate>
		if ((size%4)!=0)
 800bf8a:	07b3      	lsls	r3, r6, #30
 800bf8c:	d101      	bne.n	800bf92 <CalculateCRC8+0x26>
			pTemp=HAL_CRC_Accumulate(&hcrc, &pBuffer[(size/4)*4], 1);
 800bf8e:	b2c0      	uxtb	r0, r0
}
 800bf90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			pTemp=HAL_CRC_Accumulate(&hcrc, &pBuffer[(size/4)*4], 1);
 800bf92:	0129      	lsls	r1, r5, #4
 800bf94:	1861      	adds	r1, r4, r1
 800bf96:	2201      	movs	r2, #1
 800bf98:	0038      	movs	r0, r7
 800bf9a:	f005 fbae 	bl	80116fa <HAL_CRC_Accumulate>
 800bf9e:	e7f6      	b.n	800bf8e <CalculateCRC8+0x22>
 800bfa0:	20007924 	.word	0x20007924

0800bfa4 <IND_LED_Init>:
	IND_LED_Init();
}

//-- Configure indicator LED
void IND_LED_Init(void)
{
 800bfa4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	GPIO_InitTypeDef GPIO_InitStruct;
	
	GPIO_InitStruct.Pin = _IND_LED_PIN;
 800bfa6:	2380      	movs	r3, #128	; 0x80
 800bfa8:	01db      	lsls	r3, r3, #7
 800bfaa:	9301      	str	r3, [sp, #4]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800bfac:	2301      	movs	r3, #1
 800bfae:	9302      	str	r3, [sp, #8]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bfb0:	2300      	movs	r3, #0
	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
	HAL_GPIO_Init(_IND_LED_PORT, &GPIO_InitStruct);
 800bfb2:	a901      	add	r1, sp, #4
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bfb4:	9303      	str	r3, [sp, #12]
	HAL_GPIO_Init(_IND_LED_PORT, &GPIO_InitStruct);
 800bfb6:	4803      	ldr	r0, [pc, #12]	; (800bfc4 <IND_LED_Init+0x20>)
	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800bfb8:	3303      	adds	r3, #3
 800bfba:	9304      	str	r3, [sp, #16]
	HAL_GPIO_Init(_IND_LED_PORT, &GPIO_InitStruct);
 800bfbc:	f006 f8ee 	bl	801219c <HAL_GPIO_Init>
}
 800bfc0:	b007      	add	sp, #28
 800bfc2:	bd00      	pop	{pc}
 800bfc4:	48000400 	.word	0x48000400

0800bfc8 <GPIO_Init>:
{
 800bfc8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  __GPIOA_CLK_ENABLE();
 800bfca:	2080      	movs	r0, #128	; 0x80
 800bfcc:	4b18      	ldr	r3, [pc, #96]	; (800c030 <GPIO_Init+0x68>)
 800bfce:	0280      	lsls	r0, r0, #10
 800bfd0:	6959      	ldr	r1, [r3, #20]
 800bfd2:	4301      	orrs	r1, r0
 800bfd4:	6159      	str	r1, [r3, #20]
 800bfd6:	695a      	ldr	r2, [r3, #20]
 800bfd8:	4002      	ands	r2, r0
	__GPIOB_CLK_ENABLE();
 800bfda:	2080      	movs	r0, #128	; 0x80
  __GPIOA_CLK_ENABLE();
 800bfdc:	9201      	str	r2, [sp, #4]
 800bfde:	9a01      	ldr	r2, [sp, #4]
	__GPIOB_CLK_ENABLE();
 800bfe0:	6959      	ldr	r1, [r3, #20]
 800bfe2:	02c0      	lsls	r0, r0, #11
 800bfe4:	4301      	orrs	r1, r0
 800bfe6:	6159      	str	r1, [r3, #20]
 800bfe8:	695a      	ldr	r2, [r3, #20]
 800bfea:	4002      	ands	r2, r0
	__GPIOC_CLK_ENABLE();
 800bfec:	2080      	movs	r0, #128	; 0x80
	__GPIOB_CLK_ENABLE();
 800bfee:	9202      	str	r2, [sp, #8]
 800bff0:	9a02      	ldr	r2, [sp, #8]
	__GPIOC_CLK_ENABLE();
 800bff2:	6959      	ldr	r1, [r3, #20]
 800bff4:	0300      	lsls	r0, r0, #12
 800bff6:	4301      	orrs	r1, r0
 800bff8:	6159      	str	r1, [r3, #20]
 800bffa:	695a      	ldr	r2, [r3, #20]
 800bffc:	4002      	ands	r2, r0
  __GPIOD_CLK_ENABLE();
 800bffe:	2080      	movs	r0, #128	; 0x80
	__GPIOC_CLK_ENABLE();
 800c000:	9203      	str	r2, [sp, #12]
 800c002:	9a03      	ldr	r2, [sp, #12]
  __GPIOD_CLK_ENABLE();
 800c004:	6959      	ldr	r1, [r3, #20]
 800c006:	0340      	lsls	r0, r0, #13
 800c008:	4301      	orrs	r1, r0
 800c00a:	6159      	str	r1, [r3, #20]
	__GPIOF_CLK_ENABLE();		// for HSE and Boot0
 800c00c:	2180      	movs	r1, #128	; 0x80
  __GPIOD_CLK_ENABLE();
 800c00e:	695a      	ldr	r2, [r3, #20]
	__GPIOF_CLK_ENABLE();		// for HSE and Boot0
 800c010:	03c9      	lsls	r1, r1, #15
  __GPIOD_CLK_ENABLE();
 800c012:	4002      	ands	r2, r0
 800c014:	9204      	str	r2, [sp, #16]
 800c016:	9a04      	ldr	r2, [sp, #16]
	__GPIOF_CLK_ENABLE();		// for HSE and Boot0
 800c018:	695a      	ldr	r2, [r3, #20]
 800c01a:	430a      	orrs	r2, r1
 800c01c:	615a      	str	r2, [r3, #20]
 800c01e:	695b      	ldr	r3, [r3, #20]
 800c020:	400b      	ands	r3, r1
 800c022:	9305      	str	r3, [sp, #20]
 800c024:	9b05      	ldr	r3, [sp, #20]
	IND_LED_Init();
 800c026:	f7ff ffbd 	bl	800bfa4 <IND_LED_Init>
}
 800c02a:	b007      	add	sp, #28
 800c02c:	bd00      	pop	{pc}
 800c02e:	46c0      	nop			; (mov r8, r8)
 800c030:	40021000 	.word	0x40021000

0800c034 <GetPortGPIOs>:
/*-----------------------------------------------------------*/	

/* --- Get GPIO pins and ports of this array port
*/
BOS_Status GetPortGPIOs(uint8_t port, uint32_t *TX_Port, uint16_t *TX_Pin, uint32_t *RX_Port, uint16_t *RX_Pin)
{
 800c034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c036:	9c06      	ldr	r4, [sp, #24]
 800c038:	001d      	movs	r5, r3
 800c03a:	000f      	movs	r7, r1
 800c03c:	0016      	movs	r6, r2
	BOS_Status result = BOS_OK;
	
	/* Get port UART */
	UART_HandleTypeDef* huart = GetUart(port);
 800c03e:	f001 f9df 	bl	800d400 <GetUart>
	
	if (huart == &huart1) 
 800c042:	4b1e      	ldr	r3, [pc, #120]	; (800c0bc <GetPortGPIOs+0x88>)
 800c044:	4298      	cmp	r0, r3
 800c046:	d10c      	bne.n	800c062 <GetPortGPIOs+0x2e>
	{	
#ifdef _Usart1		
		*TX_Port = (uint32_t)USART1_TX_PORT;
 800c048:	2390      	movs	r3, #144	; 0x90
		*TX_Pin = USART1_TX_PIN;
 800c04a:	2280      	movs	r2, #128	; 0x80
		*TX_Port = (uint32_t)USART1_TX_PORT;
 800c04c:	05db      	lsls	r3, r3, #23
		*TX_Pin = USART1_TX_PIN;
 800c04e:	0092      	lsls	r2, r2, #2
		*TX_Port = (uint32_t)USART1_TX_PORT;
 800c050:	603b      	str	r3, [r7, #0]
		*TX_Pin = USART1_TX_PIN;
 800c052:	8032      	strh	r2, [r6, #0]
		*RX_Port = (uint32_t)USART1_RX_PORT;
 800c054:	602b      	str	r3, [r5, #0]
		*RX_Pin = USART1_RX_PIN;
 800c056:	2380      	movs	r3, #128	; 0x80
 800c058:	00db      	lsls	r3, r3, #3
	else if (huart == &huart5) 
	{	
		*TX_Port = (uint32_t)USART5_TX_PORT;
		*TX_Pin = USART5_TX_PIN;
		*RX_Port = (uint32_t)USART5_RX_PORT;
		*RX_Pin = USART5_RX_PIN;
 800c05a:	8023      	strh	r3, [r4, #0]
	BOS_Status result = BOS_OK;
 800c05c:	2300      	movs	r3, #0
#endif
	else
		result = BOS_ERROR;	
	
	return result;	
}
 800c05e:	0018      	movs	r0, r3
 800c060:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	else if (huart == &huart2) 
 800c062:	4b17      	ldr	r3, [pc, #92]	; (800c0c0 <GetPortGPIOs+0x8c>)
 800c064:	4298      	cmp	r0, r3
 800c066:	d107      	bne.n	800c078 <GetPortGPIOs+0x44>
		*TX_Port = (uint32_t)USART2_TX_PORT;
 800c068:	2390      	movs	r3, #144	; 0x90
		*TX_Pin = USART2_TX_PIN;
 800c06a:	2204      	movs	r2, #4
		*TX_Port = (uint32_t)USART2_TX_PORT;
 800c06c:	05db      	lsls	r3, r3, #23
 800c06e:	603b      	str	r3, [r7, #0]
		*TX_Pin = USART2_TX_PIN;
 800c070:	8032      	strh	r2, [r6, #0]
		*RX_Port = (uint32_t)USART2_RX_PORT;
 800c072:	602b      	str	r3, [r5, #0]
		*RX_Pin = USART2_RX_PIN;
 800c074:	2308      	movs	r3, #8
 800c076:	e7f0      	b.n	800c05a <GetPortGPIOs+0x26>
	else if (huart == &huart3) 
 800c078:	4b12      	ldr	r3, [pc, #72]	; (800c0c4 <GetPortGPIOs+0x90>)
 800c07a:	4298      	cmp	r0, r3
 800c07c:	d108      	bne.n	800c090 <GetPortGPIOs+0x5c>
		*TX_Pin = USART3_TX_PIN;
 800c07e:	2280      	movs	r2, #128	; 0x80
		*TX_Port = (uint32_t)USART3_TX_PORT;
 800c080:	4b11      	ldr	r3, [pc, #68]	; (800c0c8 <GetPortGPIOs+0x94>)
		*TX_Pin = USART3_TX_PIN;
 800c082:	00d2      	lsls	r2, r2, #3
		*TX_Port = (uint32_t)USART3_TX_PORT;
 800c084:	603b      	str	r3, [r7, #0]
		*TX_Pin = USART3_TX_PIN;
 800c086:	8032      	strh	r2, [r6, #0]
		*RX_Port = (uint32_t)USART3_RX_PORT;
 800c088:	602b      	str	r3, [r5, #0]
		*RX_Pin = USART3_RX_PIN;
 800c08a:	2380      	movs	r3, #128	; 0x80
 800c08c:	011b      	lsls	r3, r3, #4
 800c08e:	e7e4      	b.n	800c05a <GetPortGPIOs+0x26>
	else if (huart == &huart4) 
 800c090:	4b0e      	ldr	r3, [pc, #56]	; (800c0cc <GetPortGPIOs+0x98>)
 800c092:	4298      	cmp	r0, r3
 800c094:	d107      	bne.n	800c0a6 <GetPortGPIOs+0x72>
		*TX_Port = (uint32_t)USART4_TX_PORT;
 800c096:	2390      	movs	r3, #144	; 0x90
		*TX_Pin = USART4_TX_PIN;
 800c098:	2201      	movs	r2, #1
		*TX_Port = (uint32_t)USART4_TX_PORT;
 800c09a:	05db      	lsls	r3, r3, #23
 800c09c:	603b      	str	r3, [r7, #0]
		*TX_Pin = USART4_TX_PIN;
 800c09e:	8032      	strh	r2, [r6, #0]
		*RX_Port = (uint32_t)USART4_RX_PORT;
 800c0a0:	602b      	str	r3, [r5, #0]
		*RX_Pin = USART4_RX_PIN;
 800c0a2:	2302      	movs	r3, #2
 800c0a4:	e7d9      	b.n	800c05a <GetPortGPIOs+0x26>
	else if (huart == &huart5) 
 800c0a6:	4a0a      	ldr	r2, [pc, #40]	; (800c0d0 <GetPortGPIOs+0x9c>)
		result = BOS_ERROR;	
 800c0a8:	23ff      	movs	r3, #255	; 0xff
	else if (huart == &huart5) 
 800c0aa:	4290      	cmp	r0, r2
 800c0ac:	d1d7      	bne.n	800c05e <GetPortGPIOs+0x2a>
		*TX_Pin = USART5_TX_PIN;
 800c0ae:	2208      	movs	r2, #8
		*TX_Port = (uint32_t)USART5_TX_PORT;
 800c0b0:	4b05      	ldr	r3, [pc, #20]	; (800c0c8 <GetPortGPIOs+0x94>)
 800c0b2:	603b      	str	r3, [r7, #0]
		*TX_Pin = USART5_TX_PIN;
 800c0b4:	8032      	strh	r2, [r6, #0]
		*RX_Port = (uint32_t)USART5_RX_PORT;
 800c0b6:	602b      	str	r3, [r5, #0]
		*RX_Pin = USART5_RX_PIN;
 800c0b8:	2310      	movs	r3, #16
 800c0ba:	e7ce      	b.n	800c05a <GetPortGPIOs+0x26>
 800c0bc:	20007424 	.word	0x20007424
 800c0c0:	200077d0 	.word	0x200077d0
 800c0c4:	200070dc 	.word	0x200070dc
 800c0c8:	48000400 	.word	0x48000400
 800c0cc:	20007758 	.word	0x20007758
 800c0d0:	200073b0 	.word	0x200073b0

0800c0d4 <IsFactoryReset>:
  __GPIOA_CLK_ENABLE();
 800c0d4:	2080      	movs	r0, #128	; 0x80
{
 800c0d6:	b5f0      	push	{r4, r5, r6, r7, lr}
  __GPIOA_CLK_ENABLE();
 800c0d8:	4b37      	ldr	r3, [pc, #220]	; (800c1b8 <IsFactoryReset+0xe4>)
 800c0da:	0280      	lsls	r0, r0, #10
 800c0dc:	6959      	ldr	r1, [r3, #20]
{
 800c0de:	b093      	sub	sp, #76	; 0x4c
  __GPIOA_CLK_ENABLE();
 800c0e0:	4301      	orrs	r1, r0
 800c0e2:	6159      	str	r1, [r3, #20]
 800c0e4:	695a      	ldr	r2, [r3, #20]
	GetPortGPIOs(P_LAST, &P_last_TX_Port, &P_last_TX_Pin, &P_last_RX_Port, &P_last_RX_Pin);
 800c0e6:	2412      	movs	r4, #18
  __GPIOA_CLK_ENABLE();
 800c0e8:	4002      	ands	r2, r0
  __GPIOB_CLK_ENABLE();
 800c0ea:	2080      	movs	r0, #128	; 0x80
  __GPIOA_CLK_ENABLE();
 800c0ec:	9209      	str	r2, [sp, #36]	; 0x24
 800c0ee:	9a09      	ldr	r2, [sp, #36]	; 0x24
  __GPIOB_CLK_ENABLE();
 800c0f0:	6959      	ldr	r1, [r3, #20]
 800c0f2:	02c0      	lsls	r0, r0, #11
 800c0f4:	4301      	orrs	r1, r0
 800c0f6:	6159      	str	r1, [r3, #20]
 800c0f8:	695a      	ldr	r2, [r3, #20]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800c0fa:	2600      	movs	r6, #0
  __GPIOB_CLK_ENABLE();
 800c0fc:	4002      	ands	r2, r0
  __GPIOC_CLK_ENABLE();
 800c0fe:	2080      	movs	r0, #128	; 0x80
  __GPIOB_CLK_ENABLE();
 800c100:	920a      	str	r2, [sp, #40]	; 0x28
 800c102:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  __GPIOC_CLK_ENABLE();
 800c104:	6959      	ldr	r1, [r3, #20]
 800c106:	0300      	lsls	r0, r0, #12
 800c108:	4301      	orrs	r1, r0
 800c10a:	6159      	str	r1, [r3, #20]
	__GPIOD_CLK_ENABLE();
 800c10c:	2180      	movs	r1, #128	; 0x80
  __GPIOC_CLK_ENABLE();
 800c10e:	695a      	ldr	r2, [r3, #20]
	__GPIOD_CLK_ENABLE();
 800c110:	0349      	lsls	r1, r1, #13
  __GPIOC_CLK_ENABLE();
 800c112:	4002      	ands	r2, r0
 800c114:	920b      	str	r2, [sp, #44]	; 0x2c
 800c116:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	__GPIOD_CLK_ENABLE();
 800c118:	695a      	ldr	r2, [r3, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800c11a:	2701      	movs	r7, #1
	__GPIOD_CLK_ENABLE();
 800c11c:	430a      	orrs	r2, r1
 800c11e:	615a      	str	r2, [r3, #20]
 800c120:	695b      	ldr	r3, [r3, #20]
	GetPortGPIOs(P1, &P1_TX_Port, &P1_TX_Pin, &P1_RX_Port, &P1_RX_Pin);
 800c122:	ad03      	add	r5, sp, #12
	__GPIOD_CLK_ENABLE();
 800c124:	400b      	ands	r3, r1
 800c126:	930c      	str	r3, [sp, #48]	; 0x30
 800c128:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	GetPortGPIOs(P1, &P1_TX_Port, &P1_TX_Pin, &P1_RX_Port, &P1_RX_Pin);
 800c12a:	230e      	movs	r3, #14
 800c12c:	446b      	add	r3, sp
	GetPortGPIOs(P_LAST, &P_last_TX_Port, &P_last_TX_Pin, &P_last_RX_Port, &P_last_RX_Pin);
 800c12e:	446c      	add	r4, sp
	GetPortGPIOs(P1, &P1_TX_Port, &P1_TX_Pin, &P1_RX_Port, &P1_RX_Pin);
 800c130:	9300      	str	r3, [sp, #0]
 800c132:	002a      	movs	r2, r5
 800c134:	ab06      	add	r3, sp, #24
 800c136:	a905      	add	r1, sp, #20
 800c138:	2001      	movs	r0, #1
 800c13a:	f7ff ff7b 	bl	800c034 <GetPortGPIOs>
	GetPortGPIOs(P_LAST, &P_last_TX_Port, &P_last_TX_Pin, &P_last_RX_Port, &P_last_RX_Pin);
 800c13e:	aa04      	add	r2, sp, #16
 800c140:	ab08      	add	r3, sp, #32
 800c142:	a907      	add	r1, sp, #28
 800c144:	9400      	str	r4, [sp, #0]
 800c146:	2005      	movs	r0, #5
 800c148:	f7ff ff74 	bl	800c034 <GetPortGPIOs>
	GPIO_InitStruct.Pin = P1_TX_Pin;
 800c14c:	882b      	ldrh	r3, [r5, #0]
	HAL_GPIO_Init((GPIO_TypeDef *)P1_TX_Port, &GPIO_InitStruct);
 800c14e:	a90d      	add	r1, sp, #52	; 0x34
 800c150:	9805      	ldr	r0, [sp, #20]
	GPIO_InitStruct.Pin = P1_TX_Pin;
 800c152:	930d      	str	r3, [sp, #52]	; 0x34
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800c154:	970e      	str	r7, [sp, #56]	; 0x38
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800c156:	960f      	str	r6, [sp, #60]	; 0x3c
	HAL_GPIO_Init((GPIO_TypeDef *)P1_TX_Port, &GPIO_InitStruct);
 800c158:	f006 f820 	bl	801219c <HAL_GPIO_Init>
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;	
 800c15c:	2302      	movs	r3, #2
 800c15e:	930f      	str	r3, [sp, #60]	; 0x3c
	GPIO_InitStruct.Pin = P_last_RX_Pin;
 800c160:	8823      	ldrh	r3, [r4, #0]
	HAL_GPIO_Init((GPIO_TypeDef *)P_last_RX_Port, &GPIO_InitStruct);	
 800c162:	a90d      	add	r1, sp, #52	; 0x34
 800c164:	9808      	ldr	r0, [sp, #32]
	GPIO_InitStruct.Pin = P_last_RX_Pin;
 800c166:	930d      	str	r3, [sp, #52]	; 0x34
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800c168:	960e      	str	r6, [sp, #56]	; 0x38
	HAL_GPIO_Init((GPIO_TypeDef *)P_last_RX_Port, &GPIO_InitStruct);	
 800c16a:	f006 f817 	bl	801219c <HAL_GPIO_Init>
	HAL_GPIO_WritePin((GPIO_TypeDef *)P1_TX_Port,P1_TX_Pin,GPIO_PIN_RESET);
 800c16e:	8829      	ldrh	r1, [r5, #0]
 800c170:	0032      	movs	r2, r6
 800c172:	9805      	ldr	r0, [sp, #20]
 800c174:	f006 f8d4 	bl	8012320 <HAL_GPIO_WritePin>
	Delay_ms_no_rtos(5);
 800c178:	2005      	movs	r0, #5
 800c17a:	f000 ffd7 	bl	800d12c <StartMilliDelay>
	if (HAL_GPIO_ReadPin((GPIO_TypeDef *)P_last_RX_Port,P_last_RX_Pin) == RESET)
 800c17e:	8821      	ldrh	r1, [r4, #0]
 800c180:	9808      	ldr	r0, [sp, #32]
 800c182:	f006 f8c7 	bl	8012314 <HAL_GPIO_ReadPin>
 800c186:	42b0      	cmp	r0, r6
 800c188:	d006      	beq.n	800c198 <IsFactoryReset+0xc4>
	*((unsigned long *)0x20007FF0) = 0xFFFFFFFF; 
 800c18a:	2201      	movs	r2, #1
	return 0;
 800c18c:	2000      	movs	r0, #0
	*((unsigned long *)0x20007FF0) = 0xFFFFFFFF; 
 800c18e:	4b0b      	ldr	r3, [pc, #44]	; (800c1bc <IsFactoryReset+0xe8>)
 800c190:	4252      	negs	r2, r2
 800c192:	601a      	str	r2, [r3, #0]
}
 800c194:	b013      	add	sp, #76	; 0x4c
 800c196:	bdf0      	pop	{r4, r5, r6, r7, pc}
		HAL_GPIO_WritePin((GPIO_TypeDef *)P1_TX_Port,P1_TX_Pin,GPIO_PIN_SET);
 800c198:	8829      	ldrh	r1, [r5, #0]
 800c19a:	003a      	movs	r2, r7
 800c19c:	9805      	ldr	r0, [sp, #20]
 800c19e:	f006 f8bf 	bl	8012320 <HAL_GPIO_WritePin>
		Delay_ms_no_rtos(5);
 800c1a2:	2005      	movs	r0, #5
 800c1a4:	f000 ffc2 	bl	800d12c <StartMilliDelay>
		if (HAL_GPIO_ReadPin((GPIO_TypeDef *)P_last_RX_Port,P_last_RX_Pin) == SET) {
 800c1a8:	8821      	ldrh	r1, [r4, #0]
 800c1aa:	9808      	ldr	r0, [sp, #32]
 800c1ac:	f006 f8b2 	bl	8012314 <HAL_GPIO_ReadPin>
 800c1b0:	2801      	cmp	r0, #1
 800c1b2:	d1ea      	bne.n	800c18a <IsFactoryReset+0xb6>
 800c1b4:	e7ee      	b.n	800c194 <IsFactoryReset+0xc0>
 800c1b6:	46c0      	nop			; (mov r8, r8)
 800c1b8:	40021000 	.word	0x40021000
 800c1bc:	20007ff0 	.word	0x20007ff0

0800c1c0 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 800c1c0:	b510      	push	{r4, lr}
	
	HAL_IncTick();
 800c1c2:	f005 f995 	bl	80114f0 <HAL_IncTick>
  osSystickHandler();  
 800c1c6:	f003 fb35 	bl	800f834 <osSystickHandler>

}
 800c1ca:	bd10      	pop	{r4, pc}

0800c1cc <HardFault_Handler>:

/**
* @brief This function handles Hard Fault error callback.
*/
void HardFault_Handler(void)
 {
 800c1cc:	e7fe      	b.n	800c1cc <HardFault_Handler>
	...

0800c1d0 <TIM16_IRQHandler>:
/******************************************************************************/
/**
* @brief This function handles Timer 16 global interrupt 
*/
void TIM16_IRQHandler(void)
{
 800c1d0:	b510      	push	{r4, lr}
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

  HAL_TIM_IRQHandler(&htim16);
 800c1d2:	4802      	ldr	r0, [pc, #8]	; (800c1dc <TIM16_IRQHandler+0xc>)
 800c1d4:	f007 f970 	bl	80134b8 <HAL_TIM_IRQHandler>
	switch should be performed before the interrupt exists.  That ensures the
	unblocked (higher priority) task is returned to immediately. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );	

	
}
 800c1d8:	bd10      	pop	{r4, pc}
 800c1da:	46c0      	nop			; (mov r8, r8)
 800c1dc:	20007840 	.word	0x20007840

0800c1e0 <USART1_IRQHandler>:

/**
* @brief This function handles USART1 global interrupt / USART1 wake-up interrupt through EXTI line 25.
*/
void USART1_IRQHandler(void)
{
 800c1e0:	b510      	push	{r4, lr}
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
	
#if defined (_Usart1)		
  HAL_UART_IRQHandler(&huart1);
 800c1e2:	4802      	ldr	r0, [pc, #8]	; (800c1ec <USART1_IRQHandler+0xc>)
 800c1e4:	f007 ff23 	bl	801402e <HAL_UART_IRQHandler>
	
	/* If lHigherPriorityTaskWoken is now equal to pdTRUE, then a context
	switch should be performed before the interrupt exists.  That ensures the
	unblocked (higher priority) task is returned to immediately. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
}
 800c1e8:	bd10      	pop	{r4, pc}
 800c1ea:	46c0      	nop			; (mov r8, r8)
 800c1ec:	20007424 	.word	0x20007424

0800c1f0 <USART2_IRQHandler>:

/**
* @brief This function handles USART2 global interrupt / USART2 wake-up interrupt through EXTI line 26.
*/
void USART2_IRQHandler(void)
{
 800c1f0:	b510      	push	{r4, lr}
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
	
#if defined (_Usart2)	
  HAL_UART_IRQHandler(&huart2);
 800c1f2:	4802      	ldr	r0, [pc, #8]	; (800c1fc <USART2_IRQHandler+0xc>)
 800c1f4:	f007 ff1b 	bl	801402e <HAL_UART_IRQHandler>
	
	/* If lHigherPriorityTaskWoken is now equal to pdTRUE, then a context
	switch should be performed before the interrupt exists.  That ensures the
	unblocked (higher priority) task is returned to immediately. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
}
 800c1f8:	bd10      	pop	{r4, pc}
 800c1fa:	46c0      	nop			; (mov r8, r8)
 800c1fc:	200077d0 	.word	0x200077d0

0800c200 <USART3_8_IRQHandler>:

/**
* @brief This function handles USART3 to USART8 global interrupts / USART3 wake-up interrupt through EXTI line 28.
*/
void USART3_8_IRQHandler(void)
{
 800c200:	b510      	push	{r4, lr}
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
	
#if defined (_Usart3)
	HAL_UART_IRQHandler(&huart3);
 800c202:	4805      	ldr	r0, [pc, #20]	; (800c218 <USART3_8_IRQHandler+0x18>)
 800c204:	f007 ff13 	bl	801402e <HAL_UART_IRQHandler>
#endif
#if defined (_Usart4)
	HAL_UART_IRQHandler(&huart4);
 800c208:	4804      	ldr	r0, [pc, #16]	; (800c21c <USART3_8_IRQHandler+0x1c>)
 800c20a:	f007 ff10 	bl	801402e <HAL_UART_IRQHandler>
#endif
#if defined (_Usart5)
	HAL_UART_IRQHandler(&huart5);
 800c20e:	4804      	ldr	r0, [pc, #16]	; (800c220 <USART3_8_IRQHandler+0x20>)
 800c210:	f007 ff0d 	bl	801402e <HAL_UART_IRQHandler>

	/* If lHigherPriorityTaskWoken is now equal to pdTRUE, then a context
	switch should be performed before the interrupt exists.  That ensures the
	unblocked (higher priority) task is returned to immediately. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
}
 800c214:	bd10      	pop	{r4, pc}
 800c216:	46c0      	nop			; (mov r8, r8)
 800c218:	200070dc 	.word	0x200070dc
 800c21c:	20007758 	.word	0x20007758
 800c220:	200073b0 	.word	0x200073b0

0800c224 <DMA1_Ch1_IRQHandler>:

/**
* @brief This function handles DMA1 channel 1 interrupt (Uplink DMA 1).
*/
void DMA1_Ch1_IRQHandler(void)
{
 800c224:	b510      	push	{r4, lr}
	/* Streaming or messaging DMA on P1 */
	DMA_IRQHandler(P1);
 800c226:	2001      	movs	r0, #1
 800c228:	f7fa fb16 	bl	8006858 <DMA_IRQHandler>
	
}
 800c22c:	bd10      	pop	{r4, pc}
	...

0800c230 <DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler>:

/**
* @brief This function handles DMA1 channel 2 to 3 and DMA2 channel 1 to 2 interrupts.
*/
void DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler(void)
{
 800c230:	b510      	push	{r4, lr}
	/* Streaming or messaging DMA on P5 */
	if (HAL_DMA_GET_IT_SOURCE(DMA2,DMA_ISR_GIF2) == SET) {
 800c232:	4b0a      	ldr	r3, [pc, #40]	; (800c25c <DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler+0x2c>)
		DMA_IRQHandler(P5);
 800c234:	2005      	movs	r0, #5
	if (HAL_DMA_GET_IT_SOURCE(DMA2,DMA_ISR_GIF2) == SET) {
 800c236:	681a      	ldr	r2, [r3, #0]
 800c238:	2310      	movs	r3, #16
 800c23a:	421a      	tst	r2, r3
 800c23c:	d104      	bne.n	800c248 <DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler+0x18>
	/* Streaming or messaging DMA on P2 */
	} else if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF3) == SET) {
 800c23e:	4a08      	ldr	r2, [pc, #32]	; (800c260 <DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler+0x30>)
 800c240:	6811      	ldr	r1, [r2, #0]
 800c242:	05c9      	lsls	r1, r1, #23
 800c244:	d503      	bpl.n	800c24e <DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler+0x1e>
		DMA_IRQHandler(P2);
 800c246:	2002      	movs	r0, #2
 800c248:	f7fa fb06 	bl	8006858 <DMA_IRQHandler>
	/* TX messaging DMA 0 */
	} else if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF2) == SET) {
		HAL_DMA_IRQHandler(&msgTxDMA[0]);
	}
}
 800c24c:	bd10      	pop	{r4, pc}
	} else if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF2) == SET) {
 800c24e:	6812      	ldr	r2, [r2, #0]
 800c250:	421a      	tst	r2, r3
 800c252:	d0fb      	beq.n	800c24c <DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler+0x1c>
		HAL_DMA_IRQHandler(&msgTxDMA[0]);
 800c254:	4803      	ldr	r0, [pc, #12]	; (800c264 <DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler+0x34>)
 800c256:	f005 fb6b 	bl	8011930 <HAL_DMA_IRQHandler>
}
 800c25a:	e7f7      	b.n	800c24c <DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler+0x1c>
 800c25c:	40020400 	.word	0x40020400
 800c260:	40020000 	.word	0x40020000
 800c264:	20001a90 	.word	0x20001a90

0800c268 <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler>:

/**
* @brief This function handles DMA1 channel 4 to 7 and DMA2 channel 3 to 5 interrupts.
*/
void DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler(void)
{
 800c268:	b510      	push	{r4, lr}
	/* Streaming or messaging DMA on P3 */
	if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF5) == SET) {
 800c26a:	4b0e      	ldr	r3, [pc, #56]	; (800c2a4 <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x3c>)
		DMA_IRQHandler(P3);
 800c26c:	2003      	movs	r0, #3
	if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF5) == SET) {
 800c26e:	681a      	ldr	r2, [r3, #0]
 800c270:	03d2      	lsls	r2, r2, #15
 800c272:	d403      	bmi.n	800c27c <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x14>
	/* Streaming or messaging DMA on P4 */
	} else if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF6) == SET) {
 800c274:	681a      	ldr	r2, [r3, #0]
 800c276:	02d2      	lsls	r2, r2, #11
 800c278:	d503      	bpl.n	800c282 <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x1a>
		DMA_IRQHandler(P4);
 800c27a:	2004      	movs	r0, #4
 800c27c:	f7fa faec 	bl	8006858 <DMA_IRQHandler>
		HAL_DMA_IRQHandler(&msgTxDMA[1]);
	/* TX messaging DMA 2 */
	} else if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF7) == SET) {
		HAL_DMA_IRQHandler(&msgTxDMA[2]);
	}
}
 800c280:	bd10      	pop	{r4, pc}
	} else if (HAL_DMA_GET_IT_SOURCE(DMA2,DMA_ISR_GIF3) == SET) {
 800c282:	4a09      	ldr	r2, [pc, #36]	; (800c2a8 <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x40>)
		DMA_IRQHandler(P6);
 800c284:	2006      	movs	r0, #6
	} else if (HAL_DMA_GET_IT_SOURCE(DMA2,DMA_ISR_GIF3) == SET) {
 800c286:	6812      	ldr	r2, [r2, #0]
 800c288:	05d2      	lsls	r2, r2, #23
 800c28a:	d4f7      	bmi.n	800c27c <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x14>
	} else if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF4) == SET) {
 800c28c:	681a      	ldr	r2, [r3, #0]
		HAL_DMA_IRQHandler(&msgTxDMA[1]);
 800c28e:	4807      	ldr	r0, [pc, #28]	; (800c2ac <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x44>)
	} else if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF4) == SET) {
 800c290:	04d2      	lsls	r2, r2, #19
 800c292:	d403      	bmi.n	800c29c <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x34>
	} else if (HAL_DMA_GET_IT_SOURCE(DMA1,DMA_ISR_GIF7) == SET) {
 800c294:	681b      	ldr	r3, [r3, #0]
 800c296:	01db      	lsls	r3, r3, #7
 800c298:	d5f2      	bpl.n	800c280 <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x18>
		HAL_DMA_IRQHandler(&msgTxDMA[2]);
 800c29a:	4805      	ldr	r0, [pc, #20]	; (800c2b0 <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x48>)
 800c29c:	f005 fb48 	bl	8011930 <HAL_DMA_IRQHandler>
}
 800c2a0:	e7ee      	b.n	800c280 <DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler+0x18>
 800c2a2:	46c0      	nop			; (mov r8, r8)
 800c2a4:	40020000 	.word	0x40020000
 800c2a8:	40020400 	.word	0x40020400
 800c2ac:	20001ac8 	.word	0x20001ac8
 800c2b0:	20001b00 	.word	0x20001b00

0800c2b4 <HAL_UART_TxCpltCallback>:

/*-----------------------------------------------------------*/

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 800c2b4:	2300      	movs	r3, #0
{
 800c2b6:	b513      	push	{r0, r1, r4, lr}
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 800c2b8:	9301      	str	r3, [sp, #4]
	
	/* TX DMAs are shared so unsetup them here to be reused */
	if(huart->hdmatx != NULL)
 800c2ba:	6e03      	ldr	r3, [r0, #96]	; 0x60
{
 800c2bc:	0004      	movs	r4, r0
	if(huart->hdmatx != NULL)
 800c2be:	2b00      	cmp	r3, #0
 800c2c0:	d001      	beq.n	800c2c6 <HAL_UART_TxCpltCallback+0x12>
		DMA_MSG_TX_UnSetup(huart);
 800c2c2:	f7ff f905 	bl	800b4d0 <DMA_MSG_TX_UnSetup>

	/* Give back the mutex. */
	xSemaphoreGiveFromISR( PxTxSemaphoreHandle[GetPort(huart)], &( xHigherPriorityTaskWoken ) );
 800c2c6:	0020      	movs	r0, r4
 800c2c8:	f7fd fbc6 	bl	8009a58 <GetPort>
 800c2cc:	4b03      	ldr	r3, [pc, #12]	; (800c2dc <HAL_UART_TxCpltCallback+0x28>)
 800c2ce:	0080      	lsls	r0, r0, #2
 800c2d0:	a901      	add	r1, sp, #4
 800c2d2:	58c0      	ldr	r0, [r0, r3]
 800c2d4:	f003 fdff 	bl	800fed6 <xQueueGiveFromISR>
}
 800c2d8:	bd13      	pop	{r0, r1, r4, pc}
 800c2da:	46c0      	nop			; (mov r8, r8)
 800c2dc:	20006ff0 	.word	0x20006ff0

0800c2e0 <HAL_UART_ErrorCallback>:
{
	/* Loop here */
	//for(;;) {};

  /* Set the UART state ready to be able to start the process again */
  huart->State = HAL_UART_STATE_READY;
 800c2e0:	0003      	movs	r3, r0
{
 800c2e2:	b570      	push	{r4, r5, r6, lr}
  huart->State = HAL_UART_STATE_READY;
 800c2e4:	2401      	movs	r4, #1
 800c2e6:	3369      	adds	r3, #105	; 0x69
 800c2e8:	701c      	strb	r4, [r3, #0]
{
 800c2ea:	0005      	movs	r5, r0
	
	/* Resume streaming DMA for this UART port */
	uint8_t port = GetPort(huart);
 800c2ec:	f7fd fbb4 	bl	8009a58 <GetPort>
	if (portStatus[port] == STREAM) {
 800c2f0:	4b0b      	ldr	r3, [pc, #44]	; (800c320 <HAL_UART_ErrorCallback+0x40>)
 800c2f2:	5c1b      	ldrb	r3, [r3, r0]
 800c2f4:	2b02      	cmp	r3, #2
 800c2f6:	d10d      	bne.n	800c314 <HAL_UART_ErrorCallback+0x34>
		HAL_UART_Receive_DMA(huart, (uint8_t *)(&(dmaStreamDst[port-1]->Instance->TDR)), huart->hdmarx->Instance->CNDTR);	
 800c2f8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800c2fa:	3801      	subs	r0, #1
 800c2fc:	681b      	ldr	r3, [r3, #0]
 800c2fe:	0080      	lsls	r0, r0, #2
 800c300:	685a      	ldr	r2, [r3, #4]
 800c302:	4b08      	ldr	r3, [pc, #32]	; (800c324 <HAL_UART_ErrorCallback+0x44>)
 800c304:	b292      	uxth	r2, r2
 800c306:	58c3      	ldr	r3, [r0, r3]
 800c308:	0028      	movs	r0, r5
 800c30a:	6819      	ldr	r1, [r3, #0]
 800c30c:	3128      	adds	r1, #40	; 0x28
 800c30e:	f007 faff 	bl	8013910 <HAL_UART_Receive_DMA>
	/* Or parse the circular buffer and restart messaging DMA for this port */
	} else {
		MsgDMAStopped[port-1] = true;		// Set a flag here and let the backend task restart DMA after parsing the buffer	
	}	
}
 800c312:	bd70      	pop	{r4, r5, r6, pc}
		MsgDMAStopped[port-1] = true;		// Set a flag here and let the backend task restart DMA after parsing the buffer	
 800c314:	4b04      	ldr	r3, [pc, #16]	; (800c328 <HAL_UART_ErrorCallback+0x48>)
 800c316:	1818      	adds	r0, r3, r0
 800c318:	3801      	subs	r0, #1
 800c31a:	7004      	strb	r4, [r0, #0]
}
 800c31c:	e7f9      	b.n	800c312 <HAL_UART_ErrorCallback+0x32>
 800c31e:	46c0      	nop			; (mov r8, r8)
 800c320:	200010b2 	.word	0x200010b2
 800c324:	20001404 	.word	0x20001404
 800c328:	2000126c 	.word	0x2000126c

0800c32c <HAL_UART_RxCpltCallback>:

/*-----------------------------------------------------------*/

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 800c32c:	b570      	push	{r4, r5, r6, lr}
 800c32e:	0004      	movs	r4, r0
	// Check only ports in messaging mode
	if (portStatus[GetPort(huart)] == FREE || portStatus[GetPort(huart)] == MSG)
 800c330:	f7fd fb92 	bl	8009a58 <GetPort>
 800c334:	4d12      	ldr	r5, [pc, #72]	; (800c380 <HAL_UART_RxCpltCallback+0x54>)
 800c336:	5c2b      	ldrb	r3, [r5, r0]
 800c338:	2b00      	cmp	r3, #0
 800c33a:	d11a      	bne.n	800c372 <HAL_UART_RxCpltCallback+0x46>
	{
		// Circular buffer is full. Set a global persistant flag via BOS events and a temporary flag via portStatus.
		BOS.overrun = GetPort(huart);
 800c33c:	0020      	movs	r0, r4
 800c33e:	f7fd fb8b 	bl	8009a58 <GetPort>
 800c342:	4b10      	ldr	r3, [pc, #64]	; (800c384 <HAL_UART_RxCpltCallback+0x58>)
 800c344:	7698      	strb	r0, [r3, #26]
		portStatus[GetPort(huart)] = OVERRUN;
 800c346:	0020      	movs	r0, r4
 800c348:	f7fd fb86 	bl	8009a58 <GetPort>
 800c34c:	2305      	movs	r3, #5
 800c34e:	542b      	strb	r3, [r5, r0]
		// Reset the circular RX buffer index
		UARTRxBufIndex[GetPort(huart)-1] = 0;
 800c350:	0020      	movs	r0, r4
 800c352:	f7fd fb81 	bl	8009a58 <GetPort>
 800c356:	4b0c      	ldr	r3, [pc, #48]	; (800c388 <HAL_UART_RxCpltCallback+0x5c>)
 800c358:	1818      	adds	r0, r3, r0
 800c35a:	2300      	movs	r3, #0
 800c35c:	3801      	subs	r0, #1
 800c35e:	7003      	strb	r3, [r0, #0]
		// Set a port-specific flag here and let the backend task restart DMA
		MsgDMAStopped[GetPort(huart)-1] = true;	
 800c360:	0020      	movs	r0, r4
 800c362:	f7fd fb79 	bl	8009a58 <GetPort>
 800c366:	4b09      	ldr	r3, [pc, #36]	; (800c38c <HAL_UART_RxCpltCallback+0x60>)
 800c368:	1818      	adds	r0, r3, r0
 800c36a:	2301      	movs	r3, #1
 800c36c:	3801      	subs	r0, #1
 800c36e:	7003      	strb	r3, [r0, #0]
	}
}
 800c370:	bd70      	pop	{r4, r5, r6, pc}
	if (portStatus[GetPort(huart)] == FREE || portStatus[GetPort(huart)] == MSG)
 800c372:	0020      	movs	r0, r4
 800c374:	f7fd fb70 	bl	8009a58 <GetPort>
 800c378:	5c2b      	ldrb	r3, [r5, r0]
 800c37a:	2b01      	cmp	r3, #1
 800c37c:	d1f8      	bne.n	800c370 <HAL_UART_RxCpltCallback+0x44>
 800c37e:	e7dd      	b.n	800c33c <HAL_UART_RxCpltCallback+0x10>
 800c380:	200010b2 	.word	0x200010b2
 800c384:	20006f70 	.word	0x20006f70
 800c388:	200013b1 	.word	0x200013b1
 800c38c:	2000126c 	.word	0x2000126c

0800c390 <RTC_CalendarConfig>:
/*-----------------------------------------------------------*/

/* --- First time-configuration of the internal real-time clock.
*/
BOS_Status RTC_CalendarConfig(void)
{
 800c390:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c392:	b091      	sub	sp, #68	; 0x44
  RTC_DateTypeDef sdatestructure;
  RTC_TimeTypeDef stimestructure;	
	uint8_t month, day, year, seconds, minutes, hours; 
	char comDate[] = __DATE__, comTime[] = __TIME__;
 800c394:	ac08      	add	r4, sp, #32
 800c396:	220c      	movs	r2, #12
 800c398:	4930      	ldr	r1, [pc, #192]	; (800c45c <RTC_CalendarConfig+0xcc>)
 800c39a:	0020      	movs	r0, r4
 800c39c:	f008 f95a 	bl	8014654 <memcpy>
 800c3a0:	2209      	movs	r2, #9
 800c3a2:	492f      	ldr	r1, [pc, #188]	; (800c460 <RTC_CalendarConfig+0xd0>)
 800c3a4:	a805      	add	r0, sp, #20
 800c3a6:	f008 f955 	bl	8014654 <memcpy>
	
	/* Get compile date */
  year = atoi(comDate + 9);		// only last 2 digits
 800c3aa:	2019      	movs	r0, #25
 800c3ac:	ab04      	add	r3, sp, #16
 800c3ae:	18c0      	adds	r0, r0, r3
 800c3b0:	f007 fed0 	bl	8014154 <atoi>
  *(comDate + 6) = 0;
 800c3b4:	2500      	movs	r5, #0
  year = atoi(comDate + 9);		// only last 2 digits
 800c3b6:	b2c6      	uxtb	r6, r0
  day = atoi(comDate + 4);
 800c3b8:	a809      	add	r0, sp, #36	; 0x24
  *(comDate + 6) = 0;
 800c3ba:	71a5      	strb	r5, [r4, #6]
  day = atoi(comDate + 4);
 800c3bc:	f007 feca 	bl	8014154 <atoi>
  *(comDate + 3) = 0;
  for (uint8_t i = 0; i < 12; i++)
  {
    if (!strcmp(comDate, monthStringAbreviated[i]))	
 800c3c0:	4f28      	ldr	r7, [pc, #160]	; (800c464 <RTC_CalendarConfig+0xd4>)
  day = atoi(comDate + 4);
 800c3c2:	b2c3      	uxtb	r3, r0
 800c3c4:	9303      	str	r3, [sp, #12]
  *(comDate + 3) = 0;
 800c3c6:	70e5      	strb	r5, [r4, #3]
    if (!strcmp(comDate, monthStringAbreviated[i]))	
 800c3c8:	00ab      	lsls	r3, r5, #2
 800c3ca:	58f9      	ldr	r1, [r7, r3]
 800c3cc:	0020      	movs	r0, r4
 800c3ce:	f7f3 fe99 	bl	8000104 <strcmp>
 800c3d2:	3501      	adds	r5, #1
 800c3d4:	b2eb      	uxtb	r3, r5
 800c3d6:	2800      	cmp	r0, #0
 800c3d8:	d100      	bne.n	800c3dc <RTC_CalendarConfig+0x4c>
			month = i + 1;
 800c3da:	9302      	str	r3, [sp, #8]
  for (uint8_t i = 0; i < 12; i++)
 800c3dc:	2d0c      	cmp	r5, #12
 800c3de:	d1f3      	bne.n	800c3c8 <RTC_CalendarConfig+0x38>
  }

	/* Get compile time */
	seconds = atoi(comTime + 6);
 800c3e0:	200a      	movs	r0, #10
 800c3e2:	ab04      	add	r3, sp, #16
 800c3e4:	18c0      	adds	r0, r0, r3
 800c3e6:	f007 feb5 	bl	8014154 <atoi>
	*(comDate + 5) = 0;
 800c3ea:	2500      	movs	r5, #0
	minutes = atoi(comTime + 3);
 800c3ec:	ab04      	add	r3, sp, #16
	seconds = atoi(comTime + 6);
 800c3ee:	9000      	str	r0, [sp, #0]
	minutes = atoi(comTime + 3);
 800c3f0:	1dd8      	adds	r0, r3, #7
	*(comDate + 5) = 0;
 800c3f2:	7165      	strb	r5, [r4, #5]
	minutes = atoi(comTime + 3);
 800c3f4:	f007 feae 	bl	8014154 <atoi>
 800c3f8:	9001      	str	r0, [sp, #4]
	*(comDate + 2) = 0;
	hours = atoi(comTime);
 800c3fa:	a805      	add	r0, sp, #20
	*(comDate + 2) = 0;
 800c3fc:	70a5      	strb	r5, [r4, #2]
	hours = atoi(comTime);
 800c3fe:	f007 fea9 	bl	8014154 <atoi>
	
  /* Set Date */
  sdatestructure.Year = year;
 800c402:	ab04      	add	r3, sp, #16
 800c404:	70de      	strb	r6, [r3, #3]
  sdatestructure.Month = month;
  sdatestructure.Date = day;
  sdatestructure.WeekDay = RTC_WEEKDAY_MONDAY;		// Todo - Calculate weekday later
 800c406:	2601      	movs	r6, #1
  sdatestructure.Month = month;
 800c408:	9a02      	ldr	r2, [sp, #8]
  
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BIN) != HAL_OK)
 800c40a:	4c17      	ldr	r4, [pc, #92]	; (800c468 <RTC_CalendarConfig+0xd8>)
  sdatestructure.Month = month;
 800c40c:	705a      	strb	r2, [r3, #1]
  sdatestructure.Date = day;
 800c40e:	9a03      	ldr	r2, [sp, #12]
	hours = atoi(comTime);
 800c410:	0007      	movs	r7, r0
  sdatestructure.Date = day;
 800c412:	709a      	strb	r2, [r3, #2]
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BIN) != HAL_OK)
 800c414:	0019      	movs	r1, r3
 800c416:	002a      	movs	r2, r5
 800c418:	0020      	movs	r0, r4
  sdatestructure.WeekDay = RTC_WEEKDAY_MONDAY;		// Todo - Calculate weekday later
 800c41a:	701e      	strb	r6, [r3, #0]
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BIN) != HAL_OK)
 800c41c:	f006 fcde 	bl	8012ddc <HAL_RTC_SetDate>
 800c420:	0002      	movs	r2, r0
 800c422:	42a8      	cmp	r0, r5
 800c424:	d002      	beq.n	800c42c <RTC_CalendarConfig+0x9c>
		return BOS_ERROR;
 800c426:	20ff      	movs	r0, #255	; 0xff

  /* Writes a data in a RTC Backup data Register1 */
  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2);
	
	return BOS_OK;
}
 800c428:	b011      	add	sp, #68	; 0x44
 800c42a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  stimestructure.Hours = hours;
 800c42c:	a90b      	add	r1, sp, #44	; 0x2c
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;	BOS.hourformat = 24;
 800c42e:	7208      	strb	r0, [r1, #8]
 800c430:	2018      	movs	r0, #24
  stimestructure.Minutes = minutes;
 800c432:	9b01      	ldr	r3, [sp, #4]
  stimestructure.Hours = hours;
 800c434:	700f      	strb	r7, [r1, #0]
  stimestructure.Minutes = minutes;
 800c436:	704b      	strb	r3, [r1, #1]
  stimestructure.Seconds = seconds;
 800c438:	9b00      	ldr	r3, [sp, #0]
  stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 800c43a:	60ca      	str	r2, [r1, #12]
  stimestructure.Seconds = seconds;
 800c43c:	708b      	strb	r3, [r1, #2]
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;	BOS.hourformat = 24;
 800c43e:	4b0b      	ldr	r3, [pc, #44]	; (800c46c <RTC_CalendarConfig+0xdc>)
  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
 800c440:	610a      	str	r2, [r1, #16]
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;	BOS.hourformat = 24;
 800c442:	7358      	strb	r0, [r3, #13]
  if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, RTC_FORMAT_BIN) != HAL_OK)
 800c444:	0020      	movs	r0, r4
 800c446:	f006 fc51 	bl	8012cec <HAL_RTC_SetTime>
 800c44a:	1e05      	subs	r5, r0, #0
 800c44c:	d1eb      	bne.n	800c426 <RTC_CalendarConfig+0x96>
  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2);
 800c44e:	0020      	movs	r0, r4
 800c450:	4a07      	ldr	r2, [pc, #28]	; (800c470 <RTC_CalendarConfig+0xe0>)
 800c452:	0031      	movs	r1, r6
 800c454:	f006 fd78 	bl	8012f48 <HAL_RTCEx_BKUPWrite>
	return BOS_OK;
 800c458:	0028      	movs	r0, r5
 800c45a:	e7e5      	b.n	800c428 <RTC_CalendarConfig+0x98>
 800c45c:	0801911d 	.word	0x0801911d
 800c460:	0801bf78 	.word	0x0801bf78
 800c464:	20000020 	.word	0x20000020
 800c468:	20007948 	.word	0x20007948
 800c46c:	20006f70 	.word	0x20006f70
 800c470:	000032f2 	.word	0x000032f2

0800c474 <RTC_Init>:
  __HAL_RCC_RTC_ENABLE();
 800c474:	2380      	movs	r3, #128	; 0x80
{
 800c476:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_RTC_ENABLE();
 800c478:	4d19      	ldr	r5, [pc, #100]	; (800c4e0 <RTC_Init+0x6c>)
 800c47a:	021b      	lsls	r3, r3, #8
 800c47c:	6a2a      	ldr	r2, [r5, #32]
	RtcHandle.Instance = RTC; 
 800c47e:	4c19      	ldr	r4, [pc, #100]	; (800c4e4 <RTC_Init+0x70>)
  __HAL_RCC_RTC_ENABLE();
 800c480:	4313      	orrs	r3, r2
 800c482:	622b      	str	r3, [r5, #32]
  RtcHandle.Init.AsynchPrediv = 124;
 800c484:	227c      	movs	r2, #124	; 0x7c
	RtcHandle.Instance = RTC; 
 800c486:	4b18      	ldr	r3, [pc, #96]	; (800c4e8 <RTC_Init+0x74>)
  RtcHandle.Init.AsynchPrediv = 124;
 800c488:	60a2      	str	r2, [r4, #8]
	RtcHandle.Instance = RTC; 
 800c48a:	6023      	str	r3, [r4, #0]
  RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
 800c48c:	2300      	movs	r3, #0
  RtcHandle.Init.SynchPrediv = 1999;
 800c48e:	4a17      	ldr	r2, [pc, #92]	; (800c4ec <RTC_Init+0x78>)
	if (HAL_RTC_Init(&RtcHandle) != HAL_OK)	return BOS_ERROR;
 800c490:	0020      	movs	r0, r4
  RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
 800c492:	6063      	str	r3, [r4, #4]
  RtcHandle.Init.SynchPrediv = 1999;
 800c494:	60e2      	str	r2, [r4, #12]
  RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
 800c496:	6123      	str	r3, [r4, #16]
  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 800c498:	6163      	str	r3, [r4, #20]
  RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 800c49a:	61a3      	str	r3, [r4, #24]
	if (HAL_RTC_Init(&RtcHandle) != HAL_OK)	return BOS_ERROR;
 800c49c:	f006 fbca 	bl	8012c34 <HAL_RTC_Init>
 800c4a0:	0006      	movs	r6, r0
 800c4a2:	20ff      	movs	r0, #255	; 0xff
 800c4a4:	2e00      	cmp	r6, #0
 800c4a6:	d10e      	bne.n	800c4c6 <RTC_Init+0x52>
  if (HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1) != 0x32F2)
 800c4a8:	2101      	movs	r1, #1
 800c4aa:	0020      	movs	r0, r4
 800c4ac:	f006 fd52 	bl	8012f54 <HAL_RTCEx_BKUPRead>
 800c4b0:	4b0f      	ldr	r3, [pc, #60]	; (800c4f0 <RTC_Init+0x7c>)
 800c4b2:	4298      	cmp	r0, r3
 800c4b4:	d008      	beq.n	800c4c8 <RTC_Init+0x54>
    RTC_CalendarConfig();
 800c4b6:	f7ff ff6b 	bl	800c390 <RTC_CalendarConfig>
  __HAL_RCC_CLEAR_RESET_FLAGS();	
 800c4ba:	2380      	movs	r3, #128	; 0x80
	return BOS_OK;
 800c4bc:	2000      	movs	r0, #0
  __HAL_RCC_CLEAR_RESET_FLAGS();	
 800c4be:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800c4c0:	045b      	lsls	r3, r3, #17
 800c4c2:	4313      	orrs	r3, r2
 800c4c4:	626b      	str	r3, [r5, #36]	; 0x24
}
 800c4c6:	bd70      	pop	{r4, r5, r6, pc}
    if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET)
 800c4c8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800c4ca:	011b      	lsls	r3, r3, #4
 800c4cc:	d501      	bpl.n	800c4d2 <RTC_Init+0x5e>
			bootStatus = POWER_ON_BOOT;
 800c4ce:	4b09      	ldr	r3, [pc, #36]	; (800c4f4 <RTC_Init+0x80>)
 800c4d0:	701e      	strb	r6, [r3, #0]
    if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
 800c4d2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800c4d4:	015b      	lsls	r3, r3, #5
 800c4d6:	d5f0      	bpl.n	800c4ba <RTC_Init+0x46>
			bootStatus = RESET_BOOT;
 800c4d8:	2201      	movs	r2, #1
 800c4da:	4b06      	ldr	r3, [pc, #24]	; (800c4f4 <RTC_Init+0x80>)
 800c4dc:	701a      	strb	r2, [r3, #0]
 800c4de:	e7ec      	b.n	800c4ba <RTC_Init+0x46>
 800c4e0:	40021000 	.word	0x40021000
 800c4e4:	20007948 	.word	0x20007948
 800c4e8:	40002800 	.word	0x40002800
 800c4ec:	000007cf 	.word	0x000007cf
 800c4f0:	000032f2 	.word	0x000032f2
 800c4f4:	20001c88 	.word	0x20001c88

0800c4f8 <BOS_CalendarConfig>:

/* --- BOS internal real-time clock and calendar configuration.
*/
BOS_Status BOS_CalendarConfig(uint8_t month, uint8_t day, uint16_t year, uint8_t weekday, uint8_t seconds, \
															uint8_t minutes, uint8_t hours, uint8_t AMPM, int8_t daylightsaving)
{
 800c4f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c4fa:	b089      	sub	sp, #36	; 0x24
 800c4fc:	ac0e      	add	r4, sp, #56	; 0x38
 800c4fe:	7824      	ldrb	r4, [r4, #0]
  RTC_DateTypeDef sdatestructure;
  RTC_TimeTypeDef stimestructure;	
	
  /* Set Date */
  sdatestructure.Year = year-2000;
 800c500:	3230      	adds	r2, #48	; 0x30
{
 800c502:	9401      	str	r4, [sp, #4]
 800c504:	ac0f      	add	r4, sp, #60	; 0x3c
 800c506:	7827      	ldrb	r7, [r4, #0]
 800c508:	ac10      	add	r4, sp, #64	; 0x40
 800c50a:	7826      	ldrb	r6, [r4, #0]
 800c50c:	ac11      	add	r4, sp, #68	; 0x44
 800c50e:	7825      	ldrb	r5, [r4, #0]
  sdatestructure.Year = year-2000;
 800c510:	ac02      	add	r4, sp, #8
 800c512:	70e2      	strb	r2, [r4, #3]
  sdatestructure.Month = month;
 800c514:	7060      	strb	r0, [r4, #1]
  sdatestructure.Date = day;
 800c516:	70a1      	strb	r1, [r4, #2]
  sdatestructure.WeekDay = weekday;		// Todo - Calculate weekday later
 800c518:	7023      	strb	r3, [r4, #0]
  
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BIN) != HAL_OK)
 800c51a:	4c1a      	ldr	r4, [pc, #104]	; (800c584 <BOS_CalendarConfig+0x8c>)
 800c51c:	2200      	movs	r2, #0
 800c51e:	a902      	add	r1, sp, #8
 800c520:	0020      	movs	r0, r4
 800c522:	f006 fc5b 	bl	8012ddc <HAL_RTC_SetDate>
 800c526:	2800      	cmp	r0, #0
 800c528:	d002      	beq.n	800c530 <BOS_CalendarConfig+0x38>
		return BOS_ERROR;
 800c52a:	20ff      	movs	r0, #255	; 0xff

  /* Writes a data in a RTC Backup data Register1 */
  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2);
	
	return BOS_OK;
}
 800c52c:	b009      	add	sp, #36	; 0x24
 800c52e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  stimestructure.Seconds = seconds; 
 800c530:	9b01      	ldr	r3, [sp, #4]
  stimestructure.Hours = hours;
 800c532:	a903      	add	r1, sp, #12
  stimestructure.Minutes = minutes;
 800c534:	704f      	strb	r7, [r1, #1]
  stimestructure.Hours = hours;
 800c536:	700e      	strb	r6, [r1, #0]
  stimestructure.Seconds = seconds; 
 800c538:	708b      	strb	r3, [r1, #2]
	stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;		// Todo - Use this to make sure user does not change daylight settings again
 800c53a:	6108      	str	r0, [r1, #16]
 800c53c:	4f12      	ldr	r7, [pc, #72]	; (800c588 <BOS_CalendarConfig+0x90>)
	if (AMPM == RTC_AM) {
 800c53e:	2d01      	cmp	r5, #1
 800c540:	d118      	bne.n	800c574 <BOS_CalendarConfig+0x7c>
		stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
 800c542:	2300      	movs	r3, #0
 800c544:	720b      	strb	r3, [r1, #8]
		BOS.hourformat = 12;
 800c546:	330c      	adds	r3, #12
  if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, RTC_FORMAT_BIN) != HAL_OK)
 800c548:	2200      	movs	r2, #0
 800c54a:	0020      	movs	r0, r4
		BOS.hourformat = 24;
 800c54c:	737b      	strb	r3, [r7, #13]
  if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, RTC_FORMAT_BIN) != HAL_OK)
 800c54e:	f006 fbcd 	bl	8012cec <HAL_RTC_SetTime>
 800c552:	1e05      	subs	r5, r0, #0
 800c554:	d1e9      	bne.n	800c52a <BOS_CalendarConfig+0x32>
	EE_WriteVariable(_EE_PARAMS_RTC, ((uint16_t)BOS.hourformat<<8) | (uint16_t)BOS.buttons.minInterClickTime);
 800c556:	208d      	movs	r0, #141	; 0x8d
 800c558:	7b7b      	ldrb	r3, [r7, #13]
 800c55a:	7939      	ldrb	r1, [r7, #4]
 800c55c:	021b      	lsls	r3, r3, #8
 800c55e:	4319      	orrs	r1, r3
 800c560:	0040      	lsls	r0, r0, #1
 800c562:	f7fa fa4b 	bl	80069fc <EE_WriteVariable>
  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2);
 800c566:	0020      	movs	r0, r4
 800c568:	4a08      	ldr	r2, [pc, #32]	; (800c58c <BOS_CalendarConfig+0x94>)
 800c56a:	2101      	movs	r1, #1
 800c56c:	f006 fcec 	bl	8012f48 <HAL_RTCEx_BKUPWrite>
	return BOS_OK;
 800c570:	0028      	movs	r0, r5
 800c572:	e7db      	b.n	800c52c <BOS_CalendarConfig+0x34>
		BOS.hourformat = 24;
 800c574:	2318      	movs	r3, #24
	} else if (AMPM == RTC_PM) {
 800c576:	2d02      	cmp	r5, #2
 800c578:	d1e6      	bne.n	800c548 <BOS_CalendarConfig+0x50>
		stimestructure.TimeFormat = RTC_HOURFORMAT12_PM;
 800c57a:	2340      	movs	r3, #64	; 0x40
 800c57c:	720b      	strb	r3, [r1, #8]
		BOS.hourformat = 12;
 800c57e:	3b34      	subs	r3, #52	; 0x34
 800c580:	e7e2      	b.n	800c548 <BOS_CalendarConfig+0x50>
 800c582:	46c0      	nop			; (mov r8, r8)
 800c584:	20007948 	.word	0x20007948
 800c588:	20006f70 	.word	0x20006f70
 800c58c:	000032f2 	.word	0x000032f2

0800c590 <GetTimeDate>:
/*-----------------------------------------------------------*/

/* --- Get current RTC time and date.
*/
void GetTimeDate(void)
{
 800c590:	b530      	push	{r4, r5, lr}
	RTC_DateTypeDef sdatestructureget;
  RTC_TimeTypeDef stimestructureget;
	
  HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN);
 800c592:	4d16      	ldr	r5, [pc, #88]	; (800c5ec <GetTimeDate+0x5c>)
{
 800c594:	b087      	sub	sp, #28
  HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN);
 800c596:	ac01      	add	r4, sp, #4
 800c598:	0021      	movs	r1, r4
 800c59a:	2200      	movs	r2, #0
 800c59c:	0028      	movs	r0, r5
 800c59e:	f006 fc8b 	bl	8012eb8 <HAL_RTC_GetTime>
  HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN);
 800c5a2:	4669      	mov	r1, sp
 800c5a4:	2200      	movs	r2, #0
 800c5a6:	0028      	movs	r0, r5
 800c5a8:	f006 fcac 	bl	8012f04 <HAL_RTC_GetDate>
	
	BOS.time.ampm = (stimestructureget.TimeFormat >> 7) + 1;
 800c5ac:	7a22      	ldrb	r2, [r4, #8]
 800c5ae:	4b10      	ldr	r3, [pc, #64]	; (800c5f0 <GetTimeDate+0x60>)
 800c5b0:	09d2      	lsrs	r2, r2, #7
 800c5b2:	3201      	adds	r2, #1
 800c5b4:	74da      	strb	r2, [r3, #19]
	BOS.time.msec = stimestructureget.SubSeconds / 2;
 800c5b6:	6862      	ldr	r2, [r4, #4]
	BOS.time.minutes = stimestructureget.Minutes;
	BOS.time.hours = stimestructureget.Hours;
	BOS.date.day = sdatestructureget.Date;
	BOS.date.month = sdatestructureget.Month;
	BOS.date.weekday = sdatestructureget.WeekDay;
	BOS.date.year = sdatestructureget.Year + 2000;
 800c5b8:	21fa      	movs	r1, #250	; 0xfa
	BOS.time.msec = stimestructureget.SubSeconds / 2;
 800c5ba:	0852      	lsrs	r2, r2, #1
 800c5bc:	81da      	strh	r2, [r3, #14]
	BOS.time.seconds = stimestructureget.Seconds;
 800c5be:	78a2      	ldrb	r2, [r4, #2]
	BOS.date.year = sdatestructureget.Year + 2000;
 800c5c0:	00c9      	lsls	r1, r1, #3
	BOS.time.seconds = stimestructureget.Seconds;
 800c5c2:	741a      	strb	r2, [r3, #16]
	BOS.time.minutes = stimestructureget.Minutes;
 800c5c4:	7862      	ldrb	r2, [r4, #1]
 800c5c6:	745a      	strb	r2, [r3, #17]
	BOS.time.hours = stimestructureget.Hours;
 800c5c8:	7822      	ldrb	r2, [r4, #0]
 800c5ca:	749a      	strb	r2, [r3, #18]
	BOS.date.day = sdatestructureget.Date;
 800c5cc:	466a      	mov	r2, sp
 800c5ce:	7892      	ldrb	r2, [r2, #2]
 800c5d0:	755a      	strb	r2, [r3, #21]
	BOS.date.month = sdatestructureget.Month;
 800c5d2:	466a      	mov	r2, sp
 800c5d4:	7852      	ldrb	r2, [r2, #1]
 800c5d6:	759a      	strb	r2, [r3, #22]
	BOS.date.weekday = sdatestructureget.WeekDay;
 800c5d8:	466a      	mov	r2, sp
 800c5da:	7812      	ldrb	r2, [r2, #0]
 800c5dc:	751a      	strb	r2, [r3, #20]
	BOS.date.year = sdatestructureget.Year + 2000;
 800c5de:	466a      	mov	r2, sp
 800c5e0:	78d2      	ldrb	r2, [r2, #3]
 800c5e2:	1852      	adds	r2, r2, r1
 800c5e4:	831a      	strh	r2, [r3, #24]
}
 800c5e6:	b007      	add	sp, #28
 800c5e8:	bd30      	pop	{r4, r5, pc}
 800c5ea:	46c0      	nop			; (mov r8, r8)
 800c5ec:	20007948 	.word	0x20007948
 800c5f0:	20006f70 	.word	0x20006f70

0800c5f4 <SD_IO_CSState.part.0>:
/* Control sd chip select pin */
void SD_IO_CSState(uint8_t val)
{
  if(val == 1) 
  {
    SD_CS_HIGH();
 800c5f4:	2090      	movs	r0, #144	; 0x90
void SD_IO_CSState(uint8_t val)
 800c5f6:	b510      	push	{r4, lr}
    SD_CS_HIGH();
 800c5f8:	2201      	movs	r2, #1
 800c5fa:	2110      	movs	r1, #16
 800c5fc:	05c0      	lsls	r0, r0, #23
 800c5fe:	f005 fe8f 	bl	8012320 <HAL_GPIO_WritePin>
  }
  else
  {
    SD_CS_LOW();
  }
}
 800c602:	bd10      	pop	{r4, pc}

0800c604 <BSP_SD_IsDetected>:
{
 800c604:	b513      	push	{r0, r1, r4, lr}
  __IO uint8_t status = SD_PRESENT;
 800c606:	466b      	mov	r3, sp
 800c608:	2101      	movs	r1, #1
 800c60a:	1ddc      	adds	r4, r3, #7
  if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 800c60c:	4805      	ldr	r0, [pc, #20]	; (800c624 <BSP_SD_IsDetected+0x20>)
  __IO uint8_t status = SD_PRESENT;
 800c60e:	7021      	strb	r1, [r4, #0]
  if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 800c610:	f005 fe80 	bl	8012314 <HAL_GPIO_ReadPin>
 800c614:	2800      	cmp	r0, #0
 800c616:	d001      	beq.n	800c61c <BSP_SD_IsDetected+0x18>
    status = SD_NOT_PRESENT;
 800c618:	2300      	movs	r3, #0
 800c61a:	7023      	strb	r3, [r4, #0]
  return status;
 800c61c:	7820      	ldrb	r0, [r4, #0]
 800c61e:	b2c0      	uxtb	r0, r0
}
 800c620:	bd16      	pop	{r1, r2, r4, pc}
 800c622:	46c0      	nop			; (mov r8, r8)
 800c624:	48000400 	.word	0x48000400

0800c628 <SD_IO_CSState>:
{
 800c628:	b510      	push	{r4, lr}
  if(val == 1) 
 800c62a:	2801      	cmp	r0, #1
 800c62c:	d102      	bne.n	800c634 <SD_IO_CSState+0xc>
 800c62e:	f7ff ffe1 	bl	800c5f4 <SD_IO_CSState.part.0>
}
 800c632:	bd10      	pop	{r4, pc}
    SD_CS_LOW();
 800c634:	2090      	movs	r0, #144	; 0x90
 800c636:	2200      	movs	r2, #0
 800c638:	2110      	movs	r1, #16
 800c63a:	05c0      	lsls	r0, r0, #23
 800c63c:	f005 fe70 	bl	8012320 <HAL_GPIO_WritePin>
}
 800c640:	e7f7      	b.n	800c632 <SD_IO_CSState+0xa>

0800c642 <SD_IO_WriteByte>:
  * @brief  Writes a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_IO_WriteByte(uint8_t Data)
{
 800c642:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint8_t tmp;

  /* Send the byte */
  SPIx_WriteReadData(&Data,&tmp,1);
 800c644:	240f      	movs	r4, #15
{
 800c646:	466b      	mov	r3, sp
  SPIx_WriteReadData(&Data,&tmp,1);
 800c648:	446c      	add	r4, sp
{
 800c64a:	71d8      	strb	r0, [r3, #7]
 800c64c:	3307      	adds	r3, #7
  SPIx_WriteReadData(&Data,&tmp,1);
 800c64e:	0018      	movs	r0, r3
 800c650:	2201      	movs	r2, #1
 800c652:	0021      	movs	r1, r4
 800c654:	f000 fce2 	bl	800d01c <SPIx_WriteReadData>
  return tmp;
 800c658:	7820      	ldrb	r0, [r4, #0]
}
 800c65a:	b004      	add	sp, #16
 800c65c:	bd10      	pop	{r4, pc}

0800c65e <SD_ReadData>:
{
 800c65e:	b510      	push	{r4, lr}
 800c660:	2408      	movs	r4, #8
    readvalue = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c662:	20ff      	movs	r0, #255	; 0xff
 800c664:	f7ff ffed 	bl	800c642 <SD_IO_WriteByte>
  }while ((readvalue == SD_DUMMY_BYTE) && timeout);
 800c668:	28ff      	cmp	r0, #255	; 0xff
 800c66a:	d103      	bne.n	800c674 <SD_ReadData+0x16>
 800c66c:	3c01      	subs	r4, #1
 800c66e:	b2e4      	uxtb	r4, r4
 800c670:	2c00      	cmp	r4, #0
 800c672:	d1f6      	bne.n	800c662 <SD_ReadData+0x4>
}
 800c674:	bd10      	pop	{r4, pc}

0800c676 <SD_SendCmd>:
{
 800c676:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c678:	b087      	sub	sp, #28
 800c67a:	0004      	movs	r4, r0
 800c67c:	a80c      	add	r0, sp, #48	; 0x30
 800c67e:	7805      	ldrb	r5, [r0, #0]
  frame[0] = (Cmd | 0x40);         /* Construct byte 1 */
 800c680:	2040      	movs	r0, #64	; 0x40
 800c682:	4301      	orrs	r1, r0
 800c684:	a802      	add	r0, sp, #8
 800c686:	7001      	strb	r1, [r0, #0]
  frame[1] = (uint8_t)(Arg >> 24); /* Construct byte 2 */
 800c688:	0e11      	lsrs	r1, r2, #24
 800c68a:	7041      	strb	r1, [r0, #1]
  frame[2] = (uint8_t)(Arg >> 16); /* Construct byte 3 */
 800c68c:	0c11      	lsrs	r1, r2, #16
 800c68e:	7081      	strb	r1, [r0, #2]
  frame[4] = (uint8_t)(Arg);       /* Construct byte 5 */
 800c690:	7102      	strb	r2, [r0, #4]
  frame[3] = (uint8_t)(Arg >> 8);  /* Construct byte 4 */
 800c692:	0a11      	lsrs	r1, r2, #8
  frame[5] = (Crc | 0x01);         /* Construct byte 6 */
 800c694:	2201      	movs	r2, #1
 800c696:	4313      	orrs	r3, r2
  frame[3] = (uint8_t)(Arg >> 8);  /* Construct byte 4 */
 800c698:	70c1      	strb	r1, [r0, #3]
  frame[5] = (Crc | 0x01);         /* Construct byte 6 */
 800c69a:	7143      	strb	r3, [r0, #5]
  SD_IO_CSState(0);
 800c69c:	2000      	movs	r0, #0
 800c69e:	f7ff ffc3 	bl	800c628 <SD_IO_CSState>
  SPIx_WriteReadData(DataIn, DataOut, DataLength);
 800c6a2:	2206      	movs	r2, #6
 800c6a4:	a904      	add	r1, sp, #16
 800c6a6:	a802      	add	r0, sp, #8
 800c6a8:	f000 fcb8 	bl	800d01c <SPIx_WriteReadData>
  switch(Answer)
 800c6ac:	2d05      	cmp	r5, #5
 800c6ae:	d848      	bhi.n	800c742 <SD_SendCmd+0xcc>
 800c6b0:	0028      	movs	r0, r5
 800c6b2:	f7f3 fd43 	bl	800013c <__gnu_thumb1_case_uqi>
 800c6b6:	1303      	.short	0x1303
 800c6b8:	3346332a 	.word	0x3346332a
    retr.r1 = SD_ReadData();
 800c6bc:	f7ff ffcf 	bl	800c65e <SD_ReadData>
 800c6c0:	0007      	movs	r7, r0
  SD_CmdAnswer_typedef retr = {0xFF, 0xFF , 0xFF, 0xFF, 0xFF};
 800c6c2:	20ff      	movs	r0, #255	; 0xff
 800c6c4:	0005      	movs	r5, r0
 800c6c6:	0006      	movs	r6, r0
 800c6c8:	9001      	str	r0, [sp, #4]
  return retr;
 800c6ca:	7120      	strb	r0, [r4, #4]
}
 800c6cc:	0020      	movs	r0, r4
  return retr;
 800c6ce:	9b01      	ldr	r3, [sp, #4]
 800c6d0:	7027      	strb	r7, [r4, #0]
 800c6d2:	7066      	strb	r6, [r4, #1]
 800c6d4:	70a5      	strb	r5, [r4, #2]
 800c6d6:	70e3      	strb	r3, [r4, #3]
}
 800c6d8:	b007      	add	sp, #28
 800c6da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    retr.r1 = SD_ReadData();
 800c6dc:	f7ff ffbf 	bl	800c65e <SD_ReadData>
 800c6e0:	0007      	movs	r7, r0
    retr.r2 = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c6e2:	20ff      	movs	r0, #255	; 0xff
 800c6e4:	f7ff ffad 	bl	800c642 <SD_IO_WriteByte>
 800c6e8:	0006      	movs	r6, r0
 800c6ea:	f7ff ff83 	bl	800c5f4 <SD_IO_CSState.part.0>
    HAL_Delay(1);
 800c6ee:	2001      	movs	r0, #1
 800c6f0:	f004 ff0c 	bl	801150c <HAL_Delay>
    SD_IO_CSState(0);
 800c6f4:	2000      	movs	r0, #0
 800c6f6:	f7ff ff97 	bl	800c628 <SD_IO_CSState>
    while (SD_IO_WriteByte(SD_DUMMY_BYTE) != 0xFF); 
 800c6fa:	20ff      	movs	r0, #255	; 0xff
 800c6fc:	f7ff ffa1 	bl	800c642 <SD_IO_WriteByte>
 800c700:	28ff      	cmp	r0, #255	; 0xff
 800c702:	d1fa      	bne.n	800c6fa <SD_SendCmd+0x84>
  SD_CmdAnswer_typedef retr = {0xFF, 0xFF , 0xFF, 0xFF, 0xFF};
 800c704:	9001      	str	r0, [sp, #4]
 800c706:	0005      	movs	r5, r0
    break;
 800c708:	e7df      	b.n	800c6ca <SD_SendCmd+0x54>
    retr.r1 = SD_ReadData();
 800c70a:	f7ff ffa8 	bl	800c65e <SD_ReadData>
 800c70e:	0007      	movs	r7, r0
    retr.r2 = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c710:	20ff      	movs	r0, #255	; 0xff
 800c712:	f7ff ff96 	bl	800c642 <SD_IO_WriteByte>
 800c716:	0006      	movs	r6, r0
  SD_CmdAnswer_typedef retr = {0xFF, 0xFF , 0xFF, 0xFF, 0xFF};
 800c718:	20ff      	movs	r0, #255	; 0xff
 800c71a:	e7f3      	b.n	800c704 <SD_SendCmd+0x8e>
    retr.r1 = SD_ReadData();
 800c71c:	f7ff ff9f 	bl	800c65e <SD_ReadData>
 800c720:	0007      	movs	r7, r0
    retr.r2 = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c722:	20ff      	movs	r0, #255	; 0xff
 800c724:	f7ff ff8d 	bl	800c642 <SD_IO_WriteByte>
 800c728:	0006      	movs	r6, r0
    retr.r3 = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c72a:	20ff      	movs	r0, #255	; 0xff
 800c72c:	f7ff ff89 	bl	800c642 <SD_IO_WriteByte>
 800c730:	0005      	movs	r5, r0
    retr.r4 = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c732:	20ff      	movs	r0, #255	; 0xff
 800c734:	f7ff ff85 	bl	800c642 <SD_IO_WriteByte>
 800c738:	9001      	str	r0, [sp, #4]
    retr.r5 = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c73a:	20ff      	movs	r0, #255	; 0xff
 800c73c:	f7ff ff81 	bl	800c642 <SD_IO_WriteByte>
    break;
 800c740:	e7c3      	b.n	800c6ca <SD_SendCmd+0x54>
  SD_CmdAnswer_typedef retr = {0xFF, 0xFF , 0xFF, 0xFF, 0xFF};
 800c742:	20ff      	movs	r0, #255	; 0xff
 800c744:	9001      	str	r0, [sp, #4]
 800c746:	0005      	movs	r5, r0
 800c748:	0006      	movs	r6, r0
 800c74a:	0007      	movs	r7, r0
 800c74c:	e7bd      	b.n	800c6ca <SD_SendCmd+0x54>
	...

0800c750 <BSP_SD_WriteBlocks>:
{
 800c750:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c752:	b08b      	sub	sp, #44	; 0x2c
 800c754:	9304      	str	r3, [sp, #16]
  response = SD_SendCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c756:	2300      	movs	r3, #0
 800c758:	ac08      	add	r4, sp, #32
{
 800c75a:	9005      	str	r0, [sp, #20]
 800c75c:	9107      	str	r1, [sp, #28]
  response = SD_SendCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c75e:	0020      	movs	r0, r4
 800c760:	9300      	str	r3, [sp, #0]
 800c762:	2110      	movs	r1, #16
 800c764:	33ff      	adds	r3, #255	; 0xff
{
 800c766:	0015      	movs	r5, r2
  response = SD_SendCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c768:	f7ff ff85 	bl	800c676 <SD_SendCmd>
 800c76c:	7824      	ldrb	r4, [r4, #0]
 800c76e:	f7ff ff41 	bl	800c5f4 <SD_IO_CSState.part.0>
  SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c772:	20ff      	movs	r0, #255	; 0xff
 800c774:	f7ff ff65 	bl	800c642 <SD_IO_WriteByte>
  if ( response.r1 != SD_R1_NO_ERROR)
 800c778:	2c00      	cmp	r4, #0
 800c77a:	d106      	bne.n	800c78a <BSP_SD_WriteBlocks+0x3a>
  ptr = malloc(sizeof(uint8_t)*BlockSize);
 800c77c:	0028      	movs	r0, r5
 800c77e:	f007 fd2b 	bl	80141d8 <malloc>
  if (ptr == NULL)
 800c782:	9f05      	ldr	r7, [sp, #20]
  ptr = malloc(sizeof(uint8_t)*BlockSize);
 800c784:	9003      	str	r0, [sp, #12]
  if (ptr == NULL)
 800c786:	2800      	cmp	r0, #0
 800c788:	d154      	bne.n	800c834 <BSP_SD_WriteBlocks+0xe4>
  uint8_t retr = BSP_SD_ERROR;
 800c78a:	2401      	movs	r4, #1
 800c78c:	f7ff ff32 	bl	800c5f4 <SD_IO_CSState.part.0>
  SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c790:	20ff      	movs	r0, #255	; 0xff
 800c792:	f7ff ff56 	bl	800c642 <SD_IO_WriteByte>
}
 800c796:	0020      	movs	r0, r4
 800c798:	b00b      	add	sp, #44	; 0x2c
 800c79a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    response = SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + offset)/(flag_SDHC == 1 ? BlockSize: 1), 0xFF, SD_ANSWER_R1_EXPECTED);
 800c79c:	2101      	movs	r1, #1
 800c79e:	9b07      	ldr	r3, [sp, #28]
 800c7a0:	9a05      	ldr	r2, [sp, #20]
 800c7a2:	1a98      	subs	r0, r3, r2
 800c7a4:	4b28      	ldr	r3, [pc, #160]	; (800c848 <BSP_SD_WriteBlocks+0xf8>)
 800c7a6:	19c0      	adds	r0, r0, r7
 800c7a8:	881b      	ldrh	r3, [r3, #0]
 800c7aa:	428b      	cmp	r3, r1
 800c7ac:	d100      	bne.n	800c7b0 <BSP_SD_WriteBlocks+0x60>
 800c7ae:	0029      	movs	r1, r5
 800c7b0:	f7f3 fce2 	bl	8000178 <__udivsi3>
 800c7b4:	2300      	movs	r3, #0
 800c7b6:	ae08      	add	r6, sp, #32
 800c7b8:	0002      	movs	r2, r0
 800c7ba:	9300      	str	r3, [sp, #0]
 800c7bc:	2118      	movs	r1, #24
 800c7be:	33ff      	adds	r3, #255	; 0xff
 800c7c0:	0030      	movs	r0, r6
 800c7c2:	f7ff ff58 	bl	800c676 <SD_SendCmd>
    if (response.r1 != SD_R1_NO_ERROR)
 800c7c6:	7833      	ldrb	r3, [r6, #0]
 800c7c8:	9306      	str	r3, [sp, #24]
 800c7ca:	2b00      	cmp	r3, #0
 800c7cc:	d139      	bne.n	800c842 <BSP_SD_WriteBlocks+0xf2>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c7ce:	20ff      	movs	r0, #255	; 0xff
 800c7d0:	f7ff ff37 	bl	800c642 <SD_IO_WriteByte>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c7d4:	20ff      	movs	r0, #255	; 0xff
 800c7d6:	f7ff ff34 	bl	800c642 <SD_IO_WriteByte>
    SD_IO_WriteByte(SD_TOKEN_START_DATA_SINGLE_BLOCK_WRITE);
 800c7da:	20fe      	movs	r0, #254	; 0xfe
 800c7dc:	f7ff ff31 	bl	800c642 <SD_IO_WriteByte>
  SPIx_WriteReadData(DataIn, DataOut, DataLength);
 800c7e0:	002a      	movs	r2, r5
 800c7e2:	9903      	ldr	r1, [sp, #12]
 800c7e4:	0038      	movs	r0, r7
 800c7e6:	f000 fc19 	bl	800d01c <SPIx_WriteReadData>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c7ea:	20ff      	movs	r0, #255	; 0xff
 800c7ec:	f7ff ff29 	bl	800c642 <SD_IO_WriteByte>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c7f0:	20ff      	movs	r0, #255	; 0xff
 800c7f2:	f7ff ff26 	bl	800c642 <SD_IO_WriteByte>
  dataresponse = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c7f6:	20ff      	movs	r0, #255	; 0xff
 800c7f8:	f7ff ff23 	bl	800c642 <SD_IO_WriteByte>
 800c7fc:	0006      	movs	r6, r0
  SD_IO_WriteByte(SD_DUMMY_BYTE); /* read the busy response byte*/
 800c7fe:	20ff      	movs	r0, #255	; 0xff
 800c800:	f7ff ff1f 	bl	800c642 <SD_IO_WriteByte>
  switch (dataresponse & 0x1F)
 800c804:	231f      	movs	r3, #31
 800c806:	401e      	ands	r6, r3
 800c808:	2e05      	cmp	r6, #5
 800c80a:	d11a      	bne.n	800c842 <BSP_SD_WriteBlocks+0xf2>
 800c80c:	f7ff fef2 	bl	800c5f4 <SD_IO_CSState.part.0>
    SD_IO_CSState(0);
 800c810:	9806      	ldr	r0, [sp, #24]
 800c812:	f7ff ff09 	bl	800c628 <SD_IO_CSState>
    while (SD_IO_WriteByte(SD_DUMMY_BYTE) != 0xFF);
 800c816:	20ff      	movs	r0, #255	; 0xff
 800c818:	f7ff ff13 	bl	800c642 <SD_IO_WriteByte>
 800c81c:	0006      	movs	r6, r0
 800c81e:	28ff      	cmp	r0, #255	; 0xff
 800c820:	d1f9      	bne.n	800c816 <BSP_SD_WriteBlocks+0xc6>
 800c822:	f7ff fee7 	bl	800c5f4 <SD_IO_CSState.part.0>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c826:	0030      	movs	r0, r6
 800c828:	f7ff ff0b 	bl	800c642 <SD_IO_WriteByte>
 800c82c:	9b04      	ldr	r3, [sp, #16]
 800c82e:	197f      	adds	r7, r7, r5
 800c830:	3b01      	subs	r3, #1
 800c832:	9304      	str	r3, [sp, #16]
  while (NumberOfBlocks--)
 800c834:	9b04      	ldr	r3, [sp, #16]
 800c836:	2b00      	cmp	r3, #0
 800c838:	d1b0      	bne.n	800c79c <BSP_SD_WriteBlocks+0x4c>
  if(ptr != NULL) free(ptr);
 800c83a:	9803      	ldr	r0, [sp, #12]
 800c83c:	f007 fcd6 	bl	80141ec <free>
 800c840:	e7a4      	b.n	800c78c <BSP_SD_WriteBlocks+0x3c>
  uint8_t retr = BSP_SD_ERROR;
 800c842:	2401      	movs	r4, #1
 800c844:	e7f9      	b.n	800c83a <BSP_SD_WriteBlocks+0xea>
 800c846:	46c0      	nop			; (mov r8, r8)
 800c848:	2000009a 	.word	0x2000009a

0800c84c <BSP_SD_GetStatus>:
{
 800c84c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  retr = SD_SendCmd(SD_CMD_SEND_STATUS, 0, 0xFF, SD_ANSWER_R2_EXPECTED);
 800c84e:	2302      	movs	r3, #2
 800c850:	ac02      	add	r4, sp, #8
 800c852:	2200      	movs	r2, #0
 800c854:	210d      	movs	r1, #13
 800c856:	0020      	movs	r0, r4
 800c858:	9300      	str	r3, [sp, #0]
 800c85a:	33fd      	adds	r3, #253	; 0xfd
 800c85c:	f7ff ff0b 	bl	800c676 <SD_SendCmd>
 800c860:	f7ff fec8 	bl	800c5f4 <SD_IO_CSState.part.0>
  SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c864:	20ff      	movs	r0, #255	; 0xff
 800c866:	f7ff feec 	bl	800c642 <SD_IO_WriteByte>
  if(( retr.r1 == SD_R1_NO_ERROR) && ( retr.r2 == SD_R2_NO_ERROR))
 800c86a:	7823      	ldrb	r3, [r4, #0]
  return BSP_SD_ERROR;
 800c86c:	2001      	movs	r0, #1
  if(( retr.r1 == SD_R1_NO_ERROR) && ( retr.r2 == SD_R2_NO_ERROR))
 800c86e:	2b00      	cmp	r3, #0
 800c870:	d103      	bne.n	800c87a <BSP_SD_GetStatus+0x2e>
 800c872:	7860      	ldrb	r0, [r4, #1]
 800c874:	1e43      	subs	r3, r0, #1
 800c876:	4198      	sbcs	r0, r3
    return BSP_SD_OK;
 800c878:	b2c0      	uxtb	r0, r0
}
 800c87a:	b004      	add	sp, #16
 800c87c:	bd10      	pop	{r4, pc}
	...

0800c880 <SD_IO_Init>:
  SD_CS_GPIO_CLK_ENABLE();
 800c880:	2080      	movs	r0, #128	; 0x80
{
 800c882:	b530      	push	{r4, r5, lr}
  SD_CS_GPIO_CLK_ENABLE();
 800c884:	4b20      	ldr	r3, [pc, #128]	; (800c908 <SD_IO_Init+0x88>)
 800c886:	0280      	lsls	r0, r0, #10
 800c888:	6959      	ldr	r1, [r3, #20]
{
 800c88a:	b089      	sub	sp, #36	; 0x24
  SD_CS_GPIO_CLK_ENABLE();
 800c88c:	4301      	orrs	r1, r0
 800c88e:	6159      	str	r1, [r3, #20]
  SD_DETECT_GPIO_CLK_ENABLE();
 800c890:	2180      	movs	r1, #128	; 0x80
  SD_CS_GPIO_CLK_ENABLE();
 800c892:	695a      	ldr	r2, [r3, #20]
  SD_DETECT_GPIO_CLK_ENABLE();
 800c894:	02c9      	lsls	r1, r1, #11
  SD_CS_GPIO_CLK_ENABLE();
 800c896:	4002      	ands	r2, r0
 800c898:	9201      	str	r2, [sp, #4]
 800c89a:	9a01      	ldr	r2, [sp, #4]
  SD_DETECT_GPIO_CLK_ENABLE();
 800c89c:	695a      	ldr	r2, [r3, #20]
  HAL_GPIO_Init(SD_CS_GPIO_PORT, &GPIO_InitStruct);
 800c89e:	2090      	movs	r0, #144	; 0x90
  SD_DETECT_GPIO_CLK_ENABLE();
 800c8a0:	430a      	orrs	r2, r1
 800c8a2:	615a      	str	r2, [r3, #20]
 800c8a4:	695b      	ldr	r3, [r3, #20]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800c8a6:	2401      	movs	r4, #1
  SD_DETECT_GPIO_CLK_ENABLE();
 800c8a8:	400b      	ands	r3, r1
 800c8aa:	9302      	str	r3, [sp, #8]
 800c8ac:	9b02      	ldr	r3, [sp, #8]
  GPIO_InitStruct.Pin = SD_CS_PIN;
 800c8ae:	2510      	movs	r5, #16
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 800c8b0:	2311      	movs	r3, #17
  HAL_GPIO_Init(SD_CS_GPIO_PORT, &GPIO_InitStruct);
 800c8b2:	a903      	add	r1, sp, #12
 800c8b4:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 800c8b6:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800c8b8:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 800c8ba:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pin = SD_CS_PIN;
 800c8bc:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(SD_CS_GPIO_PORT, &GPIO_InitStruct);
 800c8be:	f005 fc6d 	bl	801219c <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 800c8c2:	4b12      	ldr	r3, [pc, #72]	; (800c90c <SD_IO_Init+0x8c>)
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &GPIO_InitStruct);
 800c8c4:	a903      	add	r1, sp, #12
 800c8c6:	4812      	ldr	r0, [pc, #72]	; (800c910 <SD_IO_Init+0x90>)
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 800c8c8:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pin = SD_DETECT_PIN;
 800c8ca:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800c8cc:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &GPIO_InitStruct);
 800c8ce:	f005 fc65 	bl	801219c <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(SD_DETECT_EXTI_IRQn, 0x03, 0);
 800c8d2:	2200      	movs	r2, #0
 800c8d4:	2103      	movs	r1, #3
 800c8d6:	2005      	movs	r0, #5
 800c8d8:	f004 fe32 	bl	8011540 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SD_DETECT_EXTI_IRQn);
 800c8dc:	2005      	movs	r0, #5
 800c8de:	f004 fe59 	bl	8011594 <HAL_NVIC_EnableIRQ>
  SPIx_Init();
 800c8e2:	f000 fb6b 	bl	800cfbc <SPIx_Init>
  SD_CS_HIGH();
 800c8e6:	2090      	movs	r0, #144	; 0x90
 800c8e8:	0022      	movs	r2, r4
 800c8ea:	0029      	movs	r1, r5
 800c8ec:	05c0      	lsls	r0, r0, #23
 800c8ee:	f005 fd17 	bl	8012320 <HAL_GPIO_WritePin>
 800c8f2:	3409      	adds	r4, #9
 800c8f4:	3c01      	subs	r4, #1
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c8f6:	20ff      	movs	r0, #255	; 0xff
 800c8f8:	b2e4      	uxtb	r4, r4
 800c8fa:	f7ff fea2 	bl	800c642 <SD_IO_WriteByte>
  for (counter = 0; counter <= 9; counter++)
 800c8fe:	2c00      	cmp	r4, #0
 800c900:	d1f8      	bne.n	800c8f4 <SD_IO_Init+0x74>
}
 800c902:	b009      	add	sp, #36	; 0x24
 800c904:	bd30      	pop	{r4, r5, pc}
 800c906:	46c0      	nop			; (mov r8, r8)
 800c908:	40021000 	.word	0x40021000
 800c90c:	10310000 	.word	0x10310000
 800c910:	48000400 	.word	0x48000400

0800c914 <BSP_SD_Init>:
{ 
 800c914:	b5f0      	push	{r4, r5, r6, r7, lr}
		RTOS_IND_blink(500); Delay_ms(500); 
 800c916:	2580      	movs	r5, #128	; 0x80
{ 
 800c918:	b087      	sub	sp, #28
		RTOS_IND_blink(500); Delay_ms(500); 
 800c91a:	01ed      	lsls	r5, r5, #7
	while(BSP_SD_IsDetected()==SD_NOT_PRESENT) 
 800c91c:	f7ff fe72 	bl	800c604 <BSP_SD_IsDetected>
 800c920:	1e04      	subs	r4, r0, #0
 800c922:	d01e      	beq.n	800c962 <BSP_SD_Init+0x4e>
  __IO uint8_t counter = 0;
 800c924:	250f      	movs	r5, #15
  SD_IO_Init();
 800c926:	f7ff ffab 	bl	800c880 <SD_IO_Init>
  __IO uint8_t counter = 0;
 800c92a:	2300      	movs	r3, #0
 800c92c:	446d      	add	r5, sp
 800c92e:	702b      	strb	r3, [r5, #0]
    response = SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95, SD_ANSWER_R1_EXPECTED);
 800c930:	2100      	movs	r1, #0
    counter++;
 800c932:	782b      	ldrb	r3, [r5, #0]
    response = SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95, SD_ANSWER_R1_EXPECTED);
 800c934:	ac04      	add	r4, sp, #16
    counter++;
 800c936:	3301      	adds	r3, #1
 800c938:	b2db      	uxtb	r3, r3
 800c93a:	702b      	strb	r3, [r5, #0]
    response = SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95, SD_ANSWER_R1_EXPECTED);
 800c93c:	000a      	movs	r2, r1
 800c93e:	2395      	movs	r3, #149	; 0x95
 800c940:	9100      	str	r1, [sp, #0]
 800c942:	0020      	movs	r0, r4
 800c944:	f7ff fe97 	bl	800c676 <SD_SendCmd>
 800c948:	7826      	ldrb	r6, [r4, #0]
 800c94a:	f7ff fe53 	bl	800c5f4 <SD_IO_CSState.part.0>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c94e:	20ff      	movs	r0, #255	; 0xff
 800c950:	f7ff fe77 	bl	800c642 <SD_IO_WriteByte>
    if(counter >= SD_MAX_TRY)
 800c954:	782b      	ldrb	r3, [r5, #0]
 800c956:	2b63      	cmp	r3, #99	; 0x63
 800c958:	d916      	bls.n	800c988 <BSP_SD_Init+0x74>
      return BSP_SD_ERROR;
 800c95a:	2501      	movs	r5, #1
}
 800c95c:	0028      	movs	r0, r5
 800c95e:	b007      	add	sp, #28
 800c960:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RTOS_IND_blink(500); Delay_ms(500); 
 800c962:	0029      	movs	r1, r5
 800c964:	2201      	movs	r2, #1
 800c966:	484f      	ldr	r0, [pc, #316]	; (800caa4 <BSP_SD_Init+0x190>)
 800c968:	f005 fcda 	bl	8012320 <HAL_GPIO_WritePin>
 800c96c:	20fa      	movs	r0, #250	; 0xfa
 800c96e:	0040      	lsls	r0, r0, #1
 800c970:	f002 fef7 	bl	800f762 <osDelay>
 800c974:	0022      	movs	r2, r4
 800c976:	0029      	movs	r1, r5
 800c978:	484a      	ldr	r0, [pc, #296]	; (800caa4 <BSP_SD_Init+0x190>)
 800c97a:	f005 fcd1 	bl	8012320 <HAL_GPIO_WritePin>
 800c97e:	20fa      	movs	r0, #250	; 0xfa
 800c980:	0040      	lsls	r0, r0, #1
 800c982:	f004 fdc3 	bl	801150c <HAL_Delay>
 800c986:	e7c9      	b.n	800c91c <BSP_SD_Init+0x8>
  while(response.r1 != SD_R1_IN_IDLE_STATE);
 800c988:	2e01      	cmp	r6, #1
 800c98a:	d1d1      	bne.n	800c930 <BSP_SD_Init+0x1c>
  response = SD_SendCmd(SD_CMD_SEND_IF_COND, 0x1AA, 0x87, SD_ANSWER_R7_EXPECTED);
 800c98c:	2305      	movs	r3, #5
 800c98e:	22d5      	movs	r2, #213	; 0xd5
 800c990:	0020      	movs	r0, r4
 800c992:	9300      	str	r3, [sp, #0]
 800c994:	0052      	lsls	r2, r2, #1
 800c996:	3382      	adds	r3, #130	; 0x82
 800c998:	2108      	movs	r1, #8
 800c99a:	f7ff fe6c 	bl	800c676 <SD_SendCmd>
 800c99e:	7825      	ldrb	r5, [r4, #0]
 800c9a0:	f7ff fe28 	bl	800c5f4 <SD_IO_CSState.part.0>
  SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c9a4:	20ff      	movs	r0, #255	; 0xff
 800c9a6:	f7ff fe4c 	bl	800c642 <SD_IO_WriteByte>
  if((response.r1  & SD_R1_ILLEGAL_COMMAND) == SD_R1_ILLEGAL_COMMAND)
 800c9aa:	076b      	lsls	r3, r5, #29
 800c9ac:	d51f      	bpl.n	800c9ee <BSP_SD_Init+0xda>
      response = SD_SendCmd(SD_CMD_APP_CMD, 0x00000000, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c9ae:	36fe      	adds	r6, #254	; 0xfe
 800c9b0:	2500      	movs	r5, #0
 800c9b2:	0033      	movs	r3, r6
 800c9b4:	002a      	movs	r2, r5
 800c9b6:	2137      	movs	r1, #55	; 0x37
 800c9b8:	0020      	movs	r0, r4
 800c9ba:	9500      	str	r5, [sp, #0]
 800c9bc:	f7ff fe5b 	bl	800c676 <SD_SendCmd>
 800c9c0:	f7ff fe18 	bl	800c5f4 <SD_IO_CSState.part.0>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c9c4:	0030      	movs	r0, r6
 800c9c6:	f7ff fe3c 	bl	800c642 <SD_IO_WriteByte>
      response = SD_SendCmd(SD_CMD_SD_APP_OP_COND, 0x00000000, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c9ca:	0020      	movs	r0, r4
 800c9cc:	0033      	movs	r3, r6
 800c9ce:	002a      	movs	r2, r5
 800c9d0:	2129      	movs	r1, #41	; 0x29
 800c9d2:	9500      	str	r5, [sp, #0]
 800c9d4:	f7ff fe4f 	bl	800c676 <SD_SendCmd>
 800c9d8:	7827      	ldrb	r7, [r4, #0]
 800c9da:	f7ff fe0b 	bl	800c5f4 <SD_IO_CSState.part.0>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800c9de:	0030      	movs	r0, r6
 800c9e0:	f7ff fe2f 	bl	800c642 <SD_IO_WriteByte>
    while(response.r1 == SD_R1_IN_IDLE_STATE);
 800c9e4:	2f01      	cmp	r7, #1
 800c9e6:	d0e3      	beq.n	800c9b0 <BSP_SD_Init+0x9c>
    flag_SDHC = 0;
 800c9e8:	4b2f      	ldr	r3, [pc, #188]	; (800caa8 <BSP_SD_Init+0x194>)
 800c9ea:	801d      	strh	r5, [r3, #0]
 800c9ec:	e7b6      	b.n	800c95c <BSP_SD_Init+0x48>
  else if(response.r1 == SD_R1_IN_IDLE_STATE)
 800c9ee:	2d01      	cmp	r5, #1
 800c9f0:	d1b3      	bne.n	800c95a <BSP_SD_Init+0x46>
      response = SD_SendCmd(SD_CMD_SD_APP_OP_COND, 0x40000000, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c9f2:	2780      	movs	r7, #128	; 0x80
      response = SD_SendCmd(SD_CMD_APP_CMD, 0, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c9f4:	35fe      	adds	r5, #254	; 0xfe
      response = SD_SendCmd(SD_CMD_SD_APP_OP_COND, 0x40000000, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c9f6:	05ff      	lsls	r7, r7, #23
      response = SD_SendCmd(SD_CMD_APP_CMD, 0, 0xFF, SD_ANSWER_R1_EXPECTED);
 800c9f8:	2600      	movs	r6, #0
 800c9fa:	002b      	movs	r3, r5
 800c9fc:	0032      	movs	r2, r6
 800c9fe:	2137      	movs	r1, #55	; 0x37
 800ca00:	0020      	movs	r0, r4
 800ca02:	9600      	str	r6, [sp, #0]
 800ca04:	f7ff fe37 	bl	800c676 <SD_SendCmd>
 800ca08:	f7ff fdf4 	bl	800c5f4 <SD_IO_CSState.part.0>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800ca0c:	0028      	movs	r0, r5
 800ca0e:	f7ff fe18 	bl	800c642 <SD_IO_WriteByte>
      response = SD_SendCmd(SD_CMD_SD_APP_OP_COND, 0x40000000, 0xFF, SD_ANSWER_R1_EXPECTED);
 800ca12:	0020      	movs	r0, r4
 800ca14:	9600      	str	r6, [sp, #0]
 800ca16:	002b      	movs	r3, r5
 800ca18:	003a      	movs	r2, r7
 800ca1a:	2129      	movs	r1, #41	; 0x29
 800ca1c:	f7ff fe2b 	bl	800c676 <SD_SendCmd>
 800ca20:	7826      	ldrb	r6, [r4, #0]
 800ca22:	f7ff fde7 	bl	800c5f4 <SD_IO_CSState.part.0>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800ca26:	0028      	movs	r0, r5
 800ca28:	f7ff fe0b 	bl	800c642 <SD_IO_WriteByte>
    while(response.r1 == SD_R1_IN_IDLE_STATE);
 800ca2c:	2e01      	cmp	r6, #1
 800ca2e:	d0e3      	beq.n	800c9f8 <BSP_SD_Init+0xe4>
    if((response.r1 & SD_R1_ILLEGAL_COMMAND) == SD_R1_ILLEGAL_COMMAND)
 800ca30:	0773      	lsls	r3, r6, #29
 800ca32:	d520      	bpl.n	800ca76 <BSP_SD_Init+0x162>
        response = SD_SendCmd(SD_CMD_APP_CMD, 0, 0xFF, SD_ANSWER_R1_EXPECTED);
 800ca34:	25ff      	movs	r5, #255	; 0xff
 800ca36:	2600      	movs	r6, #0
 800ca38:	0020      	movs	r0, r4
 800ca3a:	002b      	movs	r3, r5
 800ca3c:	0032      	movs	r2, r6
 800ca3e:	2137      	movs	r1, #55	; 0x37
 800ca40:	9600      	str	r6, [sp, #0]
 800ca42:	f7ff fe18 	bl	800c676 <SD_SendCmd>
 800ca46:	7827      	ldrb	r7, [r4, #0]
 800ca48:	f7ff fdd4 	bl	800c5f4 <SD_IO_CSState.part.0>
        SD_IO_WriteByte(SD_DUMMY_BYTE);
 800ca4c:	0028      	movs	r0, r5
 800ca4e:	f7ff fdf8 	bl	800c642 <SD_IO_WriteByte>
        if(response.r1 != SD_R1_IN_IDLE_STATE)
 800ca52:	2f01      	cmp	r7, #1
 800ca54:	d000      	beq.n	800ca58 <BSP_SD_Init+0x144>
 800ca56:	e780      	b.n	800c95a <BSP_SD_Init+0x46>
        response = SD_SendCmd(SD_CMD_SD_APP_OP_COND, 0x00000000, 0xFF, SD_ANSWER_R1_EXPECTED);
 800ca58:	0032      	movs	r2, r6
 800ca5a:	0020      	movs	r0, r4
 800ca5c:	9600      	str	r6, [sp, #0]
 800ca5e:	002b      	movs	r3, r5
 800ca60:	2129      	movs	r1, #41	; 0x29
 800ca62:	f7ff fe08 	bl	800c676 <SD_SendCmd>
 800ca66:	7826      	ldrb	r6, [r4, #0]
 800ca68:	f7ff fdc4 	bl	800c5f4 <SD_IO_CSState.part.0>
        SD_IO_WriteByte(SD_DUMMY_BYTE);
 800ca6c:	0028      	movs	r0, r5
 800ca6e:	f7ff fde8 	bl	800c642 <SD_IO_WriteByte>
      while(response.r1 == SD_R1_IN_IDLE_STATE);        
 800ca72:	2e01      	cmp	r6, #1
 800ca74:	d0df      	beq.n	800ca36 <BSP_SD_Init+0x122>
    response = SD_SendCmd(SD_CMD_READ_OCR, 0x00000000, 0xFF, SD_ANSWER_R3_EXPECTED);
 800ca76:	2303      	movs	r3, #3
 800ca78:	0020      	movs	r0, r4
 800ca7a:	9300      	str	r3, [sp, #0]
 800ca7c:	2200      	movs	r2, #0
 800ca7e:	33fc      	adds	r3, #252	; 0xfc
 800ca80:	213a      	movs	r1, #58	; 0x3a
 800ca82:	f7ff fdf8 	bl	800c676 <SD_SendCmd>
 800ca86:	7825      	ldrb	r5, [r4, #0]
 800ca88:	f7ff fdb4 	bl	800c5f4 <SD_IO_CSState.part.0>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800ca8c:	20ff      	movs	r0, #255	; 0xff
 800ca8e:	f7ff fdd8 	bl	800c642 <SD_IO_WriteByte>
    if(response.r1 != SD_R1_NO_ERROR)
 800ca92:	2d00      	cmp	r5, #0
 800ca94:	d000      	beq.n	800ca98 <BSP_SD_Init+0x184>
 800ca96:	e760      	b.n	800c95a <BSP_SD_Init+0x46>
    flag_SDHC = (response.r2 & 0x40) >> 6;
 800ca98:	7863      	ldrb	r3, [r4, #1]
 800ca9a:	4a03      	ldr	r2, [pc, #12]	; (800caa8 <BSP_SD_Init+0x194>)
 800ca9c:	065b      	lsls	r3, r3, #25
 800ca9e:	0fdb      	lsrs	r3, r3, #31
 800caa0:	8013      	strh	r3, [r2, #0]
 800caa2:	e75b      	b.n	800c95c <BSP_SD_Init+0x48>
 800caa4:	48000400 	.word	0x48000400
 800caa8:	2000009a 	.word	0x2000009a

0800caac <SD_WaitData.constprop.1>:
uint8_t SD_WaitData(uint8_t data)
 800caac:	b510      	push	{r4, lr}
  uint16_t timeout = 0xFFFF;
 800caae:	4c08      	ldr	r4, [pc, #32]	; (800cad0 <SD_WaitData.constprop.1+0x24>)
    readvalue = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cab0:	20ff      	movs	r0, #255	; 0xff
 800cab2:	f7ff fdc6 	bl	800c642 <SD_IO_WriteByte>
    timeout--;
 800cab6:	3c01      	subs	r4, #1
 800cab8:	b2a4      	uxth	r4, r4
  }while ((readvalue != data) && timeout);
 800caba:	28fe      	cmp	r0, #254	; 0xfe
 800cabc:	d003      	beq.n	800cac6 <SD_WaitData.constprop.1+0x1a>
 800cabe:	2c00      	cmp	r4, #0
 800cac0:	d1f6      	bne.n	800cab0 <SD_WaitData.constprop.1+0x4>
    return BSP_SD_TIMEOUT;
 800cac2:	2002      	movs	r0, #2
}
 800cac4:	bd10      	pop	{r4, pc}
  return BSP_SD_OK;
 800cac6:	4260      	negs	r0, r4
 800cac8:	4160      	adcs	r0, r4
 800caca:	0040      	lsls	r0, r0, #1
 800cacc:	e7fa      	b.n	800cac4 <SD_WaitData.constprop.1+0x18>
 800cace:	46c0      	nop			; (mov r8, r8)
 800cad0:	0000ffff 	.word	0x0000ffff

0800cad4 <BSP_SD_ReadBlocks>:
{
 800cad4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cad6:	b089      	sub	sp, #36	; 0x24
 800cad8:	9303      	str	r3, [sp, #12]
  response = SD_SendCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_ANSWER_R1_EXPECTED);
 800cada:	2300      	movs	r3, #0
 800cadc:	ac06      	add	r4, sp, #24
{
 800cade:	9004      	str	r0, [sp, #16]
 800cae0:	9105      	str	r1, [sp, #20]
  response = SD_SendCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_ANSWER_R1_EXPECTED);
 800cae2:	0020      	movs	r0, r4
 800cae4:	9300      	str	r3, [sp, #0]
 800cae6:	2110      	movs	r1, #16
 800cae8:	33ff      	adds	r3, #255	; 0xff
{
 800caea:	0015      	movs	r5, r2
  response = SD_SendCmd(SD_CMD_SET_BLOCKLEN, BlockSize, 0xFF, SD_ANSWER_R1_EXPECTED);
 800caec:	f7ff fdc3 	bl	800c676 <SD_SendCmd>
 800caf0:	7826      	ldrb	r6, [r4, #0]
 800caf2:	f7ff fd7f 	bl	800c5f4 <SD_IO_CSState.part.0>
  SD_IO_WriteByte(SD_DUMMY_BYTE);
 800caf6:	20ff      	movs	r0, #255	; 0xff
 800caf8:	f7ff fda3 	bl	800c642 <SD_IO_WriteByte>
  if ( response.r1 != SD_R1_NO_ERROR)
 800cafc:	2e00      	cmp	r6, #0
 800cafe:	d002      	beq.n	800cb06 <BSP_SD_ReadBlocks+0x32>
  uint8_t *ptr = NULL;
 800cb00:	2400      	movs	r4, #0
  uint8_t retr = BSP_SD_ERROR;
 800cb02:	2601      	movs	r6, #1
 800cb04:	e00c      	b.n	800cb20 <BSP_SD_ReadBlocks+0x4c>
  ptr = malloc(sizeof(uint8_t)*BlockSize);
 800cb06:	0028      	movs	r0, r5
 800cb08:	f007 fb66 	bl	80141d8 <malloc>
 800cb0c:	1e04      	subs	r4, r0, #0
  if( ptr == NULL )
 800cb0e:	d0f7      	beq.n	800cb00 <BSP_SD_ReadBlocks+0x2c>
  memset(ptr, SD_DUMMY_BYTE, sizeof(uint8_t)*BlockSize);
 800cb10:	002a      	movs	r2, r5
 800cb12:	21ff      	movs	r1, #255	; 0xff
 800cb14:	f007 fda7 	bl	8014666 <memset>
  while (NumberOfBlocks--)
 800cb18:	9f04      	ldr	r7, [sp, #16]
 800cb1a:	9b03      	ldr	r3, [sp, #12]
 800cb1c:	2b00      	cmp	r3, #0
 800cb1e:	d10c      	bne.n	800cb3a <BSP_SD_ReadBlocks+0x66>
 800cb20:	f7ff fd68 	bl	800c5f4 <SD_IO_CSState.part.0>
  SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cb24:	20ff      	movs	r0, #255	; 0xff
 800cb26:	f7ff fd8c 	bl	800c642 <SD_IO_WriteByte>
  if(ptr != NULL) free(ptr);
 800cb2a:	2c00      	cmp	r4, #0
 800cb2c:	d002      	beq.n	800cb34 <BSP_SD_ReadBlocks+0x60>
 800cb2e:	0020      	movs	r0, r4
 800cb30:	f007 fb5c 	bl	80141ec <free>
}
 800cb34:	0030      	movs	r0, r6
 800cb36:	b009      	add	sp, #36	; 0x24
 800cb38:	bdf0      	pop	{r4, r5, r6, r7, pc}
    response = SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, (ReadAddr + offset)/(flag_SDHC == 1 ?BlockSize: 1), 0xFF, SD_ANSWER_R1_EXPECTED);
 800cb3a:	2101      	movs	r1, #1
 800cb3c:	9b05      	ldr	r3, [sp, #20]
 800cb3e:	9a04      	ldr	r2, [sp, #16]
 800cb40:	1a98      	subs	r0, r3, r2
 800cb42:	4b16      	ldr	r3, [pc, #88]	; (800cb9c <BSP_SD_ReadBlocks+0xc8>)
 800cb44:	19c0      	adds	r0, r0, r7
 800cb46:	881b      	ldrh	r3, [r3, #0]
 800cb48:	428b      	cmp	r3, r1
 800cb4a:	d100      	bne.n	800cb4e <BSP_SD_ReadBlocks+0x7a>
 800cb4c:	0029      	movs	r1, r5
 800cb4e:	f7f3 fb13 	bl	8000178 <__udivsi3>
 800cb52:	2300      	movs	r3, #0
 800cb54:	0002      	movs	r2, r0
 800cb56:	9300      	str	r3, [sp, #0]
 800cb58:	2111      	movs	r1, #17
 800cb5a:	33ff      	adds	r3, #255	; 0xff
 800cb5c:	a806      	add	r0, sp, #24
 800cb5e:	f7ff fd8a 	bl	800c676 <SD_SendCmd>
    if ( response.r1 != SD_R1_NO_ERROR)
 800cb62:	ab04      	add	r3, sp, #16
 800cb64:	7a1b      	ldrb	r3, [r3, #8]
 800cb66:	2b00      	cmp	r3, #0
 800cb68:	d1cb      	bne.n	800cb02 <BSP_SD_ReadBlocks+0x2e>
    if (SD_WaitData(SD_TOKEN_START_DATA_SINGLE_BLOCK_READ) == BSP_SD_OK)
 800cb6a:	f7ff ff9f 	bl	800caac <SD_WaitData.constprop.1>
 800cb6e:	9b03      	ldr	r3, [sp, #12]
 800cb70:	3b01      	subs	r3, #1
 800cb72:	9303      	str	r3, [sp, #12]
 800cb74:	2800      	cmp	r0, #0
 800cb76:	d1c4      	bne.n	800cb02 <BSP_SD_ReadBlocks+0x2e>
  SPIx_WriteReadData(DataIn, DataOut, DataLength);
 800cb78:	0039      	movs	r1, r7
 800cb7a:	002a      	movs	r2, r5
 800cb7c:	0020      	movs	r0, r4
 800cb7e:	f000 fa4d 	bl	800d01c <SPIx_WriteReadData>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cb82:	20ff      	movs	r0, #255	; 0xff
 800cb84:	f7ff fd5d 	bl	800c642 <SD_IO_WriteByte>
      SD_IO_WriteByte(SD_DUMMY_BYTE);      
 800cb88:	20ff      	movs	r0, #255	; 0xff
 800cb8a:	f7ff fd5a 	bl	800c642 <SD_IO_WriteByte>
 800cb8e:	f7ff fd31 	bl	800c5f4 <SD_IO_CSState.part.0>
    SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cb92:	20ff      	movs	r0, #255	; 0xff
 800cb94:	f7ff fd55 	bl	800c642 <SD_IO_WriteByte>
 800cb98:	197f      	adds	r7, r7, r5
 800cb9a:	e7be      	b.n	800cb1a <BSP_SD_ReadBlocks+0x46>
 800cb9c:	2000009a 	.word	0x2000009a

0800cba0 <BSP_SD_GetCardInfo>:
  response = SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF, SD_ANSWER_R1_EXPECTED);
 800cba0:	2200      	movs	r2, #0
{
 800cba2:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cba4:	b08b      	sub	sp, #44	; 0x2c
  response = SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF, SD_ANSWER_R1_EXPECTED);
 800cba6:	ad04      	add	r5, sp, #16
 800cba8:	23ff      	movs	r3, #255	; 0xff
{
 800cbaa:	0004      	movs	r4, r0
  response = SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF, SD_ANSWER_R1_EXPECTED);
 800cbac:	9200      	str	r2, [sp, #0]
 800cbae:	2109      	movs	r1, #9
 800cbb0:	0028      	movs	r0, r5
 800cbb2:	f7ff fd60 	bl	800c676 <SD_SendCmd>
  if(response.r1 == SD_R1_NO_ERROR)
 800cbb6:	782b      	ldrb	r3, [r5, #0]
 800cbb8:	2b00      	cmp	r3, #0
 800cbba:	d02b      	beq.n	800cc14 <BSP_SD_GetCardInfo+0x74>
  uint8_t retr = BSP_SD_ERROR;
 800cbbc:	2301      	movs	r3, #1
 800cbbe:	9303      	str	r3, [sp, #12]
 800cbc0:	f7ff fd18 	bl	800c5f4 <SD_IO_CSState.part.0>
  SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cbc4:	20ff      	movs	r0, #255	; 0xff
 800cbc6:	f7ff fd3c 	bl	800c642 <SD_IO_WriteByte>
  response = SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF, SD_ANSWER_R1_EXPECTED);
 800cbca:	2200      	movs	r2, #0
 800cbcc:	ad04      	add	r5, sp, #16
 800cbce:	23ff      	movs	r3, #255	; 0xff
 800cbd0:	9200      	str	r2, [sp, #0]
 800cbd2:	210a      	movs	r1, #10
 800cbd4:	0028      	movs	r0, r5
 800cbd6:	f7ff fd4e 	bl	800c676 <SD_SendCmd>
  if(response.r1 == SD_R1_NO_ERROR)
 800cbda:	782b      	ldrb	r3, [r5, #0]
 800cbdc:	2b00      	cmp	r3, #0
 800cbde:	d100      	bne.n	800cbe2 <BSP_SD_GetCardInfo+0x42>
 800cbe0:	e129      	b.n	800ce36 <BSP_SD_GetCardInfo+0x296>
  uint8_t retr = BSP_SD_ERROR;
 800cbe2:	2601      	movs	r6, #1
 800cbe4:	f7ff fd06 	bl	800c5f4 <SD_IO_CSState.part.0>
  SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cbe8:	20ff      	movs	r0, #255	; 0xff
 800cbea:	f7ff fd2a 	bl	800c642 <SD_IO_WriteByte>
  status|= SD_GetCIDRegister(&(pCardInfo->Cid));
 800cbee:	9b03      	ldr	r3, [sp, #12]
 800cbf0:	431e      	orrs	r6, r3
  if(flag_SDHC == 1 )
 800cbf2:	4bc8      	ldr	r3, [pc, #800]	; (800cf14 <BSP_SD_GetCardInfo+0x374>)
  status|= SD_GetCIDRegister(&(pCardInfo->Cid));
 800cbf4:	b2f0      	uxtb	r0, r6
  if(flag_SDHC == 1 )
 800cbf6:	881b      	ldrh	r3, [r3, #0]
 800cbf8:	2b01      	cmp	r3, #1
 800cbfa:	d000      	beq.n	800cbfe <BSP_SD_GetCardInfo+0x5e>
 800cbfc:	e17a      	b.n	800cef4 <BSP_SD_GetCardInfo+0x354>
    pCardInfo->CardBlockSize = 512;
 800cbfe:	2380      	movs	r3, #128	; 0x80
 800cc00:	009b      	lsls	r3, r3, #2
 800cc02:	6363      	str	r3, [r4, #52]	; 0x34
    pCardInfo->CardCapacity = (pCardInfo->Csd.version.v2.DeviceSize + 1) * pCardInfo->CardBlockSize;
 800cc04:	68a3      	ldr	r3, [r4, #8]
 800cc06:	011b      	lsls	r3, r3, #4
 800cc08:	0a9b      	lsrs	r3, r3, #10
 800cc0a:	3301      	adds	r3, #1
 800cc0c:	025b      	lsls	r3, r3, #9
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 800cc0e:	6323      	str	r3, [r4, #48]	; 0x30
}
 800cc10:	b00b      	add	sp, #44	; 0x2c
 800cc12:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (SD_WaitData(SD_TOKEN_START_DATA_SINGLE_BLOCK_READ) == BSP_SD_OK)
 800cc14:	f7ff ff4a 	bl	800caac <SD_WaitData.constprop.1>
 800cc18:	9003      	str	r0, [sp, #12]
 800cc1a:	2800      	cmp	r0, #0
 800cc1c:	d1ce      	bne.n	800cbbc <BSP_SD_GetCardInfo+0x1c>
 800cc1e:	0006      	movs	r6, r0
        CSD_Tab[counter] = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cc20:	20ff      	movs	r0, #255	; 0xff
 800cc22:	f7ff fd0e 	bl	800c642 <SD_IO_WriteByte>
 800cc26:	ad06      	add	r5, sp, #24
 800cc28:	5570      	strb	r0, [r6, r5]
 800cc2a:	3601      	adds	r6, #1
      for (counter = 0; counter < 16; counter++)
 800cc2c:	2e10      	cmp	r6, #16
 800cc2e:	d1f7      	bne.n	800cc20 <BSP_SD_GetCardInfo+0x80>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cc30:	20ff      	movs	r0, #255	; 0xff
 800cc32:	f7ff fd06 	bl	800c642 <SD_IO_WriteByte>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800cc36:	20ff      	movs	r0, #255	; 0xff
 800cc38:	f7ff fd03 	bl	800c642 <SD_IO_WriteByte>
      Csd->PartBlockRead   = (CSD_Tab[6] & 0x80) >> 7;
 800cc3c:	2001      	movs	r0, #1
      Csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
 800cc3e:	782b      	ldrb	r3, [r5, #0]
      Csd->Reserved1 =  CSD_Tab[0] & 0x3F;
 800cc40:	009a      	lsls	r2, r3, #2
 800cc42:	099b      	lsrs	r3, r3, #6
 800cc44:	4313      	orrs	r3, r2
 800cc46:	7023      	strb	r3, [r4, #0]
      Csd->TAAC = CSD_Tab[1];
 800cc48:	786b      	ldrb	r3, [r5, #1]
 800cc4a:	7063      	strb	r3, [r4, #1]
      Csd->NSAC = CSD_Tab[2];
 800cc4c:	78ab      	ldrb	r3, [r5, #2]
 800cc4e:	70a3      	strb	r3, [r4, #2]
      Csd->MaxBusClkFrec = CSD_Tab[3];
 800cc50:	78eb      	ldrb	r3, [r5, #3]
 800cc52:	70e3      	strb	r3, [r4, #3]
      Csd->CardComdClasses = (CSD_Tab[4] << 4) | ((CSD_Tab[5] & 0xF0) >> 4);
 800cc54:	796a      	ldrb	r2, [r5, #5]
 800cc56:	792b      	ldrb	r3, [r5, #4]
 800cc58:	0911      	lsrs	r1, r2, #4
 800cc5a:	011b      	lsls	r3, r3, #4
 800cc5c:	4319      	orrs	r1, r3
 800cc5e:	88a3      	ldrh	r3, [r4, #4]
      Csd->RdBlockLen = CSD_Tab[5] & 0x0F;
 800cc60:	0112      	lsls	r2, r2, #4
      Csd->CardComdClasses = (CSD_Tab[4] << 4) | ((CSD_Tab[5] & 0xF0) >> 4);
 800cc62:	0b1b      	lsrs	r3, r3, #12
 800cc64:	031b      	lsls	r3, r3, #12
 800cc66:	430b      	orrs	r3, r1
 800cc68:	80a3      	strh	r3, [r4, #4]
      Csd->RdBlockLen = CSD_Tab[5] & 0x0F;
 800cc6a:	051b      	lsls	r3, r3, #20
 800cc6c:	0f1b      	lsrs	r3, r3, #28
 800cc6e:	4313      	orrs	r3, r2
 800cc70:	7163      	strb	r3, [r4, #5]
      Csd->PartBlockRead   = (CSD_Tab[6] & 0x80) >> 7;
 800cc72:	79ab      	ldrb	r3, [r5, #6]
 800cc74:	79a1      	ldrb	r1, [r4, #6]
 800cc76:	09da      	lsrs	r2, r3, #7
 800cc78:	4381      	bics	r1, r0
      Csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
 800cc7a:	119f      	asrs	r7, r3, #6
 800cc7c:	4007      	ands	r7, r0
 800cc7e:	430a      	orrs	r2, r1
 800cc80:	2102      	movs	r1, #2
 800cc82:	4087      	lsls	r7, r0
 800cc84:	438a      	bics	r2, r1
      Csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
 800cc86:	433a      	orrs	r2, r7
 800cc88:	2704      	movs	r7, #4
 800cc8a:	1159      	asrs	r1, r3, #5
 800cc8c:	4001      	ands	r1, r0
 800cc8e:	0089      	lsls	r1, r1, #2
 800cc90:	43ba      	bics	r2, r7
      Csd->DSRImpl         = (CSD_Tab[6] & 0x10) >> 4;
 800cc92:	430a      	orrs	r2, r1
 800cc94:	2108      	movs	r1, #8
 800cc96:	111f      	asrs	r7, r3, #4
 800cc98:	4038      	ands	r0, r7
 800cc9a:	00c0      	lsls	r0, r0, #3
 800cc9c:	438a      	bics	r2, r1
 800cc9e:	4302      	orrs	r2, r0
 800cca0:	71a2      	strb	r2, [r4, #6]
 800cca2:	7a28      	ldrb	r0, [r5, #8]
 800cca4:	7aa9      	ldrb	r1, [r5, #10]
 800cca6:	4684      	mov	ip, r0
      if(flag_SDHC == 0)
 800cca8:	489a      	ldr	r0, [pc, #616]	; (800cf14 <BSP_SD_GetCardInfo+0x374>)
 800ccaa:	79ea      	ldrb	r2, [r5, #7]
 800ccac:	8800      	ldrh	r0, [r0, #0]
 800ccae:	2800      	cmp	r0, #0
 800ccb0:	d000      	beq.n	800ccb4 <BSP_SD_GetCardInfo+0x114>
 800ccb2:	e0a6      	b.n	800ce02 <BSP_SD_GetCardInfo+0x262>
        Csd->version.v1.Reserved1 = ((CSD_Tab[6] & 0x0C) >> 2);
 800ccb4:	2703      	movs	r7, #3
 800ccb6:	7a68      	ldrb	r0, [r5, #9]
 800ccb8:	7a25      	ldrb	r5, [r4, #8]
 800ccba:	109e      	asrs	r6, r3, #2
 800ccbc:	43bd      	bics	r5, r7
 800ccbe:	403e      	ands	r6, r7
 800ccc0:	432e      	orrs	r6, r5
                                    |  (CSD_Tab[7] << 2)
 800ccc2:	0095      	lsls	r5, r2, #2
                                    | ((CSD_Tab[8] & 0xC0) >> 6);
 800ccc4:	4662      	mov	r2, ip
 800ccc6:	0992      	lsrs	r2, r2, #6
        Csd->version.v1.Reserved1 = ((CSD_Tab[6] & 0x0C) >> 2);
 800ccc8:	7226      	strb	r6, [r4, #8]
                                    | ((CSD_Tab[8] & 0xC0) >> 6);
 800ccca:	432a      	orrs	r2, r5
        Csd->version.v1.DeviceSize =  ((CSD_Tab[6] & 0x03) << 10) 
 800cccc:	029b      	lsls	r3, r3, #10
                                    | ((CSD_Tab[8] & 0xC0) >> 6);
 800ccce:	4313      	orrs	r3, r2
        Csd->version.v1.DeviceSize =  ((CSD_Tab[6] & 0x03) << 10) 
 800ccd0:	4d91      	ldr	r5, [pc, #580]	; (800cf18 <BSP_SD_GetCardInfo+0x378>)
 800ccd2:	8922      	ldrh	r2, [r4, #8]
 800ccd4:	051b      	lsls	r3, r3, #20
 800ccd6:	402a      	ands	r2, r5
 800ccd8:	0c9b      	lsrs	r3, r3, #18
 800ccda:	4313      	orrs	r3, r2
 800ccdc:	8123      	strh	r3, [r4, #8]
        Csd->version.v1.MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
 800ccde:	4663      	mov	r3, ip
 800cce0:	10de      	asrs	r6, r3, #3
 800cce2:	2307      	movs	r3, #7
        Csd->version.v1.MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
 800cce4:	4665      	mov	r5, ip
        Csd->version.v1.MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
 800cce6:	7aa2      	ldrb	r2, [r4, #10]
 800cce8:	401e      	ands	r6, r3
 800ccea:	439a      	bics	r2, r3
        Csd->version.v1.MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
 800ccec:	4332      	orrs	r2, r6
 800ccee:	401d      	ands	r5, r3
 800ccf0:	2638      	movs	r6, #56	; 0x38
 800ccf2:	40bd      	lsls	r5, r7
 800ccf4:	43b2      	bics	r2, r6
 800ccf6:	432a      	orrs	r2, r5
 800ccf8:	72a2      	strb	r2, [r4, #10]
        Csd->version.v1.MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
 800ccfa:	7ae2      	ldrb	r2, [r4, #11]
 800ccfc:	0947      	lsrs	r7, r0, #5
        Csd->version.v1.MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
 800ccfe:	1085      	asrs	r5, r0, #2
        Csd->version.v1.MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
 800cd00:	439a      	bics	r2, r3
        Csd->version.v1.MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
 800cd02:	401d      	ands	r5, r3
 800cd04:	433a      	orrs	r2, r7
 800cd06:	00ed      	lsls	r5, r5, #3
 800cd08:	43b2      	bics	r2, r6
 800cd0a:	432a      	orrs	r2, r5
 800cd0c:	72e2      	strb	r2, [r4, #11]
        Csd->version.v1.DeviceSizeMul = ((CSD_Tab[9] & 0x03) << 1)
 800cd0e:	2206      	movs	r2, #6
 800cd10:	0040      	lsls	r0, r0, #1
 800cd12:	4010      	ands	r0, r2
                                       |((CSD_Tab[10] & 0x80) >> 7);
 800cd14:	09ca      	lsrs	r2, r1, #7
 800cd16:	4310      	orrs	r0, r2
        Csd->version.v1.DeviceSizeMul = ((CSD_Tab[9] & 0x03) << 1)
 800cd18:	7b22      	ldrb	r2, [r4, #12]
 800cd1a:	439a      	bics	r2, r3
 800cd1c:	4310      	orrs	r0, r2
 800cd1e:	7320      	strb	r0, [r4, #12]
      Csd->EraseSingleBlockEnable = (CSD_Tab[10] & 0x40) >> 6;
 800cd20:	2001      	movs	r0, #1
 800cd22:	7c23      	ldrb	r3, [r4, #16]
 800cd24:	118e      	asrs	r6, r1, #6
 800cd26:	4006      	ands	r6, r0
 800cd28:	4383      	bics	r3, r0
      Csd->EraseSectorSize   = ((CSD_Tab[10] & 0x3F) << 1)
 800cd2a:	4081      	lsls	r1, r0
 800cd2c:	277e      	movs	r7, #126	; 0x7e
 800cd2e:	4333      	orrs	r3, r6
      Csd->WrProtectGrSize   = (CSD_Tab[11] & 0x7F);
 800cd30:	267f      	movs	r6, #127	; 0x7f
                              |((CSD_Tab[11] & 0x80) >> 7);
 800cd32:	ad06      	add	r5, sp, #24
 800cd34:	7aea      	ldrb	r2, [r5, #11]
      Csd->EraseSectorSize   = ((CSD_Tab[10] & 0x3F) << 1)
 800cd36:	4039      	ands	r1, r7
                              |((CSD_Tab[11] & 0x80) >> 7);
 800cd38:	09d7      	lsrs	r7, r2, #7
      Csd->WrProtectGrSize   = (CSD_Tab[11] & 0x7F);
 800cd3a:	4032      	ands	r2, r6
                              |((CSD_Tab[11] & 0x80) >> 7);
 800cd3c:	4339      	orrs	r1, r7
      Csd->WrProtectGrSize   = (CSD_Tab[11] & 0x7F);
 800cd3e:	0017      	movs	r7, r2
      Csd->EraseSectorSize   = ((CSD_Tab[10] & 0x3F) << 1)
 800cd40:	4081      	lsls	r1, r0
      Csd->WrProtectGrSize   = (CSD_Tab[11] & 0x7F);
 800cd42:	7c62      	ldrb	r2, [r4, #17]
      Csd->EraseSectorSize   = ((CSD_Tab[10] & 0x3F) << 1)
 800cd44:	4003      	ands	r3, r0
      Csd->WrProtectGrSize   = (CSD_Tab[11] & 0x7F);
 800cd46:	43b2      	bics	r2, r6
      Csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
 800cd48:	433a      	orrs	r2, r7
      Csd->Reserved2         = (CSD_Tab[12] & 0x60) >> 5;
 800cd4a:	2703      	movs	r7, #3
      Csd->EraseSectorSize   = ((CSD_Tab[10] & 0x3F) << 1)
 800cd4c:	4319      	orrs	r1, r3
 800cd4e:	7421      	strb	r1, [r4, #16]
      Csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
 800cd50:	7b29      	ldrb	r1, [r5, #12]
 800cd52:	4032      	ands	r2, r6
 800cd54:	09cb      	lsrs	r3, r1, #7
 800cd56:	01db      	lsls	r3, r3, #7
 800cd58:	431a      	orrs	r2, r3
      Csd->Reserved2         = (CSD_Tab[12] & 0x60) >> 5;
 800cd5a:	114b      	asrs	r3, r1, #5
 800cd5c:	403b      	ands	r3, r7
 800cd5e:	469c      	mov	ip, r3
 800cd60:	7ca3      	ldrb	r3, [r4, #18]
      Csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
 800cd62:	7462      	strb	r2, [r4, #17]
      Csd->Reserved2         = (CSD_Tab[12] & 0x60) >> 5;
 800cd64:	43bb      	bics	r3, r7
      Csd->WrSpeedFact       = (CSD_Tab[12] & 0x1C) >> 2;
 800cd66:	4667      	mov	r7, ip
 800cd68:	221c      	movs	r2, #28
 800cd6a:	433b      	orrs	r3, r7
 800cd6c:	271c      	movs	r7, #28
 800cd6e:	400a      	ands	r2, r1
 800cd70:	43bb      	bics	r3, r7
 800cd72:	431a      	orrs	r2, r3
 800cd74:	74a2      	strb	r2, [r4, #18]
      Csd->MaxWrBlockLen     = ((CSD_Tab[12] & 0x03) << 2)
 800cd76:	220c      	movs	r2, #12
                              |((CSD_Tab[13] & 0xC0) >> 6);
 800cd78:	7b6b      	ldrb	r3, [r5, #13]
      Csd->MaxWrBlockLen     = ((CSD_Tab[12] & 0x03) << 2)
 800cd7a:	0089      	lsls	r1, r1, #2
 800cd7c:	4011      	ands	r1, r2
                              |((CSD_Tab[13] & 0xC0) >> 6);
 800cd7e:	099a      	lsrs	r2, r3, #6
      Csd->MaxWrBlockLen     = ((CSD_Tab[12] & 0x03) << 2)
 800cd80:	4311      	orrs	r1, r2
 800cd82:	468c      	mov	ip, r1
 800cd84:	220f      	movs	r2, #15
      Csd->WriteBlockPartial = (CSD_Tab[13] & 0x20) >> 5;
 800cd86:	4667      	mov	r7, ip
      Csd->MaxWrBlockLen     = ((CSD_Tab[12] & 0x03) << 2)
 800cd88:	7ce1      	ldrb	r1, [r4, #19]
 800cd8a:	4391      	bics	r1, r2
      Csd->WriteBlockPartial = (CSD_Tab[13] & 0x20) >> 5;
 800cd8c:	4339      	orrs	r1, r7
 800cd8e:	2710      	movs	r7, #16
 800cd90:	115a      	asrs	r2, r3, #5
 800cd92:	4002      	ands	r2, r0
 800cd94:	43b9      	bics	r1, r7
 800cd96:	0112      	lsls	r2, r2, #4
 800cd98:	430a      	orrs	r2, r1
 800cd9a:	74e2      	strb	r2, [r4, #19]
      Csd->Reserved3         = (CSD_Tab[13] & 0x1F);
 800cd9c:	221f      	movs	r2, #31
 800cd9e:	7d21      	ldrb	r1, [r4, #20]
 800cda0:	4013      	ands	r3, r2
 800cda2:	4391      	bics	r1, r2
      Csd->FileFormatGrouop  = (CSD_Tab[14] & 0x80) >> 7;
 800cda4:	430b      	orrs	r3, r1
 800cda6:	2120      	movs	r1, #32
 800cda8:	7baa      	ldrb	r2, [r5, #14]
 800cdaa:	438b      	bics	r3, r1
 800cdac:	09d7      	lsrs	r7, r2, #7
 800cdae:	017f      	lsls	r7, r7, #5
      Csd->CopyFlag          = (CSD_Tab[14] & 0x40) >> 6;
 800cdb0:	433b      	orrs	r3, r7
 800cdb2:	2740      	movs	r7, #64	; 0x40
 800cdb4:	1191      	asrs	r1, r2, #6
 800cdb6:	4001      	ands	r1, r0
 800cdb8:	0189      	lsls	r1, r1, #6
 800cdba:	43bb      	bics	r3, r7
      Csd->PermWrProtect     = (CSD_Tab[14] & 0x20) >> 5;
 800cdbc:	430b      	orrs	r3, r1
 800cdbe:	1157      	asrs	r7, r2, #5
 800cdc0:	01ff      	lsls	r7, r7, #7
 800cdc2:	4033      	ands	r3, r6
      Csd->TempWrProtect     = (CSD_Tab[14] & 0x10) >> 4;
 800cdc4:	7d61      	ldrb	r1, [r4, #21]
      Csd->PermWrProtect     = (CSD_Tab[14] & 0x20) >> 5;
 800cdc6:	433b      	orrs	r3, r7
 800cdc8:	7523      	strb	r3, [r4, #20]
      Csd->TempWrProtect     = (CSD_Tab[14] & 0x10) >> 4;
 800cdca:	4381      	bics	r1, r0
 800cdcc:	1113      	asrs	r3, r2, #4
 800cdce:	4003      	ands	r3, r0
 800cdd0:	0008      	movs	r0, r1
      Csd->FileFormat        = (CSD_Tab[14] & 0x0C) >> 2;
 800cdd2:	2703      	movs	r7, #3
 800cdd4:	4303      	orrs	r3, r0
 800cdd6:	2006      	movs	r0, #6
 800cdd8:	1091      	asrs	r1, r2, #2
 800cdda:	4039      	ands	r1, r7
 800cddc:	0049      	lsls	r1, r1, #1
 800cdde:	4383      	bics	r3, r0
      Csd->Reserved4         = (CSD_Tab[14] & 0x03);
 800cde0:	430b      	orrs	r3, r1
 800cde2:	403a      	ands	r2, r7
 800cde4:	2118      	movs	r1, #24
 800cde6:	40ba      	lsls	r2, r7
 800cde8:	438b      	bics	r3, r1
 800cdea:	431a      	orrs	r2, r3
 800cdec:	7562      	strb	r2, [r4, #21]
      Csd->crc               = (CSD_Tab[15] & 0xFE) >> 1;
 800cdee:	7bea      	ldrb	r2, [r5, #15]
 800cdf0:	7da3      	ldrb	r3, [r4, #22]
 800cdf2:	0851      	lsrs	r1, r2, #1
 800cdf4:	43b3      	bics	r3, r6
      Csd->Reserved5         = (CSD_Tab[15] & 0x01);
 800cdf6:	430b      	orrs	r3, r1
 800cdf8:	01d2      	lsls	r2, r2, #7
 800cdfa:	401e      	ands	r6, r3
 800cdfc:	4316      	orrs	r6, r2
 800cdfe:	75a6      	strb	r6, [r4, #22]
 800ce00:	e6de      	b.n	800cbc0 <BSP_SD_GetCardInfo+0x20>
        Csd->version.v2.Reserved1 = ((CSD_Tab[6] & 0x0F) << 2) | ((CSD_Tab[7] & 0xC0) >> 6);
 800ce02:	203c      	movs	r0, #60	; 0x3c
 800ce04:	273f      	movs	r7, #63	; 0x3f
 800ce06:	009b      	lsls	r3, r3, #2
 800ce08:	4003      	ands	r3, r0
 800ce0a:	0990      	lsrs	r0, r2, #6
 800ce0c:	4303      	orrs	r3, r0
 800ce0e:	7a20      	ldrb	r0, [r4, #8]
        Csd->version.v2.DeviceSize= ((CSD_Tab[7] & 0x3F) << 16) | (CSD_Tab[8] << 8) | CSD_Tab[9];    
 800ce10:	0412      	lsls	r2, r2, #16
        Csd->version.v2.Reserved1 = ((CSD_Tab[6] & 0x0F) << 2) | ((CSD_Tab[7] & 0xC0) >> 6);
 800ce12:	43b8      	bics	r0, r7
 800ce14:	4303      	orrs	r3, r0
 800ce16:	7223      	strb	r3, [r4, #8]
        Csd->version.v2.DeviceSize= ((CSD_Tab[7] & 0x3F) << 16) | (CSD_Tab[8] << 8) | CSD_Tab[9];    
 800ce18:	892b      	ldrh	r3, [r5, #8]
 800ce1a:	68a0      	ldr	r0, [r4, #8]
 800ce1c:	ba5b      	rev16	r3, r3
 800ce1e:	b29b      	uxth	r3, r3
 800ce20:	431a      	orrs	r2, r3
 800ce22:	4b3e      	ldr	r3, [pc, #248]	; (800cf1c <BSP_SD_GetCardInfo+0x37c>)
 800ce24:	0292      	lsls	r2, r2, #10
 800ce26:	0912      	lsrs	r2, r2, #4
 800ce28:	4003      	ands	r3, r0
 800ce2a:	431a      	orrs	r2, r3
 800ce2c:	60a2      	str	r2, [r4, #8]
        Csd->version.v2.Reserved2 = ((CSD_Tab[10] & 0x80) >> 8);
 800ce2e:	0e12      	lsrs	r2, r2, #24
 800ce30:	43b2      	bics	r2, r6
 800ce32:	72e2      	strb	r2, [r4, #11]
 800ce34:	e774      	b.n	800cd20 <BSP_SD_GetCardInfo+0x180>
    if(SD_WaitData(SD_TOKEN_START_DATA_SINGLE_BLOCK_READ) == BSP_SD_OK)
 800ce36:	f7ff fe39 	bl	800caac <SD_WaitData.constprop.1>
 800ce3a:	1e06      	subs	r6, r0, #0
 800ce3c:	d000      	beq.n	800ce40 <BSP_SD_GetCardInfo+0x2a0>
 800ce3e:	e6d0      	b.n	800cbe2 <BSP_SD_GetCardInfo+0x42>
      for (counter = 0; counter < 16; counter++)
 800ce40:	0007      	movs	r7, r0
        CID_Tab[counter] = SD_IO_WriteByte(SD_DUMMY_BYTE);
 800ce42:	20ff      	movs	r0, #255	; 0xff
 800ce44:	f7ff fbfd 	bl	800c642 <SD_IO_WriteByte>
 800ce48:	ad06      	add	r5, sp, #24
 800ce4a:	5578      	strb	r0, [r7, r5]
      for (counter = 0; counter < 16; counter++)
 800ce4c:	3701      	adds	r7, #1
 800ce4e:	2f10      	cmp	r7, #16
 800ce50:	d1f7      	bne.n	800ce42 <BSP_SD_GetCardInfo+0x2a2>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800ce52:	20ff      	movs	r0, #255	; 0xff
 800ce54:	f7ff fbf5 	bl	800c642 <SD_IO_WriteByte>
      SD_IO_WriteByte(SD_DUMMY_BYTE);
 800ce58:	20ff      	movs	r0, #255	; 0xff
 800ce5a:	f7ff fbf2 	bl	800c642 <SD_IO_WriteByte>
      Cid->ManufacturerID = CID_Tab[0];
 800ce5e:	782b      	ldrb	r3, [r5, #0]
      Cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
 800ce60:	0021      	movs	r1, r4
      Cid->ManufacturerID = CID_Tab[0];
 800ce62:	7623      	strb	r3, [r4, #24]
      Cid->OEM_AppliID = CID_Tab[1] << 8;
 800ce64:	786b      	ldrb	r3, [r5, #1]
      Cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
 800ce66:	3128      	adds	r1, #40	; 0x28
      Cid->OEM_AppliID = CID_Tab[1] << 8;
 800ce68:	021b      	lsls	r3, r3, #8
 800ce6a:	8363      	strh	r3, [r4, #26]
      Cid->OEM_AppliID |= CID_Tab[2];
 800ce6c:	8b63      	ldrh	r3, [r4, #26]
 800ce6e:	78aa      	ldrb	r2, [r5, #2]
 800ce70:	4313      	orrs	r3, r2
 800ce72:	8363      	strh	r3, [r4, #26]
      Cid->ProdName1 = CID_Tab[3] << 24;
 800ce74:	78eb      	ldrb	r3, [r5, #3]
 800ce76:	061b      	lsls	r3, r3, #24
 800ce78:	61e3      	str	r3, [r4, #28]
      Cid->ProdName1 |= CID_Tab[4] << 16;
 800ce7a:	792b      	ldrb	r3, [r5, #4]
 800ce7c:	69e2      	ldr	r2, [r4, #28]
 800ce7e:	041b      	lsls	r3, r3, #16
 800ce80:	4313      	orrs	r3, r2
 800ce82:	61e3      	str	r3, [r4, #28]
      Cid->ProdName1 |= CID_Tab[5] << 8;
 800ce84:	796b      	ldrb	r3, [r5, #5]
 800ce86:	69e2      	ldr	r2, [r4, #28]
 800ce88:	021b      	lsls	r3, r3, #8
 800ce8a:	4313      	orrs	r3, r2
 800ce8c:	61e3      	str	r3, [r4, #28]
      Cid->ProdName1 |= CID_Tab[6];
 800ce8e:	69e2      	ldr	r2, [r4, #28]
 800ce90:	79ab      	ldrb	r3, [r5, #6]
 800ce92:	4313      	orrs	r3, r2
 800ce94:	61e3      	str	r3, [r4, #28]
      Cid->ProdName2 = CID_Tab[7];
 800ce96:	79ea      	ldrb	r2, [r5, #7]
 800ce98:	1c63      	adds	r3, r4, #1
 800ce9a:	77da      	strb	r2, [r3, #31]
      Cid->ProdRev = CID_Tab[8];
 800ce9c:	7a2a      	ldrb	r2, [r5, #8]
 800ce9e:	1ca3      	adds	r3, r4, #2
 800cea0:	77da      	strb	r2, [r3, #31]
      Cid->ProdSN = CID_Tab[9] << 24;
 800cea2:	7a6b      	ldrb	r3, [r5, #9]
 800cea4:	061b      	lsls	r3, r3, #24
 800cea6:	6263      	str	r3, [r4, #36]	; 0x24
      Cid->ProdSN |= CID_Tab[10] << 16;
 800cea8:	7aab      	ldrb	r3, [r5, #10]
 800ceaa:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800ceac:	041b      	lsls	r3, r3, #16
 800ceae:	4313      	orrs	r3, r2
 800ceb0:	6263      	str	r3, [r4, #36]	; 0x24
      Cid->ProdSN |= CID_Tab[11] << 8;
 800ceb2:	7aeb      	ldrb	r3, [r5, #11]
 800ceb4:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800ceb6:	021b      	lsls	r3, r3, #8
 800ceb8:	4313      	orrs	r3, r2
 800ceba:	6263      	str	r3, [r4, #36]	; 0x24
      Cid->ProdSN |= CID_Tab[12];
 800cebc:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800cebe:	7b2b      	ldrb	r3, [r5, #12]
 800cec0:	4313      	orrs	r3, r2
 800cec2:	6263      	str	r3, [r4, #36]	; 0x24
      Cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
 800cec4:	7b6b      	ldrb	r3, [r5, #13]
 800cec6:	780a      	ldrb	r2, [r1, #0]
 800cec8:	0918      	lsrs	r0, r3, #4
 800ceca:	4302      	orrs	r2, r0
 800cecc:	700a      	strb	r2, [r1, #0]
      Cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
 800cece:	22f0      	movs	r2, #240	; 0xf0
 800ced0:	021b      	lsls	r3, r3, #8
 800ced2:	0112      	lsls	r2, r2, #4
 800ced4:	4013      	ands	r3, r2
 800ced6:	8563      	strh	r3, [r4, #42]	; 0x2a
      Cid->ManufactDate |= CID_Tab[14];
 800ced8:	7baa      	ldrb	r2, [r5, #14]
 800ceda:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800cedc:	4313      	orrs	r3, r2
      Cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
 800cede:	0022      	movs	r2, r4
      Cid->ManufactDate |= CID_Tab[14];
 800cee0:	8563      	strh	r3, [r4, #42]	; 0x2a
      Cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
 800cee2:	7beb      	ldrb	r3, [r5, #15]
 800cee4:	322c      	adds	r2, #44	; 0x2c
 800cee6:	085b      	lsrs	r3, r3, #1
 800cee8:	7013      	strb	r3, [r2, #0]
      Cid->Reserved2 = 1;
 800ceea:	0023      	movs	r3, r4
 800ceec:	2201      	movs	r2, #1
 800ceee:	332d      	adds	r3, #45	; 0x2d
 800cef0:	701a      	strb	r2, [r3, #0]
 800cef2:	e677      	b.n	800cbe4 <BSP_SD_GetCardInfo+0x44>
    pCardInfo->CardBlockSize = 1 << (pCardInfo->Csd.RdBlockLen);
 800cef4:	2101      	movs	r1, #1
    pCardInfo->CardCapacity = (pCardInfo->Csd.version.v1.DeviceSize + 1) ;
 800cef6:	8923      	ldrh	r3, [r4, #8]
    pCardInfo->CardCapacity *= (1 << (pCardInfo->Csd.version.v1.DeviceSizeMul + 2));
 800cef8:	7b22      	ldrb	r2, [r4, #12]
    pCardInfo->CardCapacity = (pCardInfo->Csd.version.v1.DeviceSize + 1) ;
 800cefa:	049b      	lsls	r3, r3, #18
    pCardInfo->CardCapacity *= (1 << (pCardInfo->Csd.version.v1.DeviceSizeMul + 2));
 800cefc:	0752      	lsls	r2, r2, #29
    pCardInfo->CardCapacity = (pCardInfo->Csd.version.v1.DeviceSize + 1) ;
 800cefe:	0d1b      	lsrs	r3, r3, #20
    pCardInfo->CardCapacity *= (1 << (pCardInfo->Csd.version.v1.DeviceSizeMul + 2));
 800cf00:	0f52      	lsrs	r2, r2, #29
 800cf02:	3202      	adds	r2, #2
    pCardInfo->CardCapacity = (pCardInfo->Csd.version.v1.DeviceSize + 1) ;
 800cf04:	3301      	adds	r3, #1
    pCardInfo->CardCapacity *= (1 << (pCardInfo->Csd.version.v1.DeviceSizeMul + 2));
 800cf06:	4093      	lsls	r3, r2
    pCardInfo->CardBlockSize = 1 << (pCardInfo->Csd.RdBlockLen);
 800cf08:	7962      	ldrb	r2, [r4, #5]
 800cf0a:	0912      	lsrs	r2, r2, #4
 800cf0c:	4091      	lsls	r1, r2
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 800cf0e:	4093      	lsls	r3, r2
    pCardInfo->CardBlockSize = 1 << (pCardInfo->Csd.RdBlockLen);
 800cf10:	6361      	str	r1, [r4, #52]	; 0x34
 800cf12:	e67c      	b.n	800cc0e <BSP_SD_GetCardInfo+0x6e>
 800cf14:	2000009a 	.word	0x2000009a
 800cf18:	ffffc003 	.word	0xffffc003
 800cf1c:	f000003f 	.word	0xf000003f

0800cf20 <SPIx_MspInit>:
  * @brief SPI MSP Init
  * @param hspi: SPI handle
  * @retval None
  */
void SPIx_MspInit(SPI_HandleTypeDef *hspi)
{
 800cf20:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Enable SPI clock  */
  SPIx_CLK_ENABLE();
 800cf22:	2580      	movs	r5, #128	; 0x80
 800cf24:	4c23      	ldr	r4, [pc, #140]	; (800cfb4 <SPIx_MspInit+0x94>)
 800cf26:	016d      	lsls	r5, r5, #5
 800cf28:	69a3      	ldr	r3, [r4, #24]
{
 800cf2a:	b08b      	sub	sp, #44	; 0x2c
  SPIx_CLK_ENABLE();
 800cf2c:	432b      	orrs	r3, r5
 800cf2e:	61a3      	str	r3, [r4, #24]
 800cf30:	69a3      	ldr	r3, [r4, #24]
  GPIO_InitStruct.Pin       = SPIx_SCK_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
  GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
  GPIO_InitStruct.Alternate = SPIx_SCK_AF;
  HAL_GPIO_Init(SPIx_SCK_GPIO_PORT, &GPIO_InitStruct);
 800cf32:	2790      	movs	r7, #144	; 0x90
  SPIx_CLK_ENABLE();
 800cf34:	402b      	ands	r3, r5
 800cf36:	9301      	str	r3, [sp, #4]
 800cf38:	9b01      	ldr	r3, [sp, #4]
  SPIx_SCK_GPIO_CLK_ENABLE();
 800cf3a:	2380      	movs	r3, #128	; 0x80
 800cf3c:	6962      	ldr	r2, [r4, #20]
 800cf3e:	029b      	lsls	r3, r3, #10
 800cf40:	431a      	orrs	r2, r3
 800cf42:	6162      	str	r2, [r4, #20]
 800cf44:	6962      	ldr	r2, [r4, #20]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 800cf46:	2600      	movs	r6, #0
  SPIx_SCK_GPIO_CLK_ENABLE();
 800cf48:	401a      	ands	r2, r3
 800cf4a:	9202      	str	r2, [sp, #8]
 800cf4c:	9a02      	ldr	r2, [sp, #8]
  SPIx_MISO_GPIO_CLK_ENABLE();
 800cf4e:	6962      	ldr	r2, [r4, #20]
  HAL_GPIO_Init(SPIx_SCK_GPIO_PORT, &GPIO_InitStruct);
 800cf50:	05ff      	lsls	r7, r7, #23
  SPIx_MISO_GPIO_CLK_ENABLE();
 800cf52:	431a      	orrs	r2, r3
 800cf54:	6162      	str	r2, [r4, #20]
 800cf56:	6962      	ldr	r2, [r4, #20]
  HAL_GPIO_Init(SPIx_SCK_GPIO_PORT, &GPIO_InitStruct);
 800cf58:	a905      	add	r1, sp, #20
  SPIx_MISO_GPIO_CLK_ENABLE();
 800cf5a:	401a      	ands	r2, r3
 800cf5c:	9203      	str	r2, [sp, #12]
 800cf5e:	9a03      	ldr	r2, [sp, #12]
  SPIx_MOSI_GPIO_CLK_ENABLE();
 800cf60:	6962      	ldr	r2, [r4, #20]
  HAL_GPIO_Init(SPIx_SCK_GPIO_PORT, &GPIO_InitStruct);
 800cf62:	0038      	movs	r0, r7
  SPIx_MOSI_GPIO_CLK_ENABLE();
 800cf64:	431a      	orrs	r2, r3
 800cf66:	6162      	str	r2, [r4, #20]
 800cf68:	6962      	ldr	r2, [r4, #20]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 800cf6a:	9607      	str	r6, [sp, #28]
  SPIx_MOSI_GPIO_CLK_ENABLE();
 800cf6c:	4013      	ands	r3, r2
 800cf6e:	9304      	str	r3, [sp, #16]
 800cf70:	9b04      	ldr	r3, [sp, #16]
  GPIO_InitStruct.Pin       = SPIx_SCK_PIN;
 800cf72:	2320      	movs	r3, #32
 800cf74:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800cf76:	3b1e      	subs	r3, #30
 800cf78:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 800cf7a:	3301      	adds	r3, #1
 800cf7c:	9308      	str	r3, [sp, #32]
  GPIO_InitStruct.Alternate = SPIx_SCK_AF;
 800cf7e:	9609      	str	r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(SPIx_SCK_GPIO_PORT, &GPIO_InitStruct);
 800cf80:	f005 f90c 	bl	801219c <HAL_GPIO_Init>
  
  /* configure SPI MOSI */
  GPIO_InitStruct.Pin       = SPIx_MOSI_PIN;
 800cf84:	2380      	movs	r3, #128	; 0x80
  GPIO_InitStruct.Alternate = SPIx_MOSI_AF;
  HAL_GPIO_Init(SPIx_MOSI_GPIO_PORT, &GPIO_InitStruct);
 800cf86:	a905      	add	r1, sp, #20
 800cf88:	0038      	movs	r0, r7
  GPIO_InitStruct.Pin       = SPIx_MOSI_PIN;
 800cf8a:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = SPIx_MOSI_AF;
 800cf8c:	9609      	str	r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(SPIx_MOSI_GPIO_PORT, &GPIO_InitStruct);
 800cf8e:	f005 f905 	bl	801219c <HAL_GPIO_Init>
  
  /* configure SPI MISO  */
  GPIO_InitStruct.Pin       = SPIx_MISO_PIN;
 800cf92:	2340      	movs	r3, #64	; 0x40
  GPIO_InitStruct.Alternate = SPIx_MISO_AF;
  HAL_GPIO_Init(SPIx_MISO_GPIO_PORT, &GPIO_InitStruct);
 800cf94:	a905      	add	r1, sp, #20
 800cf96:	0038      	movs	r0, r7
  GPIO_InitStruct.Pin       = SPIx_MISO_PIN;
 800cf98:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = SPIx_MISO_AF;
 800cf9a:	9609      	str	r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(SPIx_MISO_GPIO_PORT, &GPIO_InitStruct);
 800cf9c:	f005 f8fe 	bl	801219c <HAL_GPIO_Init>
  
  /* Force the SPI peripheral clock reset */
  SPIx_FORCE_RESET();
 800cfa0:	68e3      	ldr	r3, [r4, #12]

  /* Release the SPI peripheral clock reset */
  SPIx_RELEASE_RESET();
 800cfa2:	4a05      	ldr	r2, [pc, #20]	; (800cfb8 <SPIx_MspInit+0x98>)
  SPIx_FORCE_RESET();
 800cfa4:	431d      	orrs	r5, r3
 800cfa6:	60e5      	str	r5, [r4, #12]
  SPIx_RELEASE_RESET();
 800cfa8:	68e3      	ldr	r3, [r4, #12]
 800cfaa:	4013      	ands	r3, r2
 800cfac:	60e3      	str	r3, [r4, #12]
}
 800cfae:	b00b      	add	sp, #44	; 0x2c
 800cfb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cfb2:	46c0      	nop			; (mov r8, r8)
 800cfb4:	40021000 	.word	0x40021000
 800cfb8:	ffffefff 	.word	0xffffefff

0800cfbc <SPIx_Init>:
	hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
 800cfbc:	2201      	movs	r2, #1
{
 800cfbe:	b510      	push	{r4, lr}
	hspi1.Instance = SPI1;
 800cfc0:	4c0f      	ldr	r4, [pc, #60]	; (800d000 <SPIx_Init+0x44>)
 800cfc2:	4b10      	ldr	r3, [pc, #64]	; (800d004 <SPIx_Init+0x48>)
	hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
 800cfc4:	6162      	str	r2, [r4, #20]
	hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
 800cfc6:	1892      	adds	r2, r2, r2
 800cfc8:	6122      	str	r2, [r4, #16]
	hspi1.Init.CRCPolynomial = 7;
 800cfca:	3205      	adds	r2, #5
	hspi1.Instance = SPI1;
 800cfcc:	6023      	str	r3, [r4, #0]
	hspi1.Init.CRCPolynomial = 7;
 800cfce:	62e2      	str	r2, [r4, #44]	; 0x2c
	hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 800cfd0:	2308      	movs	r3, #8
	hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 800cfd2:	22e0      	movs	r2, #224	; 0xe0
	hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 800cfd4:	61e3      	str	r3, [r4, #28]
	hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 800cfd6:	00d2      	lsls	r2, r2, #3
	hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 800cfd8:	2300      	movs	r3, #0
	hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 800cfda:	60e2      	str	r2, [r4, #12]
	hspi1.Init.NSS = SPI_NSS_SOFT;
 800cfdc:	2280      	movs	r2, #128	; 0x80
	hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 800cfde:	60a3      	str	r3, [r4, #8]
	hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800cfe0:	62a3      	str	r3, [r4, #40]	; 0x28
	hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800cfe2:	6223      	str	r3, [r4, #32]
	hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 800cfe4:	6263      	str	r3, [r4, #36]	; 0x24
	hspi1.Init.Mode = SPI_MODE_MASTER;
 800cfe6:	3305      	adds	r3, #5
	hspi1.Init.NSS = SPI_NSS_SOFT;
 800cfe8:	0092      	lsls	r2, r2, #2
	hspi1.Init.Mode = SPI_MODE_MASTER;
 800cfea:	33ff      	adds	r3, #255	; 0xff
	SPIx_MspInit(&hspi1);
 800cfec:	0020      	movs	r0, r4
	hspi1.Init.NSS = SPI_NSS_SOFT;
 800cfee:	61a2      	str	r2, [r4, #24]
	hspi1.Init.Mode = SPI_MODE_MASTER;
 800cff0:	6063      	str	r3, [r4, #4]
	SPIx_MspInit(&hspi1);
 800cff2:	f7ff ff95 	bl	800cf20 <SPIx_MspInit>
	HAL_SPI_Init(&hspi1);
 800cff6:	0020      	movs	r0, r4
 800cff8:	f006 f848 	bl	801308c <HAL_SPI_Init>
}
 800cffc:	bd10      	pop	{r4, pc}
 800cffe:	46c0      	nop			; (mov r8, r8)
 800d000:	20007968 	.word	0x20007968
 800d004:	40013000 	.word	0x40013000

0800d008 <SPIx_Error>:
{
 800d008:	b510      	push	{r4, lr}
  HAL_SPI_DeInit(&hspi1);
 800d00a:	4803      	ldr	r0, [pc, #12]	; (800d018 <SPIx_Error+0x10>)
 800d00c:	f006 f8ad 	bl	801316a <HAL_SPI_DeInit>
  SPIx_Init();
 800d010:	f7ff ffd4 	bl	800cfbc <SPIx_Init>
}
 800d014:	bd10      	pop	{r4, pc}
 800d016:	46c0      	nop			; (mov r8, r8)
 800d018:	20007968 	.word	0x20007968

0800d01c <SPIx_WriteReadData>:
{
 800d01c:	b507      	push	{r0, r1, r2, lr}
 800d01e:	0013      	movs	r3, r2
  status = HAL_SPI_TransmitReceive(&hspi1, (uint8_t*) DataIn, DataOut, DataLegnth, SpixTimeout);
 800d020:	4a06      	ldr	r2, [pc, #24]	; (800d03c <SPIx_WriteReadData+0x20>)
 800d022:	6812      	ldr	r2, [r2, #0]
 800d024:	9200      	str	r2, [sp, #0]
 800d026:	000a      	movs	r2, r1
 800d028:	0001      	movs	r1, r0
 800d02a:	4805      	ldr	r0, [pc, #20]	; (800d040 <SPIx_WriteReadData+0x24>)
 800d02c:	f006 f8b4 	bl	8013198 <HAL_SPI_TransmitReceive>
  if(status != HAL_OK)
 800d030:	2800      	cmp	r0, #0
 800d032:	d001      	beq.n	800d038 <SPIx_WriteReadData+0x1c>
    SPIx_Error();
 800d034:	f7ff ffe8 	bl	800d008 <SPIx_Error>
}
 800d038:	bd07      	pop	{r0, r1, r2, pc}
 800d03a:	46c0      	nop			; (mov r8, r8)
 800d03c:	2000009c 	.word	0x2000009c
 800d040:	20007968 	.word	0x20007968

0800d044 <TIM_USEC_Init>:
void TIM_USEC_Init(void)
{
  TIM_MasterConfigTypeDef sMasterConfig;
	
	/* Peripheral clock enable */
	__TIM14_CLK_ENABLE();
 800d044:	2080      	movs	r0, #128	; 0x80
{
 800d046:	b530      	push	{r4, r5, lr}
	__TIM14_CLK_ENABLE();
 800d048:	4a12      	ldr	r2, [pc, #72]	; (800d094 <TIM_USEC_Init+0x50>)
 800d04a:	0040      	lsls	r0, r0, #1
 800d04c:	69d1      	ldr	r1, [r2, #28]
{
 800d04e:	b085      	sub	sp, #20
	__TIM14_CLK_ENABLE();
 800d050:	4301      	orrs	r1, r0
 800d052:	61d1      	str	r1, [r2, #28]
 800d054:	69d3      	ldr	r3, [r2, #28]

	/* Peripheral configuration */
  htim14.Instance = TIM14;
 800d056:	4c10      	ldr	r4, [pc, #64]	; (800d098 <TIM_USEC_Init+0x54>)
	__TIM14_CLK_ENABLE();
 800d058:	4003      	ands	r3, r0
 800d05a:	9301      	str	r3, [sp, #4]
 800d05c:	9b01      	ldr	r3, [sp, #4]
  htim14.Instance = TIM14;
 800d05e:	4b0f      	ldr	r3, [pc, #60]	; (800d09c <TIM_USEC_Init+0x58>)
  htim14.Init.Prescaler = HAL_RCC_GetPCLK1Freq()/1000000;
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 800d060:	2500      	movs	r5, #0
  htim14.Instance = TIM14;
 800d062:	6023      	str	r3, [r4, #0]
  htim14.Init.Prescaler = HAL_RCC_GetPCLK1Freq()/1000000;
 800d064:	f005 fd0a 	bl	8012a7c <HAL_RCC_GetPCLK1Freq>
 800d068:	490d      	ldr	r1, [pc, #52]	; (800d0a0 <TIM_USEC_Init+0x5c>)
 800d06a:	f7f3 f885 	bl	8000178 <__udivsi3>
  htim14.Init.Period = 0xFFFF;
 800d06e:	4b0d      	ldr	r3, [pc, #52]	; (800d0a4 <TIM_USEC_Init+0x60>)
  htim14.Init.Prescaler = HAL_RCC_GetPCLK1Freq()/1000000;
 800d070:	6060      	str	r0, [r4, #4]
  HAL_TIM_Base_Init(&htim14);
 800d072:	0020      	movs	r0, r4
  htim14.Init.Period = 0xFFFF;
 800d074:	60e3      	str	r3, [r4, #12]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 800d076:	60a5      	str	r5, [r4, #8]
  HAL_TIM_Base_Init(&htim14);
 800d078:	f006 fb14 	bl	80136a4 <HAL_TIM_Base_Init>

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  HAL_TIMEx_MasterConfigSynchronization(&htim14, &sMasterConfig);
 800d07c:	a902      	add	r1, sp, #8
 800d07e:	0020      	movs	r0, r4
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800d080:	9502      	str	r5, [sp, #8]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800d082:	9503      	str	r5, [sp, #12]
  HAL_TIMEx_MasterConfigSynchronization(&htim14, &sMasterConfig);
 800d084:	f006 fb29 	bl	80136da <HAL_TIMEx_MasterConfigSynchronization>
	
	HAL_TIM_Base_Start(&htim14);
 800d088:	0020      	movs	r0, r4
 800d08a:	f006 f9de 	bl	801344a <HAL_TIM_Base_Start>
}
 800d08e:	b005      	add	sp, #20
 800d090:	bd30      	pop	{r4, r5, pc}
 800d092:	46c0      	nop			; (mov r8, r8)
 800d094:	40021000 	.word	0x40021000
 800d098:	20007a08 	.word	0x20007a08
 800d09c:	40002000 	.word	0x40002000
 800d0a0:	000f4240 	.word	0x000f4240
 800d0a4:	0000ffff 	.word	0x0000ffff

0800d0a8 <TIM_MSEC_Init>:
void TIM_MSEC_Init(void)
{
  TIM_MasterConfigTypeDef sMasterConfig;
	
	/* Peripheral clock enable */
	__TIM15_CLK_ENABLE();
 800d0a8:	2080      	movs	r0, #128	; 0x80
{
 800d0aa:	b530      	push	{r4, r5, lr}
	__TIM15_CLK_ENABLE();
 800d0ac:	4a12      	ldr	r2, [pc, #72]	; (800d0f8 <TIM_MSEC_Init+0x50>)
 800d0ae:	0240      	lsls	r0, r0, #9
 800d0b0:	6991      	ldr	r1, [r2, #24]
{
 800d0b2:	b085      	sub	sp, #20
	__TIM15_CLK_ENABLE();
 800d0b4:	4301      	orrs	r1, r0
 800d0b6:	6191      	str	r1, [r2, #24]
 800d0b8:	6993      	ldr	r3, [r2, #24]

	/* Peripheral configuration */
  htim15.Instance = TIM15;
 800d0ba:	4c10      	ldr	r4, [pc, #64]	; (800d0fc <TIM_MSEC_Init+0x54>)
	__TIM15_CLK_ENABLE();
 800d0bc:	4003      	ands	r3, r0
 800d0be:	9301      	str	r3, [sp, #4]
 800d0c0:	9b01      	ldr	r3, [sp, #4]
  htim15.Instance = TIM15;
 800d0c2:	4b0f      	ldr	r3, [pc, #60]	; (800d100 <TIM_MSEC_Init+0x58>)
  htim15.Init.Prescaler = HAL_RCC_GetPCLK1Freq()/1000;
  htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 800d0c4:	2500      	movs	r5, #0
  htim15.Instance = TIM15;
 800d0c6:	6023      	str	r3, [r4, #0]
  htim15.Init.Prescaler = HAL_RCC_GetPCLK1Freq()/1000;
 800d0c8:	f005 fcd8 	bl	8012a7c <HAL_RCC_GetPCLK1Freq>
 800d0cc:	21fa      	movs	r1, #250	; 0xfa
 800d0ce:	0089      	lsls	r1, r1, #2
 800d0d0:	f7f3 f852 	bl	8000178 <__udivsi3>
  htim15.Init.Period = 0xFFFF;
 800d0d4:	4b0b      	ldr	r3, [pc, #44]	; (800d104 <TIM_MSEC_Init+0x5c>)
  htim15.Init.Prescaler = HAL_RCC_GetPCLK1Freq()/1000;
 800d0d6:	6060      	str	r0, [r4, #4]
  HAL_TIM_Base_Init(&htim15);
 800d0d8:	0020      	movs	r0, r4
  htim15.Init.Period = 0xFFFF;
 800d0da:	60e3      	str	r3, [r4, #12]
  htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 800d0dc:	60a5      	str	r5, [r4, #8]
  HAL_TIM_Base_Init(&htim15);
 800d0de:	f006 fae1 	bl	80136a4 <HAL_TIM_Base_Init>

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  HAL_TIMEx_MasterConfigSynchronization(&htim15, &sMasterConfig);
 800d0e2:	a902      	add	r1, sp, #8
 800d0e4:	0020      	movs	r0, r4
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800d0e6:	9502      	str	r5, [sp, #8]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800d0e8:	9503      	str	r5, [sp, #12]
  HAL_TIMEx_MasterConfigSynchronization(&htim15, &sMasterConfig);
 800d0ea:	f006 faf6 	bl	80136da <HAL_TIMEx_MasterConfigSynchronization>
	
	HAL_TIM_Base_Start(&htim15);
 800d0ee:	0020      	movs	r0, r4
 800d0f0:	f006 f9ab 	bl	801344a <HAL_TIM_Base_Start>
}
 800d0f4:	b005      	add	sp, #20
 800d0f6:	bd30      	pop	{r4, r5, pc}
 800d0f8:	40021000 	.word	0x40021000
 800d0fc:	200079cc 	.word	0x200079cc
 800d100:	40014000 	.word	0x40014000
 800d104:	0000ffff 	.word	0x0000ffff

0800d108 <StartMicroDelay>:
/*-----------------------------------------------------------*/

/* --- Load and start micro-second delay counter --- 
*/
void StartMicroDelay(uint16_t Delay)
{
 800d108:	b510      	push	{r4, lr}
 800d10a:	0004      	movs	r4, r0
	uint32_t t0=0;

	portENTER_CRITICAL();
 800d10c:	f004 f8ae 	bl	801126c <vPortEnterCritical>
	
	if (Delay)
 800d110:	2c00      	cmp	r4, #0
 800d112:	d006      	beq.n	800d122 <StartMicroDelay+0x1a>
	{
		t0 = htim14.Instance->CNT;
 800d114:	4b04      	ldr	r3, [pc, #16]	; (800d128 <StartMicroDelay+0x20>)
 800d116:	681a      	ldr	r2, [r3, #0]
 800d118:	6a51      	ldr	r1, [r2, #36]	; 0x24

		while(htim14.Instance->CNT - t0 <= Delay) {};
 800d11a:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800d11c:	1a5b      	subs	r3, r3, r1
 800d11e:	42a3      	cmp	r3, r4
 800d120:	d9fb      	bls.n	800d11a <StartMicroDelay+0x12>
	}
	
	portEXIT_CRITICAL();
 800d122:	f004 f8af 	bl	8011284 <vPortExitCritical>
}
 800d126:	bd10      	pop	{r4, pc}
 800d128:	20007a08 	.word	0x20007a08

0800d12c <StartMilliDelay>:
/*-----------------------------------------------------------*/

/* --- Load and start milli-second delay counter --- 
*/
void StartMilliDelay(uint16_t Delay)
{
 800d12c:	b510      	push	{r4, lr}
 800d12e:	0004      	movs	r4, r0
	uint32_t t0=0;
	
	portENTER_CRITICAL();
 800d130:	f004 f89c 	bl	801126c <vPortEnterCritical>
	
	if (Delay)
 800d134:	2c00      	cmp	r4, #0
 800d136:	d006      	beq.n	800d146 <StartMilliDelay+0x1a>
	{
		t0 = htim15.Instance->CNT;
 800d138:	4b04      	ldr	r3, [pc, #16]	; (800d14c <StartMilliDelay+0x20>)
 800d13a:	681a      	ldr	r2, [r3, #0]
 800d13c:	6a51      	ldr	r1, [r2, #36]	; 0x24

		while(htim15.Instance->CNT - t0 <= Delay) {};
 800d13e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800d140:	1a5b      	subs	r3, r3, r1
 800d142:	42a3      	cmp	r3, r4
 800d144:	d9fb      	bls.n	800d13e <StartMilliDelay+0x12>
	}
	
	portEXIT_CRITICAL();
 800d146:	f004 f89d 	bl	8011284 <vPortExitCritical>
}
 800d14a:	bd10      	pop	{r4, pc}
 800d14c:	200079cc 	.word	0x200079cc

0800d150 <MX_USART1_UART_Init>:

/* USART1 init function */
#ifdef _Usart1
void MX_USART1_UART_Init(void)
{
  huart1.Instance = USART1;
 800d150:	4809      	ldr	r0, [pc, #36]	; (800d178 <MX_USART1_UART_Init+0x28>)
 800d152:	4b0a      	ldr	r3, [pc, #40]	; (800d17c <MX_USART1_UART_Init+0x2c>)
{
 800d154:	b510      	push	{r4, lr}
  huart1.Instance = USART1;
 800d156:	6003      	str	r3, [r0, #0]
  huart1.Init.BaudRate = DEF_ARRAY_BAUDRATE;
 800d158:	23e1      	movs	r3, #225	; 0xe1
 800d15a:	031b      	lsls	r3, r3, #12
 800d15c:	6043      	str	r3, [r0, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
 800d15e:	220c      	movs	r2, #12
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800d160:	2300      	movs	r3, #0
  huart1.Init.Mode = UART_MODE_TX_RX;
 800d162:	6142      	str	r2, [r0, #20]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800d164:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 800d166:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 800d168:	6103      	str	r3, [r0, #16]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800d16a:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 800d16c:	61c3      	str	r3, [r0, #28]
  huart1.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED;
 800d16e:	6203      	str	r3, [r0, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800d170:	6243      	str	r3, [r0, #36]	; 0x24
	HAL_UART_Init(&huart1);
 800d172:	f006 fe8b 	bl	8013e8c <HAL_UART_Init>
	#if _P4pol_reversed	
		huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
		huart1.AdvancedInit.Swap = UART_ADVFEATURE_SWAP_ENABLE;
	  HAL_UART_Init(&huart1);
	#endif	
}
 800d176:	bd10      	pop	{r4, pc}
 800d178:	20007424 	.word	0x20007424
 800d17c:	40013800 	.word	0x40013800

0800d180 <MX_USART2_UART_Init>:

/* USART2 init function */
#ifdef _Usart2
void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
 800d180:	4809      	ldr	r0, [pc, #36]	; (800d1a8 <MX_USART2_UART_Init+0x28>)
 800d182:	4b0a      	ldr	r3, [pc, #40]	; (800d1ac <MX_USART2_UART_Init+0x2c>)
{
 800d184:	b510      	push	{r4, lr}
  huart2.Instance = USART2;
 800d186:	6003      	str	r3, [r0, #0]
  huart2.Init.BaudRate = DEF_ARRAY_BAUDRATE;
 800d188:	23e1      	movs	r3, #225	; 0xe1
 800d18a:	031b      	lsls	r3, r3, #12
 800d18c:	6043      	str	r3, [r0, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 800d18e:	220c      	movs	r2, #12
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800d190:	2300      	movs	r3, #0
  huart2.Init.Mode = UART_MODE_TX_RX;
 800d192:	6142      	str	r2, [r0, #20]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800d194:	6083      	str	r3, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 800d196:	60c3      	str	r3, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 800d198:	6103      	str	r3, [r0, #16]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800d19a:	6183      	str	r3, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 800d19c:	61c3      	str	r3, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED;
 800d19e:	6203      	str	r3, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800d1a0:	6243      	str	r3, [r0, #36]	; 0x24
	HAL_UART_Init(&huart2);
 800d1a2:	f006 fe73 	bl	8013e8c <HAL_UART_Init>
	#if _P2pol_reversed
		huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
		huart2.AdvancedInit.Swap = UART_ADVFEATURE_SWAP_ENABLE;
	  HAL_UART_Init(&huart2);
	#endif	
}
 800d1a6:	bd10      	pop	{r4, pc}
 800d1a8:	200077d0 	.word	0x200077d0
 800d1ac:	40004400 	.word	0x40004400

0800d1b0 <MX_USART3_UART_Init>:

/* USART3 init function */
#ifdef _Usart3
void MX_USART3_UART_Init(void)
{
  huart3.Instance = USART3;
 800d1b0:	4809      	ldr	r0, [pc, #36]	; (800d1d8 <MX_USART3_UART_Init+0x28>)
 800d1b2:	4b0a      	ldr	r3, [pc, #40]	; (800d1dc <MX_USART3_UART_Init+0x2c>)
{
 800d1b4:	b510      	push	{r4, lr}
  huart3.Instance = USART3;
 800d1b6:	6003      	str	r3, [r0, #0]
  huart3.Init.BaudRate = DEF_ARRAY_BAUDRATE;
 800d1b8:	23e1      	movs	r3, #225	; 0xe1
 800d1ba:	031b      	lsls	r3, r3, #12
 800d1bc:	6043      	str	r3, [r0, #4]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
 800d1be:	220c      	movs	r2, #12
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 800d1c0:	2300      	movs	r3, #0
  huart3.Init.Mode = UART_MODE_TX_RX;
 800d1c2:	6142      	str	r2, [r0, #20]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 800d1c4:	6083      	str	r3, [r0, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 800d1c6:	60c3      	str	r3, [r0, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 800d1c8:	6103      	str	r3, [r0, #16]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800d1ca:	6183      	str	r3, [r0, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 800d1cc:	61c3      	str	r3, [r0, #28]
  huart3.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED;
 800d1ce:	6203      	str	r3, [r0, #32]
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800d1d0:	6243      	str	r3, [r0, #36]	; 0x24
	HAL_UART_Init(&huart3);
 800d1d2:	f006 fe5b 	bl	8013e8c <HAL_UART_Init>
	#if _P3pol_reversed	
		huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
		huart3.AdvancedInit.Swap = UART_ADVFEATURE_SWAP_ENABLE;
	  HAL_UART_Init(&huart3);
	#endif	
}
 800d1d6:	bd10      	pop	{r4, pc}
 800d1d8:	200070dc 	.word	0x200070dc
 800d1dc:	40004800 	.word	0x40004800

0800d1e0 <MX_USART4_UART_Init>:

/* USART4 init function */
#ifdef _Usart4
void MX_USART4_UART_Init(void)
{
  huart4.Instance = USART4;
 800d1e0:	4809      	ldr	r0, [pc, #36]	; (800d208 <MX_USART4_UART_Init+0x28>)
 800d1e2:	4b0a      	ldr	r3, [pc, #40]	; (800d20c <MX_USART4_UART_Init+0x2c>)
{
 800d1e4:	b510      	push	{r4, lr}
  huart4.Instance = USART4;
 800d1e6:	6003      	str	r3, [r0, #0]
  huart4.Init.BaudRate = DEF_ARRAY_BAUDRATE;
 800d1e8:	23e1      	movs	r3, #225	; 0xe1
 800d1ea:	031b      	lsls	r3, r3, #12
 800d1ec:	6043      	str	r3, [r0, #4]
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
  huart4.Init.StopBits = UART_STOPBITS_1;
  huart4.Init.Parity = UART_PARITY_NONE;
  huart4.Init.Mode = UART_MODE_TX_RX;
 800d1ee:	220c      	movs	r2, #12
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
 800d1f0:	2300      	movs	r3, #0
  huart4.Init.Mode = UART_MODE_TX_RX;
 800d1f2:	6142      	str	r2, [r0, #20]
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
 800d1f4:	6083      	str	r3, [r0, #8]
  huart4.Init.StopBits = UART_STOPBITS_1;
 800d1f6:	60c3      	str	r3, [r0, #12]
  huart4.Init.Parity = UART_PARITY_NONE;
 800d1f8:	6103      	str	r3, [r0, #16]
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800d1fa:	6183      	str	r3, [r0, #24]
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
 800d1fc:	61c3      	str	r3, [r0, #28]
  huart4.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED;
 800d1fe:	6203      	str	r3, [r0, #32]
  huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800d200:	6243      	str	r3, [r0, #36]	; 0x24
	HAL_UART_Init(&huart4);
 800d202:	f006 fe43 	bl	8013e8c <HAL_UART_Init>
	#if _P1pol_reversed	
		huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
		huart4.AdvancedInit.Swap = UART_ADVFEATURE_SWAP_ENABLE;
	  HAL_UART_Init(&huart4);
	#endif	
}
 800d206:	bd10      	pop	{r4, pc}
 800d208:	20007758 	.word	0x20007758
 800d20c:	40004c00 	.word	0x40004c00

0800d210 <MX_USART5_UART_Init>:

/* USART5 init function */
#ifdef _Usart5
void MX_USART5_UART_Init(void)
{
  huart5.Instance = USART5;
 800d210:	4809      	ldr	r0, [pc, #36]	; (800d238 <MX_USART5_UART_Init+0x28>)
 800d212:	4b0a      	ldr	r3, [pc, #40]	; (800d23c <MX_USART5_UART_Init+0x2c>)
{
 800d214:	b510      	push	{r4, lr}
  huart5.Instance = USART5;
 800d216:	6003      	str	r3, [r0, #0]
  huart5.Init.BaudRate = DEF_ARRAY_BAUDRATE;
 800d218:	23e1      	movs	r3, #225	; 0xe1
 800d21a:	031b      	lsls	r3, r3, #12
 800d21c:	6043      	str	r3, [r0, #4]
  huart5.Init.WordLength = UART_WORDLENGTH_8B;
  huart5.Init.StopBits = UART_STOPBITS_1;
  huart5.Init.Parity = UART_PARITY_NONE;
  huart5.Init.Mode = UART_MODE_TX_RX;
 800d21e:	220c      	movs	r2, #12
  huart5.Init.WordLength = UART_WORDLENGTH_8B;
 800d220:	2300      	movs	r3, #0
  huart5.Init.Mode = UART_MODE_TX_RX;
 800d222:	6142      	str	r2, [r0, #20]
  huart5.Init.WordLength = UART_WORDLENGTH_8B;
 800d224:	6083      	str	r3, [r0, #8]
  huart5.Init.StopBits = UART_STOPBITS_1;
 800d226:	60c3      	str	r3, [r0, #12]
  huart5.Init.Parity = UART_PARITY_NONE;
 800d228:	6103      	str	r3, [r0, #16]
  huart5.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800d22a:	6183      	str	r3, [r0, #24]
  huart5.Init.OverSampling = UART_OVERSAMPLING_16;
 800d22c:	61c3      	str	r3, [r0, #28]
  huart5.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED;
 800d22e:	6203      	str	r3, [r0, #32]
  huart5.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800d230:	6243      	str	r3, [r0, #36]	; 0x24
	HAL_UART_Init(&huart5);
 800d232:	f006 fe2b 	bl	8013e8c <HAL_UART_Init>
	#if _P5pol_reversed	
		huart5.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
		huart5.AdvancedInit.Swap = UART_ADVFEATURE_SWAP_ENABLE;
	  HAL_UART_Init(&huart5);
	#endif	
}
 800d236:	bd10      	pop	{r4, pc}
 800d238:	200073b0 	.word	0x200073b0
 800d23c:	40005000 	.word	0x40005000

0800d240 <HAL_UART_MspInit>:
	#endif	
}
#endif

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 800d240:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART1)
 800d242:	4a68      	ldr	r2, [pc, #416]	; (800d3e4 <HAL_UART_MspInit+0x1a4>)
 800d244:	6803      	ldr	r3, [r0, #0]
{
 800d246:	b08b      	sub	sp, #44	; 0x2c
  if(huart->Instance==USART1)
 800d248:	4293      	cmp	r3, r2
 800d24a:	d12e      	bne.n	800d2aa <HAL_UART_MspInit+0x6a>
  {
	#ifdef _Usart1
    /* Peripheral clock enable */
    __USART1_CLK_ENABLE();
 800d24c:	2080      	movs	r0, #128	; 0x80
 800d24e:	4a66      	ldr	r2, [pc, #408]	; (800d3e8 <HAL_UART_MspInit+0x1a8>)
 800d250:	01c0      	lsls	r0, r0, #7
 800d252:	6991      	ldr	r1, [r2, #24]
  
    /* USART1 GPIO Configuration */
    GPIO_InitStruct.Pin = USART1_TX_PIN; 
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d254:	2401      	movs	r4, #1
    __USART1_CLK_ENABLE();
 800d256:	4301      	orrs	r1, r0
 800d258:	6191      	str	r1, [r2, #24]
 800d25a:	6993      	ldr	r3, [r2, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d25c:	2602      	movs	r6, #2
    __USART1_CLK_ENABLE();
 800d25e:	4003      	ands	r3, r0
 800d260:	9300      	str	r3, [sp, #0]
 800d262:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = USART1_AF;	
    HAL_GPIO_Init(USART1_TX_PORT, &GPIO_InitStruct);
 800d264:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Pin = USART1_TX_PIN; 
 800d266:	2380      	movs	r3, #128	; 0x80
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d268:	2503      	movs	r5, #3
    GPIO_InitStruct.Pin = USART1_TX_PIN; 
 800d26a:	009b      	lsls	r3, r3, #2
    HAL_GPIO_Init(USART1_TX_PORT, &GPIO_InitStruct);
 800d26c:	a905      	add	r1, sp, #20
 800d26e:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Pin = USART1_TX_PIN; 
 800d270:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d272:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d274:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d276:	9508      	str	r5, [sp, #32]
    GPIO_InitStruct.Alternate = USART1_AF;	
 800d278:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART1_TX_PORT, &GPIO_InitStruct);
 800d27a:	f004 ff8f 	bl	801219c <HAL_GPIO_Init>
		
		GPIO_InitStruct.Pin = USART1_RX_PIN;  
 800d27e:	2380      	movs	r3, #128	; 0x80
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = USART1_AF;
    HAL_GPIO_Init(USART1_RX_PORT, &GPIO_InitStruct);
 800d280:	2090      	movs	r0, #144	; 0x90
		GPIO_InitStruct.Pin = USART1_RX_PIN;  
 800d282:	00db      	lsls	r3, r3, #3
    HAL_GPIO_Init(USART1_RX_PORT, &GPIO_InitStruct);
 800d284:	a905      	add	r1, sp, #20
 800d286:	05c0      	lsls	r0, r0, #23
		GPIO_InitStruct.Pin = USART1_RX_PIN;  
 800d288:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d28a:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d28c:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d28e:	9508      	str	r5, [sp, #32]
    GPIO_InitStruct.Alternate = USART1_AF;
 800d290:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART1_RX_PORT, &GPIO_InitStruct);
 800d292:	f004 ff83 	bl	801219c <HAL_GPIO_Init>

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);
 800d296:	201b      	movs	r0, #27
 800d298:	2200      	movs	r2, #0
 800d29a:	0021      	movs	r1, r4
 800d29c:	f004 f950 	bl	8011540 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 800d2a0:	201b      	movs	r0, #27
    GPIO_InitStruct.Alternate = USART5_AF;
    HAL_GPIO_Init(USART5_RX_PORT, &GPIO_InitStruct);

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USART3_8_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(USART3_8_IRQn);
 800d2a2:	f004 f977 	bl	8011594 <HAL_NVIC_EnableIRQ>
    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USART3_8_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(USART3_8_IRQn);
	#endif
  }
}
 800d2a6:	b00b      	add	sp, #44	; 0x2c
 800d2a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(huart->Instance==USART2)
 800d2aa:	4a50      	ldr	r2, [pc, #320]	; (800d3ec <HAL_UART_MspInit+0x1ac>)
 800d2ac:	4293      	cmp	r3, r2
 800d2ae:	d129      	bne.n	800d304 <HAL_UART_MspInit+0xc4>
    __USART2_CLK_ENABLE();
 800d2b0:	2080      	movs	r0, #128	; 0x80
 800d2b2:	4a4d      	ldr	r2, [pc, #308]	; (800d3e8 <HAL_UART_MspInit+0x1a8>)
 800d2b4:	0280      	lsls	r0, r0, #10
 800d2b6:	69d1      	ldr	r1, [r2, #28]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d2b8:	2401      	movs	r4, #1
    __USART2_CLK_ENABLE();
 800d2ba:	4301      	orrs	r1, r0
 800d2bc:	61d1      	str	r1, [r2, #28]
 800d2be:	69d3      	ldr	r3, [r2, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d2c0:	2602      	movs	r6, #2
    __USART2_CLK_ENABLE();
 800d2c2:	4003      	ands	r3, r0
 800d2c4:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USART2_TX_PORT, &GPIO_InitStruct);
 800d2c6:	2090      	movs	r0, #144	; 0x90
    __USART2_CLK_ENABLE();
 800d2c8:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d2ca:	2503      	movs	r5, #3
    GPIO_InitStruct.Pin = USART2_TX_PIN; 
 800d2cc:	2304      	movs	r3, #4
    HAL_GPIO_Init(USART2_TX_PORT, &GPIO_InitStruct);
 800d2ce:	a905      	add	r1, sp, #20
 800d2d0:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Pin = USART2_TX_PIN; 
 800d2d2:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d2d4:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d2d6:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d2d8:	9508      	str	r5, [sp, #32]
    GPIO_InitStruct.Alternate = USART2_AF;	
 800d2da:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART2_TX_PORT, &GPIO_InitStruct);
 800d2dc:	f004 ff5e 	bl	801219c <HAL_GPIO_Init>
    HAL_GPIO_Init(USART2_RX_PORT, &GPIO_InitStruct);
 800d2e0:	2090      	movs	r0, #144	; 0x90
		GPIO_InitStruct.Pin = USART2_RX_PIN;  
 800d2e2:	2308      	movs	r3, #8
    HAL_GPIO_Init(USART2_RX_PORT, &GPIO_InitStruct);
 800d2e4:	a905      	add	r1, sp, #20
 800d2e6:	05c0      	lsls	r0, r0, #23
		GPIO_InitStruct.Pin = USART2_RX_PIN;  
 800d2e8:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d2ea:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d2ec:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d2ee:	9508      	str	r5, [sp, #32]
    GPIO_InitStruct.Alternate = USART2_AF;
 800d2f0:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART2_RX_PORT, &GPIO_InitStruct);
 800d2f2:	f004 ff53 	bl	801219c <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART2_IRQn, 1, 0);
 800d2f6:	201c      	movs	r0, #28
 800d2f8:	2200      	movs	r2, #0
 800d2fa:	0021      	movs	r1, r4
 800d2fc:	f004 f920 	bl	8011540 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 800d300:	201c      	movs	r0, #28
 800d302:	e7ce      	b.n	800d2a2 <HAL_UART_MspInit+0x62>
  else if(huart->Instance==USART3)
 800d304:	4a3a      	ldr	r2, [pc, #232]	; (800d3f0 <HAL_UART_MspInit+0x1b0>)
 800d306:	4293      	cmp	r3, r2
 800d308:	d122      	bne.n	800d350 <HAL_UART_MspInit+0x110>
    __USART3_CLK_ENABLE();
 800d30a:	2080      	movs	r0, #128	; 0x80
 800d30c:	4a36      	ldr	r2, [pc, #216]	; (800d3e8 <HAL_UART_MspInit+0x1a8>)
 800d30e:	02c0      	lsls	r0, r0, #11
 800d310:	69d1      	ldr	r1, [r2, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d312:	2702      	movs	r7, #2
    __USART3_CLK_ENABLE();
 800d314:	4301      	orrs	r1, r0
 800d316:	61d1      	str	r1, [r2, #28]
 800d318:	69d3      	ldr	r3, [r2, #28]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d31a:	2401      	movs	r4, #1
    __USART3_CLK_ENABLE();
 800d31c:	4003      	ands	r3, r0
 800d31e:	9302      	str	r3, [sp, #8]
 800d320:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = USART3_TX_PIN; 
 800d322:	2380      	movs	r3, #128	; 0x80
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d324:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = USART3_AF;	
 800d326:	2504      	movs	r5, #4
    GPIO_InitStruct.Pin = USART3_TX_PIN; 
 800d328:	00db      	lsls	r3, r3, #3
    HAL_GPIO_Init(USART3_TX_PORT, &GPIO_InitStruct);
 800d32a:	a905      	add	r1, sp, #20
 800d32c:	4831      	ldr	r0, [pc, #196]	; (800d3f4 <HAL_UART_MspInit+0x1b4>)
    GPIO_InitStruct.Pin = USART3_TX_PIN; 
 800d32e:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d330:	9706      	str	r7, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d332:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d334:	9608      	str	r6, [sp, #32]
    GPIO_InitStruct.Alternate = USART3_AF;	
 800d336:	9509      	str	r5, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART3_TX_PORT, &GPIO_InitStruct);
 800d338:	f004 ff30 	bl	801219c <HAL_GPIO_Init>
		GPIO_InitStruct.Pin = USART3_RX_PIN;  
 800d33c:	2380      	movs	r3, #128	; 0x80
 800d33e:	011b      	lsls	r3, r3, #4
		GPIO_InitStruct.Pin = USART5_RX_PIN;  
 800d340:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d342:	9706      	str	r7, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d344:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d346:	9608      	str	r6, [sp, #32]
    GPIO_InitStruct.Alternate = USART5_AF;
 800d348:	9509      	str	r5, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART5_RX_PORT, &GPIO_InitStruct);
 800d34a:	a905      	add	r1, sp, #20
 800d34c:	4829      	ldr	r0, [pc, #164]	; (800d3f4 <HAL_UART_MspInit+0x1b4>)
 800d34e:	e022      	b.n	800d396 <HAL_UART_MspInit+0x156>
  else if(huart->Instance==USART4)
 800d350:	4a29      	ldr	r2, [pc, #164]	; (800d3f8 <HAL_UART_MspInit+0x1b8>)
 800d352:	4293      	cmp	r3, r2
 800d354:	d128      	bne.n	800d3a8 <HAL_UART_MspInit+0x168>
    __USART4_CLK_ENABLE();
 800d356:	2080      	movs	r0, #128	; 0x80
 800d358:	4a23      	ldr	r2, [pc, #140]	; (800d3e8 <HAL_UART_MspInit+0x1a8>)
 800d35a:	0300      	lsls	r0, r0, #12
 800d35c:	69d1      	ldr	r1, [r2, #28]
    GPIO_InitStruct.Pin = USART4_TX_PIN; 
 800d35e:	2401      	movs	r4, #1
    __USART4_CLK_ENABLE();
 800d360:	4301      	orrs	r1, r0
 800d362:	61d1      	str	r1, [r2, #28]
 800d364:	69d3      	ldr	r3, [r2, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d366:	2502      	movs	r5, #2
    __USART4_CLK_ENABLE();
 800d368:	4003      	ands	r3, r0
    HAL_GPIO_Init(USART4_TX_PORT, &GPIO_InitStruct);
 800d36a:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d36c:	2703      	movs	r7, #3
    GPIO_InitStruct.Alternate = USART4_AF;	
 800d36e:	2604      	movs	r6, #4
    __USART4_CLK_ENABLE();
 800d370:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(USART4_TX_PORT, &GPIO_InitStruct);
 800d372:	a905      	add	r1, sp, #20
 800d374:	05c0      	lsls	r0, r0, #23
    __USART4_CLK_ENABLE();
 800d376:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = USART4_TX_PIN; 
 800d378:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d37a:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d37c:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d37e:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Alternate = USART4_AF;	
 800d380:	9609      	str	r6, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART4_TX_PORT, &GPIO_InitStruct);
 800d382:	f004 ff0b 	bl	801219c <HAL_GPIO_Init>
    HAL_GPIO_Init(USART4_RX_PORT, &GPIO_InitStruct);
 800d386:	2090      	movs	r0, #144	; 0x90
		GPIO_InitStruct.Pin = USART4_RX_PIN;  
 800d388:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d38a:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d38c:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d38e:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Alternate = USART4_AF;
 800d390:	9609      	str	r6, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART4_RX_PORT, &GPIO_InitStruct);
 800d392:	a905      	add	r1, sp, #20
 800d394:	05c0      	lsls	r0, r0, #23
    HAL_GPIO_Init(USART5_RX_PORT, &GPIO_InitStruct);
 800d396:	f004 ff01 	bl	801219c <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART3_8_IRQn, 1, 0);
 800d39a:	201d      	movs	r0, #29
 800d39c:	2200      	movs	r2, #0
 800d39e:	0021      	movs	r1, r4
 800d3a0:	f004 f8ce 	bl	8011540 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_8_IRQn);
 800d3a4:	201d      	movs	r0, #29
 800d3a6:	e77c      	b.n	800d2a2 <HAL_UART_MspInit+0x62>
  else if(huart->Instance==USART5)
 800d3a8:	4a14      	ldr	r2, [pc, #80]	; (800d3fc <HAL_UART_MspInit+0x1bc>)
 800d3aa:	4293      	cmp	r3, r2
 800d3ac:	d000      	beq.n	800d3b0 <HAL_UART_MspInit+0x170>
 800d3ae:	e77a      	b.n	800d2a6 <HAL_UART_MspInit+0x66>
    __USART5_CLK_ENABLE();
 800d3b0:	2080      	movs	r0, #128	; 0x80
 800d3b2:	4a0d      	ldr	r2, [pc, #52]	; (800d3e8 <HAL_UART_MspInit+0x1a8>)
 800d3b4:	0340      	lsls	r0, r0, #13
 800d3b6:	69d1      	ldr	r1, [r2, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d3b8:	2702      	movs	r7, #2
    __USART5_CLK_ENABLE();
 800d3ba:	4301      	orrs	r1, r0
 800d3bc:	61d1      	str	r1, [r2, #28]
 800d3be:	69d3      	ldr	r3, [r2, #28]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d3c0:	2401      	movs	r4, #1
    __USART5_CLK_ENABLE();
 800d3c2:	4003      	ands	r3, r0
 800d3c4:	9304      	str	r3, [sp, #16]
 800d3c6:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d3c8:	2603      	movs	r6, #3
    GPIO_InitStruct.Pin = USART5_TX_PIN; 
 800d3ca:	2308      	movs	r3, #8
    GPIO_InitStruct.Alternate = USART5_AF;	
 800d3cc:	2504      	movs	r5, #4
    HAL_GPIO_Init(USART5_TX_PORT, &GPIO_InitStruct);
 800d3ce:	a905      	add	r1, sp, #20
 800d3d0:	4808      	ldr	r0, [pc, #32]	; (800d3f4 <HAL_UART_MspInit+0x1b4>)
    GPIO_InitStruct.Pin = USART5_TX_PIN; 
 800d3d2:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d3d4:	9706      	str	r7, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800d3d6:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800d3d8:	9608      	str	r6, [sp, #32]
    GPIO_InitStruct.Alternate = USART5_AF;	
 800d3da:	9509      	str	r5, [sp, #36]	; 0x24
    HAL_GPIO_Init(USART5_TX_PORT, &GPIO_InitStruct);
 800d3dc:	f004 fede 	bl	801219c <HAL_GPIO_Init>
		GPIO_InitStruct.Pin = USART5_RX_PIN;  
 800d3e0:	2310      	movs	r3, #16
 800d3e2:	e7ad      	b.n	800d340 <HAL_UART_MspInit+0x100>
 800d3e4:	40013800 	.word	0x40013800
 800d3e8:	40021000 	.word	0x40021000
 800d3ec:	40004400 	.word	0x40004400
 800d3f0:	40004800 	.word	0x40004800
 800d3f4:	48000400 	.word	0x48000400
 800d3f8:	40004c00 	.word	0x40004c00
 800d3fc:	40005000 	.word	0x40005000

0800d400 <GetUart>:
}

/* --- Get the UART for a given port. 
*/
UART_HandleTypeDef* GetUart(uint8_t port)
{
 800d400:	3801      	subs	r0, #1
 800d402:	b2c3      	uxtb	r3, r0
 800d404:	2000      	movs	r0, #0
 800d406:	2b04      	cmp	r3, #4
 800d408:	d802      	bhi.n	800d410 <GetUart+0x10>
 800d40a:	4a02      	ldr	r2, [pc, #8]	; (800d414 <GetUart+0x14>)
 800d40c:	009b      	lsls	r3, r3, #2
 800d40e:	5898      	ldr	r0, [r3, r2]
			return P10uart;
	#endif
		default:
			return 0;
	}		
}
 800d410:	4770      	bx	lr
 800d412:	46c0      	nop			; (mov r8, r8)
 800d414:	0801bf84 	.word	0x0801bf84

0800d418 <writePxMutex>:
{
 800d418:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d41a:	0004      	movs	r4, r0
 800d41c:	9100      	str	r1, [sp, #0]
 800d41e:	9201      	str	r2, [sp, #4]
 800d420:	001d      	movs	r5, r3
	if (GetUart(port) != NULL) {
 800d422:	f7ff ffed 	bl	800d400 <GetUart>
 800d426:	1e06      	subs	r6, r0, #0
 800d428:	d102      	bne.n	800d430 <writePxMutex+0x18>
	HAL_StatusTypeDef result = HAL_ERROR;
 800d42a:	2501      	movs	r5, #1
}
 800d42c:	0028      	movs	r0, r5
 800d42e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (osSemaphoreWait(PxTxSemaphoreHandle[port], mutexTimeout) == osOK) {
 800d430:	4f0b      	ldr	r7, [pc, #44]	; (800d460 <writePxMutex+0x48>)
 800d432:	00a3      	lsls	r3, r4, #2
 800d434:	0029      	movs	r1, r5
 800d436:	59d8      	ldr	r0, [r3, r7]
 800d438:	f002 f9d2 	bl	800f7e0 <osSemaphoreWait>
 800d43c:	2800      	cmp	r0, #0
 800d43e:	d1f4      	bne.n	800d42a <writePxMutex+0x12>
				result = HAL_UART_Transmit(GetUart(port), (uint8_t *)buffer, n, portTimeout);
 800d440:	9b08      	ldr	r3, [sp, #32]
 800d442:	9a01      	ldr	r2, [sp, #4]
 800d444:	9900      	ldr	r1, [sp, #0]
 800d446:	0030      	movs	r0, r6
 800d448:	f006 fc88 	bl	8013d5c <HAL_UART_Transmit>
 800d44c:	1e05      	subs	r5, r0, #0
			while( result != HAL_OK && result !=  HAL_TIMEOUT ) {
 800d44e:	d001      	beq.n	800d454 <writePxMutex+0x3c>
 800d450:	2803      	cmp	r0, #3
 800d452:	d1f5      	bne.n	800d440 <writePxMutex+0x28>
			osSemaphoreRelease(PxTxSemaphoreHandle[port]);
 800d454:	00a4      	lsls	r4, r4, #2
 800d456:	5938      	ldr	r0, [r7, r4]
 800d458:	f002 f9e8 	bl	800f82c <osSemaphoreRelease>
 800d45c:	e7e6      	b.n	800d42c <writePxMutex+0x14>
 800d45e:	46c0      	nop			; (mov r8, r8)
 800d460:	20006ff0 	.word	0x20006ff0

0800d464 <writePxITMutex>:
{
 800d464:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d466:	0004      	movs	r4, r0
 800d468:	000e      	movs	r6, r1
 800d46a:	9201      	str	r2, [sp, #4]
 800d46c:	001f      	movs	r7, r3
	if (GetUart(port) != NULL) {	
 800d46e:	f7ff ffc7 	bl	800d400 <GetUart>
 800d472:	1e05      	subs	r5, r0, #0
 800d474:	d101      	bne.n	800d47a <writePxITMutex+0x16>
	HAL_StatusTypeDef result = HAL_ERROR; 
 800d476:	2001      	movs	r0, #1
}
 800d478:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (osSemaphoreWait(PxTxSemaphoreHandle[port], mutexTimeout) == osOK) {
 800d47a:	4b07      	ldr	r3, [pc, #28]	; (800d498 <writePxITMutex+0x34>)
 800d47c:	00a4      	lsls	r4, r4, #2
 800d47e:	0039      	movs	r1, r7
 800d480:	58e0      	ldr	r0, [r4, r3]
 800d482:	f002 f9ad 	bl	800f7e0 <osSemaphoreWait>
 800d486:	2800      	cmp	r0, #0
 800d488:	d1f5      	bne.n	800d476 <writePxITMutex+0x12>
			result = HAL_UART_Transmit_IT(GetUart(port), (uint8_t *)buffer, n);
 800d48a:	9a01      	ldr	r2, [sp, #4]
 800d48c:	0031      	movs	r1, r6
 800d48e:	0028      	movs	r0, r5
 800d490:	f006 f969 	bl	8013766 <HAL_UART_Transmit_IT>
 800d494:	e7f0      	b.n	800d478 <writePxITMutex+0x14>
 800d496:	46c0      	nop			; (mov r8, r8)
 800d498:	20006ff0 	.word	0x20006ff0

0800d49c <writePxDMAMutex>:
{
 800d49c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d49e:	0004      	movs	r4, r0
 800d4a0:	000e      	movs	r6, r1
 800d4a2:	9201      	str	r2, [sp, #4]
 800d4a4:	001f      	movs	r7, r3
	UART_HandleTypeDef* hUart = GetUart(port);
 800d4a6:	f7ff ffab 	bl	800d400 <GetUart>
 800d4aa:	1e05      	subs	r5, r0, #0
	if (hUart != NULL) {	
 800d4ac:	d101      	bne.n	800d4b2 <writePxDMAMutex+0x16>
	HAL_StatusTypeDef result = HAL_ERROR; 
 800d4ae:	2001      	movs	r0, #1
}
 800d4b0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (osSemaphoreWait(PxTxSemaphoreHandle[port], mutexTimeout) == osOK) {
 800d4b2:	4b08      	ldr	r3, [pc, #32]	; (800d4d4 <writePxDMAMutex+0x38>)
 800d4b4:	00a4      	lsls	r4, r4, #2
 800d4b6:	0039      	movs	r1, r7
 800d4b8:	58e0      	ldr	r0, [r4, r3]
 800d4ba:	f002 f991 	bl	800f7e0 <osSemaphoreWait>
 800d4be:	2800      	cmp	r0, #0
 800d4c0:	d1f5      	bne.n	800d4ae <writePxDMAMutex+0x12>
			DMA_MSG_TX_Setup(hUart);
 800d4c2:	0028      	movs	r0, r5
 800d4c4:	f7fe fd12 	bl	800beec <DMA_MSG_TX_Setup>
			result = HAL_UART_Transmit_DMA(hUart, (uint8_t *)buffer, n);
 800d4c8:	9a01      	ldr	r2, [sp, #4]
 800d4ca:	0031      	movs	r1, r6
 800d4cc:	0028      	movs	r0, r5
 800d4ce:	f006 f9d9 	bl	8013884 <HAL_UART_Transmit_DMA>
 800d4d2:	e7ed      	b.n	800d4b0 <writePxDMAMutex+0x14>
 800d4d4:	20006ff0 	.word	0x20006ff0

0800d4d8 <UpdateBaudrate>:
{
 800d4d8:	b510      	push	{r4, lr}
 800d4da:	000c      	movs	r4, r1
	UART_HandleTypeDef *huart = GetUart(port);
 800d4dc:	f7ff ff90 	bl	800d400 <GetUart>
	huart->Init.BaudRate = baudrate;
 800d4e0:	6044      	str	r4, [r0, #4]
	HAL_UART_Init(huart);
 800d4e2:	f006 fcd3 	bl	8013e8c <HAL_UART_Init>
}
 800d4e6:	2000      	movs	r0, #0
 800d4e8:	bd10      	pop	{r4, pc}
	...

0800d4ec <SwapUartPins>:
/*-----------------------------------------------------------*/

/* --- Swap UART pins ( NORMAL | REVERSED )--- 
*/
void SwapUartPins(UART_HandleTypeDef *huart, uint8_t direction)
{
 800d4ec:	b570      	push	{r4, r5, r6, lr}
 800d4ee:	0004      	movs	r4, r0
 800d4f0:	000d      	movs	r5, r1
	if (huart != NULL) {
 800d4f2:	2800      	cmp	r0, #0
 800d4f4:	d016      	beq.n	800d524 <SwapUartPins+0x38>
		if (direction == REVERSED) {
 800d4f6:	2901      	cmp	r1, #1
 800d4f8:	d115      	bne.n	800d526 <SwapUartPins+0x3a>
			arrayPortsDir[myID-1] |= (0x8000>>(GetPort(huart)-1));		/* Set bit to one */
 800d4fa:	f7fc faad 	bl	8009a58 <GetPort>
 800d4fe:	2180      	movs	r1, #128	; 0x80
 800d500:	0209      	lsls	r1, r1, #8
 800d502:	000a      	movs	r2, r1
 800d504:	3801      	subs	r0, #1
 800d506:	4102      	asrs	r2, r0
 800d508:	4b11      	ldr	r3, [pc, #68]	; (800d550 <SwapUartPins+0x64>)
 800d50a:	4d12      	ldr	r5, [pc, #72]	; (800d554 <SwapUartPins+0x68>)
 800d50c:	781b      	ldrb	r3, [r3, #0]
			huart->AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
			huart->AdvancedInit.Swap = UART_ADVFEATURE_SWAP_ENABLE;
 800d50e:	6361      	str	r1, [r4, #52]	; 0x34
			arrayPortsDir[myID-1] |= (0x8000>>(GetPort(huart)-1));		/* Set bit to one */
 800d510:	3b01      	subs	r3, #1
 800d512:	005b      	lsls	r3, r3, #1
 800d514:	5b58      	ldrh	r0, [r3, r5]
 800d516:	4302      	orrs	r2, r0
 800d518:	535a      	strh	r2, [r3, r5]
			huart->AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
 800d51a:	2308      	movs	r3, #8
 800d51c:	6263      	str	r3, [r4, #36]	; 0x24
			HAL_UART_Init(huart);
		} else if (direction == NORMAL) {
			arrayPortsDir[myID-1] &= (~(0x8000>>(GetPort(huart)-1)));		/* Set bit to zero */
			huart->AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
			huart->AdvancedInit.Swap = UART_ADVFEATURE_SWAP_DISABLE;
			HAL_UART_Init(huart);		
 800d51e:	0020      	movs	r0, r4
 800d520:	f006 fcb4 	bl	8013e8c <HAL_UART_Init>
		}
	}
}
 800d524:	bd70      	pop	{r4, r5, r6, pc}
		} else if (direction == NORMAL) {
 800d526:	2900      	cmp	r1, #0
 800d528:	d1fc      	bne.n	800d524 <SwapUartPins+0x38>
			arrayPortsDir[myID-1] &= (~(0x8000>>(GetPort(huart)-1)));		/* Set bit to zero */
 800d52a:	f7fc fa95 	bl	8009a58 <GetPort>
 800d52e:	2180      	movs	r1, #128	; 0x80
 800d530:	3801      	subs	r0, #1
 800d532:	0209      	lsls	r1, r1, #8
 800d534:	4101      	asrs	r1, r0
 800d536:	4b06      	ldr	r3, [pc, #24]	; (800d550 <SwapUartPins+0x64>)
 800d538:	4e06      	ldr	r6, [pc, #24]	; (800d554 <SwapUartPins+0x68>)
 800d53a:	781b      	ldrb	r3, [r3, #0]
			huart->AdvancedInit.Swap = UART_ADVFEATURE_SWAP_DISABLE;
 800d53c:	6365      	str	r5, [r4, #52]	; 0x34
			arrayPortsDir[myID-1] &= (~(0x8000>>(GetPort(huart)-1)));		/* Set bit to zero */
 800d53e:	3b01      	subs	r3, #1
 800d540:	005b      	lsls	r3, r3, #1
 800d542:	5b9a      	ldrh	r2, [r3, r6]
 800d544:	438a      	bics	r2, r1
 800d546:	539a      	strh	r2, [r3, r6]
			huart->AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_SWAP_INIT;
 800d548:	2308      	movs	r3, #8
 800d54a:	6263      	str	r3, [r4, #36]	; 0x24
 800d54c:	e7e7      	b.n	800d51e <SwapUartPins+0x32>
 800d54e:	46c0      	nop			; (mov r8, r8)
 800d550:	20001039 	.word	0x20001039
 800d554:	20007a44 	.word	0x20007a44

0800d558 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800d558:	4816      	ldr	r0, [pc, #88]	; (800d5b4 <LoopForever+0x4>)
  mov   sp, r0          /* set stack pointer */
 800d55a:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 800d55c:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800d55e:	e003      	b.n	800d568 <LoopCopyDataInit>

0800d560 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 800d560:	4b15      	ldr	r3, [pc, #84]	; (800d5b8 <LoopForever+0x8>)
  ldr r3, [r3, r1]
 800d562:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 800d564:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 800d566:	3104      	adds	r1, #4

0800d568 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 800d568:	4814      	ldr	r0, [pc, #80]	; (800d5bc <LoopForever+0xc>)
  ldr r3, =_edata
 800d56a:	4b15      	ldr	r3, [pc, #84]	; (800d5c0 <LoopForever+0x10>)
  adds r2, r0, r1
 800d56c:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800d56e:	429a      	cmp	r2, r3
  bcc CopyDataInit
 800d570:	d3f6      	bcc.n	800d560 <CopyDataInit>
  ldr r2, =_sbss
 800d572:	4a14      	ldr	r2, [pc, #80]	; (800d5c4 <LoopForever+0x14>)
  b LoopFillZerobss
 800d574:	e002      	b.n	800d57c <LoopFillZerobss>

0800d576 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 800d576:	2300      	movs	r3, #0
  str  r3, [r2]
 800d578:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800d57a:	3204      	adds	r2, #4

0800d57c <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 800d57c:	4b12      	ldr	r3, [pc, #72]	; (800d5c8 <LoopForever+0x18>)
  cmp r2, r3
 800d57e:	429a      	cmp	r2, r3
  bcc FillZerobss
 800d580:	d3f9      	bcc.n	800d576 <FillZerobss>

//------------------------------------------------------------------------------
// Modified Reset Handler for bootloader reboot (sourcer32@gmail.com)
	LDR        R0, =0x20007FF0  	// Address for RAM signature (STM32F09x)
 800d582:	4812      	ldr	r0, [pc, #72]	; (800d5cc <LoopForever+0x1c>)
	LDR        R1, =0xDEADBEEF
 800d584:	4912      	ldr	r1, [pc, #72]	; (800d5d0 <LoopForever+0x20>)
	LDR        R2, [R0, #0] 		// Read current
 800d586:	6802      	ldr	r2, [r0, #0]
	STR        R0, [R0, #0] 		// Invalidate
 800d588:	6000      	str	r0, [r0, #0]
	CMP        R2, R1
 800d58a:	428a      	cmp	r2, r1
	BEQ        Reboot_Loader
 800d58c:	d005      	beq.n	800d59a <Reboot_Loader>

// Normal startup path

/* Call the clock system intitialization function.*/
  bl  SystemInit
 800d58e:	f000 f82b 	bl	800d5e8 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 800d592:	f006 fdeb 	bl	801416c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800d596:	f006 fdcb 	bl	8014130 <main>

0800d59a <Reboot_Loader>:

// Vector into System Loader
Reboot_Loader:
	LDR     R0, =0x40021018 	// RCC_APB2ENR (+0x18)
 800d59a:	480e      	ldr	r0, [pc, #56]	; (800d5d4 <LoopForever+0x24>)
	LDR     R1, =0x00000001 	// ENABLE SYSCFG CLOCK
 800d59c:	490e      	ldr	r1, [pc, #56]	; (800d5d8 <LoopForever+0x28>)
	STR     R1, [R0, #0]
 800d59e:	6001      	str	r1, [r0, #0]
	LDR     R0, =0x40010000 	// SYSCFG_CFGR1 (+0x00)
 800d5a0:	480e      	ldr	r0, [pc, #56]	; (800d5dc <LoopForever+0x2c>)
	LDR     R1, =0x00000001 	// MAP ROM AT ZERO
 800d5a2:	490d      	ldr	r1, [pc, #52]	; (800d5d8 <LoopForever+0x28>)
	STR     R1, [R0, #0]
 800d5a4:	6001      	str	r1, [r0, #0]
	//                LDR     R0, =0x1FFFEC00 ; ROM BASE (STM32F03x)
	//                LDR     R0, =0x1FFFC400 ; ROM BASE (STM32F04x)
	//                LDR     R0, =0x1FFFEC00 ; ROM BASE (STM32F05x)
	//                LDR     R0, =0x1FFFC800 ; ROM BASE (STM32F07x)
	LDR     R0, =0x1FFFD800 	// ROM BASE (STM32F09x)
 800d5a6:	480e      	ldr	r0, [pc, #56]	; (800d5e0 <LoopForever+0x30>)
	LDR     R1, [R0, #0]    	// SP @ +0
 800d5a8:	6801      	ldr	r1, [r0, #0]
	MOV     SP, R1
 800d5aa:	468d      	mov	sp, r1
	LDR     R0, [R0, #4]    	// PC @ +4
 800d5ac:	6840      	ldr	r0, [r0, #4]
	BX      R0
 800d5ae:	4700      	bx	r0

0800d5b0 <LoopForever>:


LoopForever:
    b LoopForever
 800d5b0:	e7fe      	b.n	800d5b0 <LoopForever>
 800d5b2:	0000      	.short	0x0000
  ldr   r0, =_estack
 800d5b4:	20008000 	.word	0x20008000
  ldr r3, =_sidata
 800d5b8:	0801c848 	.word	0x0801c848
  ldr r0, =_sdata
 800d5bc:	20000000 	.word	0x20000000
  ldr r3, =_edata
 800d5c0:	20000a80 	.word	0x20000a80
  ldr r2, =_sbss
 800d5c4:	20000a80 	.word	0x20000a80
  ldr r3, = _ebss
 800d5c8:	20007ae8 	.word	0x20007ae8
	LDR        R0, =0x20007FF0  	// Address for RAM signature (STM32F09x)
 800d5cc:	20007ff0 	.word	0x20007ff0
	LDR        R1, =0xDEADBEEF
 800d5d0:	deadbeef 	.word	0xdeadbeef
	LDR     R0, =0x40021018 	// RCC_APB2ENR (+0x18)
 800d5d4:	40021018 	.word	0x40021018
	LDR     R1, =0x00000001 	// ENABLE SYSCFG CLOCK
 800d5d8:	00000001 	.word	0x00000001
	LDR     R0, =0x40010000 	// SYSCFG_CFGR1 (+0x00)
 800d5dc:	40010000 	.word	0x40010000
	LDR     R0, =0x1FFFD800 	// ROM BASE (STM32F09x)
 800d5e0:	1fffd800 	.word	0x1fffd800

0800d5e4 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800d5e4:	e7fe      	b.n	800d5e4 <ADC1_COMP_IRQHandler>
	...

0800d5e8 <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800d5e8:	2101      	movs	r1, #1
 800d5ea:	4b11      	ldr	r3, [pc, #68]	; (800d630 <SystemInit+0x48>)
#if defined (STM32F051x8) || defined (STM32F058x8)
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80C;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80C;
 800d5ec:	4811      	ldr	r0, [pc, #68]	; (800d634 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001;
 800d5ee:	681a      	ldr	r2, [r3, #0]
 800d5f0:	430a      	orrs	r2, r1
 800d5f2:	601a      	str	r2, [r3, #0]
  RCC->CFGR &= (uint32_t)0x08FFB80C;
 800d5f4:	685a      	ldr	r2, [r3, #4]
 800d5f6:	4002      	ands	r2, r0
 800d5f8:	605a      	str	r2, [r3, #4]
#endif /* STM32F051x8 or STM32F058x8 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800d5fa:	681a      	ldr	r2, [r3, #0]
 800d5fc:	480e      	ldr	r0, [pc, #56]	; (800d638 <SystemInit+0x50>)
 800d5fe:	4002      	ands	r2, r0
 800d600:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800d602:	681a      	ldr	r2, [r3, #0]
 800d604:	480d      	ldr	r0, [pc, #52]	; (800d63c <SystemInit+0x54>)
 800d606:	4002      	ands	r2, r0
 800d608:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFF;
 800d60a:	685a      	ldr	r2, [r3, #4]
 800d60c:	480c      	ldr	r0, [pc, #48]	; (800d640 <SystemInit+0x58>)
 800d60e:	4002      	ands	r2, r0

  /* Reset PREDIV[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 800d610:	200f      	movs	r0, #15
  RCC->CFGR &= (uint32_t)0xFFC0FFFF;
 800d612:	605a      	str	r2, [r3, #4]
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 800d614:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d616:	4382      	bics	r2, r0
 800d618:	62da      	str	r2, [r3, #44]	; 0x2c
#elif defined (STM32F071xB)
  /* Reset USART2SW[1:0], USART1SW[1:0], I2C1SW, CECSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFFCEAC;
#elif defined (STM32F091xC) || defined (STM32F098xx)
  /* Reset USART3SW[1:0], USART2SW[1:0], USART1SW[1:0], I2C1SW, CECSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFF0FEAC;
 800d61a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d61c:	4809      	ldr	r0, [pc, #36]	; (800d644 <SystemInit+0x5c>)
 800d61e:	4002      	ands	r2, r0
 800d620:	631a      	str	r2, [r3, #48]	; 0x30
#else
 #warning "No target selected"
#endif

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFE;
 800d622:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d624:	438a      	bics	r2, r1
 800d626:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800d628:	2200      	movs	r2, #0
 800d62a:	609a      	str	r2, [r3, #8]

}
 800d62c:	4770      	bx	lr
 800d62e:	46c0      	nop			; (mov r8, r8)
 800d630:	40021000 	.word	0x40021000
 800d634:	08ffb80c 	.word	0x08ffb80c
 800d638:	fef6ffff 	.word	0xfef6ffff
 800d63c:	fffbffff 	.word	0xfffbffff
 800d640:	ffc0ffff 	.word	0xffc0ffff
 800d644:	fff0feac 	.word	0xfff0feac

0800d648 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 800d648:	b530      	push	{r4, r5, lr}
  uint8_t ret = 1;
 800d64a:	2401      	movs	r4, #1
  uint8_t DiskNum = 0;
  
  if(disk.nbr <= FF_VOLUMES)
 800d64c:	4b0e      	ldr	r3, [pc, #56]	; (800d688 <FATFS_LinkDriverEx+0x40>)
 800d64e:	7a5d      	ldrb	r5, [r3, #9]
 800d650:	42a5      	cmp	r5, r4
 800d652:	d816      	bhi.n	800d682 <FATFS_LinkDriverEx+0x3a>
  {
    disk.is_initialized[disk.nbr] = 0;
 800d654:	2400      	movs	r4, #0
 800d656:	7a5d      	ldrb	r5, [r3, #9]
 800d658:	b2ed      	uxtb	r5, r5
 800d65a:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;  
 800d65c:	7a5d      	ldrb	r5, [r3, #9]
 800d65e:	00ad      	lsls	r5, r5, #2
 800d660:	195d      	adds	r5, r3, r5
 800d662:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;  
 800d664:	7a58      	ldrb	r0, [r3, #9]
 800d666:	1818      	adds	r0, r3, r0
 800d668:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 800d66a:	7a5a      	ldrb	r2, [r3, #9]
 800d66c:	b2d2      	uxtb	r2, r2
 800d66e:	1c50      	adds	r0, r2, #1
 800d670:	b2c0      	uxtb	r0, r0
 800d672:	7258      	strb	r0, [r3, #9]
    path[0] = DiskNum + '0';
    path[1] = ':';
 800d674:	233a      	movs	r3, #58	; 0x3a
    path[0] = DiskNum + '0';
 800d676:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 800d678:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
 800d67a:	3b0b      	subs	r3, #11
    path[0] = DiskNum + '0';
 800d67c:	700a      	strb	r2, [r1, #0]
    path[2] = '/';
 800d67e:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 800d680:	70cc      	strb	r4, [r1, #3]
    ret = 0;
  }
  
  return ret;
}
 800d682:	0020      	movs	r0, r4
 800d684:	bd30      	pop	{r4, r5, pc}
 800d686:	46c0      	nop			; (mov r8, r8)
 800d688:	20001c8c 	.word	0x20001c8c

0800d68c <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path 
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path)
{
 800d68c:	b510      	push	{r4, lr}
  return FATFS_LinkDriverEx(drv, path, 0);
 800d68e:	2200      	movs	r2, #0
 800d690:	f7ff ffda 	bl	800d648 <FATFS_LinkDriverEx>
}
 800d694:	bd10      	pop	{r4, pc}
	...

0800d698 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used 
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 800d698:	b570      	push	{r4, r5, r6, lr}
  Stat = STA_NOINIT;
 800d69a:	2501      	movs	r5, #1
 800d69c:	4c05      	ldr	r4, [pc, #20]	; (800d6b4 <SD_initialize+0x1c>)
 800d69e:	7025      	strb	r5, [r4, #0]
  
  /* Configure the uSD device */
  if(BSP_SD_Init() == MSD_OK)
 800d6a0:	f7ff f938 	bl	800c914 <BSP_SD_Init>
 800d6a4:	2800      	cmp	r0, #0
 800d6a6:	d102      	bne.n	800d6ae <SD_initialize+0x16>
  {
    Stat &= ~STA_NOINIT;
 800d6a8:	7823      	ldrb	r3, [r4, #0]
 800d6aa:	43ab      	bics	r3, r5
 800d6ac:	7023      	strb	r3, [r4, #0]
  }

  return Stat;
 800d6ae:	7820      	ldrb	r0, [r4, #0]
 800d6b0:	b2c0      	uxtb	r0, r0
}
 800d6b2:	bd70      	pop	{r4, r5, r6, pc}
 800d6b4:	200000b8 	.word	0x200000b8

0800d6b8 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 800d6b8:	b570      	push	{r4, r5, r6, lr}
  Stat = STA_NOINIT;
 800d6ba:	2501      	movs	r5, #1
 800d6bc:	4c05      	ldr	r4, [pc, #20]	; (800d6d4 <SD_status+0x1c>)
 800d6be:	7025      	strb	r5, [r4, #0]

  if(BSP_SD_GetStatus() == MSD_OK)
 800d6c0:	f7ff f8c4 	bl	800c84c <BSP_SD_GetStatus>
 800d6c4:	2800      	cmp	r0, #0
 800d6c6:	d102      	bne.n	800d6ce <SD_status+0x16>
  {
    Stat &= ~STA_NOINIT;
 800d6c8:	7823      	ldrb	r3, [r4, #0]
 800d6ca:	43ab      	bics	r3, r5
 800d6cc:	7023      	strb	r3, [r4, #0]
  }
  
  return Stat;
 800d6ce:	7820      	ldrb	r0, [r4, #0]
 800d6d0:	b2c0      	uxtb	r0, r0
}
 800d6d2:	bd70      	pop	{r4, r5, r6, pc}
 800d6d4:	200000b8 	.word	0x200000b8

0800d6d8 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 800d6d8:	b510      	push	{r4, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_ReadBlocks((uint32_t*)buff, 
 800d6da:	2480      	movs	r4, #128	; 0x80
{
 800d6dc:	0008      	movs	r0, r1
                       (uint64_t) (sector * BLOCK_SIZE), 
 800d6de:	0251      	lsls	r1, r2, #9
  if(BSP_SD_ReadBlocks((uint32_t*)buff, 
 800d6e0:	00a2      	lsls	r2, r4, #2
 800d6e2:	f7ff f9f7 	bl	800cad4 <BSP_SD_ReadBlocks>
 800d6e6:	1e43      	subs	r3, r0, #1
 800d6e8:	4198      	sbcs	r0, r3
                       count) != MSD_OK)
  {
    res = RES_ERROR;
  }
  
  return res;
 800d6ea:	b2c0      	uxtb	r0, r0
}
 800d6ec:	bd10      	pop	{r4, pc}

0800d6ee <SD_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 800d6ee:	b510      	push	{r4, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_WriteBlocks((uint32_t*)buff, 
 800d6f0:	2480      	movs	r4, #128	; 0x80
{
 800d6f2:	0008      	movs	r0, r1
                        (uint64_t)(sector * BLOCK_SIZE), 
 800d6f4:	0251      	lsls	r1, r2, #9
  if(BSP_SD_WriteBlocks((uint32_t*)buff, 
 800d6f6:	00a2      	lsls	r2, r4, #2
 800d6f8:	f7ff f82a 	bl	800c750 <BSP_SD_WriteBlocks>
 800d6fc:	1e43      	subs	r3, r0, #1
 800d6fe:	4198      	sbcs	r0, r3
                        BLOCK_SIZE, count) != MSD_OK)
  {
    res = RES_ERROR;
  }
  
  return res;
 800d700:	b2c0      	uxtb	r0, r0
}
 800d702:	bd10      	pop	{r4, pc}

0800d704 <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 800d704:	b510      	push	{r4, lr}
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 800d706:	4b10      	ldr	r3, [pc, #64]	; (800d748 <SD_ioctl+0x44>)
{
 800d708:	0014      	movs	r4, r2
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 800d70a:	781a      	ldrb	r2, [r3, #0]
{
 800d70c:	b08e      	sub	sp, #56	; 0x38
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 800d70e:	2003      	movs	r0, #3
 800d710:	07d3      	lsls	r3, r2, #31
 800d712:	d417      	bmi.n	800d744 <SD_ioctl+0x40>
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
    break;
  
  default:
    res = RES_PARERR;
 800d714:	3001      	adds	r0, #1
  switch (cmd)
 800d716:	2903      	cmp	r1, #3
 800d718:	d814      	bhi.n	800d744 <SD_ioctl+0x40>
 800d71a:	0008      	movs	r0, r1
 800d71c:	f7f2 fd0e 	bl	800013c <__gnu_thumb1_case_uqi>
 800d720:	0e0a0208 	.word	0x0e0a0208
    BSP_SD_GetCardInfo(&CardInfo);
 800d724:	4668      	mov	r0, sp
 800d726:	f7ff fa3b 	bl	800cba0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.CardCapacity / BLOCK_SIZE;
 800d72a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d72c:	0a5b      	lsrs	r3, r3, #9
 800d72e:	6023      	str	r3, [r4, #0]
    res = RES_OK;
 800d730:	2000      	movs	r0, #0
 800d732:	e007      	b.n	800d744 <SD_ioctl+0x40>
    *(WORD*)buff = BLOCK_SIZE;
 800d734:	2380      	movs	r3, #128	; 0x80
 800d736:	009b      	lsls	r3, r3, #2
 800d738:	8023      	strh	r3, [r4, #0]
 800d73a:	e7f9      	b.n	800d730 <SD_ioctl+0x2c>
    *(DWORD*)buff = BLOCK_SIZE;
 800d73c:	2380      	movs	r3, #128	; 0x80
  DRESULT res = RES_ERROR;
 800d73e:	2001      	movs	r0, #1
    *(DWORD*)buff = BLOCK_SIZE;
 800d740:	009b      	lsls	r3, r3, #2
 800d742:	6023      	str	r3, [r4, #0]
  }
  
  return res;
}
 800d744:	b00e      	add	sp, #56	; 0x38
 800d746:	bd10      	pop	{r4, pc}
 800d748:	200000b8 	.word	0x200000b8

0800d74c <disk_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
 800d74c:	b510      	push	{r4, lr}
  DSTATUS stat;
  
  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 800d74e:	4b05      	ldr	r3, [pc, #20]	; (800d764 <disk_status+0x18>)
 800d750:	181a      	adds	r2, r3, r0
 800d752:	0080      	lsls	r0, r0, #2
 800d754:	181b      	adds	r3, r3, r0
 800d756:	7a11      	ldrb	r1, [r2, #8]
 800d758:	685b      	ldr	r3, [r3, #4]
 800d75a:	0008      	movs	r0, r1
 800d75c:	685b      	ldr	r3, [r3, #4]
 800d75e:	4798      	blx	r3
  return stat;
}
 800d760:	bd10      	pop	{r4, pc}
 800d762:	46c0      	nop			; (mov r8, r8)
 800d764:	20001c8c 	.word	0x20001c8c

0800d768 <disk_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
 800d768:	b510      	push	{r4, lr}
  DSTATUS stat = RES_OK;
  
  if(disk.is_initialized[pdrv] == 0)
 800d76a:	4b08      	ldr	r3, [pc, #32]	; (800d78c <disk_initialize+0x24>)
{
 800d76c:	0002      	movs	r2, r0
  if(disk.is_initialized[pdrv] == 0)
 800d76e:	5c19      	ldrb	r1, [r3, r0]
  DSTATUS stat = RES_OK;
 800d770:	2000      	movs	r0, #0
  if(disk.is_initialized[pdrv] == 0)
 800d772:	4281      	cmp	r1, r0
 800d774:	d108      	bne.n	800d788 <disk_initialize+0x20>
  { 
    disk.is_initialized[pdrv] = 1;
 800d776:	2101      	movs	r1, #1
 800d778:	5499      	strb	r1, [r3, r2]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800d77a:	1899      	adds	r1, r3, r2
 800d77c:	0092      	lsls	r2, r2, #2
 800d77e:	189b      	adds	r3, r3, r2
 800d780:	685b      	ldr	r3, [r3, #4]
 800d782:	7a08      	ldrb	r0, [r1, #8]
 800d784:	681b      	ldr	r3, [r3, #0]
 800d786:	4798      	blx	r3
  }
  return stat;
}
 800d788:	bd10      	pop	{r4, pc}
 800d78a:	46c0      	nop			; (mov r8, r8)
 800d78c:	20001c8c 	.word	0x20001c8c

0800d790 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 800d790:	b570      	push	{r4, r5, r6, lr}
  DRESULT res;
 
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800d792:	4c05      	ldr	r4, [pc, #20]	; (800d7a8 <disk_read+0x18>)
 800d794:	1825      	adds	r5, r4, r0
 800d796:	0080      	lsls	r0, r0, #2
 800d798:	1824      	adds	r4, r4, r0
 800d79a:	7a2e      	ldrb	r6, [r5, #8]
 800d79c:	6860      	ldr	r0, [r4, #4]
 800d79e:	6884      	ldr	r4, [r0, #8]
 800d7a0:	0030      	movs	r0, r6
 800d7a2:	47a0      	blx	r4
  return res;
}
 800d7a4:	bd70      	pop	{r4, r5, r6, pc}
 800d7a6:	46c0      	nop			; (mov r8, r8)
 800d7a8:	20001c8c 	.word	0x20001c8c

0800d7ac <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 800d7ac:	b570      	push	{r4, r5, r6, lr}
  DRESULT res;
  
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 800d7ae:	4c05      	ldr	r4, [pc, #20]	; (800d7c4 <disk_write+0x18>)
 800d7b0:	1825      	adds	r5, r4, r0
 800d7b2:	0080      	lsls	r0, r0, #2
 800d7b4:	1824      	adds	r4, r4, r0
 800d7b6:	7a2e      	ldrb	r6, [r5, #8]
 800d7b8:	6860      	ldr	r0, [r4, #4]
 800d7ba:	68c4      	ldr	r4, [r0, #12]
 800d7bc:	0030      	movs	r0, r6
 800d7be:	47a0      	blx	r4
  return res;
}
 800d7c0:	bd70      	pop	{r4, r5, r6, pc}
 800d7c2:	46c0      	nop			; (mov r8, r8)
 800d7c4:	20001c8c 	.word	0x20001c8c

0800d7c8 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 800d7c8:	b570      	push	{r4, r5, r6, lr}
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 800d7ca:	4b05      	ldr	r3, [pc, #20]	; (800d7e0 <disk_ioctl+0x18>)
 800d7cc:	181c      	adds	r4, r3, r0
 800d7ce:	0080      	lsls	r0, r0, #2
 800d7d0:	181b      	adds	r3, r3, r0
 800d7d2:	7a25      	ldrb	r5, [r4, #8]
 800d7d4:	685b      	ldr	r3, [r3, #4]
 800d7d6:	0028      	movs	r0, r5
 800d7d8:	691b      	ldr	r3, [r3, #16]
 800d7da:	4798      	blx	r3
  return res;
}
 800d7dc:	bd70      	pop	{r4, r5, r6, pc}
 800d7de:	46c0      	nop			; (mov r8, r8)
 800d7e0:	20001c8c 	.word	0x20001c8c

0800d7e4 <ld_dword>:
DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
	DWORD rv;

	rv = ptr[3];
	rv = rv << 8 | ptr[2];
 800d7e4:	78c3      	ldrb	r3, [r0, #3]
 800d7e6:	7882      	ldrb	r2, [r0, #2]
 800d7e8:	021b      	lsls	r3, r3, #8
 800d7ea:	4313      	orrs	r3, r2
	rv = rv << 8 | ptr[1];
 800d7ec:	7842      	ldrb	r2, [r0, #1]
 800d7ee:	021b      	lsls	r3, r3, #8
 800d7f0:	4313      	orrs	r3, r2
	rv = rv << 8 | ptr[0];
 800d7f2:	7800      	ldrb	r0, [r0, #0]
 800d7f4:	021b      	lsls	r3, r3, #8
 800d7f6:	4318      	orrs	r0, r3
	return rv;
}
 800d7f8:	4770      	bx	lr

0800d7fa <mem_cmp>:


/* Compare memory block */
static
int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
{
 800d7fa:	b530      	push	{r4, r5, lr}
 800d7fc:	2300      	movs	r3, #0
 800d7fe:	0005      	movs	r5, r0
 800d800:	3a01      	subs	r2, #1
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	do {
		r = *d++ - *s++;
 800d802:	5cec      	ldrb	r4, [r5, r3]
 800d804:	5cc8      	ldrb	r0, [r1, r3]
 800d806:	1a20      	subs	r0, r4, r0
	} while (--cnt && r == 0);
 800d808:	429a      	cmp	r2, r3
 800d80a:	d002      	beq.n	800d812 <mem_cmp+0x18>
 800d80c:	3301      	adds	r3, #1
 800d80e:	2800      	cmp	r0, #0
 800d810:	d0f7      	beq.n	800d802 <mem_cmp+0x8>

	return r;
}
 800d812:	bd30      	pop	{r4, r5, pc}

0800d814 <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 800d814:	0002      	movs	r2, r0
 800d816:	b5f0      	push	{r4, r5, r6, r7, lr}
	UINT i;


	for (i = 0; i < FF_FS_LOCK; i++) {	/* Find the object */
		if (Files[i].fs == dp->obj.fs &&
 800d818:	4b13      	ldr	r3, [pc, #76]	; (800d868 <inc_lock+0x54>)
 800d81a:	6815      	ldr	r5, [r2, #0]
 800d81c:	681c      	ldr	r4, [r3, #0]
			Files[i].clu == dp->obj.sclust &&
 800d81e:	685e      	ldr	r6, [r3, #4]
			Files[i].ofs == dp->dptr) break;
 800d820:	6898      	ldr	r0, [r3, #8]
		if (Files[i].fs == dp->obj.fs &&
 800d822:	42ac      	cmp	r4, r5
 800d824:	d110      	bne.n	800d848 <inc_lock+0x34>
 800d826:	6897      	ldr	r7, [r2, #8]
 800d828:	42be      	cmp	r6, r7
 800d82a:	d10d      	bne.n	800d848 <inc_lock+0x34>
			Files[i].clu == dp->obj.sclust &&
 800d82c:	6956      	ldr	r6, [r2, #20]
 800d82e:	42b0      	cmp	r0, r6
 800d830:	d10a      	bne.n	800d848 <inc_lock+0x34>
		Files[i].clu = dp->obj.sclust;
		Files[i].ofs = dp->dptr;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800d832:	2900      	cmp	r1, #0
 800d834:	d004      	beq.n	800d840 <inc_lock+0x2c>
 800d836:	2000      	movs	r0, #0
 800d838:	899a      	ldrh	r2, [r3, #12]
 800d83a:	4282      	cmp	r2, r0
 800d83c:	d00f      	beq.n	800d85e <inc_lock+0x4a>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */

	return i + 1;	/* Index number origin from 1 */
}
 800d83e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800d840:	899a      	ldrh	r2, [r3, #12]
 800d842:	3201      	adds	r2, #1
 800d844:	b292      	uxth	r2, r2
 800d846:	e00c      	b.n	800d862 <inc_lock+0x4e>
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800d848:	2000      	movs	r0, #0
		for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
 800d84a:	4284      	cmp	r4, r0
 800d84c:	d1f7      	bne.n	800d83e <inc_lock+0x2a>
		Files[i].clu = dp->obj.sclust;
 800d84e:	6890      	ldr	r0, [r2, #8]
		Files[i].ofs = dp->dptr;
 800d850:	6952      	ldr	r2, [r2, #20]
		Files[i].fs = dp->obj.fs;
 800d852:	601d      	str	r5, [r3, #0]
		Files[i].clu = dp->obj.sclust;
 800d854:	6058      	str	r0, [r3, #4]
		Files[i].ofs = dp->dptr;
 800d856:	609a      	str	r2, [r3, #8]
		Files[i].ctr = 0;
 800d858:	819c      	strh	r4, [r3, #12]
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800d85a:	2900      	cmp	r1, #0
 800d85c:	d0f0      	beq.n	800d840 <inc_lock+0x2c>
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800d85e:	2280      	movs	r2, #128	; 0x80
 800d860:	0052      	lsls	r2, r2, #1
 800d862:	819a      	strh	r2, [r3, #12]
	return i + 1;	/* Index number origin from 1 */
 800d864:	2001      	movs	r0, #1
 800d866:	e7ea      	b.n	800d83e <inc_lock+0x2a>
 800d868:	20001c9c 	.word	0x20001c9c

0800d86c <clst2sect>:
	FATFS* fs,		/* Filesystem object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;		/* Cluster number is origin from 2 */
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800d86c:	6a02      	ldr	r2, [r0, #32]
	clst -= 2;		/* Cluster number is origin from 2 */
 800d86e:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800d870:	3a02      	subs	r2, #2
{
 800d872:	0003      	movs	r3, r0
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800d874:	2000      	movs	r0, #0
 800d876:	428a      	cmp	r2, r1
 800d878:	d903      	bls.n	800d882 <clst2sect+0x16>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 800d87a:	8958      	ldrh	r0, [r3, #10]
 800d87c:	4341      	muls	r1, r0
 800d87e:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800d880:	1808      	adds	r0, r1, r0
}
 800d882:	4770      	bx	lr

0800d884 <clmt_clust>:
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File offset to be converted to cluster# */
)
{
 800d884:	0003      	movs	r3, r0
 800d886:	b510      	push	{r4, lr}
	DWORD cl, ncl, *tbl;
	FATFS *fs = fp->obj.fs;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800d888:	681b      	ldr	r3, [r3, #0]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 800d88a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800d88c:	0a48      	lsrs	r0, r1, #9
 800d88e:	8959      	ldrh	r1, [r3, #10]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 800d890:	1d14      	adds	r4, r2, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800d892:	f7f2 fc71 	bl	8000178 <__udivsi3>
 800d896:	0002      	movs	r2, r0
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800d898:	6820      	ldr	r0, [r4, #0]
		if (ncl == 0) return 0;	/* End of table? (error) */
 800d89a:	2800      	cmp	r0, #0
 800d89c:	d006      	beq.n	800d8ac <clmt_clust+0x28>
		if (cl < ncl) break;	/* In this fragment? */
 800d89e:	4282      	cmp	r2, r0
 800d8a0:	d302      	bcc.n	800d8a8 <clmt_clust+0x24>
		cl -= ncl; tbl++;		/* Next fragment */
 800d8a2:	1a12      	subs	r2, r2, r0
 800d8a4:	3408      	adds	r4, #8
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800d8a6:	e7f7      	b.n	800d898 <clmt_clust+0x14>
	}
	return cl + *tbl;	/* Return the cluster number */
 800d8a8:	6860      	ldr	r0, [r4, #4]
 800d8aa:	1810      	adds	r0, r2, r0
}
 800d8ac:	bd10      	pop	{r4, pc}

0800d8ae <sum_sfn>:

static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 800d8ae:	0001      	movs	r1, r0
	BYTE sum = 0;
 800d8b0:	2300      	movs	r3, #0
 800d8b2:	310b      	adds	r1, #11
	UINT n = 11;

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800d8b4:	085a      	lsrs	r2, r3, #1
 800d8b6:	01db      	lsls	r3, r3, #7
 800d8b8:	4313      	orrs	r3, r2
 800d8ba:	7802      	ldrb	r2, [r0, #0]
 800d8bc:	3001      	adds	r0, #1
 800d8be:	189b      	adds	r3, r3, r2
 800d8c0:	b2db      	uxtb	r3, r3
	} while (--n);
 800d8c2:	4288      	cmp	r0, r1
 800d8c4:	d1f6      	bne.n	800d8b4 <sum_sfn+0x6>
	return sum;
}
 800d8c6:	0018      	movs	r0, r3
 800d8c8:	4770      	bx	lr

0800d8ca <get_ldnumber>:
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 800d8ca:	6802      	ldr	r2, [r0, #0]
 800d8cc:	1e13      	subs	r3, r2, #0
 800d8ce:	d103      	bne.n	800d8d8 <get_ldnumber+0xe>
	int vol = -1;
 800d8d0:	2001      	movs	r0, #1
 800d8d2:	4240      	negs	r0, r0
 800d8d4:	e00e      	b.n	800d8f4 <get_ldnumber+0x2a>
		for (tt = *path; (UINT)*tt >= (FF_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find a colon in the path */
 800d8d6:	3301      	adds	r3, #1
 800d8d8:	7819      	ldrb	r1, [r3, #0]
 800d8da:	291f      	cmp	r1, #31
 800d8dc:	d909      	bls.n	800d8f2 <get_ldnumber+0x28>
 800d8de:	293a      	cmp	r1, #58	; 0x3a
 800d8e0:	d1f9      	bne.n	800d8d6 <get_ldnumber+0xc>
		if (*tt == ':') {	/* If a colon is exist in the path name */
			tp = *path;
			i = *tp++;
 800d8e2:	1c51      	adds	r1, r2, #1
			if (IsDigit(i) && tp == tt) {	/* Is there a numeric drive id + colon? */
 800d8e4:	428b      	cmp	r3, r1
 800d8e6:	d1f3      	bne.n	800d8d0 <get_ldnumber+0x6>
				if ((i -= '0') < FF_VOLUMES) {	/* If drive id is found, get the value and strip it */
 800d8e8:	7812      	ldrb	r2, [r2, #0]
 800d8ea:	2a30      	cmp	r2, #48	; 0x30
 800d8ec:	d1f0      	bne.n	800d8d0 <get_ldnumber+0x6>
					vol = (int)i;
					*path = ++tt;
 800d8ee:	3301      	adds	r3, #1
 800d8f0:	6003      	str	r3, [r0, #0]
#endif
		} else {	/* No volume id and use default drive */
#if FF_FS_RPATH != 0 && FF_VOLUMES >= 2
			vol = CurrVol;	/* Current drive */
#else
			vol = 0;		/* Drive 0 */
 800d8f2:	2000      	movs	r0, #0
#endif
		}
	}
	return vol;
}
 800d8f4:	4770      	bx	lr

0800d8f6 <mem_cpy.part.0>:
void mem_cpy (void* dst, const void* src, UINT cnt)
 800d8f6:	2300      	movs	r3, #0
 800d8f8:	b510      	push	{r4, lr}
			*d++ = *s++;
 800d8fa:	5ccc      	ldrb	r4, [r1, r3]
 800d8fc:	54c4      	strb	r4, [r0, r3]
 800d8fe:	3301      	adds	r3, #1
		} while (--cnt);
 800d900:	429a      	cmp	r2, r3
 800d902:	d1fa      	bne.n	800d8fa <mem_cpy.part.0+0x4>
}
 800d904:	bd10      	pop	{r4, pc}
	...

0800d908 <chk_lock>:
{
 800d908:	b570      	push	{r4, r5, r6, lr}
		if (Files[i].fs) {	/* Existing entry */
 800d90a:	4b0f      	ldr	r3, [pc, #60]	; (800d948 <chk_lock+0x40>)
{
 800d90c:	0002      	movs	r2, r0
		if (Files[i].fs) {	/* Existing entry */
 800d90e:	681c      	ldr	r4, [r3, #0]
				Files[i].clu == dp->obj.sclust &&
 800d910:	685e      	ldr	r6, [r3, #4]
				Files[i].ofs == dp->dptr) break;
 800d912:	689d      	ldr	r5, [r3, #8]
		return (!be && acc != 2) ? FR_TOO_MANY_OPEN_FILES : FR_OK;	/* Is there a blank entry for new object? */
 800d914:	1e20      	subs	r0, r4, #0
		if (Files[i].fs) {	/* Existing entry */
 800d916:	d011      	beq.n	800d93c <chk_lock+0x34>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matches with an open object */
 800d918:	6810      	ldr	r0, [r2, #0]
 800d91a:	4284      	cmp	r4, r0
 800d91c:	d10f      	bne.n	800d93e <chk_lock+0x36>
 800d91e:	6890      	ldr	r0, [r2, #8]
 800d920:	4286      	cmp	r6, r0
 800d922:	d10c      	bne.n	800d93e <chk_lock+0x36>
				Files[i].clu == dp->obj.sclust &&
 800d924:	6952      	ldr	r2, [r2, #20]
 800d926:	4295      	cmp	r5, r2
 800d928:	d109      	bne.n	800d93e <chk_lock+0x36>
	return (acc != 0 || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 800d92a:	2010      	movs	r0, #16
 800d92c:	2900      	cmp	r1, #0
 800d92e:	d105      	bne.n	800d93c <chk_lock+0x34>
 800d930:	8998      	ldrh	r0, [r3, #12]
 800d932:	3801      	subs	r0, #1
 800d934:	38ff      	subs	r0, #255	; 0xff
 800d936:	4243      	negs	r3, r0
 800d938:	4158      	adcs	r0, r3
 800d93a:	0100      	lsls	r0, r0, #4
}
 800d93c:	bd70      	pop	{r4, r5, r6, pc}
		return (!be && acc != 2) ? FR_TOO_MANY_OPEN_FILES : FR_OK;	/* Is there a blank entry for new object? */
 800d93e:	2000      	movs	r0, #0
 800d940:	2902      	cmp	r1, #2
 800d942:	d0fb      	beq.n	800d93c <chk_lock+0x34>
 800d944:	3012      	adds	r0, #18
 800d946:	e7f9      	b.n	800d93c <chk_lock+0x34>
 800d948:	20001c9c 	.word	0x20001c9c

0800d94c <dec_lock>:
{
 800d94c:	0003      	movs	r3, r0
		res = FR_INT_ERR;			/* Invalid index nunber */
 800d94e:	2002      	movs	r0, #2
	if (--i < FF_FS_LOCK) {	/* Index number origin from 0 */
 800d950:	2b01      	cmp	r3, #1
 800d952:	d112      	bne.n	800d97a <dec_lock+0x2e>
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 800d954:	2180      	movs	r1, #128	; 0x80
		n = Files[i].ctr;
 800d956:	4a09      	ldr	r2, [pc, #36]	; (800d97c <dec_lock+0x30>)
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 800d958:	0049      	lsls	r1, r1, #1
		n = Files[i].ctr;
 800d95a:	8993      	ldrh	r3, [r2, #12]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 800d95c:	428b      	cmp	r3, r1
 800d95e:	d104      	bne.n	800d96a <dec_lock+0x1e>
		Files[i].ctr = n;
 800d960:	2300      	movs	r3, #0
 800d962:	8193      	strh	r3, [r2, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 800d964:	2000      	movs	r0, #0
 800d966:	6010      	str	r0, [r2, #0]
 800d968:	e007      	b.n	800d97a <dec_lock+0x2e>
		if (n > 0) n--;				/* Decrement read mode open count */
 800d96a:	2b00      	cmp	r3, #0
 800d96c:	d0fa      	beq.n	800d964 <dec_lock+0x18>
 800d96e:	3b01      	subs	r3, #1
 800d970:	b29b      	uxth	r3, r3
		Files[i].ctr = n;
 800d972:	8193      	strh	r3, [r2, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 800d974:	2000      	movs	r0, #0
 800d976:	2b00      	cmp	r3, #0
 800d978:	d0f4      	beq.n	800d964 <dec_lock+0x18>
}
 800d97a:	4770      	bx	lr
 800d97c:	20001c9c 	.word	0x20001c9c

0800d980 <ld_clust.isra.5>:
	rv = rv << 8 | ptr[0];
 800d980:	7eca      	ldrb	r2, [r1, #27]
DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
 800d982:	b510      	push	{r4, lr}
 800d984:	0004      	movs	r4, r0
	rv = rv << 8 | ptr[0];
 800d986:	7e88      	ldrb	r0, [r1, #26]
 800d988:	0212      	lsls	r2, r2, #8
	cl = ld_word(dir + DIR_FstClusLO);
 800d98a:	4310      	orrs	r0, r2
	if (fs->fs_type == FS_FAT32) {
 800d98c:	2c03      	cmp	r4, #3
 800d98e:	d105      	bne.n	800d99c <ld_clust.isra.5+0x1c>
	rv = rv << 8 | ptr[0];
 800d990:	7d4a      	ldrb	r2, [r1, #21]
 800d992:	7d0b      	ldrb	r3, [r1, #20]
 800d994:	0212      	lsls	r2, r2, #8
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800d996:	4313      	orrs	r3, r2
 800d998:	041b      	lsls	r3, r3, #16
 800d99a:	4318      	orrs	r0, r3
}
 800d99c:	bd10      	pop	{r4, pc}

0800d99e <st_clust.isra.6>:
	*ptr++ = (BYTE)val; val >>= 8;
 800d99e:	b293      	uxth	r3, r2
 800d9a0:	0a1b      	lsrs	r3, r3, #8
 800d9a2:	768a      	strb	r2, [r1, #26]
	*ptr++ = (BYTE)val;
 800d9a4:	76cb      	strb	r3, [r1, #27]
	if (fs->fs_type == FS_FAT32) {
 800d9a6:	7803      	ldrb	r3, [r0, #0]
 800d9a8:	2b03      	cmp	r3, #3
 800d9aa:	d103      	bne.n	800d9b4 <st_clust.isra.6+0x16>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800d9ac:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800d9ae:	750a      	strb	r2, [r1, #20]
 800d9b0:	0a12      	lsrs	r2, r2, #8
	*ptr++ = (BYTE)val;
 800d9b2:	754a      	strb	r2, [r1, #21]
}
 800d9b4:	4770      	bx	lr

0800d9b6 <sync_window>:
{
 800d9b6:	b570      	push	{r4, r5, r6, lr}
	if (fs->wflag) {	/* Is the disk access window dirty */
 800d9b8:	78c3      	ldrb	r3, [r0, #3]
{
 800d9ba:	0004      	movs	r4, r0
	if (fs->wflag) {	/* Is the disk access window dirty */
 800d9bc:	2b00      	cmp	r3, #0
 800d9be:	d102      	bne.n	800d9c6 <sync_window+0x10>
	FRESULT res = FR_OK;
 800d9c0:	2300      	movs	r3, #0
}
 800d9c2:	0018      	movs	r0, r3
 800d9c4:	bd70      	pop	{r4, r5, r6, pc}
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 800d9c6:	0006      	movs	r6, r0
 800d9c8:	363c      	adds	r6, #60	; 0x3c
 800d9ca:	2301      	movs	r3, #1
 800d9cc:	7840      	ldrb	r0, [r0, #1]
 800d9ce:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800d9d0:	0031      	movs	r1, r6
 800d9d2:	f7ff feeb 	bl	800d7ac <disk_write>
			res = FR_DISK_ERR;
 800d9d6:	2301      	movs	r3, #1
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 800d9d8:	1e05      	subs	r5, r0, #0
 800d9da:	d1f2      	bne.n	800d9c2 <sync_window+0xc>
			fs->wflag = 0;	/* Clear window dirty flag */
 800d9dc:	70e0      	strb	r0, [r4, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 800d9de:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800d9e0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800d9e2:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800d9e4:	1a51      	subs	r1, r2, r1
 800d9e6:	4281      	cmp	r1, r0
 800d9e8:	d2ea      	bcs.n	800d9c0 <sync_window+0xa>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 800d9ea:	78a1      	ldrb	r1, [r4, #2]
 800d9ec:	2902      	cmp	r1, #2
 800d9ee:	d1e7      	bne.n	800d9c0 <sync_window+0xa>
 800d9f0:	1812      	adds	r2, r2, r0
 800d9f2:	0031      	movs	r1, r6
 800d9f4:	7860      	ldrb	r0, [r4, #1]
 800d9f6:	f7ff fed9 	bl	800d7ac <disk_write>
	FRESULT res = FR_OK;
 800d9fa:	002b      	movs	r3, r5
 800d9fc:	e7e1      	b.n	800d9c2 <sync_window+0xc>

0800d9fe <move_window>:
{
 800d9fe:	b570      	push	{r4, r5, r6, lr}
	if (sector != fs->winsect) {	/* Window offset changed? */
 800da00:	6b83      	ldr	r3, [r0, #56]	; 0x38
{
 800da02:	0004      	movs	r4, r0
 800da04:	000e      	movs	r6, r1
	FRESULT res = FR_OK;
 800da06:	2500      	movs	r5, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 800da08:	428b      	cmp	r3, r1
 800da0a:	d010      	beq.n	800da2e <move_window+0x30>
		res = sync_window(fs);		/* Write-back changes */
 800da0c:	f7ff ffd3 	bl	800d9b6 <sync_window>
 800da10:	1e05      	subs	r5, r0, #0
		if (res == FR_OK) {			/* Fill sector window with new data */
 800da12:	d10c      	bne.n	800da2e <move_window+0x30>
			if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK) {
 800da14:	0021      	movs	r1, r4
 800da16:	7860      	ldrb	r0, [r4, #1]
 800da18:	2301      	movs	r3, #1
 800da1a:	0032      	movs	r2, r6
 800da1c:	313c      	adds	r1, #60	; 0x3c
 800da1e:	f7ff feb7 	bl	800d790 <disk_read>
 800da22:	2800      	cmp	r0, #0
 800da24:	d002      	beq.n	800da2c <move_window+0x2e>
				sector = 0xFFFFFFFF;	/* Invalidate window if read data is not valid */
 800da26:	2601      	movs	r6, #1
				res = FR_DISK_ERR;
 800da28:	3501      	adds	r5, #1
				sector = 0xFFFFFFFF;	/* Invalidate window if read data is not valid */
 800da2a:	4276      	negs	r6, r6
			fs->winsect = sector;
 800da2c:	63a6      	str	r6, [r4, #56]	; 0x38
}
 800da2e:	0028      	movs	r0, r5
 800da30:	bd70      	pop	{r4, r5, r6, pc}
	...

0800da34 <check_fs>:
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* Filesystem object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800da34:	2300      	movs	r3, #0
{
 800da36:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800da38:	70c3      	strb	r3, [r0, #3]
 800da3a:	3b01      	subs	r3, #1
 800da3c:	6383      	str	r3, [r0, #56]	; 0x38
{
 800da3e:	0004      	movs	r4, r0
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 800da40:	f7ff ffdd 	bl	800d9fe <move_window>
 800da44:	2304      	movs	r3, #4
 800da46:	2800      	cmp	r0, #0
 800da48:	d129      	bne.n	800da9e <check_fs+0x6a>
	rv = ptr[1];
 800da4a:	4b16      	ldr	r3, [pc, #88]	; (800daa4 <check_fs+0x70>)
	rv = rv << 8 | ptr[0];
 800da4c:	4a16      	ldr	r2, [pc, #88]	; (800daa8 <check_fs+0x74>)
 800da4e:	5ce3      	ldrb	r3, [r4, r3]
 800da50:	5ca2      	ldrb	r2, [r4, r2]
 800da52:	021b      	lsls	r3, r3, #8
 800da54:	431a      	orrs	r2, r3

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800da56:	4915      	ldr	r1, [pc, #84]	; (800daac <check_fs+0x78>)
 800da58:	b212      	sxth	r2, r2
 800da5a:	2303      	movs	r3, #3
 800da5c:	428a      	cmp	r2, r1
 800da5e:	d11e      	bne.n	800da9e <check_fs+0x6a>

#if FF_FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* Check if exFAT VBR */
#endif
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {	/* Valid JumpBoot code? */
 800da60:	0023      	movs	r3, r4
 800da62:	333c      	adds	r3, #60	; 0x3c
 800da64:	781b      	ldrb	r3, [r3, #0]
 800da66:	2be9      	cmp	r3, #233	; 0xe9
 800da68:	d006      	beq.n	800da78 <check_fs+0x44>
 800da6a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800da6c:	4a10      	ldr	r2, [pc, #64]	; (800dab0 <check_fs+0x7c>)
 800da6e:	4911      	ldr	r1, [pc, #68]	; (800dab4 <check_fs+0x80>)
 800da70:	401a      	ands	r2, r3
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
	}
	return 2;	/* Valid BS but not FAT */
 800da72:	2302      	movs	r3, #2
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {	/* Valid JumpBoot code? */
 800da74:	428a      	cmp	r2, r1
 800da76:	d112      	bne.n	800da9e <check_fs+0x6a>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
 800da78:	0020      	movs	r0, r4
 800da7a:	2203      	movs	r2, #3
 800da7c:	490e      	ldr	r1, [pc, #56]	; (800dab8 <check_fs+0x84>)
 800da7e:	3072      	adds	r0, #114	; 0x72
 800da80:	f7ff febb 	bl	800d7fa <mem_cmp>
 800da84:	2300      	movs	r3, #0
 800da86:	4298      	cmp	r0, r3
 800da88:	d009      	beq.n	800da9e <check_fs+0x6a>
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
 800da8a:	0020      	movs	r0, r4
 800da8c:	2205      	movs	r2, #5
 800da8e:	308e      	adds	r0, #142	; 0x8e
 800da90:	490a      	ldr	r1, [pc, #40]	; (800dabc <check_fs+0x88>)
 800da92:	f7ff feb2 	bl	800d7fa <mem_cmp>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
 800da96:	0003      	movs	r3, r0
 800da98:	1e58      	subs	r0, r3, #1
 800da9a:	4183      	sbcs	r3, r0
 800da9c:	005b      	lsls	r3, r3, #1
}
 800da9e:	0018      	movs	r0, r3
 800daa0:	bd10      	pop	{r4, pc}
 800daa2:	46c0      	nop			; (mov r8, r8)
 800daa4:	0000023b 	.word	0x0000023b
 800daa8:	0000023a 	.word	0x0000023a
 800daac:	ffffaa55 	.word	0xffffaa55
 800dab0:	00ff00ff 	.word	0x00ff00ff
 800dab4:	009000eb 	.word	0x009000eb
 800dab8:	0801c025 	.word	0x0801c025
 800dabc:	0801c029 	.word	0x0801c029

0800dac0 <find_volume>:
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 800dac0:	2300      	movs	r3, #0
{
 800dac2:	b5f0      	push	{r4, r5, r6, r7, lr}
	*rfs = 0;
 800dac4:	600b      	str	r3, [r1, #0]
{
 800dac6:	b08b      	sub	sp, #44	; 0x2c
 800dac8:	000d      	movs	r5, r1
 800daca:	0017      	movs	r7, r2
	vol = get_ldnumber(path);
 800dacc:	f7ff fefd 	bl	800d8ca <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 800dad0:	230b      	movs	r3, #11
	vol = get_ldnumber(path);
 800dad2:	1e06      	subs	r6, r0, #0
	if (vol < 0) return FR_INVALID_DRIVE;
 800dad4:	db1c      	blt.n	800db10 <find_volume+0x50>

	/* Check if the filesystem object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
 800dad6:	4bac      	ldr	r3, [pc, #688]	; (800dd88 <find_volume+0x2c8>)
 800dad8:	0082      	lsls	r2, r0, #2
 800dada:	58d4      	ldr	r4, [r2, r3]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 800dadc:	230c      	movs	r3, #12
 800dade:	2c00      	cmp	r4, #0
 800dae0:	d016      	beq.n	800db10 <find_volume+0x50>
	return ff_req_grant(fs->sobj);
 800dae2:	6920      	ldr	r0, [r4, #16]
 800dae4:	f001 fdb2 	bl	800f64c <ff_req_grant>
#if FF_FS_REENTRANT
	if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
 800dae8:	230f      	movs	r3, #15
 800daea:	2800      	cmp	r0, #0
 800daec:	d010      	beq.n	800db10 <find_volume+0x50>
#endif
	*rfs = fs;							/* Return pointer to the filesystem object */
 800daee:	602c      	str	r4, [r5, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 800daf0:	2501      	movs	r5, #1
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 800daf2:	7823      	ldrb	r3, [r4, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 800daf4:	43af      	bics	r7, r5
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 800daf6:	2b00      	cmp	r3, #0
 800daf8:	d00d      	beq.n	800db16 <find_volume+0x56>
		stat = disk_status(fs->pdrv);
 800dafa:	7860      	ldrb	r0, [r4, #1]
 800dafc:	f7ff fe26 	bl	800d74c <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 800db00:	4005      	ands	r5, r0
 800db02:	d108      	bne.n	800db16 <find_volume+0x56>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			}
			return FR_OK;				/* The filesystem object is valid */
 800db04:	002b      	movs	r3, r5
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 800db06:	2f00      	cmp	r7, #0
 800db08:	d002      	beq.n	800db10 <find_volume+0x50>
 800db0a:	0742      	lsls	r2, r0, #29
 800db0c:	d500      	bpl.n	800db10 <find_volume+0x50>
				return FR_WRITE_PROTECTED;
 800db0e:	230a      	movs	r3, #10
#endif
#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
}
 800db10:	0018      	movs	r0, r3
 800db12:	b00b      	add	sp, #44	; 0x2c
 800db14:	bdf0      	pop	{r4, r5, r6, r7, pc}
	fs->fs_type = 0;					/* Clear the filesystem object */
 800db16:	2300      	movs	r3, #0
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800db18:	b2f0      	uxtb	r0, r6
	fs->fs_type = 0;					/* Clear the filesystem object */
 800db1a:	7023      	strb	r3, [r4, #0]
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800db1c:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 800db1e:	f7ff fe23 	bl	800d768 <disk_initialize>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800db22:	2303      	movs	r3, #3
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 800db24:	07c2      	lsls	r2, r0, #31
 800db26:	d4f3      	bmi.n	800db10 <find_volume+0x50>
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 800db28:	2f00      	cmp	r7, #0
 800db2a:	d001      	beq.n	800db30 <find_volume+0x70>
 800db2c:	0743      	lsls	r3, r0, #29
 800db2e:	d4ee      	bmi.n	800db0e <find_volume+0x4e>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 800db30:	2100      	movs	r1, #0
 800db32:	0020      	movs	r0, r4
 800db34:	f7ff ff7e 	bl	800da34 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 800db38:	2802      	cmp	r0, #2
 800db3a:	d128      	bne.n	800db8e <find_volume+0xce>
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 800db3c:	2500      	movs	r5, #0
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800db3e:	4b93      	ldr	r3, [pc, #588]	; (800dd8c <find_volume+0x2cc>)
 800db40:	18e6      	adds	r6, r4, r3
 800db42:	012b      	lsls	r3, r5, #4
 800db44:	001a      	movs	r2, r3
 800db46:	2000      	movs	r0, #0
 800db48:	32ff      	adds	r2, #255	; 0xff
 800db4a:	32ff      	adds	r2, #255	; 0xff
 800db4c:	5ca2      	ldrb	r2, [r4, r2]
 800db4e:	4282      	cmp	r2, r0
 800db50:	d002      	beq.n	800db58 <find_volume+0x98>
 800db52:	18f0      	adds	r0, r6, r3
 800db54:	f7ff fe46 	bl	800d7e4 <ld_dword>
 800db58:	00ab      	lsls	r3, r5, #2
 800db5a:	aa06      	add	r2, sp, #24
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 800db5c:	3501      	adds	r5, #1
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800db5e:	5098      	str	r0, [r3, r2]
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 800db60:	2d04      	cmp	r5, #4
 800db62:	d1ee      	bne.n	800db42 <find_volume+0x82>
 800db64:	2500      	movs	r5, #0
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800db66:	2603      	movs	r6, #3
			bsect = br[i];
 800db68:	00ab      	lsls	r3, r5, #2
 800db6a:	aa06      	add	r2, sp, #24
 800db6c:	58d7      	ldr	r7, [r2, r3]
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800db6e:	0030      	movs	r0, r6
 800db70:	2f00      	cmp	r7, #0
 800db72:	d005      	beq.n	800db80 <find_volume+0xc0>
 800db74:	0039      	movs	r1, r7
 800db76:	0020      	movs	r0, r4
 800db78:	f7ff ff5c 	bl	800da34 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800db7c:	2801      	cmp	r0, #1
 800db7e:	d90e      	bls.n	800db9e <find_volume+0xde>
 800db80:	3501      	adds	r5, #1
 800db82:	2d04      	cmp	r5, #4
 800db84:	d1f0      	bne.n	800db68 <find_volume+0xa8>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800db86:	2301      	movs	r3, #1
 800db88:	2804      	cmp	r0, #4
 800db8a:	d106      	bne.n	800db9a <find_volume+0xda>
 800db8c:	e7c0      	b.n	800db10 <find_volume+0x50>
 800db8e:	2301      	movs	r3, #1
 800db90:	2804      	cmp	r0, #4
 800db92:	d0bd      	beq.n	800db10 <find_volume+0x50>
	bsect = 0;
 800db94:	2700      	movs	r7, #0
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800db96:	4298      	cmp	r0, r3
 800db98:	d901      	bls.n	800db9e <find_volume+0xde>
 800db9a:	230d      	movs	r3, #13
 800db9c:	e7b8      	b.n	800db10 <find_volume+0x50>
	rv = ptr[1];
 800db9e:	0023      	movs	r3, r4
 800dba0:	3348      	adds	r3, #72	; 0x48
	rv = rv << 8 | ptr[0];
 800dba2:	781a      	ldrb	r2, [r3, #0]
 800dba4:	3b01      	subs	r3, #1
 800dba6:	781b      	ldrb	r3, [r3, #0]
 800dba8:	0212      	lsls	r2, r2, #8
 800dbaa:	4313      	orrs	r3, r2
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800dbac:	2280      	movs	r2, #128	; 0x80
 800dbae:	b21b      	sxth	r3, r3
 800dbb0:	0092      	lsls	r2, r2, #2
 800dbb2:	4293      	cmp	r3, r2
 800dbb4:	d1f1      	bne.n	800db9a <find_volume+0xda>
	rv = ptr[1];
 800dbb6:	0023      	movs	r3, r4
 800dbb8:	3353      	adds	r3, #83	; 0x53
	rv = rv << 8 | ptr[0];
 800dbba:	781a      	ldrb	r2, [r3, #0]
 800dbbc:	3b01      	subs	r3, #1
 800dbbe:	781b      	ldrb	r3, [r3, #0]
 800dbc0:	0212      	lsls	r2, r2, #8
 800dbc2:	4313      	orrs	r3, r2
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 800dbc4:	d100      	bne.n	800dbc8 <find_volume+0x108>
 800dbc6:	e0c7      	b.n	800dd58 <find_volume+0x298>
		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 800dbc8:	9302      	str	r3, [sp, #8]
		fs->fsize = fasize;
 800dbca:	9b02      	ldr	r3, [sp, #8]
 800dbcc:	6263      	str	r3, [r4, #36]	; 0x24
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800dbce:	0023      	movs	r3, r4
 800dbd0:	334c      	adds	r3, #76	; 0x4c
 800dbd2:	781e      	ldrb	r6, [r3, #0]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800dbd4:	1e73      	subs	r3, r6, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800dbd6:	70a6      	strb	r6, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800dbd8:	2b01      	cmp	r3, #1
 800dbda:	d8de      	bhi.n	800db9a <find_volume+0xda>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 800dbdc:	0023      	movs	r3, r4
 800dbde:	3349      	adds	r3, #73	; 0x49
 800dbe0:	781d      	ldrb	r5, [r3, #0]
 800dbe2:	b2ab      	uxth	r3, r5
 800dbe4:	8163      	strh	r3, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 800dbe6:	2b00      	cmp	r3, #0
 800dbe8:	d0d7      	beq.n	800db9a <find_volume+0xda>
 800dbea:	1e6b      	subs	r3, r5, #1
 800dbec:	421d      	tst	r5, r3
 800dbee:	d1d4      	bne.n	800db9a <find_volume+0xda>
	rv = ptr[1];
 800dbf0:	0023      	movs	r3, r4
	rv = rv << 8 | ptr[0];
 800dbf2:	0022      	movs	r2, r4
	rv = ptr[1];
 800dbf4:	334e      	adds	r3, #78	; 0x4e
	rv = rv << 8 | ptr[0];
 800dbf6:	781b      	ldrb	r3, [r3, #0]
 800dbf8:	324d      	adds	r2, #77	; 0x4d
 800dbfa:	7812      	ldrb	r2, [r2, #0]
 800dbfc:	021b      	lsls	r3, r3, #8
 800dbfe:	431a      	orrs	r2, r3
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 800dc00:	0013      	movs	r3, r2
	rv = rv << 8 | ptr[0];
 800dc02:	9201      	str	r2, [sp, #4]
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 800dc04:	8122      	strh	r2, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800dc06:	071b      	lsls	r3, r3, #28
 800dc08:	d1c7      	bne.n	800db9a <find_volume+0xda>
	rv = ptr[1];
 800dc0a:	0023      	movs	r3, r4
	rv = rv << 8 | ptr[0];
 800dc0c:	0022      	movs	r2, r4
	rv = ptr[1];
 800dc0e:	3350      	adds	r3, #80	; 0x50
	rv = rv << 8 | ptr[0];
 800dc10:	781b      	ldrb	r3, [r3, #0]
 800dc12:	324f      	adds	r2, #79	; 0x4f
 800dc14:	7810      	ldrb	r0, [r2, #0]
 800dc16:	021b      	lsls	r3, r3, #8
 800dc18:	4318      	orrs	r0, r3
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 800dc1a:	d103      	bne.n	800dc24 <find_volume+0x164>
 800dc1c:	0020      	movs	r0, r4
 800dc1e:	305c      	adds	r0, #92	; 0x5c
 800dc20:	f7ff fde0 	bl	800d7e4 <ld_dword>
	rv = ptr[1];
 800dc24:	0023      	movs	r3, r4
	rv = rv << 8 | ptr[0];
 800dc26:	0022      	movs	r2, r4
	rv = ptr[1];
 800dc28:	334b      	adds	r3, #75	; 0x4b
	rv = rv << 8 | ptr[0];
 800dc2a:	781b      	ldrb	r3, [r3, #0]
 800dc2c:	324a      	adds	r2, #74	; 0x4a
 800dc2e:	7812      	ldrb	r2, [r2, #0]
 800dc30:	021b      	lsls	r3, r3, #8
 800dc32:	431a      	orrs	r2, r3
 800dc34:	9204      	str	r2, [sp, #16]
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 800dc36:	d0b0      	beq.n	800db9a <find_volume+0xda>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 800dc38:	9b02      	ldr	r3, [sp, #8]
 800dc3a:	4373      	muls	r3, r6
 800dc3c:	9305      	str	r3, [sp, #20]
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 800dc3e:	9b01      	ldr	r3, [sp, #4]
 800dc40:	091b      	lsrs	r3, r3, #4
 800dc42:	189b      	adds	r3, r3, r2
 800dc44:	9a05      	ldr	r2, [sp, #20]
 800dc46:	189b      	adds	r3, r3, r2
 800dc48:	9303      	str	r3, [sp, #12]
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 800dc4a:	4298      	cmp	r0, r3
 800dc4c:	d3a5      	bcc.n	800db9a <find_volume+0xda>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800dc4e:	1ac0      	subs	r0, r0, r3
 800dc50:	0029      	movs	r1, r5
 800dc52:	f7f2 fa91 	bl	8000178 <__udivsi3>
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800dc56:	2800      	cmp	r0, #0
 800dc58:	d09f      	beq.n	800db9a <find_volume+0xda>
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 800dc5a:	4b4d      	ldr	r3, [pc, #308]	; (800dd90 <find_volume+0x2d0>)
 800dc5c:	4298      	cmp	r0, r3
 800dc5e:	d89c      	bhi.n	800db9a <find_volume+0xda>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800dc60:	4b4c      	ldr	r3, [pc, #304]	; (800dd94 <find_volume+0x2d4>)
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 800dc62:	2603      	movs	r6, #3
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800dc64:	4298      	cmp	r0, r3
 800dc66:	d804      	bhi.n	800dc72 <find_volume+0x1b2>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800dc68:	4e4b      	ldr	r6, [pc, #300]	; (800dd98 <find_volume+0x2d8>)
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800dc6a:	4286      	cmp	r6, r0
 800dc6c:	41b6      	sbcs	r6, r6
 800dc6e:	4276      	negs	r6, r6
 800dc70:	3601      	adds	r6, #1
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800dc72:	9b04      	ldr	r3, [sp, #16]
		fs->database = bsect + sysect;					/* Data start sector */
 800dc74:	9a03      	ldr	r2, [sp, #12]
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800dc76:	1c85      	adds	r5, r0, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800dc78:	19db      	adds	r3, r3, r7
		fs->database = bsect + sysect;					/* Data start sector */
 800dc7a:	19d2      	adds	r2, r2, r7
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800dc7c:	6225      	str	r5, [r4, #32]
		fs->volbase = bsect;							/* Volume start sector */
 800dc7e:	62a7      	str	r7, [r4, #40]	; 0x28
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800dc80:	62e3      	str	r3, [r4, #44]	; 0x2c
		fs->database = bsect + sysect;					/* Data start sector */
 800dc82:	6362      	str	r2, [r4, #52]	; 0x34
		if (fmt == FS_FAT32) {
 800dc84:	2e03      	cmp	r6, #3
 800dc86:	d16d      	bne.n	800dd64 <find_volume+0x2a4>
	rv = ptr[1];
 800dc88:	0023      	movs	r3, r4
 800dc8a:	3367      	adds	r3, #103	; 0x67
	rv = rv << 8 | ptr[0];
 800dc8c:	781a      	ldrb	r2, [r3, #0]
 800dc8e:	3b01      	subs	r3, #1
 800dc90:	781b      	ldrb	r3, [r3, #0]
 800dc92:	0212      	lsls	r2, r2, #8
 800dc94:	4313      	orrs	r3, r2
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800dc96:	d000      	beq.n	800dc9a <find_volume+0x1da>
 800dc98:	e77f      	b.n	800db9a <find_volume+0xda>
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800dc9a:	9b01      	ldr	r3, [sp, #4]
 800dc9c:	2b00      	cmp	r3, #0
 800dc9e:	d000      	beq.n	800dca2 <find_volume+0x1e2>
 800dca0:	e77b      	b.n	800db9a <find_volume+0xda>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 800dca2:	0020      	movs	r0, r4
 800dca4:	3068      	adds	r0, #104	; 0x68
 800dca6:	f7ff fd9d 	bl	800d7e4 <ld_dword>
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800dcaa:	00ad      	lsls	r5, r5, #2
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 800dcac:	6320      	str	r0, [r4, #48]	; 0x30
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800dcae:	4b3b      	ldr	r3, [pc, #236]	; (800dd9c <find_volume+0x2dc>)
 800dcb0:	18ed      	adds	r5, r5, r3
 800dcb2:	9b02      	ldr	r3, [sp, #8]
 800dcb4:	0a6d      	lsrs	r5, r5, #9
 800dcb6:	429d      	cmp	r5, r3
 800dcb8:	d900      	bls.n	800dcbc <find_volume+0x1fc>
 800dcba:	e76e      	b.n	800db9a <find_volume+0xda>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800dcbc:	2301      	movs	r3, #1
 800dcbe:	425b      	negs	r3, r3
 800dcc0:	61a3      	str	r3, [r4, #24]
 800dcc2:	6163      	str	r3, [r4, #20]
		fs->fsi_flag = 0x80;
 800dcc4:	3381      	adds	r3, #129	; 0x81
 800dcc6:	7123      	strb	r3, [r4, #4]
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
 800dcc8:	2e03      	cmp	r6, #3
 800dcca:	d134      	bne.n	800dd36 <find_volume+0x276>
	rv = ptr[1];
 800dccc:	0023      	movs	r3, r4
 800dcce:	336d      	adds	r3, #109	; 0x6d
	rv = rv << 8 | ptr[0];
 800dcd0:	781a      	ldrb	r2, [r3, #0]
 800dcd2:	3b01      	subs	r3, #1
 800dcd4:	781b      	ldrb	r3, [r3, #0]
 800dcd6:	0212      	lsls	r2, r2, #8
 800dcd8:	4313      	orrs	r3, r2
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 800dcda:	2b01      	cmp	r3, #1
 800dcdc:	d12b      	bne.n	800dd36 <find_volume+0x276>
			&& move_window(fs, bsect + 1) == FR_OK)
 800dcde:	1c79      	adds	r1, r7, #1
 800dce0:	0020      	movs	r0, r4
 800dce2:	f7ff fe8c 	bl	800d9fe <move_window>
 800dce6:	2800      	cmp	r0, #0
 800dce8:	d125      	bne.n	800dd36 <find_volume+0x276>
	rv = ptr[1];
 800dcea:	4b2d      	ldr	r3, [pc, #180]	; (800dda0 <find_volume+0x2e0>)
			fs->fsi_flag = 0;
 800dcec:	7120      	strb	r0, [r4, #4]
	rv = rv << 8 | ptr[0];
 800dcee:	5ce2      	ldrb	r2, [r4, r3]
 800dcf0:	4b2c      	ldr	r3, [pc, #176]	; (800dda4 <find_volume+0x2e4>)
 800dcf2:	0212      	lsls	r2, r2, #8
 800dcf4:	5ce3      	ldrb	r3, [r4, r3]
 800dcf6:	4313      	orrs	r3, r2
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 800dcf8:	4a2b      	ldr	r2, [pc, #172]	; (800dda8 <find_volume+0x2e8>)
 800dcfa:	b21b      	sxth	r3, r3
 800dcfc:	4293      	cmp	r3, r2
 800dcfe:	d11a      	bne.n	800dd36 <find_volume+0x276>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 800dd00:	0020      	movs	r0, r4
 800dd02:	303c      	adds	r0, #60	; 0x3c
 800dd04:	f7ff fd6e 	bl	800d7e4 <ld_dword>
 800dd08:	4b28      	ldr	r3, [pc, #160]	; (800ddac <find_volume+0x2ec>)
 800dd0a:	4298      	cmp	r0, r3
 800dd0c:	d113      	bne.n	800dd36 <find_volume+0x276>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 800dd0e:	2388      	movs	r3, #136	; 0x88
 800dd10:	009b      	lsls	r3, r3, #2
 800dd12:	18e0      	adds	r0, r4, r3
 800dd14:	f7ff fd66 	bl	800d7e4 <ld_dword>
 800dd18:	4b25      	ldr	r3, [pc, #148]	; (800ddb0 <find_volume+0x2f0>)
 800dd1a:	4298      	cmp	r0, r3
 800dd1c:	d10b      	bne.n	800dd36 <find_volume+0x276>
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 800dd1e:	2389      	movs	r3, #137	; 0x89
 800dd20:	009b      	lsls	r3, r3, #2
 800dd22:	18e0      	adds	r0, r4, r3
 800dd24:	f7ff fd5e 	bl	800d7e4 <ld_dword>
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 800dd28:	238a      	movs	r3, #138	; 0x8a
 800dd2a:	009b      	lsls	r3, r3, #2
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 800dd2c:	61a0      	str	r0, [r4, #24]
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 800dd2e:	18e0      	adds	r0, r4, r3
 800dd30:	f7ff fd58 	bl	800d7e4 <ld_dword>
 800dd34:	6160      	str	r0, [r4, #20]
	fs->id = ++Fsid;		/* Volume mount ID */
 800dd36:	4a1f      	ldr	r2, [pc, #124]	; (800ddb4 <find_volume+0x2f4>)
		if (Files[i].fs == fs) Files[i].fs = 0;
 800dd38:	491f      	ldr	r1, [pc, #124]	; (800ddb8 <find_volume+0x2f8>)
	fs->id = ++Fsid;		/* Volume mount ID */
 800dd3a:	8813      	ldrh	r3, [r2, #0]
		if (Files[i].fs == fs) Files[i].fs = 0;
 800dd3c:	6808      	ldr	r0, [r1, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
 800dd3e:	3301      	adds	r3, #1
 800dd40:	b29b      	uxth	r3, r3
 800dd42:	8013      	strh	r3, [r2, #0]
	fs->cdir = 0;			/* Initialize current directory */
 800dd44:	2200      	movs	r2, #0
	fs->id = ++Fsid;		/* Volume mount ID */
 800dd46:	80e3      	strh	r3, [r4, #6]
	fs->fs_type = fmt;		/* FAT sub-type */
 800dd48:	7026      	strb	r6, [r4, #0]
	fs->cdir = 0;			/* Initialize current directory */
 800dd4a:	61e2      	str	r2, [r4, #28]
	return FR_OK;
 800dd4c:	0013      	movs	r3, r2
		if (Files[i].fs == fs) Files[i].fs = 0;
 800dd4e:	4284      	cmp	r4, r0
 800dd50:	d000      	beq.n	800dd54 <find_volume+0x294>
 800dd52:	e6dd      	b.n	800db10 <find_volume+0x50>
 800dd54:	600a      	str	r2, [r1, #0]
 800dd56:	e6db      	b.n	800db10 <find_volume+0x50>
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 800dd58:	0020      	movs	r0, r4
 800dd5a:	3060      	adds	r0, #96	; 0x60
 800dd5c:	f7ff fd42 	bl	800d7e4 <ld_dword>
 800dd60:	9002      	str	r0, [sp, #8]
 800dd62:	e732      	b.n	800dbca <find_volume+0x10a>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 800dd64:	9a01      	ldr	r2, [sp, #4]
 800dd66:	2a00      	cmp	r2, #0
 800dd68:	d100      	bne.n	800dd6c <find_volume+0x2ac>
 800dd6a:	e716      	b.n	800db9a <find_volume+0xda>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800dd6c:	9a05      	ldr	r2, [sp, #20]
 800dd6e:	189b      	adds	r3, r3, r2
 800dd70:	6323      	str	r3, [r4, #48]	; 0x30
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800dd72:	2e02      	cmp	r6, #2
 800dd74:	d101      	bne.n	800dd7a <find_volume+0x2ba>
 800dd76:	006d      	lsls	r5, r5, #1
 800dd78:	e799      	b.n	800dcae <find_volume+0x1ee>
 800dd7a:	2003      	movs	r0, #3
 800dd7c:	2301      	movs	r3, #1
 800dd7e:	4368      	muls	r0, r5
 800dd80:	401d      	ands	r5, r3
 800dd82:	0840      	lsrs	r0, r0, #1
 800dd84:	1945      	adds	r5, r0, r5
 800dd86:	e792      	b.n	800dcae <find_volume+0x1ee>
 800dd88:	20001c98 	.word	0x20001c98
 800dd8c:	00000202 	.word	0x00000202
 800dd90:	0ffffff5 	.word	0x0ffffff5
 800dd94:	0000fff5 	.word	0x0000fff5
 800dd98:	00000ff5 	.word	0x00000ff5
 800dd9c:	000001ff 	.word	0x000001ff
 800dda0:	0000023b 	.word	0x0000023b
 800dda4:	0000023a 	.word	0x0000023a
 800dda8:	ffffaa55 	.word	0xffffaa55
 800ddac:	41615252 	.word	0x41615252
 800ddb0:	61417272 	.word	0x61417272
 800ddb4:	20001cac 	.word	0x20001cac
 800ddb8:	20001c9c 	.word	0x20001c9c

0800ddbc <put_fat>:
{
 800ddbc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ddbe:	0006      	movs	r6, r0
 800ddc0:	b085      	sub	sp, #20
 800ddc2:	000d      	movs	r5, r1
 800ddc4:	0014      	movs	r4, r2
	FRESULT res = FR_INT_ERR;
 800ddc6:	2702      	movs	r7, #2
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800ddc8:	2901      	cmp	r1, #1
 800ddca:	d946      	bls.n	800de5a <put_fat+0x9e>
 800ddcc:	6a03      	ldr	r3, [r0, #32]
 800ddce:	428b      	cmp	r3, r1
 800ddd0:	d943      	bls.n	800de5a <put_fat+0x9e>
		switch (fs->fs_type) {
 800ddd2:	7803      	ldrb	r3, [r0, #0]
 800ddd4:	9300      	str	r3, [sp, #0]
 800ddd6:	42bb      	cmp	r3, r7
 800ddd8:	d049      	beq.n	800de6e <put_fat+0xb2>
 800ddda:	2b03      	cmp	r3, #3
 800dddc:	d05a      	beq.n	800de94 <put_fat+0xd8>
	FRESULT res = FR_INT_ERR;
 800ddde:	2702      	movs	r7, #2
		switch (fs->fs_type) {
 800dde0:	2b01      	cmp	r3, #1
 800dde2:	d13a      	bne.n	800de5a <put_fat+0x9e>
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 800dde4:	084b      	lsrs	r3, r1, #1
 800dde6:	185b      	adds	r3, r3, r1
 800dde8:	9301      	str	r3, [sp, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800ddea:	0a59      	lsrs	r1, r3, #9
 800ddec:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800ddee:	18c9      	adds	r1, r1, r3
 800ddf0:	f7ff fe05 	bl	800d9fe <move_window>
 800ddf4:	1e07      	subs	r7, r0, #0
			if (res != FR_OK) break;
 800ddf6:	d130      	bne.n	800de5a <put_fat+0x9e>
			p = fs->win + bc++ % SS(fs);
 800ddf8:	0033      	movs	r3, r6
 800ddfa:	333c      	adds	r3, #60	; 0x3c
 800ddfc:	9302      	str	r3, [sp, #8]
 800ddfe:	9b01      	ldr	r3, [sp, #4]
 800de00:	9a02      	ldr	r2, [sp, #8]
 800de02:	3301      	adds	r3, #1
 800de04:	9303      	str	r3, [sp, #12]
 800de06:	9b01      	ldr	r3, [sp, #4]
 800de08:	05db      	lsls	r3, r3, #23
 800de0a:	0ddb      	lsrs	r3, r3, #23
 800de0c:	18d3      	adds	r3, r2, r3
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 800de0e:	9a00      	ldr	r2, [sp, #0]
 800de10:	4015      	ands	r5, r2
 800de12:	b2e2      	uxtb	r2, r4
 800de14:	2d00      	cmp	r5, #0
 800de16:	d008      	beq.n	800de2a <put_fat+0x6e>
 800de18:	210f      	movs	r1, #15
 800de1a:	20ff      	movs	r0, #255	; 0xff
 800de1c:	781a      	ldrb	r2, [r3, #0]
 800de1e:	0100      	lsls	r0, r0, #4
 800de20:	400a      	ands	r2, r1
 800de22:	0121      	lsls	r1, r4, #4
 800de24:	4001      	ands	r1, r0
 800de26:	430a      	orrs	r2, r1
 800de28:	b2d2      	uxtb	r2, r2
 800de2a:	701a      	strb	r2, [r3, #0]
			fs->wflag = 1;
 800de2c:	2301      	movs	r3, #1
 800de2e:	70f3      	strb	r3, [r6, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800de30:	9b03      	ldr	r3, [sp, #12]
 800de32:	0030      	movs	r0, r6
 800de34:	0a59      	lsrs	r1, r3, #9
 800de36:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800de38:	18c9      	adds	r1, r1, r3
 800de3a:	f7ff fde0 	bl	800d9fe <move_window>
 800de3e:	1e07      	subs	r7, r0, #0
			if (res != FR_OK) break;
 800de40:	d10b      	bne.n	800de5a <put_fat+0x9e>
			p = fs->win + bc % SS(fs);
 800de42:	9b03      	ldr	r3, [sp, #12]
 800de44:	05da      	lsls	r2, r3, #23
 800de46:	9b02      	ldr	r3, [sp, #8]
 800de48:	0dd2      	lsrs	r2, r2, #23
 800de4a:	189a      	adds	r2, r3, r2
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 800de4c:	2d00      	cmp	r5, #0
 800de4e:	d007      	beq.n	800de60 <put_fat+0xa4>
 800de50:	0924      	lsrs	r4, r4, #4
 800de52:	b2e4      	uxtb	r4, r4
 800de54:	7014      	strb	r4, [r2, #0]
			fs->wflag = 1;
 800de56:	2301      	movs	r3, #1
 800de58:	70f3      	strb	r3, [r6, #3]
}
 800de5a:	0038      	movs	r0, r7
 800de5c:	b005      	add	sp, #20
 800de5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 800de60:	210f      	movs	r1, #15
 800de62:	7813      	ldrb	r3, [r2, #0]
 800de64:	0a24      	lsrs	r4, r4, #8
 800de66:	438b      	bics	r3, r1
 800de68:	400c      	ands	r4, r1
 800de6a:	431c      	orrs	r4, r3
 800de6c:	e7f2      	b.n	800de54 <put_fat+0x98>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800de6e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800de70:	0a09      	lsrs	r1, r1, #8
 800de72:	18c9      	adds	r1, r1, r3
 800de74:	f7ff fdc3 	bl	800d9fe <move_window>
 800de78:	1e07      	subs	r7, r0, #0
			if (res != FR_OK) break;
 800de7a:	d1ee      	bne.n	800de5a <put_fat+0x9e>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 800de7c:	22ff      	movs	r2, #255	; 0xff
 800de7e:	0033      	movs	r3, r6
 800de80:	006d      	lsls	r5, r5, #1
 800de82:	0052      	lsls	r2, r2, #1
 800de84:	333c      	adds	r3, #60	; 0x3c
 800de86:	4015      	ands	r5, r2
 800de88:	195d      	adds	r5, r3, r5
	*ptr++ = (BYTE)val; val >>= 8;
 800de8a:	702c      	strb	r4, [r5, #0]
 800de8c:	b2a4      	uxth	r4, r4
 800de8e:	0a24      	lsrs	r4, r4, #8
	*ptr++ = (BYTE)val;
 800de90:	706c      	strb	r4, [r5, #1]
 800de92:	e7e0      	b.n	800de56 <put_fat+0x9a>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 800de94:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800de96:	09c9      	lsrs	r1, r1, #7
 800de98:	18c9      	adds	r1, r1, r3
 800de9a:	f7ff fdb0 	bl	800d9fe <move_window>
 800de9e:	1e07      	subs	r7, r0, #0
			if (res != FR_OK) break;
 800dea0:	d1db      	bne.n	800de5a <put_fat+0x9e>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 800dea2:	22fe      	movs	r2, #254	; 0xfe
 800dea4:	0033      	movs	r3, r6
 800dea6:	0052      	lsls	r2, r2, #1
 800dea8:	00ad      	lsls	r5, r5, #2
 800deaa:	333c      	adds	r3, #60	; 0x3c
 800deac:	4015      	ands	r5, r2
 800deae:	195d      	adds	r5, r3, r5
 800deb0:	0028      	movs	r0, r5
 800deb2:	f7ff fc97 	bl	800d7e4 <ld_dword>
 800deb6:	0124      	lsls	r4, r4, #4
 800deb8:	0f00      	lsrs	r0, r0, #28
 800deba:	0924      	lsrs	r4, r4, #4
 800debc:	0700      	lsls	r0, r0, #28
 800debe:	4304      	orrs	r4, r0
	*ptr++ = (BYTE)val; val >>= 8;
 800dec0:	0a23      	lsrs	r3, r4, #8
 800dec2:	702c      	strb	r4, [r5, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800dec4:	706b      	strb	r3, [r5, #1]
 800dec6:	0c23      	lsrs	r3, r4, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800dec8:	0e24      	lsrs	r4, r4, #24
 800deca:	70ab      	strb	r3, [r5, #2]
	*ptr++ = (BYTE)val;
 800decc:	70ec      	strb	r4, [r5, #3]
 800dece:	e7c2      	b.n	800de56 <put_fat+0x9a>

0800ded0 <get_fat.isra.12>:
DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 800ded0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
		val = 1;	/* Internal error */
 800ded2:	2601      	movs	r6, #1
DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 800ded4:	0004      	movs	r4, r0
 800ded6:	000d      	movs	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800ded8:	42b1      	cmp	r1, r6
 800deda:	d914      	bls.n	800df06 <get_fat.isra.12+0x36>
 800dedc:	6a03      	ldr	r3, [r0, #32]
 800dede:	4299      	cmp	r1, r3
 800dee0:	d211      	bcs.n	800df06 <get_fat.isra.12+0x36>
		switch (fs->fs_type) {
 800dee2:	7803      	ldrb	r3, [r0, #0]
 800dee4:	2b02      	cmp	r3, #2
 800dee6:	d02e      	beq.n	800df46 <get_fat.isra.12+0x76>
 800dee8:	2b03      	cmp	r3, #3
 800deea:	d03e      	beq.n	800df6a <get_fat.isra.12+0x9a>
 800deec:	42b3      	cmp	r3, r6
 800deee:	d10a      	bne.n	800df06 <get_fat.isra.12+0x36>
			bc = (UINT)clst; bc += bc / 2;
 800def0:	084f      	lsrs	r7, r1, #1
 800def2:	187f      	adds	r7, r7, r1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800def4:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800def6:	0a79      	lsrs	r1, r7, #9
 800def8:	18c9      	adds	r1, r1, r3
 800defa:	f7ff fd80 	bl	800d9fe <move_window>
 800defe:	2800      	cmp	r0, #0
 800df00:	d003      	beq.n	800df0a <get_fat.isra.12+0x3a>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800df02:	2601      	movs	r6, #1
 800df04:	4276      	negs	r6, r6
}
 800df06:	0030      	movs	r0, r6
 800df08:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800df0a:	1c7b      	adds	r3, r7, #1
 800df0c:	05ff      	lsls	r7, r7, #23
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df0e:	0a59      	lsrs	r1, r3, #9
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800df10:	9301      	str	r3, [sp, #4]
 800df12:	0dff      	lsrs	r7, r7, #23
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df14:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800df16:	19e7      	adds	r7, r4, r7
 800df18:	373c      	adds	r7, #60	; 0x3c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df1a:	18c9      	adds	r1, r1, r3
 800df1c:	0020      	movs	r0, r4
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800df1e:	783f      	ldrb	r7, [r7, #0]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df20:	f7ff fd6d 	bl	800d9fe <move_window>
 800df24:	2800      	cmp	r0, #0
 800df26:	d1ec      	bne.n	800df02 <get_fat.isra.12+0x32>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 800df28:	9b01      	ldr	r3, [sp, #4]
 800df2a:	05d8      	lsls	r0, r3, #23
 800df2c:	0dc0      	lsrs	r0, r0, #23
 800df2e:	1824      	adds	r4, r4, r0
 800df30:	343c      	adds	r4, #60	; 0x3c
 800df32:	7820      	ldrb	r0, [r4, #0]
 800df34:	0200      	lsls	r0, r0, #8
 800df36:	4307      	orrs	r7, r0
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 800df38:	4235      	tst	r5, r6
 800df3a:	d001      	beq.n	800df40 <get_fat.isra.12+0x70>
 800df3c:	093e      	lsrs	r6, r7, #4
 800df3e:	e7e2      	b.n	800df06 <get_fat.isra.12+0x36>
 800df40:	053f      	lsls	r7, r7, #20
 800df42:	0d3e      	lsrs	r6, r7, #20
 800df44:	e7df      	b.n	800df06 <get_fat.isra.12+0x36>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800df46:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800df48:	0a09      	lsrs	r1, r1, #8
 800df4a:	18c9      	adds	r1, r1, r3
 800df4c:	f7ff fd57 	bl	800d9fe <move_window>
 800df50:	2800      	cmp	r0, #0
 800df52:	d1d6      	bne.n	800df02 <get_fat.isra.12+0x32>
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 800df54:	30ff      	adds	r0, #255	; 0xff
 800df56:	30ff      	adds	r0, #255	; 0xff
 800df58:	006d      	lsls	r5, r5, #1
 800df5a:	4005      	ands	r5, r0
 800df5c:	343c      	adds	r4, #60	; 0x3c
 800df5e:	1964      	adds	r4, r4, r5
	rv = rv << 8 | ptr[0];
 800df60:	7866      	ldrb	r6, [r4, #1]
 800df62:	7820      	ldrb	r0, [r4, #0]
 800df64:	0236      	lsls	r6, r6, #8
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 800df66:	4306      	orrs	r6, r0
 800df68:	e7cd      	b.n	800df06 <get_fat.isra.12+0x36>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800df6a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800df6c:	09c9      	lsrs	r1, r1, #7
 800df6e:	18c9      	adds	r1, r1, r3
 800df70:	f7ff fd45 	bl	800d9fe <move_window>
 800df74:	2800      	cmp	r0, #0
 800df76:	d1c4      	bne.n	800df02 <get_fat.isra.12+0x32>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 800df78:	0020      	movs	r0, r4
 800df7a:	24fe      	movs	r4, #254	; 0xfe
 800df7c:	00ad      	lsls	r5, r5, #2
 800df7e:	0064      	lsls	r4, r4, #1
 800df80:	303c      	adds	r0, #60	; 0x3c
 800df82:	4025      	ands	r5, r4
 800df84:	1940      	adds	r0, r0, r5
 800df86:	f7ff fc2d 	bl	800d7e4 <ld_dword>
 800df8a:	0106      	lsls	r6, r0, #4
 800df8c:	0936      	lsrs	r6, r6, #4
 800df8e:	e7ba      	b.n	800df06 <get_fat.isra.12+0x36>

0800df90 <dir_sdi>:
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800df90:	4b23      	ldr	r3, [pc, #140]	; (800e020 <dir_sdi+0x90>)
{
 800df92:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800df94:	0006      	movs	r6, r0
 800df96:	000c      	movs	r4, r1
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800df98:	4299      	cmp	r1, r3
 800df9a:	d901      	bls.n	800dfa0 <dir_sdi+0x10>
		return FR_INT_ERR;
 800df9c:	2002      	movs	r0, #2
}
 800df9e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800dfa0:	06cb      	lsls	r3, r1, #27
 800dfa2:	d1fb      	bne.n	800df9c <dir_sdi+0xc>
	FATFS *fs = dp->obj.fs;
 800dfa4:	6805      	ldr	r5, [r0, #0]
	dp->dptr = ofs;				/* Set current offset */
 800dfa6:	6171      	str	r1, [r6, #20]
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 800dfa8:	6887      	ldr	r7, [r0, #8]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800dfaa:	2f00      	cmp	r7, #0
 800dfac:	d119      	bne.n	800dfe2 <dir_sdi+0x52>
 800dfae:	782b      	ldrb	r3, [r5, #0]
 800dfb0:	2b02      	cmp	r3, #2
 800dfb2:	d902      	bls.n	800dfba <dir_sdi+0x2a>
		clst = fs->dirbase;
 800dfb4:	6b2b      	ldr	r3, [r5, #48]	; 0x30
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 800dfb6:	2b00      	cmp	r3, #0
 800dfb8:	d114      	bne.n	800dfe4 <dir_sdi+0x54>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 800dfba:	892a      	ldrh	r2, [r5, #8]
 800dfbc:	0963      	lsrs	r3, r4, #5
 800dfbe:	4293      	cmp	r3, r2
 800dfc0:	d2ec      	bcs.n	800df9c <dir_sdi+0xc>
		dp->sect = fs->dirbase;
 800dfc2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800dfc4:	61f3      	str	r3, [r6, #28]
	if (dp->sect == 0) return FR_INT_ERR;
 800dfc6:	69f2      	ldr	r2, [r6, #28]
	dp->clust = clst;					/* Current cluster# */
 800dfc8:	61b7      	str	r7, [r6, #24]
	if (dp->sect == 0) return FR_INT_ERR;
 800dfca:	2a00      	cmp	r2, #0
 800dfcc:	d0e6      	beq.n	800df9c <dir_sdi+0xc>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800dfce:	0a63      	lsrs	r3, r4, #9
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800dfd0:	05e4      	lsls	r4, r4, #23
 800dfd2:	353c      	adds	r5, #60	; 0x3c
 800dfd4:	0de4      	lsrs	r4, r4, #23
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800dfd6:	189b      	adds	r3, r3, r2
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800dfd8:	192c      	adds	r4, r5, r4
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800dfda:	61f3      	str	r3, [r6, #28]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800dfdc:	6234      	str	r4, [r6, #32]
	return FR_OK;
 800dfde:	2000      	movs	r0, #0
 800dfe0:	e7dd      	b.n	800df9e <dir_sdi+0xe>
 800dfe2:	003b      	movs	r3, r7
		while (ofs >= csz) {				/* Follow cluster chain */
 800dfe4:	001f      	movs	r7, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800dfe6:	896a      	ldrh	r2, [r5, #10]
 800dfe8:	0252      	lsls	r2, r2, #9
 800dfea:	9201      	str	r2, [sp, #4]
		while (ofs >= csz) {				/* Follow cluster chain */
 800dfec:	9b01      	ldr	r3, [sp, #4]
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 800dfee:	0039      	movs	r1, r7
		while (ofs >= csz) {				/* Follow cluster chain */
 800dff0:	429c      	cmp	r4, r3
 800dff2:	d204      	bcs.n	800dffe <dir_sdi+0x6e>
		dp->sect = clst2sect(fs, clst);
 800dff4:	0028      	movs	r0, r5
 800dff6:	f7ff fc39 	bl	800d86c <clst2sect>
 800dffa:	61f0      	str	r0, [r6, #28]
 800dffc:	e7e3      	b.n	800dfc6 <dir_sdi+0x36>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 800dffe:	6830      	ldr	r0, [r6, #0]
 800e000:	f7ff ff66 	bl	800ded0 <get_fat.isra.12>
 800e004:	0007      	movs	r7, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800e006:	1c43      	adds	r3, r0, #1
 800e008:	d007      	beq.n	800e01a <dir_sdi+0x8a>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 800e00a:	2801      	cmp	r0, #1
 800e00c:	d9c6      	bls.n	800df9c <dir_sdi+0xc>
 800e00e:	6a2b      	ldr	r3, [r5, #32]
 800e010:	4283      	cmp	r3, r0
 800e012:	d9c3      	bls.n	800df9c <dir_sdi+0xc>
			ofs -= csz;
 800e014:	9b01      	ldr	r3, [sp, #4]
 800e016:	1ae4      	subs	r4, r4, r3
 800e018:	e7e8      	b.n	800dfec <dir_sdi+0x5c>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800e01a:	2001      	movs	r0, #1
 800e01c:	e7bf      	b.n	800df9e <dir_sdi+0xe>
 800e01e:	46c0      	nop			; (mov r8, r8)
 800e020:	001fffff 	.word	0x001fffff

0800e024 <create_chain>:
{
 800e024:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e026:	1e0f      	subs	r7, r1, #0
 800e028:	9001      	str	r0, [sp, #4]
	FATFS *fs = obj->fs;
 800e02a:	6805      	ldr	r5, [r0, #0]
	if (clst == 0) {	/* Create a new chain */
 800e02c:	d10a      	bne.n	800e044 <create_chain+0x20>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
 800e02e:	696e      	ldr	r6, [r5, #20]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800e030:	2e00      	cmp	r6, #0
 800e032:	d018      	beq.n	800e066 <create_chain+0x42>
 800e034:	6a2b      	ldr	r3, [r5, #32]
 800e036:	42b3      	cmp	r3, r6
 800e038:	d915      	bls.n	800e066 <create_chain+0x42>
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 800e03a:	69ab      	ldr	r3, [r5, #24]
 800e03c:	2b00      	cmp	r3, #0
 800e03e:	d114      	bne.n	800e06a <create_chain+0x46>
 800e040:	2400      	movs	r4, #0
 800e042:	e009      	b.n	800e058 <create_chain+0x34>
		cs = get_fat(obj, clst);			/* Check the cluster status */
 800e044:	0028      	movs	r0, r5
 800e046:	f7ff ff43 	bl	800ded0 <get_fat.isra.12>
 800e04a:	0004      	movs	r4, r0
		if (cs < 2) return 1;				/* Test for insanity */
 800e04c:	2801      	cmp	r0, #1
 800e04e:	d95c      	bls.n	800e10a <create_chain+0xe6>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 800e050:	1c43      	adds	r3, r0, #1
 800e052:	d103      	bne.n	800e05c <create_chain+0x38>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 800e054:	2401      	movs	r4, #1
 800e056:	4264      	negs	r4, r4
}
 800e058:	0020      	movs	r0, r4
 800e05a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800e05c:	6a2b      	ldr	r3, [r5, #32]
 800e05e:	003e      	movs	r6, r7
 800e060:	4283      	cmp	r3, r0
 800e062:	d9ea      	bls.n	800e03a <create_chain+0x16>
 800e064:	e7f8      	b.n	800e058 <create_chain+0x34>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800e066:	2601      	movs	r6, #1
 800e068:	e7e7      	b.n	800e03a <create_chain+0x16>
		if (scl == clst) {						/* Stretching an existing chain? */
 800e06a:	42be      	cmp	r6, r7
 800e06c:	d115      	bne.n	800e09a <create_chain+0x76>
			if (ncl >= fs->n_fatent) ncl = 2;
 800e06e:	6a2b      	ldr	r3, [r5, #32]
			ncl = scl + 1;						/* Test if next cluster is free */
 800e070:	1c74      	adds	r4, r6, #1
			if (ncl >= fs->n_fatent) ncl = 2;
 800e072:	429c      	cmp	r4, r3
 800e074:	d300      	bcc.n	800e078 <create_chain+0x54>
 800e076:	2402      	movs	r4, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 800e078:	9b01      	ldr	r3, [sp, #4]
 800e07a:	0021      	movs	r1, r4
 800e07c:	6818      	ldr	r0, [r3, #0]
 800e07e:	f7ff ff27 	bl	800ded0 <get_fat.isra.12>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 800e082:	2801      	cmp	r0, #1
 800e084:	d041      	beq.n	800e10a <create_chain+0xe6>
 800e086:	1c43      	adds	r3, r0, #1
 800e088:	d0e4      	beq.n	800e054 <create_chain+0x30>
			if (cs != 0) {						/* Not free? */
 800e08a:	2800      	cmp	r0, #0
 800e08c:	d01b      	beq.n	800e0c6 <create_chain+0xa2>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 800e08e:	696b      	ldr	r3, [r5, #20]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 800e090:	2b01      	cmp	r3, #1
 800e092:	d902      	bls.n	800e09a <create_chain+0x76>
 800e094:	6a2a      	ldr	r2, [r5, #32]
 800e096:	4293      	cmp	r3, r2
 800e098:	d32c      	bcc.n	800e0f4 <create_chain+0xd0>
 800e09a:	0034      	movs	r4, r6
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 800e09c:	6a2b      	ldr	r3, [r5, #32]
				ncl++;							/* Next cluster */
 800e09e:	3401      	adds	r4, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 800e0a0:	42a3      	cmp	r3, r4
 800e0a2:	d802      	bhi.n	800e0aa <create_chain+0x86>
					if (ncl > scl) return 0;	/* No free cluster found? */
 800e0a4:	2e01      	cmp	r6, #1
 800e0a6:	d9cb      	bls.n	800e040 <create_chain+0x1c>
					ncl = 2;
 800e0a8:	2402      	movs	r4, #2
				cs = get_fat(obj, ncl);			/* Get the cluster status */
 800e0aa:	9b01      	ldr	r3, [sp, #4]
 800e0ac:	0021      	movs	r1, r4
 800e0ae:	6818      	ldr	r0, [r3, #0]
 800e0b0:	f7ff ff0e 	bl	800ded0 <get_fat.isra.12>
				if (cs == 0) break;				/* Found a free cluster? */
 800e0b4:	2800      	cmp	r0, #0
 800e0b6:	d008      	beq.n	800e0ca <create_chain+0xa6>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 800e0b8:	2801      	cmp	r0, #1
 800e0ba:	d026      	beq.n	800e10a <create_chain+0xe6>
 800e0bc:	1c43      	adds	r3, r0, #1
 800e0be:	d0c9      	beq.n	800e054 <create_chain+0x30>
				if (ncl == scl) return 0;		/* No free cluster found? */
 800e0c0:	42b4      	cmp	r4, r6
 800e0c2:	d1eb      	bne.n	800e09c <create_chain+0x78>
 800e0c4:	e7bc      	b.n	800e040 <create_chain+0x1c>
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 800e0c6:	2c00      	cmp	r4, #0
 800e0c8:	d0e7      	beq.n	800e09a <create_chain+0x76>
		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
 800e0ca:	2201      	movs	r2, #1
 800e0cc:	0021      	movs	r1, r4
 800e0ce:	4252      	negs	r2, r2
 800e0d0:	0028      	movs	r0, r5
 800e0d2:	f7ff fe73 	bl	800ddbc <put_fat>
		if (res == FR_OK && clst != 0) {
 800e0d6:	2800      	cmp	r0, #0
 800e0d8:	d115      	bne.n	800e106 <create_chain+0xe2>
 800e0da:	2f00      	cmp	r7, #0
 800e0dc:	d10c      	bne.n	800e0f8 <create_chain+0xd4>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800e0de:	6a2a      	ldr	r2, [r5, #32]
 800e0e0:	69ab      	ldr	r3, [r5, #24]
 800e0e2:	3a02      	subs	r2, #2
		fs->last_clst = ncl;
 800e0e4:	616c      	str	r4, [r5, #20]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800e0e6:	4293      	cmp	r3, r2
 800e0e8:	d911      	bls.n	800e10e <create_chain+0xea>
		fs->fsi_flag |= 1;
 800e0ea:	2301      	movs	r3, #1
 800e0ec:	792a      	ldrb	r2, [r5, #4]
 800e0ee:	4313      	orrs	r3, r2
 800e0f0:	712b      	strb	r3, [r5, #4]
 800e0f2:	e7b1      	b.n	800e058 <create_chain+0x34>
 800e0f4:	001e      	movs	r6, r3
 800e0f6:	e7d0      	b.n	800e09a <create_chain+0x76>
			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
 800e0f8:	0022      	movs	r2, r4
 800e0fa:	0039      	movs	r1, r7
 800e0fc:	0028      	movs	r0, r5
 800e0fe:	f7ff fe5d 	bl	800ddbc <put_fat>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 800e102:	2800      	cmp	r0, #0
 800e104:	d0eb      	beq.n	800e0de <create_chain+0xba>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 800e106:	2801      	cmp	r0, #1
 800e108:	d0a4      	beq.n	800e054 <create_chain+0x30>
 800e10a:	2401      	movs	r4, #1
 800e10c:	e7a4      	b.n	800e058 <create_chain+0x34>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800e10e:	3b01      	subs	r3, #1
 800e110:	61ab      	str	r3, [r5, #24]
 800e112:	e7ea      	b.n	800e0ea <create_chain+0xc6>

0800e114 <remove_chain>:
{
 800e114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e116:	000d      	movs	r5, r1
 800e118:	0007      	movs	r7, r0
 800e11a:	0011      	movs	r1, r2
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800e11c:	2d01      	cmp	r5, #1
 800e11e:	d92e      	bls.n	800e17e <remove_chain+0x6a>
	FATFS *fs = obj->fs;
 800e120:	6804      	ldr	r4, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800e122:	6a23      	ldr	r3, [r4, #32]
 800e124:	42ab      	cmp	r3, r5
 800e126:	d92a      	bls.n	800e17e <remove_chain+0x6a>
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 800e128:	2a00      	cmp	r2, #0
 800e12a:	d006      	beq.n	800e13a <remove_chain+0x26>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 800e12c:	2201      	movs	r2, #1
 800e12e:	0020      	movs	r0, r4
 800e130:	4252      	negs	r2, r2
 800e132:	f7ff fe43 	bl	800ddbc <put_fat>
		if (res != FR_OK) return res;
 800e136:	2800      	cmp	r0, #0
 800e138:	d106      	bne.n	800e148 <remove_chain+0x34>
		nxt = get_fat(obj, clst);			/* Get cluster status */
 800e13a:	0029      	movs	r1, r5
 800e13c:	6838      	ldr	r0, [r7, #0]
 800e13e:	f7ff fec7 	bl	800ded0 <get_fat.isra.12>
 800e142:	1e06      	subs	r6, r0, #0
		if (nxt == 0) break;				/* Empty cluster? */
 800e144:	d101      	bne.n	800e14a <remove_chain+0x36>
	return FR_OK;
 800e146:	2000      	movs	r0, #0
}
 800e148:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 800e14a:	2801      	cmp	r0, #1
 800e14c:	d017      	beq.n	800e17e <remove_chain+0x6a>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800e14e:	1c43      	adds	r3, r0, #1
 800e150:	d017      	beq.n	800e182 <remove_chain+0x6e>
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 800e152:	2200      	movs	r2, #0
 800e154:	0029      	movs	r1, r5
 800e156:	0020      	movs	r0, r4
 800e158:	f7ff fe30 	bl	800ddbc <put_fat>
			if (res != FR_OK) return res;
 800e15c:	2800      	cmp	r0, #0
 800e15e:	d1f3      	bne.n	800e148 <remove_chain+0x34>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 800e160:	6a22      	ldr	r2, [r4, #32]
 800e162:	69a3      	ldr	r3, [r4, #24]
 800e164:	1e91      	subs	r1, r2, #2
 800e166:	428b      	cmp	r3, r1
 800e168:	d205      	bcs.n	800e176 <remove_chain+0x62>
			fs->fsi_flag |= 1;
 800e16a:	2101      	movs	r1, #1
			fs->free_clst++;
 800e16c:	3301      	adds	r3, #1
 800e16e:	61a3      	str	r3, [r4, #24]
			fs->fsi_flag |= 1;
 800e170:	7923      	ldrb	r3, [r4, #4]
 800e172:	430b      	orrs	r3, r1
 800e174:	7123      	strb	r3, [r4, #4]
 800e176:	0035      	movs	r5, r6
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 800e178:	42b2      	cmp	r2, r6
 800e17a:	d8de      	bhi.n	800e13a <remove_chain+0x26>
 800e17c:	e7e3      	b.n	800e146 <remove_chain+0x32>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800e17e:	2002      	movs	r0, #2
 800e180:	e7e2      	b.n	800e148 <remove_chain+0x34>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800e182:	2001      	movs	r0, #1
 800e184:	e7e0      	b.n	800e148 <remove_chain+0x34>

0800e186 <unlock_fs>:
{
 800e186:	b510      	push	{r4, lr}
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 800e188:	2800      	cmp	r0, #0
 800e18a:	d008      	beq.n	800e19e <unlock_fs+0x18>
 800e18c:	000b      	movs	r3, r1
 800e18e:	3b0b      	subs	r3, #11
 800e190:	2b01      	cmp	r3, #1
 800e192:	d904      	bls.n	800e19e <unlock_fs+0x18>
 800e194:	290f      	cmp	r1, #15
 800e196:	d002      	beq.n	800e19e <unlock_fs+0x18>
		ff_rel_grant(fs->sobj);
 800e198:	6900      	ldr	r0, [r0, #16]
 800e19a:	f001 fa62 	bl	800f662 <ff_rel_grant>
}
 800e19e:	bd10      	pop	{r4, pc}

0800e1a0 <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	FFOBJID* obj,	/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
	FATFS** rfs		/* Pointer to pointer to the owner filesystem object to return */
)
{
 800e1a0:	b570      	push	{r4, r5, r6, lr}
 800e1a2:	0004      	movs	r4, r0
 800e1a4:	000d      	movs	r5, r1
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800e1a6:	2800      	cmp	r0, #0
 800e1a8:	d01f      	beq.n	800e1ea <validate+0x4a>
 800e1aa:	6803      	ldr	r3, [r0, #0]
	FRESULT res = FR_INVALID_OBJECT;
 800e1ac:	2009      	movs	r0, #9
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800e1ae:	2b00      	cmp	r3, #0
 800e1b0:	d015      	beq.n	800e1de <validate+0x3e>
 800e1b2:	781a      	ldrb	r2, [r3, #0]
 800e1b4:	2a00      	cmp	r2, #0
 800e1b6:	d018      	beq.n	800e1ea <validate+0x4a>
 800e1b8:	88a1      	ldrh	r1, [r4, #4]
 800e1ba:	88da      	ldrh	r2, [r3, #6]
 800e1bc:	4291      	cmp	r1, r2
 800e1be:	d114      	bne.n	800e1ea <validate+0x4a>
	return ff_req_grant(fs->sobj);
 800e1c0:	6918      	ldr	r0, [r3, #16]
 800e1c2:	f001 fa43 	bl	800f64c <ff_req_grant>
 800e1c6:	0003      	movs	r3, r0
				res = FR_OK;
			} else {
				unlock_fs(obj->fs, FR_OK);
			}
		} else {
			res = FR_TIMEOUT;
 800e1c8:	200f      	movs	r0, #15
		if (lock_fs(obj->fs)) {	/* Obtain the filesystem object */
 800e1ca:	2b00      	cmp	r3, #0
 800e1cc:	d007      	beq.n	800e1de <validate+0x3e>
			if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800e1ce:	6823      	ldr	r3, [r4, #0]
 800e1d0:	7858      	ldrb	r0, [r3, #1]
 800e1d2:	f7ff fabb 	bl	800d74c <disk_status>
 800e1d6:	2301      	movs	r3, #1
 800e1d8:	4018      	ands	r0, r3
 800e1da:	d102      	bne.n	800e1e2 <validate+0x42>
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800e1dc:	6823      	ldr	r3, [r4, #0]
 800e1de:	602b      	str	r3, [r5, #0]
	return res;
}
 800e1e0:	bd70      	pop	{r4, r5, r6, pc}
				unlock_fs(obj->fs, FR_OK);
 800e1e2:	2100      	movs	r1, #0
 800e1e4:	6820      	ldr	r0, [r4, #0]
 800e1e6:	f7ff ffce 	bl	800e186 <unlock_fs>
	FRESULT res = FR_INVALID_OBJECT;
 800e1ea:	2009      	movs	r0, #9
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800e1ec:	2300      	movs	r3, #0
 800e1ee:	e7f6      	b.n	800e1de <validate+0x3e>

0800e1f0 <dir_clear>:
{
 800e1f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e1f2:	0004      	movs	r4, r0
 800e1f4:	000e      	movs	r6, r1
	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 800e1f6:	f7ff fbde 	bl	800d9b6 <sync_window>
 800e1fa:	0005      	movs	r5, r0
 800e1fc:	2001      	movs	r0, #1
 800e1fe:	2d00      	cmp	r5, #0
 800e200:	d136      	bne.n	800e270 <dir_clear+0x80>
	sect = clst2sect(fs, clst);		/* Top of the cluster */
 800e202:	0031      	movs	r1, r6
 800e204:	0020      	movs	r0, r4
 800e206:	f7ff fb31 	bl	800d86c <clst2sect>
	mem_set(fs->win, 0, SS(fs));	/* Clear window buffer */
 800e20a:	0023      	movs	r3, r4
 800e20c:	228f      	movs	r2, #143	; 0x8f
 800e20e:	333c      	adds	r3, #60	; 0x3c
 800e210:	0092      	lsls	r2, r2, #2
	sect = clst2sect(fs, clst);		/* Top of the cluster */
 800e212:	9000      	str	r0, [sp, #0]
	fs->winsect = sect;				/* Set window to top of the cluster */
 800e214:	63a0      	str	r0, [r4, #56]	; 0x38
	mem_set(fs->win, 0, SS(fs));	/* Clear window buffer */
 800e216:	9301      	str	r3, [sp, #4]
 800e218:	18a2      	adds	r2, r4, r2
		*d++ = (BYTE)val;
 800e21a:	701d      	strb	r5, [r3, #0]
 800e21c:	3301      	adds	r3, #1
	} while (--cnt);
 800e21e:	429a      	cmp	r2, r3
 800e220:	d1fb      	bne.n	800e21a <dir_clear+0x2a>
	for (szb = ((DWORD)fs->csize * SS(fs) >= 0x8000) ? 0x8000 : fs->csize * SS(fs); szb > SS(fs) && !(ibuf = ff_memalloc(szb)); szb /= 2) ;
 800e222:	8965      	ldrh	r5, [r4, #10]
 800e224:	4b21      	ldr	r3, [pc, #132]	; (800e2ac <dir_clear+0xbc>)
 800e226:	026d      	lsls	r5, r5, #9
 800e228:	429d      	cmp	r5, r3
 800e22a:	d901      	bls.n	800e230 <dir_clear+0x40>
 800e22c:	2580      	movs	r5, #128	; 0x80
 800e22e:	022d      	lsls	r5, r5, #8
 800e230:	2780      	movs	r7, #128	; 0x80
 800e232:	00bf      	lsls	r7, r7, #2
 800e234:	42bd      	cmp	r5, r7
 800e236:	d929      	bls.n	800e28c <dir_clear+0x9c>
 800e238:	0028      	movs	r0, r5
 800e23a:	f001 f9f1 	bl	800f620 <ff_memalloc>
 800e23e:	1e06      	subs	r6, r0, #0
 800e240:	d017      	beq.n	800e272 <dir_clear+0x82>
 800e242:	0003      	movs	r3, r0
		*d++ = (BYTE)val;
 800e244:	2100      	movs	r1, #0
 800e246:	182a      	adds	r2, r5, r0
 800e248:	7019      	strb	r1, [r3, #0]
 800e24a:	3301      	adds	r3, #1
	} while (--cnt);
 800e24c:	429a      	cmp	r2, r3
 800e24e:	d1fb      	bne.n	800e248 <dir_clear+0x58>
		szb /= SS(fs);		/* Bytes -> Sectors */
 800e250:	0a6b      	lsrs	r3, r5, #9
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 800e252:	9d00      	ldr	r5, [sp, #0]
		szb /= SS(fs);		/* Bytes -> Sectors */
 800e254:	9301      	str	r3, [sp, #4]
 800e256:	9b00      	ldr	r3, [sp, #0]
 800e258:	1aef      	subs	r7, r5, r3
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 800e25a:	8963      	ldrh	r3, [r4, #10]
 800e25c:	42bb      	cmp	r3, r7
 800e25e:	d80a      	bhi.n	800e276 <dir_clear+0x86>
		ff_memfree(ibuf);
 800e260:	0030      	movs	r0, r6
 800e262:	f001 f9e1 	bl	800f628 <ff_memfree>
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
 800e266:	8960      	ldrh	r0, [r4, #10]
 800e268:	1bc7      	subs	r7, r0, r7
 800e26a:	1e78      	subs	r0, r7, #1
 800e26c:	4187      	sbcs	r7, r0
 800e26e:	b2f8      	uxtb	r0, r7
}
 800e270:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	for (szb = ((DWORD)fs->csize * SS(fs) >= 0x8000) ? 0x8000 : fs->csize * SS(fs); szb > SS(fs) && !(ibuf = ff_memalloc(szb)); szb /= 2) ;
 800e272:	086d      	lsrs	r5, r5, #1
 800e274:	e7de      	b.n	800e234 <dir_clear+0x44>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 800e276:	9b01      	ldr	r3, [sp, #4]
 800e278:	002a      	movs	r2, r5
 800e27a:	7860      	ldrb	r0, [r4, #1]
 800e27c:	0031      	movs	r1, r6
 800e27e:	f7ff fa95 	bl	800d7ac <disk_write>
 800e282:	9b01      	ldr	r3, [sp, #4]
 800e284:	18ed      	adds	r5, r5, r3
 800e286:	2800      	cmp	r0, #0
 800e288:	d0e5      	beq.n	800e256 <dir_clear+0x66>
 800e28a:	e7e9      	b.n	800e260 <dir_clear+0x70>
 800e28c:	9d00      	ldr	r5, [sp, #0]
 800e28e:	9b00      	ldr	r3, [sp, #0]
 800e290:	1aef      	subs	r7, r5, r3
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 800e292:	8963      	ldrh	r3, [r4, #10]
 800e294:	42bb      	cmp	r3, r7
 800e296:	d9e6      	bls.n	800e266 <dir_clear+0x76>
 800e298:	002a      	movs	r2, r5
 800e29a:	7860      	ldrb	r0, [r4, #1]
 800e29c:	2301      	movs	r3, #1
 800e29e:	9901      	ldr	r1, [sp, #4]
 800e2a0:	f7ff fa84 	bl	800d7ac <disk_write>
 800e2a4:	3501      	adds	r5, #1
 800e2a6:	2800      	cmp	r0, #0
 800e2a8:	d0f1      	beq.n	800e28e <dir_clear+0x9e>
 800e2aa:	e7dc      	b.n	800e266 <dir_clear+0x76>
 800e2ac:	00007fff 	.word	0x00007fff

0800e2b0 <dir_next>:
{
 800e2b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800e2b2:	69c3      	ldr	r3, [r0, #28]
{
 800e2b4:	0004      	movs	r4, r0
 800e2b6:	9101      	str	r1, [sp, #4]
	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800e2b8:	2004      	movs	r0, #4
 800e2ba:	2b00      	cmp	r3, #0
 800e2bc:	d015      	beq.n	800e2ea <dir_next+0x3a>
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800e2be:	6967      	ldr	r7, [r4, #20]
	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800e2c0:	4a25      	ldr	r2, [pc, #148]	; (800e358 <dir_next+0xa8>)
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800e2c2:	3720      	adds	r7, #32
	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800e2c4:	4297      	cmp	r7, r2
 800e2c6:	d810      	bhi.n	800e2ea <dir_next+0x3a>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800e2c8:	05fa      	lsls	r2, r7, #23
 800e2ca:	0dd2      	lsrs	r2, r2, #23
	FATFS *fs = dp->obj.fs;
 800e2cc:	6825      	ldr	r5, [r4, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800e2ce:	9200      	str	r2, [sp, #0]
 800e2d0:	d13b      	bne.n	800e34a <dir_next+0x9a>
		if (dp->clust == 0) {	/* Static table */
 800e2d2:	69a1      	ldr	r1, [r4, #24]
		dp->sect++;				/* Next sector */
 800e2d4:	3301      	adds	r3, #1
 800e2d6:	61e3      	str	r3, [r4, #28]
		if (dp->clust == 0) {	/* Static table */
 800e2d8:	2900      	cmp	r1, #0
 800e2da:	d107      	bne.n	800e2ec <dir_next+0x3c>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800e2dc:	892a      	ldrh	r2, [r5, #8]
 800e2de:	097b      	lsrs	r3, r7, #5
 800e2e0:	4293      	cmp	r3, r2
 800e2e2:	d332      	bcc.n	800e34a <dir_next+0x9a>
				dp->sect = 0; return FR_NO_FILE;
 800e2e4:	2300      	movs	r3, #0
 800e2e6:	2004      	movs	r0, #4
 800e2e8:	61e3      	str	r3, [r4, #28]
}
 800e2ea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 800e2ec:	896b      	ldrh	r3, [r5, #10]
 800e2ee:	0a7a      	lsrs	r2, r7, #9
 800e2f0:	3b01      	subs	r3, #1
 800e2f2:	421a      	tst	r2, r3
 800e2f4:	d129      	bne.n	800e34a <dir_next+0x9a>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 800e2f6:	0028      	movs	r0, r5
 800e2f8:	f7ff fdea 	bl	800ded0 <get_fat.isra.12>
 800e2fc:	0006      	movs	r6, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 800e2fe:	2801      	cmp	r0, #1
 800e300:	d801      	bhi.n	800e306 <dir_next+0x56>
 800e302:	2002      	movs	r0, #2
 800e304:	e7f1      	b.n	800e2ea <dir_next+0x3a>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800e306:	1c43      	adds	r3, r0, #1
 800e308:	d101      	bne.n	800e30e <dir_next+0x5e>
 800e30a:	2001      	movs	r0, #1
 800e30c:	e7ed      	b.n	800e2ea <dir_next+0x3a>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 800e30e:	6a2b      	ldr	r3, [r5, #32]
 800e310:	4283      	cmp	r3, r0
 800e312:	d814      	bhi.n	800e33e <dir_next+0x8e>
					if (!stretch) {								/* If no stretch, report EOT */
 800e314:	9b01      	ldr	r3, [sp, #4]
 800e316:	2b00      	cmp	r3, #0
 800e318:	d0e4      	beq.n	800e2e4 <dir_next+0x34>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 800e31a:	69a1      	ldr	r1, [r4, #24]
 800e31c:	0020      	movs	r0, r4
 800e31e:	f7ff fe81 	bl	800e024 <create_chain>
 800e322:	0006      	movs	r6, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800e324:	2007      	movs	r0, #7
 800e326:	2e00      	cmp	r6, #0
 800e328:	d0df      	beq.n	800e2ea <dir_next+0x3a>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 800e32a:	2e01      	cmp	r6, #1
 800e32c:	d0e9      	beq.n	800e302 <dir_next+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800e32e:	1c73      	adds	r3, r6, #1
 800e330:	d0eb      	beq.n	800e30a <dir_next+0x5a>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 800e332:	0031      	movs	r1, r6
 800e334:	0028      	movs	r0, r5
 800e336:	f7ff ff5b 	bl	800e1f0 <dir_clear>
 800e33a:	2800      	cmp	r0, #0
 800e33c:	d1e5      	bne.n	800e30a <dir_next+0x5a>
				dp->clust = clst;		/* Initialize data for new cluster */
 800e33e:	61a6      	str	r6, [r4, #24]
				dp->sect = clst2sect(fs, clst);
 800e340:	0031      	movs	r1, r6
 800e342:	0028      	movs	r0, r5
 800e344:	f7ff fa92 	bl	800d86c <clst2sect>
 800e348:	61e0      	str	r0, [r4, #28]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800e34a:	9b00      	ldr	r3, [sp, #0]
 800e34c:	353c      	adds	r5, #60	; 0x3c
 800e34e:	18ed      	adds	r5, r5, r3
	dp->dptr = ofs;						/* Current entry */
 800e350:	6167      	str	r7, [r4, #20]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800e352:	6225      	str	r5, [r4, #32]
	return FR_OK;
 800e354:	2000      	movs	r0, #0
 800e356:	e7c8      	b.n	800e2ea <dir_next+0x3a>
 800e358:	001fffff 	.word	0x001fffff

0800e35c <dir_alloc>:
{
 800e35c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e35e:	000f      	movs	r7, r1
	res = dir_sdi(dp, 0);
 800e360:	2100      	movs	r1, #0
{
 800e362:	0004      	movs	r4, r0
	FATFS *fs = dp->obj.fs;
 800e364:	6806      	ldr	r6, [r0, #0]
	res = dir_sdi(dp, 0);
 800e366:	f7ff fe13 	bl	800df90 <dir_sdi>
	if (res == FR_OK) {
 800e36a:	2800      	cmp	r0, #0
 800e36c:	d117      	bne.n	800e39e <dir_alloc+0x42>
		n = 0;
 800e36e:	0005      	movs	r5, r0
			res = move_window(fs, dp->sect);
 800e370:	69e1      	ldr	r1, [r4, #28]
 800e372:	0030      	movs	r0, r6
 800e374:	f7ff fb43 	bl	800d9fe <move_window>
			if (res != FR_OK) break;
 800e378:	2800      	cmp	r0, #0
 800e37a:	d110      	bne.n	800e39e <dir_alloc+0x42>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 800e37c:	6a23      	ldr	r3, [r4, #32]
 800e37e:	781b      	ldrb	r3, [r3, #0]
 800e380:	2be5      	cmp	r3, #229	; 0xe5
 800e382:	d001      	beq.n	800e388 <dir_alloc+0x2c>
 800e384:	2b00      	cmp	r3, #0
 800e386:	d103      	bne.n	800e390 <dir_alloc+0x34>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 800e388:	3501      	adds	r5, #1
 800e38a:	42bd      	cmp	r5, r7
 800e38c:	d101      	bne.n	800e392 <dir_alloc+0x36>
}
 800e38e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				n = 0;					/* Not a blank entry. Restart to search */
 800e390:	0005      	movs	r5, r0
			res = dir_next(dp, 1);
 800e392:	2101      	movs	r1, #1
 800e394:	0020      	movs	r0, r4
 800e396:	f7ff ff8b 	bl	800e2b0 <dir_next>
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 800e39a:	2800      	cmp	r0, #0
 800e39c:	d0e8      	beq.n	800e370 <dir_alloc+0x14>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 800e39e:	2804      	cmp	r0, #4
 800e3a0:	d1f5      	bne.n	800e38e <dir_alloc+0x32>
 800e3a2:	3003      	adds	r0, #3
 800e3a4:	e7f3      	b.n	800e38e <dir_alloc+0x32>
	...

0800e3a8 <dir_read>:
{
 800e3a8:	b5f0      	push	{r4, r5, r6, r7, lr}
	FATFS *fs = dp->obj.fs;
 800e3aa:	6803      	ldr	r3, [r0, #0]
{
 800e3ac:	b087      	sub	sp, #28
	FATFS *fs = dp->obj.fs;
 800e3ae:	9304      	str	r3, [sp, #16]
	BYTE ord = 0xFF, sum = 0xFF;
 800e3b0:	23ff      	movs	r3, #255	; 0xff
{
 800e3b2:	0005      	movs	r5, r0
	BYTE ord = 0xFF, sum = 0xFF;
 800e3b4:	001c      	movs	r4, r3
	FRESULT res = FR_NO_FILE;
 800e3b6:	2704      	movs	r7, #4
				ord = 0xFF;
 800e3b8:	001e      	movs	r6, r3
{
 800e3ba:	9105      	str	r1, [sp, #20]
	BYTE ord = 0xFF, sum = 0xFF;
 800e3bc:	9302      	str	r3, [sp, #8]
	while (dp->sect) {
 800e3be:	69e9      	ldr	r1, [r5, #28]
 800e3c0:	2900      	cmp	r1, #0
 800e3c2:	d102      	bne.n	800e3ca <dir_read+0x22>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800e3c4:	2f00      	cmp	r7, #0
 800e3c6:	d07d      	beq.n	800e4c4 <dir_read+0x11c>
 800e3c8:	e069      	b.n	800e49e <dir_read+0xf6>
		res = move_window(fs, dp->sect);
 800e3ca:	9804      	ldr	r0, [sp, #16]
 800e3cc:	f7ff fb17 	bl	800d9fe <move_window>
 800e3d0:	1e07      	subs	r7, r0, #0
		if (res != FR_OK) break;
 800e3d2:	d164      	bne.n	800e49e <dir_read+0xf6>
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 800e3d4:	6a28      	ldr	r0, [r5, #32]
 800e3d6:	7803      	ldrb	r3, [r0, #0]
 800e3d8:	9301      	str	r3, [sp, #4]
		if (c == 0) {
 800e3da:	2b00      	cmp	r3, #0
 800e3dc:	d100      	bne.n	800e3e0 <dir_read+0x38>
 800e3de:	e079      	b.n	800e4d4 <dir_read+0x12c>
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800e3e0:	223f      	movs	r2, #63	; 0x3f
 800e3e2:	7ac3      	ldrb	r3, [r0, #11]
 800e3e4:	4013      	ands	r3, r2
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800e3e6:	9a01      	ldr	r2, [sp, #4]
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800e3e8:	71ab      	strb	r3, [r5, #6]
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800e3ea:	2ae5      	cmp	r2, #229	; 0xe5
 800e3ec:	d05d      	beq.n	800e4aa <dir_read+0x102>
 800e3ee:	2a2e      	cmp	r2, #46	; 0x2e
 800e3f0:	d05b      	beq.n	800e4aa <dir_read+0x102>
 800e3f2:	2120      	movs	r1, #32
 800e3f4:	001a      	movs	r2, r3
 800e3f6:	438a      	bics	r2, r1
 800e3f8:	0011      	movs	r1, r2
 800e3fa:	3908      	subs	r1, #8
 800e3fc:	424a      	negs	r2, r1
 800e3fe:	414a      	adcs	r2, r1
 800e400:	0011      	movs	r1, r2
 800e402:	9a05      	ldr	r2, [sp, #20]
 800e404:	4291      	cmp	r1, r2
 800e406:	d150      	bne.n	800e4aa <dir_read+0x102>
				if (a == AM_LFN) {			/* An LFN entry is found */
 800e408:	2b0f      	cmp	r3, #15
 800e40a:	d154      	bne.n	800e4b6 <dir_read+0x10e>
					if (c & LLEF) {			/* Is it start of an LFN sequence? */
 800e40c:	9a01      	ldr	r2, [sp, #4]
 800e40e:	3331      	adds	r3, #49	; 0x31
 800e410:	421a      	tst	r2, r3
 800e412:	d047      	beq.n	800e4a4 <dir_read+0xfc>
						sum = dp->dir[LDIR_Chksum];
 800e414:	7b42      	ldrb	r2, [r0, #13]
 800e416:	9202      	str	r2, [sp, #8]
						c &= (BYTE)~LLEF; ord = c;
 800e418:	9a01      	ldr	r2, [sp, #4]
 800e41a:	439a      	bics	r2, r3
						dp->blk_ofs = dp->dptr;
 800e41c:	696b      	ldr	r3, [r5, #20]
						c &= (BYTE)~LLEF; ord = c;
 800e41e:	9201      	str	r2, [sp, #4]
						dp->blk_ofs = dp->dptr;
 800e420:	632b      	str	r3, [r5, #48]	; 0x30
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e422:	7b43      	ldrb	r3, [r0, #13]
 800e424:	9a02      	ldr	r2, [sp, #8]
 800e426:	0034      	movs	r4, r6
 800e428:	4293      	cmp	r3, r2
 800e42a:	d132      	bne.n	800e492 <dir_read+0xea>
	rv = rv << 8 | ptr[0];
 800e42c:	7ec1      	ldrb	r1, [r0, #27]
 800e42e:	7e83      	ldrb	r3, [r0, #26]
 800e430:	0209      	lsls	r1, r1, #8
 800e432:	430b      	orrs	r3, r1
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 800e434:	b21b      	sxth	r3, r3
 800e436:	2b00      	cmp	r3, #0
 800e438:	d12b      	bne.n	800e492 <dir_read+0xea>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e43a:	9a04      	ldr	r2, [sp, #16]
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800e43c:	2440      	movs	r4, #64	; 0x40
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e43e:	68d2      	ldr	r2, [r2, #12]
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800e440:	7801      	ldrb	r1, [r0, #0]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e442:	9203      	str	r2, [sp, #12]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e444:	2201      	movs	r2, #1
 800e446:	4694      	mov	ip, r2
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800e448:	43a1      	bics	r1, r4
 800e44a:	3901      	subs	r1, #1
 800e44c:	3c33      	subs	r4, #51	; 0x33
 800e44e:	4361      	muls	r1, r4
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800e450:	4a21      	ldr	r2, [pc, #132]	; (800e4d8 <dir_read+0x130>)
 800e452:	5c9c      	ldrb	r4, [r3, r2]
		if (wc) {
 800e454:	4662      	mov	r2, ip
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800e456:	1904      	adds	r4, r0, r4
	rv = rv << 8 | ptr[0];
 800e458:	7867      	ldrb	r7, [r4, #1]
 800e45a:	7824      	ldrb	r4, [r4, #0]
 800e45c:	023f      	lsls	r7, r7, #8
 800e45e:	433c      	orrs	r4, r7
		if (wc) {
 800e460:	2a00      	cmp	r2, #0
 800e462:	d024      	beq.n	800e4ae <dir_read+0x106>
			if (i >= FF_MAX_LFN) return 0;	/* Buffer overflow? */
 800e464:	29fe      	cmp	r1, #254	; 0xfe
 800e466:	d820      	bhi.n	800e4aa <dir_read+0x102>
	rv = rv << 8 | ptr[0];
 800e468:	46a4      	mov	ip, r4
			lfnbuf[i++] = wc = uc;			/* Store it */
 800e46a:	9a03      	ldr	r2, [sp, #12]
 800e46c:	004f      	lsls	r7, r1, #1
 800e46e:	52bc      	strh	r4, [r7, r2]
 800e470:	3101      	adds	r1, #1
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e472:	3301      	adds	r3, #1
 800e474:	2b0d      	cmp	r3, #13
 800e476:	d1eb      	bne.n	800e450 <dir_read+0xa8>
	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 800e478:	7803      	ldrb	r3, [r0, #0]
 800e47a:	065b      	lsls	r3, r3, #25
 800e47c:	d506      	bpl.n	800e48c <dir_read+0xe4>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e47e:	0034      	movs	r4, r6
		if (i >= FF_MAX_LFN) return 0;		/* Buffer overflow? */
 800e480:	29fe      	cmp	r1, #254	; 0xfe
 800e482:	d806      	bhi.n	800e492 <dir_read+0xea>
		lfnbuf[i] = 0;
 800e484:	2300      	movs	r3, #0
 800e486:	9a03      	ldr	r2, [sp, #12]
 800e488:	0049      	lsls	r1, r1, #1
 800e48a:	528b      	strh	r3, [r1, r2]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e48c:	9a01      	ldr	r2, [sp, #4]
 800e48e:	3a01      	subs	r2, #1
 800e490:	b2d4      	uxtb	r4, r2
		res = dir_next(dp, 0);		/* Next entry */
 800e492:	2100      	movs	r1, #0
 800e494:	0028      	movs	r0, r5
 800e496:	f7ff ff0b 	bl	800e2b0 <dir_next>
 800e49a:	1e07      	subs	r7, r0, #0
		if (res != FR_OK) break;
 800e49c:	d08f      	beq.n	800e3be <dir_read+0x16>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800e49e:	2300      	movs	r3, #0
 800e4a0:	61eb      	str	r3, [r5, #28]
 800e4a2:	e010      	b.n	800e4c6 <dir_read+0x11e>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e4a4:	9b01      	ldr	r3, [sp, #4]
 800e4a6:	429c      	cmp	r4, r3
 800e4a8:	d0bb      	beq.n	800e422 <dir_read+0x7a>
 800e4aa:	0034      	movs	r4, r6
 800e4ac:	e7f1      	b.n	800e492 <dir_read+0xea>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800e4ae:	4a0b      	ldr	r2, [pc, #44]	; (800e4dc <dir_read+0x134>)
 800e4b0:	4294      	cmp	r4, r2
 800e4b2:	d0de      	beq.n	800e472 <dir_read+0xca>
 800e4b4:	e7f9      	b.n	800e4aa <dir_read+0x102>
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 800e4b6:	2c00      	cmp	r4, #0
 800e4b8:	d108      	bne.n	800e4cc <dir_read+0x124>
 800e4ba:	f7ff f9f8 	bl	800d8ae <sum_sfn>
 800e4be:	9b02      	ldr	r3, [sp, #8]
 800e4c0:	4298      	cmp	r0, r3
 800e4c2:	d103      	bne.n	800e4cc <dir_read+0x124>
		res = move_window(fs, dp->sect);
 800e4c4:	2700      	movs	r7, #0
}
 800e4c6:	0038      	movs	r0, r7
 800e4c8:	b007      	add	sp, #28
 800e4ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800e4cc:	2301      	movs	r3, #1
 800e4ce:	425b      	negs	r3, r3
 800e4d0:	632b      	str	r3, [r5, #48]	; 0x30
 800e4d2:	e7f8      	b.n	800e4c6 <dir_read+0x11e>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 800e4d4:	2704      	movs	r7, #4
 800e4d6:	e7e2      	b.n	800e49e <dir_read+0xf6>
 800e4d8:	0801c018 	.word	0x0801c018
 800e4dc:	0000ffff 	.word	0x0000ffff

0800e4e0 <dir_remove>:
{
 800e4e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	DWORD last = dp->dptr;
 800e4e2:	6943      	ldr	r3, [r0, #20]
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 800e4e4:	6b01      	ldr	r1, [r0, #48]	; 0x30
{
 800e4e6:	0004      	movs	r4, r0
	FATFS *fs = dp->obj.fs;
 800e4e8:	6805      	ldr	r5, [r0, #0]
	DWORD last = dp->dptr;
 800e4ea:	9301      	str	r3, [sp, #4]
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 800e4ec:	1c4b      	adds	r3, r1, #1
 800e4ee:	d118      	bne.n	800e522 <dir_remove+0x42>
				dp->dir[DIR_Name] = DDEM;
 800e4f0:	26e5      	movs	r6, #229	; 0xe5
			fs->wflag = 1;
 800e4f2:	2701      	movs	r7, #1
			res = move_window(fs, dp->sect);
 800e4f4:	69e1      	ldr	r1, [r4, #28]
 800e4f6:	0028      	movs	r0, r5
 800e4f8:	f7ff fa81 	bl	800d9fe <move_window>
			if (res != FR_OK) break;
 800e4fc:	2800      	cmp	r0, #0
 800e4fe:	d10c      	bne.n	800e51a <dir_remove+0x3a>
				dp->dir[DIR_Name] = DDEM;
 800e500:	6a23      	ldr	r3, [r4, #32]
			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 800e502:	9a01      	ldr	r2, [sp, #4]
				dp->dir[DIR_Name] = DDEM;
 800e504:	701e      	strb	r6, [r3, #0]
			fs->wflag = 1;
 800e506:	70ef      	strb	r7, [r5, #3]
			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 800e508:	6963      	ldr	r3, [r4, #20]
 800e50a:	4293      	cmp	r3, r2
 800e50c:	d20d      	bcs.n	800e52a <dir_remove+0x4a>
			res = dir_next(dp, 0);	/* Next entry */
 800e50e:	0001      	movs	r1, r0
 800e510:	0020      	movs	r0, r4
 800e512:	f7ff fecd 	bl	800e2b0 <dir_next>
		} while (res == FR_OK);
 800e516:	2800      	cmp	r0, #0
 800e518:	d0ec      	beq.n	800e4f4 <dir_remove+0x14>
		if (res == FR_NO_FILE) res = FR_INT_ERR;
 800e51a:	2804      	cmp	r0, #4
 800e51c:	d105      	bne.n	800e52a <dir_remove+0x4a>
 800e51e:	3802      	subs	r0, #2
 800e520:	e003      	b.n	800e52a <dir_remove+0x4a>
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 800e522:	f7ff fd35 	bl	800df90 <dir_sdi>
	if (res == FR_OK) {
 800e526:	2800      	cmp	r0, #0
 800e528:	d0e2      	beq.n	800e4f0 <dir_remove+0x10>
}
 800e52a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800e52c <dir_find>:
{
 800e52c:	b5f0      	push	{r4, r5, r6, r7, lr}
	FATFS *fs = dp->obj.fs;
 800e52e:	6803      	ldr	r3, [r0, #0]
{
 800e530:	b089      	sub	sp, #36	; 0x24
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800e532:	2100      	movs	r1, #0
{
 800e534:	0004      	movs	r4, r0
	FATFS *fs = dp->obj.fs;
 800e536:	9304      	str	r3, [sp, #16]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800e538:	f7ff fd2a 	bl	800df90 <dir_sdi>
 800e53c:	1e07      	subs	r7, r0, #0
	if (res != FR_OK) return res;
 800e53e:	d000      	beq.n	800e542 <dir_find+0x16>
 800e540:	e09f      	b.n	800e682 <dir_find+0x156>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800e542:	22ff      	movs	r2, #255	; 0xff
 800e544:	2301      	movs	r3, #1
 800e546:	0016      	movs	r6, r2
 800e548:	425b      	negs	r3, r3
 800e54a:	6323      	str	r3, [r4, #48]	; 0x30
 800e54c:	9202      	str	r2, [sp, #8]
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800e54e:	9305      	str	r3, [sp, #20]
		res = move_window(fs, dp->sect);
 800e550:	69e1      	ldr	r1, [r4, #28]
 800e552:	9804      	ldr	r0, [sp, #16]
 800e554:	f7ff fa53 	bl	800d9fe <move_window>
 800e558:	1e07      	subs	r7, r0, #0
		if (res != FR_OK) break;
 800e55a:	d000      	beq.n	800e55e <dir_find+0x32>
 800e55c:	e091      	b.n	800e682 <dir_find+0x156>
		c = dp->dir[DIR_Name];
 800e55e:	6a25      	ldr	r5, [r4, #32]
 800e560:	782b      	ldrb	r3, [r5, #0]
 800e562:	9300      	str	r3, [sp, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800e564:	2b00      	cmp	r3, #0
 800e566:	d100      	bne.n	800e56a <dir_find+0x3e>
 800e568:	e08e      	b.n	800e688 <dir_find+0x15c>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800e56a:	233f      	movs	r3, #63	; 0x3f
 800e56c:	7aea      	ldrb	r2, [r5, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800e56e:	9900      	ldr	r1, [sp, #0]
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800e570:	4013      	ands	r3, r2
 800e572:	71a3      	strb	r3, [r4, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800e574:	29e5      	cmp	r1, #229	; 0xe5
 800e576:	d003      	beq.n	800e580 <dir_find+0x54>
 800e578:	0712      	lsls	r2, r2, #28
 800e57a:	d504      	bpl.n	800e586 <dir_find+0x5a>
 800e57c:	2b0f      	cmp	r3, #15
 800e57e:	d004      	beq.n	800e58a <dir_find+0x5e>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800e580:	9b05      	ldr	r3, [sp, #20]
 800e582:	6323      	str	r3, [r4, #48]	; 0x30
 800e584:	e061      	b.n	800e64a <dir_find+0x11e>
			if (a == AM_LFN) {			/* An LFN entry is found */
 800e586:	2b0f      	cmp	r3, #15
 800e588:	d165      	bne.n	800e656 <dir_find+0x12a>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 800e58a:	0023      	movs	r3, r4
 800e58c:	332f      	adds	r3, #47	; 0x2f
 800e58e:	781a      	ldrb	r2, [r3, #0]
 800e590:	2340      	movs	r3, #64	; 0x40
 800e592:	421a      	tst	r2, r3
 800e594:	d14f      	bne.n	800e636 <dir_find+0x10a>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 800e596:	9a00      	ldr	r2, [sp, #0]
 800e598:	421a      	tst	r2, r3
 800e59a:	d053      	beq.n	800e644 <dir_find+0x118>
						sum = dp->dir[LDIR_Chksum];
 800e59c:	7b6a      	ldrb	r2, [r5, #13]
 800e59e:	9202      	str	r2, [sp, #8]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 800e5a0:	9a00      	ldr	r2, [sp, #0]
 800e5a2:	439a      	bics	r2, r3
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800e5a4:	6963      	ldr	r3, [r4, #20]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 800e5a6:	9200      	str	r2, [sp, #0]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800e5a8:	6323      	str	r3, [r4, #48]	; 0x30
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e5aa:	7b6b      	ldrb	r3, [r5, #13]
 800e5ac:	9a02      	ldr	r2, [sp, #8]
 800e5ae:	26ff      	movs	r6, #255	; 0xff
 800e5b0:	4293      	cmp	r3, r2
 800e5b2:	d140      	bne.n	800e636 <dir_find+0x10a>
	rv = rv << 8 | ptr[0];
 800e5b4:	7eea      	ldrb	r2, [r5, #27]
 800e5b6:	7eab      	ldrb	r3, [r5, #26]
 800e5b8:	0212      	lsls	r2, r2, #8
 800e5ba:	4313      	orrs	r3, r2
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 800e5bc:	b21b      	sxth	r3, r3
 800e5be:	2b00      	cmp	r3, #0
 800e5c0:	d139      	bne.n	800e636 <dir_find+0x10a>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800e5c2:	213f      	movs	r1, #63	; 0x3f
 800e5c4:	270d      	movs	r7, #13
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e5c6:	9a04      	ldr	r2, [sp, #16]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e5c8:	9301      	str	r3, [sp, #4]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e5ca:	68d2      	ldr	r2, [r2, #12]
 800e5cc:	9203      	str	r2, [sp, #12]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800e5ce:	782a      	ldrb	r2, [r5, #0]
 800e5d0:	400a      	ands	r2, r1
 800e5d2:	3a01      	subs	r2, #1
 800e5d4:	4357      	muls	r7, r2
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e5d6:	2201      	movs	r2, #1
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800e5d8:	4b2c      	ldr	r3, [pc, #176]	; (800e68c <dir_find+0x160>)
 800e5da:	9901      	ldr	r1, [sp, #4]
 800e5dc:	5ccb      	ldrb	r3, [r1, r3]
 800e5de:	18eb      	adds	r3, r5, r3
	rv = rv << 8 | ptr[0];
 800e5e0:	785e      	ldrb	r6, [r3, #1]
 800e5e2:	781b      	ldrb	r3, [r3, #0]
 800e5e4:	0236      	lsls	r6, r6, #8
 800e5e6:	431e      	orrs	r6, r3
		if (wc) {
 800e5e8:	2a00      	cmp	r2, #0
 800e5ea:	d030      	beq.n	800e64e <dir_find+0x122>
			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800e5ec:	2ffe      	cmp	r7, #254	; 0xfe
 800e5ee:	d82c      	bhi.n	800e64a <dir_find+0x11e>
 800e5f0:	0030      	movs	r0, r6
 800e5f2:	f001 f86b 	bl	800f6cc <ff_wtoupper>
 800e5f6:	1c7b      	adds	r3, r7, #1
 800e5f8:	9306      	str	r3, [sp, #24]
 800e5fa:	9b03      	ldr	r3, [sp, #12]
 800e5fc:	007f      	lsls	r7, r7, #1
 800e5fe:	9007      	str	r0, [sp, #28]
 800e600:	5af8      	ldrh	r0, [r7, r3]
 800e602:	f001 f863 	bl	800f6cc <ff_wtoupper>
 800e606:	9b07      	ldr	r3, [sp, #28]
 800e608:	4283      	cmp	r3, r0
 800e60a:	d11e      	bne.n	800e64a <dir_find+0x11e>
	rv = rv << 8 | ptr[0];
 800e60c:	0032      	movs	r2, r6
			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800e60e:	9f06      	ldr	r7, [sp, #24]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e610:	9b01      	ldr	r3, [sp, #4]
 800e612:	3301      	adds	r3, #1
 800e614:	9301      	str	r3, [sp, #4]
 800e616:	2b0d      	cmp	r3, #13
 800e618:	d1de      	bne.n	800e5d8 <dir_find+0xac>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 800e61a:	782b      	ldrb	r3, [r5, #0]
 800e61c:	065b      	lsls	r3, r3, #25
 800e61e:	d507      	bpl.n	800e630 <dir_find+0x104>
 800e620:	2a00      	cmp	r2, #0
 800e622:	d005      	beq.n	800e630 <dir_find+0x104>
 800e624:	9a03      	ldr	r2, [sp, #12]
 800e626:	007b      	lsls	r3, r7, #1
 800e628:	5a9b      	ldrh	r3, [r3, r2]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e62a:	26ff      	movs	r6, #255	; 0xff
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 800e62c:	2b00      	cmp	r3, #0
 800e62e:	d102      	bne.n	800e636 <dir_find+0x10a>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e630:	9e00      	ldr	r6, [sp, #0]
 800e632:	3e01      	subs	r6, #1
 800e634:	b2f6      	uxtb	r6, r6
		res = dir_next(dp, 0);	/* Next entry */
 800e636:	2100      	movs	r1, #0
 800e638:	0020      	movs	r0, r4
 800e63a:	f7ff fe39 	bl	800e2b0 <dir_next>
 800e63e:	1e07      	subs	r7, r0, #0
	} while (res == FR_OK);
 800e640:	d086      	beq.n	800e550 <dir_find+0x24>
 800e642:	e01e      	b.n	800e682 <dir_find+0x156>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e644:	9b00      	ldr	r3, [sp, #0]
 800e646:	429e      	cmp	r6, r3
 800e648:	d0af      	beq.n	800e5aa <dir_find+0x7e>
 800e64a:	26ff      	movs	r6, #255	; 0xff
 800e64c:	e7f3      	b.n	800e636 <dir_find+0x10a>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800e64e:	4b10      	ldr	r3, [pc, #64]	; (800e690 <dir_find+0x164>)
 800e650:	429e      	cmp	r6, r3
 800e652:	d0dd      	beq.n	800e610 <dir_find+0xe4>
 800e654:	e7f9      	b.n	800e64a <dir_find+0x11e>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800e656:	2e00      	cmp	r6, #0
 800e658:	d105      	bne.n	800e666 <dir_find+0x13a>
 800e65a:	0028      	movs	r0, r5
 800e65c:	f7ff f927 	bl	800d8ae <sum_sfn>
 800e660:	9b02      	ldr	r3, [sp, #8]
 800e662:	4298      	cmp	r0, r3
 800e664:	d00d      	beq.n	800e682 <dir_find+0x156>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800e666:	0023      	movs	r3, r4
 800e668:	332f      	adds	r3, #47	; 0x2f
 800e66a:	781b      	ldrb	r3, [r3, #0]
 800e66c:	07db      	lsls	r3, r3, #31
 800e66e:	d487      	bmi.n	800e580 <dir_find+0x54>
 800e670:	0021      	movs	r1, r4
 800e672:	220b      	movs	r2, #11
 800e674:	3124      	adds	r1, #36	; 0x24
 800e676:	0028      	movs	r0, r5
 800e678:	f7ff f8bf 	bl	800d7fa <mem_cmp>
 800e67c:	2800      	cmp	r0, #0
 800e67e:	d000      	beq.n	800e682 <dir_find+0x156>
 800e680:	e77e      	b.n	800e580 <dir_find+0x54>
}
 800e682:	0038      	movs	r0, r7
 800e684:	b009      	add	sp, #36	; 0x24
 800e686:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800e688:	2704      	movs	r7, #4
 800e68a:	e7fa      	b.n	800e682 <dir_find+0x156>
 800e68c:	0801c018 	.word	0x0801c018
 800e690:	0000ffff 	.word	0x0000ffff

0800e694 <follow_path>:
{
 800e694:	b5f0      	push	{r4, r5, r6, r7, lr}
	FATFS *fs = dp->obj.fs;
 800e696:	6803      	ldr	r3, [r0, #0]
{
 800e698:	b089      	sub	sp, #36	; 0x24
	FATFS *fs = dp->obj.fs;
 800e69a:	9307      	str	r3, [sp, #28]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
 800e69c:	780b      	ldrb	r3, [r1, #0]
{
 800e69e:	0006      	movs	r6, r0
 800e6a0:	9104      	str	r1, [sp, #16]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
 800e6a2:	2b2f      	cmp	r3, #47	; 0x2f
 800e6a4:	d017      	beq.n	800e6d6 <follow_path+0x42>
 800e6a6:	2b5c      	cmp	r3, #92	; 0x5c
 800e6a8:	d015      	beq.n	800e6d6 <follow_path+0x42>
		dp->obj.sclust = fs->cdir;				/* Start from current directory */
 800e6aa:	9b07      	ldr	r3, [sp, #28]
 800e6ac:	69db      	ldr	r3, [r3, #28]
 800e6ae:	9301      	str	r3, [sp, #4]
		dp->obj.sclust = 0;					/* Start from root directory */
 800e6b0:	60b3      	str	r3, [r6, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800e6b2:	9b04      	ldr	r3, [sp, #16]
 800e6b4:	781b      	ldrb	r3, [r3, #0]
 800e6b6:	2b1f      	cmp	r3, #31
 800e6b8:	d900      	bls.n	800e6bc <follow_path+0x28>
 800e6ba:	e123      	b.n	800e904 <follow_path+0x270>
		dp->fn[NSFLAG] = NS_NONAME;
 800e6bc:	0033      	movs	r3, r6
 800e6be:	2280      	movs	r2, #128	; 0x80
 800e6c0:	332f      	adds	r3, #47	; 0x2f
 800e6c2:	701a      	strb	r2, [r3, #0]
		res = dir_sdi(dp, 0);
 800e6c4:	2100      	movs	r1, #0
 800e6c6:	0030      	movs	r0, r6
 800e6c8:	f7ff fc62 	bl	800df90 <dir_sdi>
}
 800e6cc:	b009      	add	sp, #36	; 0x24
 800e6ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 800e6d0:	9b04      	ldr	r3, [sp, #16]
 800e6d2:	3301      	adds	r3, #1
 800e6d4:	9304      	str	r3, [sp, #16]
 800e6d6:	9b04      	ldr	r3, [sp, #16]
 800e6d8:	781b      	ldrb	r3, [r3, #0]
 800e6da:	2b2f      	cmp	r3, #47	; 0x2f
 800e6dc:	d0f8      	beq.n	800e6d0 <follow_path+0x3c>
 800e6de:	2b5c      	cmp	r3, #92	; 0x5c
 800e6e0:	d0f6      	beq.n	800e6d0 <follow_path+0x3c>
		dp->obj.sclust = 0;					/* Start from root directory */
 800e6e2:	2300      	movs	r3, #0
 800e6e4:	e7e4      	b.n	800e6b0 <follow_path+0x1c>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 800e6e6:	3401      	adds	r4, #1
 800e6e8:	e11a      	b.n	800e920 <follow_path+0x28c>
		if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 800e6ea:	2dff      	cmp	r5, #255	; 0xff
 800e6ec:	d00f      	beq.n	800e70e <follow_path+0x7a>
		w = ff_oem2uni(w, CODEPAGE);	/* Convert ANSI/OEM to Unicode */
 800e6ee:	21b6      	movs	r1, #182	; 0xb6
 800e6f0:	31ff      	adds	r1, #255	; 0xff
 800e6f2:	f000 ffd7 	bl	800f6a4 <ff_oem2uni>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 800e6f6:	2800      	cmp	r0, #0
 800e6f8:	d009      	beq.n	800e70e <follow_path+0x7a>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 800e6fa:	287f      	cmp	r0, #127	; 0x7f
 800e6fc:	d809      	bhi.n	800e712 <follow_path+0x7e>
 800e6fe:	2300      	movs	r3, #0
	while (*str && *str != chr) str++;
 800e700:	49b0      	ldr	r1, [pc, #704]	; (800e9c4 <follow_path+0x330>)
 800e702:	5cca      	ldrb	r2, [r1, r3]
 800e704:	2a00      	cmp	r2, #0
 800e706:	d004      	beq.n	800e712 <follow_path+0x7e>
 800e708:	3301      	adds	r3, #1
 800e70a:	4282      	cmp	r2, r0
 800e70c:	d1f9      	bne.n	800e702 <follow_path+0x6e>
						res = FR_OK;
 800e70e:	2006      	movs	r0, #6
 800e710:	e7dc      	b.n	800e6cc <follow_path+0x38>
		lfn[di++] = w;					/* Store the Unicode character */
 800e712:	9b02      	ldr	r3, [sp, #8]
 800e714:	006d      	lsls	r5, r5, #1
 800e716:	5358      	strh	r0, [r3, r5]
 800e718:	0025      	movs	r5, r4
 800e71a:	e0f7      	b.n	800e90c <follow_path+0x278>
	if ((di == 1 && lfn[di - 1] == '.') ||
 800e71c:	2d02      	cmp	r5, #2
 800e71e:	d104      	bne.n	800e72a <follow_path+0x96>
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
 800e720:	9b02      	ldr	r3, [sp, #8]
 800e722:	885b      	ldrh	r3, [r3, #2]
 800e724:	2b2e      	cmp	r3, #46	; 0x2e
 800e726:	d100      	bne.n	800e72a <follow_path+0x96>
 800e728:	e10c      	b.n	800e944 <follow_path+0x2b0>
 800e72a:	006b      	lsls	r3, r5, #1
	while (di) {						/* Snip off trailing spaces and dots if exist */
 800e72c:	2d00      	cmp	r5, #0
 800e72e:	d13a      	bne.n	800e7a6 <follow_path+0x112>
	lfn[di] = 0;						/* LFN is created */
 800e730:	2200      	movs	r2, #0
 800e732:	9902      	ldr	r1, [sp, #8]
 800e734:	52ca      	strh	r2, [r1, r3]
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 800e736:	4295      	cmp	r5, r2
 800e738:	d0e9      	beq.n	800e70e <follow_path+0x7a>
	mem_set(dp->fn, ' ', 11);
 800e73a:	0033      	movs	r3, r6
 800e73c:	0032      	movs	r2, r6
 800e73e:	3324      	adds	r3, #36	; 0x24
 800e740:	322f      	adds	r2, #47	; 0x2f
		*d++ = (BYTE)val;
 800e742:	2120      	movs	r1, #32
 800e744:	7019      	strb	r1, [r3, #0]
 800e746:	3301      	adds	r3, #1
	} while (--cnt);
 800e748:	4293      	cmp	r3, r2
 800e74a:	d1fa      	bne.n	800e742 <follow_path+0xae>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 800e74c:	2300      	movs	r3, #0
 800e74e:	9902      	ldr	r1, [sp, #8]
 800e750:	005a      	lsls	r2, r3, #1
 800e752:	5a8a      	ldrh	r2, [r1, r2]
 800e754:	2a20      	cmp	r2, #32
 800e756:	d02f      	beq.n	800e7b8 <follow_path+0x124>
 800e758:	2a2e      	cmp	r2, #46	; 0x2e
 800e75a:	d02d      	beq.n	800e7b8 <follow_path+0x124>
	if (si > 0) cf |= NS_LOSS | NS_LFN;
 800e75c:	2b00      	cmp	r3, #0
 800e75e:	d002      	beq.n	800e766 <follow_path+0xd2>
 800e760:	2203      	movs	r2, #3
 800e762:	4314      	orrs	r4, r2
 800e764:	b2e4      	uxtb	r4, r4
	while (di > 0 && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 800e766:	006a      	lsls	r2, r5, #1
 800e768:	9902      	ldr	r1, [sp, #8]
 800e76a:	3a02      	subs	r2, #2
 800e76c:	5a8a      	ldrh	r2, [r1, r2]
 800e76e:	2a2e      	cmp	r2, #46	; 0x2e
 800e770:	d002      	beq.n	800e778 <follow_path+0xe4>
 800e772:	3d01      	subs	r5, #1
 800e774:	2d00      	cmp	r5, #0
 800e776:	d1f6      	bne.n	800e766 <follow_path+0xd2>
				cf |= NS_LOSS | NS_LFN;
 800e778:	2208      	movs	r2, #8
 800e77a:	2700      	movs	r7, #0
 800e77c:	9203      	str	r2, [sp, #12]
 800e77e:	9701      	str	r7, [sp, #4]
		w = lfn[si++];					/* Get an LFN character */
 800e780:	1c5a      	adds	r2, r3, #1
 800e782:	9205      	str	r2, [sp, #20]
 800e784:	9a02      	ldr	r2, [sp, #8]
 800e786:	005b      	lsls	r3, r3, #1
 800e788:	5a98      	ldrh	r0, [r3, r2]
		if (!w) break;					/* Break on end of the LFN */
 800e78a:	2800      	cmp	r0, #0
 800e78c:	d028      	beq.n	800e7e0 <follow_path+0x14c>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 800e78e:	2820      	cmp	r0, #32
 800e790:	d004      	beq.n	800e79c <follow_path+0x108>
 800e792:	282e      	cmp	r0, #46	; 0x2e
 800e794:	d112      	bne.n	800e7bc <follow_path+0x128>
 800e796:	9b05      	ldr	r3, [sp, #20]
 800e798:	429d      	cmp	r5, r3
 800e79a:	d015      	beq.n	800e7c8 <follow_path+0x134>
			cf |= NS_LOSS | NS_LFN;
 800e79c:	2303      	movs	r3, #3
 800e79e:	431c      	orrs	r4, r3
 800e7a0:	b2e4      	uxtb	r4, r4
				cf |= NS_LOSS | NS_LFN;
 800e7a2:	9b05      	ldr	r3, [sp, #20]
 800e7a4:	e7ec      	b.n	800e780 <follow_path+0xec>
		w = lfn[di - 1];
 800e7a6:	9902      	ldr	r1, [sp, #8]
 800e7a8:	1e9a      	subs	r2, r3, #2
 800e7aa:	5a8a      	ldrh	r2, [r1, r2]
		if (w != ' ' && w != '.') break;
 800e7ac:	2a20      	cmp	r2, #32
 800e7ae:	d001      	beq.n	800e7b4 <follow_path+0x120>
 800e7b0:	2a2e      	cmp	r2, #46	; 0x2e
 800e7b2:	d1bd      	bne.n	800e730 <follow_path+0x9c>
		di--;
 800e7b4:	3d01      	subs	r5, #1
 800e7b6:	e7b8      	b.n	800e72a <follow_path+0x96>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 800e7b8:	3301      	adds	r3, #1
 800e7ba:	e7c8      	b.n	800e74e <follow_path+0xba>
		if (i >= ni || si == di) {		/* Entered extension or end of SFN */
 800e7bc:	9b03      	ldr	r3, [sp, #12]
 800e7be:	429f      	cmp	r7, r3
 800e7c0:	d206      	bcs.n	800e7d0 <follow_path+0x13c>
 800e7c2:	9b05      	ldr	r3, [sp, #20]
 800e7c4:	429d      	cmp	r5, r3
 800e7c6:	d148      	bne.n	800e85a <follow_path+0x1c6>
			if (ni == 11) {				/* Extension fileld overflow? */
 800e7c8:	9b03      	ldr	r3, [sp, #12]
 800e7ca:	2b0b      	cmp	r3, #11
 800e7cc:	d13c      	bne.n	800e848 <follow_path+0x1b4>
 800e7ce:	e002      	b.n	800e7d6 <follow_path+0x142>
 800e7d0:	9b03      	ldr	r3, [sp, #12]
 800e7d2:	2b0b      	cmp	r3, #11
 800e7d4:	d12f      	bne.n	800e836 <follow_path+0x1a2>
				cf |= NS_LOSS | NS_LFN;
 800e7d6:	2303      	movs	r3, #3
 800e7d8:	431c      	orrs	r4, r3
 800e7da:	3308      	adds	r3, #8
 800e7dc:	b2e4      	uxtb	r4, r4
 800e7de:	9303      	str	r3, [sp, #12]
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800e7e0:	1d73      	adds	r3, r6, #5
 800e7e2:	7fda      	ldrb	r2, [r3, #31]
 800e7e4:	2ae5      	cmp	r2, #229	; 0xe5
 800e7e6:	d101      	bne.n	800e7ec <follow_path+0x158>
 800e7e8:	3ae0      	subs	r2, #224	; 0xe0
 800e7ea:	77da      	strb	r2, [r3, #31]
	if (ni == 8) b <<= 2;
 800e7ec:	9b03      	ldr	r3, [sp, #12]
 800e7ee:	2b08      	cmp	r3, #8
 800e7f0:	d103      	bne.n	800e7fa <follow_path+0x166>
 800e7f2:	9b01      	ldr	r3, [sp, #4]
 800e7f4:	009b      	lsls	r3, r3, #2
 800e7f6:	b2db      	uxtb	r3, r3
 800e7f8:	9301      	str	r3, [sp, #4]
 800e7fa:	230c      	movs	r3, #12
 800e7fc:	9a01      	ldr	r2, [sp, #4]
 800e7fe:	4013      	ands	r3, r2
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800e800:	2b0c      	cmp	r3, #12
 800e802:	d002      	beq.n	800e80a <follow_path+0x176>
 800e804:	43d2      	mvns	r2, r2
 800e806:	0792      	lsls	r2, r2, #30
 800e808:	d102      	bne.n	800e810 <follow_path+0x17c>
 800e80a:	2202      	movs	r2, #2
 800e80c:	4314      	orrs	r4, r2
 800e80e:	b2e4      	uxtb	r4, r4
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800e810:	07a2      	lsls	r2, r4, #30
 800e812:	d500      	bpl.n	800e816 <follow_path+0x182>
 800e814:	e0ac      	b.n	800e970 <follow_path+0x2dc>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 800e816:	2203      	movs	r2, #3
 800e818:	9901      	ldr	r1, [sp, #4]
 800e81a:	4011      	ands	r1, r2
 800e81c:	000a      	movs	r2, r1
 800e81e:	2901      	cmp	r1, #1
 800e820:	d102      	bne.n	800e828 <follow_path+0x194>
 800e822:	320f      	adds	r2, #15
 800e824:	4314      	orrs	r4, r2
 800e826:	b2e4      	uxtb	r4, r4
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 800e828:	2b04      	cmp	r3, #4
 800e82a:	d000      	beq.n	800e82e <follow_path+0x19a>
 800e82c:	e0a0      	b.n	800e970 <follow_path+0x2dc>
 800e82e:	3304      	adds	r3, #4
 800e830:	431c      	orrs	r4, r3
 800e832:	b2e4      	uxtb	r4, r4
 800e834:	e09c      	b.n	800e970 <follow_path+0x2dc>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 800e836:	9b05      	ldr	r3, [sp, #20]
 800e838:	429d      	cmp	r5, r3
 800e83a:	d005      	beq.n	800e848 <follow_path+0x1b4>
 800e83c:	2303      	movs	r3, #3
 800e83e:	431c      	orrs	r4, r3
			if (si > di) break;			/* No extension */
 800e840:	9b05      	ldr	r3, [sp, #20]
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 800e842:	b2e4      	uxtb	r4, r4
			if (si > di) break;			/* No extension */
 800e844:	429d      	cmp	r5, r3
 800e846:	d3cb      	bcc.n	800e7e0 <follow_path+0x14c>
			b <<= 2; continue;
 800e848:	9b01      	ldr	r3, [sp, #4]
 800e84a:	9505      	str	r5, [sp, #20]
 800e84c:	009b      	lsls	r3, r3, #2
 800e84e:	b2db      	uxtb	r3, r3
 800e850:	9301      	str	r3, [sp, #4]
			si = di; i = 8; ni = 11;	/* Enter extension fileld */
 800e852:	230b      	movs	r3, #11
 800e854:	2708      	movs	r7, #8
 800e856:	9303      	str	r3, [sp, #12]
 800e858:	e7a3      	b.n	800e7a2 <follow_path+0x10e>
		if (w >= 0x80) {				/* Is this a non-ASCII character? */
 800e85a:	9406      	str	r4, [sp, #24]
 800e85c:	287f      	cmp	r0, #127	; 0x7f
 800e85e:	d90f      	bls.n	800e880 <follow_path+0x1ec>
			cf |= NS_LFN;				/* Force to create LFN entry */
 800e860:	2302      	movs	r3, #2
			w = ff_uni2oem(w, CODEPAGE);	/* Unicode -> OEM code */
 800e862:	21b6      	movs	r1, #182	; 0xb6
			cf |= NS_LFN;				/* Force to create LFN entry */
 800e864:	4323      	orrs	r3, r4
 800e866:	b2db      	uxtb	r3, r3
			w = ff_uni2oem(w, CODEPAGE);	/* Unicode -> OEM code */
 800e868:	31ff      	adds	r1, #255	; 0xff
			cf |= NS_LFN;				/* Force to create LFN entry */
 800e86a:	9306      	str	r3, [sp, #24]
			w = ff_uni2oem(w, CODEPAGE);	/* Unicode -> OEM code */
 800e86c:	f000 ff00 	bl	800f670 <ff_uni2oem>
			if (w & 0x80) w = ExCvt[w & 0x7F];	/* Convert extended character to upper (SBCS) */
 800e870:	0603      	lsls	r3, r0, #24
 800e872:	d515      	bpl.n	800e8a0 <follow_path+0x20c>
 800e874:	237f      	movs	r3, #127	; 0x7f
 800e876:	4018      	ands	r0, r3
 800e878:	4b53      	ldr	r3, [pc, #332]	; (800e9c8 <follow_path+0x334>)
 800e87a:	5c18      	ldrb	r0, [r3, r0]
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 800e87c:	2800      	cmp	r0, #0
 800e87e:	d008      	beq.n	800e892 <follow_path+0x1fe>
		if (w >= 0x80) {				/* Is this a non-ASCII character? */
 800e880:	2300      	movs	r3, #0
	while (*str && *str != chr) str++;
 800e882:	4952      	ldr	r1, [pc, #328]	; (800e9cc <follow_path+0x338>)
 800e884:	5cca      	ldrb	r2, [r1, r3]
 800e886:	2a00      	cmp	r2, #0
 800e888:	d100      	bne.n	800e88c <follow_path+0x1f8>
 800e88a:	e08a      	b.n	800e9a2 <follow_path+0x30e>
 800e88c:	3301      	adds	r3, #1
 800e88e:	4290      	cmp	r0, r2
 800e890:	d1f8      	bne.n	800e884 <follow_path+0x1f0>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 800e892:	2203      	movs	r2, #3
 800e894:	9b06      	ldr	r3, [sp, #24]
 800e896:	205f      	movs	r0, #95	; 0x5f
 800e898:	4313      	orrs	r3, r2
 800e89a:	b2db      	uxtb	r3, r3
 800e89c:	9306      	str	r3, [sp, #24]
 800e89e:	e00f      	b.n	800e8c0 <follow_path+0x22c>
		if (w >= 0x100) {				/* Is this a DBC? */
 800e8a0:	28ff      	cmp	r0, #255	; 0xff
 800e8a2:	d9eb      	bls.n	800e87c <follow_path+0x1e8>
			if (i >= ni - 1) {			/* Field overflow? */
 800e8a4:	9b03      	ldr	r3, [sp, #12]
 800e8a6:	3b01      	subs	r3, #1
 800e8a8:	429f      	cmp	r7, r3
 800e8aa:	d304      	bcc.n	800e8b6 <follow_path+0x222>
				cf |= NS_LOSS | NS_LFN;
 800e8ac:	2303      	movs	r3, #3
 800e8ae:	431c      	orrs	r4, r3
 800e8b0:	b2e4      	uxtb	r4, r4
 800e8b2:	9f03      	ldr	r7, [sp, #12]
 800e8b4:	e775      	b.n	800e7a2 <follow_path+0x10e>
			dp->fn[i++] = (BYTE)(w >> 8);	/* Put 1st byte */
 800e8b6:	19f3      	adds	r3, r6, r7
 800e8b8:	3305      	adds	r3, #5
 800e8ba:	0a02      	lsrs	r2, r0, #8
 800e8bc:	77da      	strb	r2, [r3, #31]
 800e8be:	3701      	adds	r7, #1
		dp->fn[i++] = (BYTE)w;
 800e8c0:	19f3      	adds	r3, r6, r7
 800e8c2:	3305      	adds	r3, #5
 800e8c4:	77d8      	strb	r0, [r3, #31]
 800e8c6:	3701      	adds	r7, #1
 800e8c8:	9c06      	ldr	r4, [sp, #24]
 800e8ca:	e76a      	b.n	800e7a2 <follow_path+0x10e>
					b |= 2;
 800e8cc:	2302      	movs	r3, #2
 800e8ce:	9a01      	ldr	r2, [sp, #4]
 800e8d0:	431a      	orrs	r2, r3
 800e8d2:	9201      	str	r2, [sp, #4]
 800e8d4:	e7f4      	b.n	800e8c0 <follow_path+0x22c>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800e8d6:	2a00      	cmp	r2, #0
 800e8d8:	d000      	beq.n	800e8dc <follow_path+0x248>
 800e8da:	e6f7      	b.n	800e6cc <follow_path+0x38>
 800e8dc:	2005      	movs	r0, #5
	return res;
 800e8de:	e6f5      	b.n	800e6cc <follow_path+0x38>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800e8e0:	2204      	movs	r2, #4
 800e8e2:	4213      	tst	r3, r2
 800e8e4:	d000      	beq.n	800e8e8 <follow_path+0x254>
 800e8e6:	e6f1      	b.n	800e6cc <follow_path+0x38>
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 800e8e8:	79b3      	ldrb	r3, [r6, #6]
 800e8ea:	06db      	lsls	r3, r3, #27
 800e8ec:	d5f6      	bpl.n	800e8dc <follow_path+0x248>
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800e8ee:	6973      	ldr	r3, [r6, #20]
 800e8f0:	9907      	ldr	r1, [sp, #28]
 800e8f2:	05db      	lsls	r3, r3, #23
 800e8f4:	0ddb      	lsrs	r3, r3, #23
 800e8f6:	313c      	adds	r1, #60	; 0x3c
 800e8f8:	18c9      	adds	r1, r1, r3
 800e8fa:	9b07      	ldr	r3, [sp, #28]
 800e8fc:	7818      	ldrb	r0, [r3, #0]
 800e8fe:	f7ff f83f 	bl	800d980 <ld_clust.isra.5>
 800e902:	60b0      	str	r0, [r6, #8]
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 800e904:	2500      	movs	r5, #0
 800e906:	6833      	ldr	r3, [r6, #0]
 800e908:	68db      	ldr	r3, [r3, #12]
 800e90a:	9302      	str	r3, [sp, #8]
		w = p[si++];					/* Get a character */
 800e90c:	9b04      	ldr	r3, [sp, #16]
 800e90e:	1c6c      	adds	r4, r5, #1
 800e910:	5d58      	ldrb	r0, [r3, r5]
		if (w < ' ') break;				/* Break if end of the path name */
 800e912:	281f      	cmp	r0, #31
 800e914:	d90c      	bls.n	800e930 <follow_path+0x29c>
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 800e916:	282f      	cmp	r0, #47	; 0x2f
 800e918:	d002      	beq.n	800e920 <follow_path+0x28c>
 800e91a:	285c      	cmp	r0, #92	; 0x5c
 800e91c:	d000      	beq.n	800e920 <follow_path+0x28c>
 800e91e:	e6e4      	b.n	800e6ea <follow_path+0x56>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 800e920:	9b04      	ldr	r3, [sp, #16]
 800e922:	5d1b      	ldrb	r3, [r3, r4]
 800e924:	2b2f      	cmp	r3, #47	; 0x2f
 800e926:	d100      	bne.n	800e92a <follow_path+0x296>
 800e928:	e6dd      	b.n	800e6e6 <follow_path+0x52>
 800e92a:	2b5c      	cmp	r3, #92	; 0x5c
 800e92c:	d100      	bne.n	800e930 <follow_path+0x29c>
 800e92e:	e6da      	b.n	800e6e6 <follow_path+0x52>
	*path = &p[si];						/* Return pointer to the next segment */
 800e930:	9b04      	ldr	r3, [sp, #16]
 800e932:	191b      	adds	r3, r3, r4
 800e934:	9304      	str	r3, [sp, #16]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800e936:	2400      	movs	r4, #0
 800e938:	281f      	cmp	r0, #31
 800e93a:	d800      	bhi.n	800e93e <follow_path+0x2aa>
 800e93c:	3404      	adds	r4, #4
	if ((di == 1 && lfn[di - 1] == '.') ||
 800e93e:	2d01      	cmp	r5, #1
 800e940:	d000      	beq.n	800e944 <follow_path+0x2b0>
 800e942:	e6eb      	b.n	800e71c <follow_path+0x88>
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
 800e944:	9b02      	ldr	r3, [sp, #8]
 800e946:	881b      	ldrh	r3, [r3, #0]
 800e948:	2b2e      	cmp	r3, #46	; 0x2e
 800e94a:	d000      	beq.n	800e94e <follow_path+0x2ba>
 800e94c:	e6ed      	b.n	800e72a <follow_path+0x96>
		lfn[di] = 0;
 800e94e:	2300      	movs	r3, #0
			dp->fn[i] = (i < di) ? '.' : ' ';
 800e950:	202e      	movs	r0, #46	; 0x2e
		lfn[di] = 0;
 800e952:	9902      	ldr	r1, [sp, #8]
 800e954:	006a      	lsls	r2, r5, #1
 800e956:	5253      	strh	r3, [r2, r1]
			dp->fn[i] = (i < di) ? '.' : ' ';
 800e958:	2220      	movs	r2, #32
 800e95a:	429d      	cmp	r5, r3
 800e95c:	d900      	bls.n	800e960 <follow_path+0x2cc>
 800e95e:	0002      	movs	r2, r0
 800e960:	0019      	movs	r1, r3
		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
 800e962:	3301      	adds	r3, #1
			dp->fn[i] = (i < di) ? '.' : ' ';
 800e964:	3124      	adds	r1, #36	; 0x24
 800e966:	5472      	strb	r2, [r6, r1]
		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
 800e968:	2b0b      	cmp	r3, #11
 800e96a:	d1f5      	bne.n	800e958 <follow_path+0x2c4>
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
 800e96c:	3315      	adds	r3, #21
 800e96e:	431c      	orrs	r4, r3
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 800e970:	0033      	movs	r3, r6
 800e972:	332f      	adds	r3, #47	; 0x2f
 800e974:	701c      	strb	r4, [r3, #0]
			res = dir_find(dp);				/* Find an object with the segment name */
 800e976:	0030      	movs	r0, r6
 800e978:	f7ff fdd8 	bl	800e52c <dir_find>
			ns = dp->fn[NSFLAG];
 800e97c:	0031      	movs	r1, r6
 800e97e:	312f      	adds	r1, #47	; 0x2f
 800e980:	780b      	ldrb	r3, [r1, #0]
			if (res != FR_OK) {				/* Failed to find the object */
 800e982:	2800      	cmp	r0, #0
 800e984:	d0ac      	beq.n	800e8e0 <follow_path+0x24c>
				if (res == FR_NO_FILE) {	/* Object is not found */
 800e986:	2804      	cmp	r0, #4
 800e988:	d000      	beq.n	800e98c <follow_path+0x2f8>
 800e98a:	e69f      	b.n	800e6cc <follow_path+0x38>
 800e98c:	001a      	movs	r2, r3
					if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
 800e98e:	2420      	movs	r4, #32
 800e990:	4002      	ands	r2, r0
 800e992:	4223      	tst	r3, r4
 800e994:	d09f      	beq.n	800e8d6 <follow_path+0x242>
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
 800e996:	2a00      	cmp	r2, #0
 800e998:	d0b4      	beq.n	800e904 <follow_path+0x270>
						dp->fn[NSFLAG] = NS_NONAME;
 800e99a:	2380      	movs	r3, #128	; 0x80
						res = FR_OK;
 800e99c:	2000      	movs	r0, #0
						dp->fn[NSFLAG] = NS_NONAME;
 800e99e:	700b      	strb	r3, [r1, #0]
 800e9a0:	e694      	b.n	800e6cc <follow_path+0x38>
				if (IsUpper(w)) {		/* ASCII large capital */
 800e9a2:	0003      	movs	r3, r0
 800e9a4:	3b41      	subs	r3, #65	; 0x41
 800e9a6:	b29b      	uxth	r3, r3
 800e9a8:	2b19      	cmp	r3, #25
 800e9aa:	d98f      	bls.n	800e8cc <follow_path+0x238>
					if (IsLower(w)) {	/* ASCII small capital */
 800e9ac:	0003      	movs	r3, r0
 800e9ae:	3b61      	subs	r3, #97	; 0x61
 800e9b0:	b29b      	uxth	r3, r3
 800e9b2:	2b19      	cmp	r3, #25
 800e9b4:	d884      	bhi.n	800e8c0 <follow_path+0x22c>
						b |= 1; w -= 0x20;
 800e9b6:	2301      	movs	r3, #1
 800e9b8:	9a01      	ldr	r2, [sp, #4]
 800e9ba:	3820      	subs	r0, #32
 800e9bc:	431a      	orrs	r2, r3
 800e9be:	9201      	str	r2, [sp, #4]
 800e9c0:	b280      	uxth	r0, r0
 800e9c2:	e77d      	b.n	800e8c0 <follow_path+0x22c>
 800e9c4:	0801c02f 	.word	0x0801c02f
 800e9c8:	0801bf98 	.word	0x0801bf98
 800e9cc:	0801c038 	.word	0x0801c038

0800e9d0 <sync_fs>:
{
 800e9d0:	b570      	push	{r4, r5, r6, lr}
 800e9d2:	0004      	movs	r4, r0
	res = sync_window(fs);
 800e9d4:	f7fe ffef 	bl	800d9b6 <sync_window>
	if (res == FR_OK) {
 800e9d8:	2800      	cmp	r0, #0
 800e9da:	d155      	bne.n	800ea88 <sync_fs+0xb8>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 800e9dc:	7823      	ldrb	r3, [r4, #0]
 800e9de:	2b03      	cmp	r3, #3
 800e9e0:	d14a      	bne.n	800ea78 <sync_fs+0xa8>
 800e9e2:	7923      	ldrb	r3, [r4, #4]
 800e9e4:	2b01      	cmp	r3, #1
 800e9e6:	d147      	bne.n	800ea78 <sync_fs+0xa8>
			mem_set(fs->win, 0, SS(fs));
 800e9e8:	0021      	movs	r1, r4
 800e9ea:	228f      	movs	r2, #143	; 0x8f
 800e9ec:	313c      	adds	r1, #60	; 0x3c
 800e9ee:	000b      	movs	r3, r1
		*d++ = (BYTE)val;
 800e9f0:	0005      	movs	r5, r0
 800e9f2:	0092      	lsls	r2, r2, #2
 800e9f4:	18a2      	adds	r2, r4, r2
 800e9f6:	701d      	strb	r5, [r3, #0]
 800e9f8:	3301      	adds	r3, #1
	} while (--cnt);
 800e9fa:	4293      	cmp	r3, r2
 800e9fc:	d1fb      	bne.n	800e9f6 <sync_fs+0x26>
	*ptr++ = (BYTE)val; val >>= 8;
 800e9fe:	2255      	movs	r2, #85	; 0x55
 800ea00:	4b22      	ldr	r3, [pc, #136]	; (800ea8c <sync_fs+0xbc>)
	*ptr++ = (BYTE)val;
 800ea02:	2041      	movs	r0, #65	; 0x41
	*ptr++ = (BYTE)val; val >>= 8;
 800ea04:	54e2      	strb	r2, [r4, r3]
	*ptr++ = (BYTE)val;
 800ea06:	4b22      	ldr	r3, [pc, #136]	; (800ea90 <sync_fs+0xc0>)
 800ea08:	1892      	adds	r2, r2, r2
 800ea0a:	54e2      	strb	r2, [r4, r3]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea0c:	0022      	movs	r2, r4
	*ptr++ = (BYTE)val; val >>= 8;
 800ea0e:	3bea      	subs	r3, #234	; 0xea
 800ea10:	3bff      	subs	r3, #255	; 0xff
	*ptr++ = (BYTE)val; val >>= 8;
 800ea12:	323d      	adds	r2, #61	; 0x3d
	*ptr++ = (BYTE)val; val >>= 8;
 800ea14:	700b      	strb	r3, [r1, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea16:	7013      	strb	r3, [r2, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea18:	0023      	movs	r3, r4
 800ea1a:	2261      	movs	r2, #97	; 0x61
 800ea1c:	333e      	adds	r3, #62	; 0x3e
	*ptr++ = (BYTE)val; val >>= 8;
 800ea1e:	2688      	movs	r6, #136	; 0x88
	*ptr++ = (BYTE)val; val >>= 8;
 800ea20:	701a      	strb	r2, [r3, #0]
	*ptr++ = (BYTE)val;
 800ea22:	7058      	strb	r0, [r3, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea24:	2372      	movs	r3, #114	; 0x72
 800ea26:	00b6      	lsls	r6, r6, #2
 800ea28:	55a3      	strb	r3, [r4, r6]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea2a:	4e1a      	ldr	r6, [pc, #104]	; (800ea94 <sync_fs+0xc4>)
 800ea2c:	55a3      	strb	r3, [r4, r6]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea2e:	4b1a      	ldr	r3, [pc, #104]	; (800ea98 <sync_fs+0xc8>)
 800ea30:	54e0      	strb	r0, [r4, r3]
	*ptr++ = (BYTE)val;
 800ea32:	4b1a      	ldr	r3, [pc, #104]	; (800ea9c <sync_fs+0xcc>)
 800ea34:	54e2      	strb	r2, [r4, r3]
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
 800ea36:	69a3      	ldr	r3, [r4, #24]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea38:	32c4      	adds	r2, #196	; 0xc4
 800ea3a:	32ff      	adds	r2, #255	; 0xff
 800ea3c:	54a3      	strb	r3, [r4, r2]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea3e:	4a18      	ldr	r2, [pc, #96]	; (800eaa0 <sync_fs+0xd0>)
	*ptr++ = (BYTE)val; val >>= 8;
 800ea40:	0a18      	lsrs	r0, r3, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800ea42:	54a0      	strb	r0, [r4, r2]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea44:	4a17      	ldr	r2, [pc, #92]	; (800eaa4 <sync_fs+0xd4>)
	*ptr++ = (BYTE)val; val >>= 8;
 800ea46:	0c18      	lsrs	r0, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800ea48:	54a0      	strb	r0, [r4, r2]
	*ptr++ = (BYTE)val;
 800ea4a:	4a17      	ldr	r2, [pc, #92]	; (800eaa8 <sync_fs+0xd8>)
	*ptr++ = (BYTE)val; val >>= 8;
 800ea4c:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val;
 800ea4e:	54a3      	strb	r3, [r4, r2]
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 800ea50:	6963      	ldr	r3, [r4, #20]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea52:	3201      	adds	r2, #1
 800ea54:	54a3      	strb	r3, [r4, r2]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea56:	4a15      	ldr	r2, [pc, #84]	; (800eaac <sync_fs+0xdc>)
	*ptr++ = (BYTE)val; val >>= 8;
 800ea58:	0a18      	lsrs	r0, r3, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800ea5a:	54a0      	strb	r0, [r4, r2]
	*ptr++ = (BYTE)val; val >>= 8;
 800ea5c:	4a14      	ldr	r2, [pc, #80]	; (800eab0 <sync_fs+0xe0>)
	*ptr++ = (BYTE)val; val >>= 8;
 800ea5e:	0c18      	lsrs	r0, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800ea60:	54a0      	strb	r0, [r4, r2]
	*ptr++ = (BYTE)val;
 800ea62:	4a14      	ldr	r2, [pc, #80]	; (800eab4 <sync_fs+0xe4>)
	*ptr++ = (BYTE)val; val >>= 8;
 800ea64:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val;
 800ea66:	54a3      	strb	r3, [r4, r2]
			fs->winsect = fs->volbase + 1;
 800ea68:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 800ea6a:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;
 800ea6c:	1c5a      	adds	r2, r3, #1
 800ea6e:	63a2      	str	r2, [r4, #56]	; 0x38
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 800ea70:	2301      	movs	r3, #1
 800ea72:	f7fe fe9b 	bl	800d7ac <disk_write>
			fs->fsi_flag = 0;
 800ea76:	7125      	strb	r5, [r4, #4]
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 800ea78:	2200      	movs	r2, #0
 800ea7a:	7860      	ldrb	r0, [r4, #1]
 800ea7c:	0011      	movs	r1, r2
 800ea7e:	f7fe fea3 	bl	800d7c8 <disk_ioctl>
 800ea82:	1e43      	subs	r3, r0, #1
 800ea84:	4198      	sbcs	r0, r3
 800ea86:	b2c0      	uxtb	r0, r0
}
 800ea88:	bd70      	pop	{r4, r5, r6, pc}
 800ea8a:	46c0      	nop			; (mov r8, r8)
 800ea8c:	0000023a 	.word	0x0000023a
 800ea90:	0000023b 	.word	0x0000023b
 800ea94:	00000221 	.word	0x00000221
 800ea98:	00000222 	.word	0x00000222
 800ea9c:	00000223 	.word	0x00000223
 800eaa0:	00000225 	.word	0x00000225
 800eaa4:	00000226 	.word	0x00000226
 800eaa8:	00000227 	.word	0x00000227
 800eaac:	00000229 	.word	0x00000229
 800eab0:	0000022a 	.word	0x0000022a
 800eab4:	0000022b 	.word	0x0000022b

0800eab8 <dir_register>:
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800eab8:	0003      	movs	r3, r0
{
 800eaba:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800eabc:	332f      	adds	r3, #47	; 0x2f
{
 800eabe:	b08b      	sub	sp, #44	; 0x2c
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800eac0:	9302      	str	r3, [sp, #8]
{
 800eac2:	0004      	movs	r4, r0
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800eac4:	7818      	ldrb	r0, [r3, #0]
 800eac6:	235f      	movs	r3, #95	; 0x5f
 800eac8:	2606      	movs	r6, #6
 800eaca:	4398      	bics	r0, r3
 800eacc:	d14f      	bne.n	800eb6e <dir_register+0xb6>
	FATFS *fs = dp->obj.fs;
 800eace:	6827      	ldr	r7, [r4, #0]
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 800ead0:	9001      	str	r0, [sp, #4]
 800ead2:	68fa      	ldr	r2, [r7, #12]
 800ead4:	9b01      	ldr	r3, [sp, #4]
 800ead6:	005b      	lsls	r3, r3, #1
 800ead8:	5ad3      	ldrh	r3, [r2, r3]
 800eada:	2b00      	cmp	r3, #0
 800eadc:	d14a      	bne.n	800eb74 <dir_register+0xbc>
	mem_cpy(sn, dp->fn, 12);
 800eade:	0023      	movs	r3, r4
 800eae0:	ad07      	add	r5, sp, #28
 800eae2:	3324      	adds	r3, #36	; 0x24
 800eae4:	0019      	movs	r1, r3
 800eae6:	0028      	movs	r0, r5
 800eae8:	220c      	movs	r2, #12
 800eaea:	9300      	str	r3, [sp, #0]
 800eaec:	f7fe ff03 	bl	800d8f6 <mem_cpy.part.0>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 800eaf0:	7aeb      	ldrb	r3, [r5, #11]
 800eaf2:	2501      	movs	r5, #1
 800eaf4:	422b      	tst	r3, r5
 800eaf6:	d05f      	beq.n	800ebb8 <dir_register+0x100>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800eaf8:	2340      	movs	r3, #64	; 0x40
 800eafa:	9a02      	ldr	r2, [sp, #8]
 800eafc:	7013      	strb	r3, [r2, #0]
 800eafe:	220b      	movs	r2, #11
 800eb00:	a907      	add	r1, sp, #28
 800eb02:	9800      	ldr	r0, [sp, #0]
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 800eb04:	68fe      	ldr	r6, [r7, #12]
 800eb06:	f7fe fef6 	bl	800d8f6 <mem_cpy.part.0>
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 800eb0a:	002b      	movs	r3, r5
 800eb0c:	2d05      	cmp	r5, #5
 800eb0e:	d846      	bhi.n	800eb9e <dir_register+0xe6>
		c = (BYTE)((seq % 16) + '0');
 800eb10:	210f      	movs	r1, #15
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 800eb12:	2207      	movs	r2, #7
		c = (BYTE)((seq % 16) + '0');
 800eb14:	468c      	mov	ip, r1
		ns[i--] = c;
 800eb16:	a805      	add	r0, sp, #20
		c = (BYTE)((seq % 16) + '0');
 800eb18:	4666      	mov	r6, ip
 800eb1a:	401e      	ands	r6, r3
 800eb1c:	0031      	movs	r1, r6
 800eb1e:	3130      	adds	r1, #48	; 0x30
		if (c > '9') c += 7;
 800eb20:	2939      	cmp	r1, #57	; 0x39
 800eb22:	d900      	bls.n	800eb26 <dir_register+0x6e>
 800eb24:	3107      	adds	r1, #7
		ns[i--] = c;
 800eb26:	3a01      	subs	r2, #1
 800eb28:	1886      	adds	r6, r0, r2
 800eb2a:	7071      	strb	r1, [r6, #1]
		seq /= 16;
 800eb2c:	091b      	lsrs	r3, r3, #4
	} while (seq);
 800eb2e:	d1f3      	bne.n	800eb18 <dir_register+0x60>
	ns[i] = '~';
 800eb30:	217e      	movs	r1, #126	; 0x7e
 800eb32:	5481      	strb	r1, [r0, r2]
	for (j = 0; j < i && dst[j] != ' '; j++) {
 800eb34:	4293      	cmp	r3, r2
 800eb36:	d004      	beq.n	800eb42 <dir_register+0x8a>
 800eb38:	9900      	ldr	r1, [sp, #0]
 800eb3a:	1c58      	adds	r0, r3, #1
 800eb3c:	5cc9      	ldrb	r1, [r1, r3]
 800eb3e:	2920      	cmp	r1, #32
 800eb40:	d131      	bne.n	800eba6 <dir_register+0xee>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800eb42:	2120      	movs	r1, #32
 800eb44:	468c      	mov	ip, r1
 800eb46:	ae05      	add	r6, sp, #20
 800eb48:	4661      	mov	r1, ip
 800eb4a:	2a07      	cmp	r2, #7
 800eb4c:	d801      	bhi.n	800eb52 <dir_register+0x9a>
 800eb4e:	5cb1      	ldrb	r1, [r6, r2]
 800eb50:	3201      	adds	r2, #1
 800eb52:	9800      	ldr	r0, [sp, #0]
 800eb54:	54c1      	strb	r1, [r0, r3]
 800eb56:	3301      	adds	r3, #1
	} while (j < 8);
 800eb58:	2b07      	cmp	r3, #7
 800eb5a:	d9f5      	bls.n	800eb48 <dir_register+0x90>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 800eb5c:	0020      	movs	r0, r4
 800eb5e:	f7ff fce5 	bl	800e52c <dir_find>
 800eb62:	1e06      	subs	r6, r0, #0
			if (res != FR_OK) break;
 800eb64:	d121      	bne.n	800ebaa <dir_register+0xf2>
		for (n = 1; n < 100; n++) {
 800eb66:	3501      	adds	r5, #1
 800eb68:	2d64      	cmp	r5, #100	; 0x64
 800eb6a:	d1c8      	bne.n	800eafe <dir_register+0x46>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 800eb6c:	3607      	adds	r6, #7
}
 800eb6e:	0030      	movs	r0, r6
 800eb70:	b00b      	add	sp, #44	; 0x2c
 800eb72:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 800eb74:	9b01      	ldr	r3, [sp, #4]
 800eb76:	3301      	adds	r3, #1
 800eb78:	9301      	str	r3, [sp, #4]
 800eb7a:	e7ab      	b.n	800ead4 <dir_register+0x1c>
			wc = *lfn++;
 800eb7c:	2110      	movs	r1, #16
 800eb7e:	3602      	adds	r6, #2
				sr = (sr << 1) + (wc & 1);
 800eb80:	2001      	movs	r0, #1
 800eb82:	4010      	ands	r0, r2
 800eb84:	4684      	mov	ip, r0
				if (sr & 0x10000) sr ^= 0x11021;
 800eb86:	2080      	movs	r0, #128	; 0x80
				sr = (sr << 1) + (wc & 1);
 800eb88:	005b      	lsls	r3, r3, #1
 800eb8a:	4463      	add	r3, ip
				if (sr & 0x10000) sr ^= 0x11021;
 800eb8c:	0240      	lsls	r0, r0, #9
				wc >>= 1;
 800eb8e:	0852      	lsrs	r2, r2, #1
				if (sr & 0x10000) sr ^= 0x11021;
 800eb90:	4203      	tst	r3, r0
 800eb92:	d001      	beq.n	800eb98 <dir_register+0xe0>
 800eb94:	484b      	ldr	r0, [pc, #300]	; (800ecc4 <dir_register+0x20c>)
 800eb96:	4043      	eors	r3, r0
 800eb98:	3901      	subs	r1, #1
			for (i = 0; i < 16; i++) {
 800eb9a:	2900      	cmp	r1, #0
 800eb9c:	d1f0      	bne.n	800eb80 <dir_register+0xc8>
		while (*lfn) {	/* Create a CRC */
 800eb9e:	8832      	ldrh	r2, [r6, #0]
 800eba0:	2a00      	cmp	r2, #0
 800eba2:	d1eb      	bne.n	800eb7c <dir_register+0xc4>
 800eba4:	e7b4      	b.n	800eb10 <dir_register+0x58>
	for (j = 0; j < i && dst[j] != ' '; j++) {
 800eba6:	0003      	movs	r3, r0
 800eba8:	e7c4      	b.n	800eb34 <dir_register+0x7c>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 800ebaa:	2804      	cmp	r0, #4
 800ebac:	d1df      	bne.n	800eb6e <dir_register+0xb6>
		dp->fn[NSFLAG] = sn[NSFLAG];
 800ebae:	ab07      	add	r3, sp, #28
 800ebb0:	7ada      	ldrb	r2, [r3, #11]
 800ebb2:	0023      	movs	r3, r4
 800ebb4:	332f      	adds	r3, #47	; 0x2f
 800ebb6:	701a      	strb	r2, [r3, #0]
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 800ebb8:	ab07      	add	r3, sp, #28
 800ebba:	7adb      	ldrb	r3, [r3, #11]
 800ebbc:	2501      	movs	r5, #1
 800ebbe:	079b      	lsls	r3, r3, #30
 800ebc0:	d505      	bpl.n	800ebce <dir_register+0x116>
 800ebc2:	9801      	ldr	r0, [sp, #4]
 800ebc4:	210d      	movs	r1, #13
 800ebc6:	300c      	adds	r0, #12
 800ebc8:	f7f1 fad6 	bl	8000178 <__udivsi3>
 800ebcc:	1945      	adds	r5, r0, r5
	res = dir_alloc(dp, nent);		/* Allocate entries */
 800ebce:	0029      	movs	r1, r5
 800ebd0:	0020      	movs	r0, r4
 800ebd2:	f7ff fbc3 	bl	800e35c <dir_alloc>
 800ebd6:	1e06      	subs	r6, r0, #0
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 800ebd8:	d1c9      	bne.n	800eb6e <dir_register+0xb6>
 800ebda:	3d01      	subs	r5, #1
 800ebdc:	2d00      	cmp	r5, #0
 800ebde:	d054      	beq.n	800ec8a <dir_register+0x1d2>
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 800ebe0:	6963      	ldr	r3, [r4, #20]
 800ebe2:	0169      	lsls	r1, r5, #5
 800ebe4:	1a59      	subs	r1, r3, r1
 800ebe6:	0020      	movs	r0, r4
 800ebe8:	f7ff f9d2 	bl	800df90 <dir_sdi>
 800ebec:	1e06      	subs	r6, r0, #0
		if (res == FR_OK) {
 800ebee:	d1be      	bne.n	800eb6e <dir_register+0xb6>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 800ebf0:	9800      	ldr	r0, [sp, #0]
 800ebf2:	f7fe fe5c 	bl	800d8ae <sum_sfn>
 800ebf6:	9003      	str	r0, [sp, #12]
				res = move_window(fs, dp->sect);
 800ebf8:	69e1      	ldr	r1, [r4, #28]
 800ebfa:	0038      	movs	r0, r7
 800ebfc:	f7fe feff 	bl	800d9fe <move_window>
 800ec00:	1e06      	subs	r6, r0, #0
				if (res != FR_OK) break;
 800ec02:	d1b4      	bne.n	800eb6e <dir_register+0xb6>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 800ec04:	68fb      	ldr	r3, [r7, #12]
 800ec06:	6a22      	ldr	r2, [r4, #32]
 800ec08:	9302      	str	r3, [sp, #8]
 800ec0a:	b2eb      	uxtb	r3, r5
 800ec0c:	469c      	mov	ip, r3
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 800ec0e:	9b03      	ldr	r3, [sp, #12]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 800ec10:	210d      	movs	r1, #13
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 800ec12:	7353      	strb	r3, [r2, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 800ec14:	230f      	movs	r3, #15
 800ec16:	72d3      	strb	r3, [r2, #11]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 800ec18:	23ff      	movs	r3, #255	; 0xff
 800ec1a:	402b      	ands	r3, r5
 800ec1c:	3b01      	subs	r3, #1
 800ec1e:	4359      	muls	r1, r3
 800ec20:	9101      	str	r1, [sp, #4]
	s = wc = 0;
 800ec22:	0001      	movs	r1, r0
	dir[LDIR_Type] = 0;
 800ec24:	7310      	strb	r0, [r2, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 800ec26:	7690      	strb	r0, [r2, #26]
	*ptr++ = (BYTE)val;
 800ec28:	76d0      	strb	r0, [r2, #27]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800ec2a:	4e27      	ldr	r6, [pc, #156]	; (800ecc8 <dir_register+0x210>)
 800ec2c:	42b0      	cmp	r0, r6
 800ec2e:	d005      	beq.n	800ec3c <dir_register+0x184>
 800ec30:	9b01      	ldr	r3, [sp, #4]
 800ec32:	9e02      	ldr	r6, [sp, #8]
 800ec34:	0058      	lsls	r0, r3, #1
 800ec36:	5b80      	ldrh	r0, [r0, r6]
 800ec38:	3301      	adds	r3, #1
 800ec3a:	9301      	str	r3, [sp, #4]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 800ec3c:	4e23      	ldr	r6, [pc, #140]	; (800eccc <dir_register+0x214>)
 800ec3e:	5d8e      	ldrb	r6, [r1, r6]
 800ec40:	1993      	adds	r3, r2, r6
	*ptr++ = (BYTE)val; val >>= 8;
 800ec42:	0a06      	lsrs	r6, r0, #8
 800ec44:	7018      	strb	r0, [r3, #0]
	*ptr++ = (BYTE)val;
 800ec46:	705e      	strb	r6, [r3, #1]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800ec48:	2800      	cmp	r0, #0
 800ec4a:	d100      	bne.n	800ec4e <dir_register+0x196>
 800ec4c:	481e      	ldr	r0, [pc, #120]	; (800ecc8 <dir_register+0x210>)
	} while (++s < 13);
 800ec4e:	3101      	adds	r1, #1
 800ec50:	290d      	cmp	r1, #13
 800ec52:	d1ea      	bne.n	800ec2a <dir_register+0x172>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 800ec54:	491c      	ldr	r1, [pc, #112]	; (800ecc8 <dir_register+0x210>)
 800ec56:	4288      	cmp	r0, r1
 800ec58:	d005      	beq.n	800ec66 <dir_register+0x1ae>
 800ec5a:	9b01      	ldr	r3, [sp, #4]
 800ec5c:	9902      	ldr	r1, [sp, #8]
 800ec5e:	005b      	lsls	r3, r3, #1
 800ec60:	5a5b      	ldrh	r3, [r3, r1]
 800ec62:	2b00      	cmp	r3, #0
 800ec64:	d103      	bne.n	800ec6e <dir_register+0x1b6>
 800ec66:	4661      	mov	r1, ip
 800ec68:	2340      	movs	r3, #64	; 0x40
 800ec6a:	4319      	orrs	r1, r3
 800ec6c:	468c      	mov	ip, r1
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 800ec6e:	4663      	mov	r3, ip
 800ec70:	7013      	strb	r3, [r2, #0]
				fs->wflag = 1;
 800ec72:	2301      	movs	r3, #1
				res = dir_next(dp, 0);	/* Next entry */
 800ec74:	2100      	movs	r1, #0
				fs->wflag = 1;
 800ec76:	70fb      	strb	r3, [r7, #3]
				res = dir_next(dp, 0);	/* Next entry */
 800ec78:	0020      	movs	r0, r4
 800ec7a:	f7ff fb19 	bl	800e2b0 <dir_next>
 800ec7e:	1e06      	subs	r6, r0, #0
			} while (res == FR_OK && --nent);
 800ec80:	d000      	beq.n	800ec84 <dir_register+0x1cc>
 800ec82:	e774      	b.n	800eb6e <dir_register+0xb6>
 800ec84:	3d01      	subs	r5, #1
 800ec86:	2d00      	cmp	r5, #0
 800ec88:	d1b6      	bne.n	800ebf8 <dir_register+0x140>
		res = move_window(fs, dp->sect);
 800ec8a:	69e1      	ldr	r1, [r4, #28]
 800ec8c:	0038      	movs	r0, r7
 800ec8e:	f7fe feb6 	bl	800d9fe <move_window>
 800ec92:	1e06      	subs	r6, r0, #0
		if (res == FR_OK) {
 800ec94:	d000      	beq.n	800ec98 <dir_register+0x1e0>
 800ec96:	e76a      	b.n	800eb6e <dir_register+0xb6>
 800ec98:	6a23      	ldr	r3, [r4, #32]
		*d++ = (BYTE)val;
 800ec9a:	0001      	movs	r1, r0
 800ec9c:	001a      	movs	r2, r3
 800ec9e:	3220      	adds	r2, #32
 800eca0:	7019      	strb	r1, [r3, #0]
 800eca2:	3301      	adds	r3, #1
	} while (--cnt);
 800eca4:	429a      	cmp	r2, r3
 800eca6:	d1fb      	bne.n	800eca0 <dir_register+0x1e8>
 800eca8:	220b      	movs	r2, #11
 800ecaa:	9900      	ldr	r1, [sp, #0]
 800ecac:	6a20      	ldr	r0, [r4, #32]
 800ecae:	f7fe fe22 	bl	800d8f6 <mem_cpy.part.0>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 800ecb2:	2118      	movs	r1, #24
 800ecb4:	6a22      	ldr	r2, [r4, #32]
 800ecb6:	342f      	adds	r4, #47	; 0x2f
 800ecb8:	7823      	ldrb	r3, [r4, #0]
 800ecba:	400b      	ands	r3, r1
 800ecbc:	7313      	strb	r3, [r2, #12]
			fs->wflag = 1;
 800ecbe:	2301      	movs	r3, #1
 800ecc0:	70fb      	strb	r3, [r7, #3]
 800ecc2:	e754      	b.n	800eb6e <dir_register+0xb6>
 800ecc4:	00011021 	.word	0x00011021
 800ecc8:	0000ffff 	.word	0x0000ffff
 800eccc:	0801c018 	.word	0x0801c018

0800ecd0 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the filesystem object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 800ecd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ecd2:	b087      	sub	sp, #28
 800ecd4:	9003      	str	r0, [sp, #12]
	FRESULT res;
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 800ecd6:	a805      	add	r0, sp, #20
{
 800ecd8:	9102      	str	r1, [sp, #8]
 800ecda:	9201      	str	r2, [sp, #4]
	const TCHAR *rp = path;
 800ecdc:	9105      	str	r1, [sp, #20]
	vol = get_ldnumber(&rp);
 800ecde:	f7fe fdf4 	bl	800d8ca <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 800ece2:	250b      	movs	r5, #11
	vol = get_ldnumber(&rp);
 800ece4:	1e04      	subs	r4, r0, #0
	if (vol < 0) return FR_INVALID_DRIVE;
 800ece6:	db24      	blt.n	800ed32 <f_mount+0x62>
	cfs = FatFs[vol];					/* Pointer to fs object */
 800ece8:	4e1a      	ldr	r6, [pc, #104]	; (800ed54 <f_mount+0x84>)
 800ecea:	0087      	lsls	r7, r0, #2
 800ecec:	59bd      	ldr	r5, [r7, r6]

	if (cfs) {
 800ecee:	2d00      	cmp	r5, #0
 800ecf0:	d113      	bne.n	800ed1a <f_mount+0x4a>
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
	}

	if (fs) {
 800ecf2:	9b03      	ldr	r3, [sp, #12]
 800ecf4:	2b00      	cmp	r3, #0
 800ecf6:	d122      	bne.n	800ed3e <f_mount+0x6e>
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 800ecf8:	2500      	movs	r5, #0
	FatFs[vol] = fs;					/* Register new fs object */
 800ecfa:	9b03      	ldr	r3, [sp, #12]
 800ecfc:	51f3      	str	r3, [r6, r7]
	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 800ecfe:	9b01      	ldr	r3, [sp, #4]
 800ed00:	42ab      	cmp	r3, r5
 800ed02:	d016      	beq.n	800ed32 <f_mount+0x62>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 800ed04:	002a      	movs	r2, r5
 800ed06:	a903      	add	r1, sp, #12
 800ed08:	a802      	add	r0, sp, #8
 800ed0a:	f7fe fed9 	bl	800dac0 <find_volume>
 800ed0e:	0005      	movs	r5, r0
	LEAVE_FF(fs, res);
 800ed10:	0001      	movs	r1, r0
 800ed12:	9803      	ldr	r0, [sp, #12]
 800ed14:	f7ff fa37 	bl	800e186 <unlock_fs>
 800ed18:	e00b      	b.n	800ed32 <f_mount+0x62>
		if (Files[i].fs == fs) Files[i].fs = 0;
 800ed1a:	4b0f      	ldr	r3, [pc, #60]	; (800ed58 <f_mount+0x88>)
 800ed1c:	681a      	ldr	r2, [r3, #0]
 800ed1e:	4295      	cmp	r5, r2
 800ed20:	d101      	bne.n	800ed26 <f_mount+0x56>
 800ed22:	2200      	movs	r2, #0
 800ed24:	601a      	str	r2, [r3, #0]
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
 800ed26:	6928      	ldr	r0, [r5, #16]
 800ed28:	f000 fc8b 	bl	800f642 <ff_del_syncobj>
 800ed2c:	2800      	cmp	r0, #0
 800ed2e:	d103      	bne.n	800ed38 <f_mount+0x68>
 800ed30:	2502      	movs	r5, #2
}
 800ed32:	0028      	movs	r0, r5
 800ed34:	b007      	add	sp, #28
 800ed36:	bdf0      	pop	{r4, r5, r6, r7, pc}
		cfs->fs_type = 0;				/* Clear old fs object */
 800ed38:	2300      	movs	r3, #0
 800ed3a:	702b      	strb	r3, [r5, #0]
 800ed3c:	e7d9      	b.n	800ecf2 <f_mount+0x22>
		fs->fs_type = 0;				/* Clear new fs object */
 800ed3e:	2200      	movs	r2, #0
 800ed40:	701a      	strb	r2, [r3, #0]
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
 800ed42:	9903      	ldr	r1, [sp, #12]
 800ed44:	b2e0      	uxtb	r0, r4
 800ed46:	3110      	adds	r1, #16
 800ed48:	f000 fc72 	bl	800f630 <ff_cre_syncobj>
 800ed4c:	2800      	cmp	r0, #0
 800ed4e:	d1d3      	bne.n	800ecf8 <f_mount+0x28>
 800ed50:	e7ee      	b.n	800ed30 <f_mount+0x60>
 800ed52:	46c0      	nop			; (mov r8, r8)
 800ed54:	20001c98 	.word	0x20001c98
 800ed58:	20001c9c 	.word	0x20001c9c

0800ed5c <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 800ed5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ed5e:	b097      	sub	sp, #92	; 0x5c
 800ed60:	0005      	movs	r5, r0
 800ed62:	9105      	str	r1, [sp, #20]
 800ed64:	0017      	movs	r7, r2
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 800ed66:	2409      	movs	r4, #9
 800ed68:	2800      	cmp	r0, #0
 800ed6a:	d019      	beq.n	800eda0 <f_open+0x44>

	/* Get logical drive */
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800ed6c:	233f      	movs	r3, #63	; 0x3f
 800ed6e:	4013      	ands	r3, r2
	res = find_volume(&path, &fs, mode);
 800ed70:	001a      	movs	r2, r3
 800ed72:	a907      	add	r1, sp, #28
 800ed74:	a805      	add	r0, sp, #20
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800ed76:	9301      	str	r3, [sp, #4]
	res = find_volume(&path, &fs, mode);
 800ed78:	f7fe fea2 	bl	800dac0 <find_volume>
 800ed7c:	1e04      	subs	r4, r0, #0
	if (res == FR_OK) {
 800ed7e:	d000      	beq.n	800ed82 <f_open+0x26>
 800ed80:	e0a1      	b.n	800eec6 <f_open+0x16a>
		dj.obj.fs = fs;
		INIT_NAMBUF(fs);
 800ed82:	2080      	movs	r0, #128	; 0x80
		dj.obj.fs = fs;
 800ed84:	9b07      	ldr	r3, [sp, #28]
		INIT_NAMBUF(fs);
 800ed86:	0080      	lsls	r0, r0, #2
		dj.obj.fs = fs;
 800ed88:	9308      	str	r3, [sp, #32]
		INIT_NAMBUF(fs);
 800ed8a:	f000 fc49 	bl	800f620 <ff_memalloc>
		dj.obj.fs = fs;
 800ed8e:	ae08      	add	r6, sp, #32
		INIT_NAMBUF(fs);
 800ed90:	9002      	str	r0, [sp, #8]
 800ed92:	2800      	cmp	r0, #0
 800ed94:	d107      	bne.n	800eda6 <f_open+0x4a>
 800ed96:	2111      	movs	r1, #17
 800ed98:	9807      	ldr	r0, [sp, #28]
 800ed9a:	f7ff f9f4 	bl	800e186 <unlock_fs>
 800ed9e:	3411      	adds	r4, #17
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */

	LEAVE_FF(fs, res);
}
 800eda0:	0020      	movs	r0, r4
 800eda2:	b017      	add	sp, #92	; 0x5c
 800eda4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		INIT_NAMBUF(fs);
 800eda6:	9b07      	ldr	r3, [sp, #28]
 800eda8:	9a02      	ldr	r2, [sp, #8]
		res = follow_path(&dj, path);	/* Follow the file path */
 800edaa:	9905      	ldr	r1, [sp, #20]
		INIT_NAMBUF(fs);
 800edac:	60da      	str	r2, [r3, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 800edae:	0030      	movs	r0, r6
 800edb0:	f7ff fc70 	bl	800e694 <follow_path>
 800edb4:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {
 800edb6:	d10f      	bne.n	800edd8 <f_open+0x7c>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 800edb8:	233f      	movs	r3, #63	; 0x3f
 800edba:	aa04      	add	r2, sp, #16
 800edbc:	189b      	adds	r3, r3, r2
 800edbe:	781b      	ldrb	r3, [r3, #0]
				res = FR_INVALID_NAME;
 800edc0:	3406      	adds	r4, #6
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 800edc2:	2b7f      	cmp	r3, #127	; 0x7f
 800edc4:	d808      	bhi.n	800edd8 <f_open+0x7c>
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
 800edc6:	2301      	movs	r3, #1
 800edc8:	9901      	ldr	r1, [sp, #4]
 800edca:	0030      	movs	r0, r6
 800edcc:	4399      	bics	r1, r3
 800edce:	1e4b      	subs	r3, r1, #1
 800edd0:	4199      	sbcs	r1, r3
 800edd2:	f7fe fd99 	bl	800d908 <chk_lock>
 800edd6:	0004      	movs	r4, r0
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800edd8:	231c      	movs	r3, #28
 800edda:	421f      	tst	r7, r3
 800eddc:	d07a      	beq.n	800eed4 <f_open+0x178>
			if (res != FR_OK) {					/* No file, create new */
 800edde:	2c00      	cmp	r4, #0
 800ede0:	d064      	beq.n	800eeac <f_open+0x150>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 800ede2:	2c04      	cmp	r4, #4
 800ede4:	d16a      	bne.n	800eebc <f_open+0x160>
	for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
 800ede6:	4b62      	ldr	r3, [pc, #392]	; (800ef70 <f_open+0x214>)
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 800ede8:	340e      	adds	r4, #14
	for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
 800edea:	681b      	ldr	r3, [r3, #0]
 800edec:	2b00      	cmp	r3, #0
 800edee:	d165      	bne.n	800eebc <f_open+0x160>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 800edf0:	0030      	movs	r0, r6
 800edf2:	f7ff fe61 	bl	800eab8 <dir_register>
 800edf6:	1e04      	subs	r4, r0, #0
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 800edf8:	d160      	bne.n	800eebc <f_open+0x160>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 800edfa:	2308      	movs	r3, #8
 800edfc:	9a01      	ldr	r2, [sp, #4]
 800edfe:	431a      	orrs	r2, r3
 800ee00:	9201      	str	r2, [sp, #4]
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 800ee02:	9b01      	ldr	r3, [sp, #4]
 800ee04:	071b      	lsls	r3, r3, #28
 800ee06:	d537      	bpl.n	800ee78 <f_open+0x11c>
 800ee08:	6a34      	ldr	r4, [r6, #32]
 800ee0a:	9b07      	ldr	r3, [sp, #28]
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 800ee0c:	0021      	movs	r1, r4
 800ee0e:	7818      	ldrb	r0, [r3, #0]
 800ee10:	9304      	str	r3, [sp, #16]
 800ee12:	f7fe fdb5 	bl	800d980 <ld_clust.isra.5>
	*ptr++ = (BYTE)val; val >>= 8;
 800ee16:	23a1      	movs	r3, #161	; 0xa1
	*ptr++ = (BYTE)val; val >>= 8;
 800ee18:	2700      	movs	r7, #0
	*ptr++ = (BYTE)val; val >>= 8;
 800ee1a:	7423      	strb	r3, [r4, #16]
	*ptr++ = (BYTE)val;
 800ee1c:	3b57      	subs	r3, #87	; 0x57
 800ee1e:	7463      	strb	r3, [r4, #17]
	*ptr++ = (BYTE)val; val >>= 8;
 800ee20:	73a7      	strb	r7, [r4, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 800ee22:	73e7      	strb	r7, [r4, #15]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 800ee24:	6a32      	ldr	r2, [r6, #32]
 800ee26:	3b2a      	subs	r3, #42	; 0x2a
 800ee28:	72d3      	strb	r3, [r2, #11]
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 800ee2a:	9003      	str	r0, [sp, #12]
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 800ee2c:	003a      	movs	r2, r7
 800ee2e:	6a31      	ldr	r1, [r6, #32]
 800ee30:	9804      	ldr	r0, [sp, #16]
 800ee32:	f7fe fdb4 	bl	800d99e <st_clust.isra.6>
					st_dword(dj.dir + DIR_FileSize, 0);
 800ee36:	6a33      	ldr	r3, [r6, #32]
					fs->wflag = 1;
 800ee38:	9a07      	ldr	r2, [sp, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 800ee3a:	771f      	strb	r7, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 800ee3c:	775f      	strb	r7, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 800ee3e:	779f      	strb	r7, [r3, #30]
	*ptr++ = (BYTE)val;
 800ee40:	77df      	strb	r7, [r3, #31]
					fs->wflag = 1;
 800ee42:	2301      	movs	r3, #1
 800ee44:	70d3      	strb	r3, [r2, #3]
					if (cl != 0) {						/* Remove the cluster chain if exist */
 800ee46:	9b03      	ldr	r3, [sp, #12]
 800ee48:	42bb      	cmp	r3, r7
 800ee4a:	d015      	beq.n	800ee78 <f_open+0x11c>
						dw = fs->winsect;
 800ee4c:	9b07      	ldr	r3, [sp, #28]
						res = remove_chain(&dj.obj, cl, 0);
 800ee4e:	003a      	movs	r2, r7
						dw = fs->winsect;
 800ee50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
						res = remove_chain(&dj.obj, cl, 0);
 800ee52:	9903      	ldr	r1, [sp, #12]
 800ee54:	0030      	movs	r0, r6
						dw = fs->winsect;
 800ee56:	9304      	str	r3, [sp, #16]
						res = remove_chain(&dj.obj, cl, 0);
 800ee58:	f7ff f95c 	bl	800e114 <remove_chain>
 800ee5c:	0004      	movs	r4, r0
						if (res == FR_OK) {
 800ee5e:	42b8      	cmp	r0, r7
 800ee60:	d12c      	bne.n	800eebc <f_open+0x160>
							res = move_window(fs, dw);
 800ee62:	9904      	ldr	r1, [sp, #16]
 800ee64:	9807      	ldr	r0, [sp, #28]
 800ee66:	f7fe fdca 	bl	800d9fe <move_window>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 800ee6a:	9b03      	ldr	r3, [sp, #12]
 800ee6c:	9a07      	ldr	r2, [sp, #28]
 800ee6e:	3b01      	subs	r3, #1
							res = move_window(fs, dw);
 800ee70:	0004      	movs	r4, r0
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 800ee72:	6153      	str	r3, [r2, #20]
		if (res == FR_OK) {
 800ee74:	42b8      	cmp	r0, r7
 800ee76:	d121      	bne.n	800eebc <f_open+0x160>
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
 800ee78:	9b01      	ldr	r3, [sp, #4]
 800ee7a:	071b      	lsls	r3, r3, #28
 800ee7c:	d503      	bpl.n	800ee86 <f_open+0x12a>
 800ee7e:	2340      	movs	r3, #64	; 0x40
 800ee80:	9a01      	ldr	r2, [sp, #4]
 800ee82:	431a      	orrs	r2, r3
 800ee84:	9201      	str	r2, [sp, #4]
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 800ee86:	9b07      	ldr	r3, [sp, #28]
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
 800ee88:	9901      	ldr	r1, [sp, #4]
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 800ee8a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
 800ee8c:	a808      	add	r0, sp, #32
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 800ee8e:	626b      	str	r3, [r5, #36]	; 0x24
			fp->dir_ptr = dj.dir;
 800ee90:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800ee92:	9303      	str	r3, [sp, #12]
 800ee94:	62ab      	str	r3, [r5, #40]	; 0x28
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
 800ee96:	2301      	movs	r3, #1
 800ee98:	4399      	bics	r1, r3
 800ee9a:	1e4b      	subs	r3, r1, #1
 800ee9c:	4199      	sbcs	r1, r3
 800ee9e:	f7fe fcb9 	bl	800d814 <inc_lock>
 800eea2:	6128      	str	r0, [r5, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
 800eea4:	2800      	cmp	r0, #0
 800eea6:	d121      	bne.n	800eeec <f_open+0x190>
 800eea8:	2402      	movs	r4, #2
 800eeaa:	e007      	b.n	800eebc <f_open+0x160>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 800eeac:	2311      	movs	r3, #17
 800eeae:	79b2      	ldrb	r2, [r6, #6]
					res = FR_DENIED;
 800eeb0:	2407      	movs	r4, #7
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 800eeb2:	421a      	tst	r2, r3
 800eeb4:	d102      	bne.n	800eebc <f_open+0x160>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 800eeb6:	3401      	adds	r4, #1
 800eeb8:	077b      	lsls	r3, r7, #29
 800eeba:	d5a2      	bpl.n	800ee02 <f_open+0xa6>
		FREE_NAMBUF();
 800eebc:	9802      	ldr	r0, [sp, #8]
 800eebe:	f000 fbb3 	bl	800f628 <ff_memfree>
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800eec2:	2c00      	cmp	r4, #0
 800eec4:	d001      	beq.n	800eeca <f_open+0x16e>
 800eec6:	2300      	movs	r3, #0
 800eec8:	602b      	str	r3, [r5, #0]
	LEAVE_FF(fs, res);
 800eeca:	0021      	movs	r1, r4
 800eecc:	9807      	ldr	r0, [sp, #28]
 800eece:	f7ff f95a 	bl	800e186 <unlock_fs>
 800eed2:	e765      	b.n	800eda0 <f_open+0x44>
			if (res == FR_OK) {					/* Is the object exsiting? */
 800eed4:	2c00      	cmp	r4, #0
 800eed6:	d1f1      	bne.n	800eebc <f_open+0x160>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 800eed8:	79b3      	ldrb	r3, [r6, #6]
					res = FR_NO_FILE;
 800eeda:	3404      	adds	r4, #4
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 800eedc:	06da      	lsls	r2, r3, #27
 800eede:	d4ed      	bmi.n	800eebc <f_open+0x160>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
 800eee0:	07ba      	lsls	r2, r7, #30
 800eee2:	d5c9      	bpl.n	800ee78 <f_open+0x11c>
					res = FR_DENIED;
 800eee4:	3403      	adds	r4, #3
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
 800eee6:	07db      	lsls	r3, r3, #31
 800eee8:	d4e8      	bmi.n	800eebc <f_open+0x160>
 800eeea:	e7c5      	b.n	800ee78 <f_open+0x11c>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 800eeec:	9c07      	ldr	r4, [sp, #28]
 800eeee:	9e10      	ldr	r6, [sp, #64]	; 0x40
 800eef0:	7820      	ldrb	r0, [r4, #0]
 800eef2:	0031      	movs	r1, r6
 800eef4:	f7fe fd44 	bl	800d980 <ld_clust.isra.5>
 800eef8:	60a8      	str	r0, [r5, #8]
 800eefa:	0007      	movs	r7, r0
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 800eefc:	0030      	movs	r0, r6
 800eefe:	301c      	adds	r0, #28
 800ef00:	f7fe fc70 	bl	800d7e4 <ld_dword>
			fp->cltbl = 0;			/* Disable fast seek mode */
 800ef04:	2300      	movs	r3, #0
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 800ef06:	60e8      	str	r0, [r5, #12]
			fp->cltbl = 0;			/* Disable fast seek mode */
 800ef08:	62eb      	str	r3, [r5, #44]	; 0x2c
			fp->obj.fs = fs;	 	/* Validate the file object */
 800ef0a:	602c      	str	r4, [r5, #0]
			fp->obj.id = fs->id;
 800ef0c:	88e2      	ldrh	r2, [r4, #6]
			fp->err = 0;			/* Clear error flag */
 800ef0e:	756b      	strb	r3, [r5, #21]
			fp->obj.id = fs->id;
 800ef10:	80aa      	strh	r2, [r5, #4]
			fp->flag = mode;		/* Set file access mode */
 800ef12:	9a01      	ldr	r2, [sp, #4]
			fp->sect = 0;			/* Invalidate current data sector */
 800ef14:	622b      	str	r3, [r5, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 800ef16:	61ab      	str	r3, [r5, #24]
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 800ef18:	0013      	movs	r3, r2
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 800ef1a:	0006      	movs	r6, r0
			fp->flag = mode;		/* Set file access mode */
 800ef1c:	752a      	strb	r2, [r5, #20]
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 800ef1e:	069b      	lsls	r3, r3, #26
 800ef20:	d401      	bmi.n	800ef26 <f_open+0x1ca>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 800ef22:	2400      	movs	r4, #0
 800ef24:	e7ca      	b.n	800eebc <f_open+0x160>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 800ef26:	2800      	cmp	r0, #0
 800ef28:	d0fb      	beq.n	800ef22 <f_open+0x1c6>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 800ef2a:	61a8      	str	r0, [r5, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 800ef2c:	8964      	ldrh	r4, [r4, #10]
 800ef2e:	0264      	lsls	r4, r4, #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800ef30:	42b4      	cmp	r4, r6
 800ef32:	d30f      	bcc.n	800ef54 <f_open+0x1f8>
 800ef34:	2400      	movs	r4, #0
				fp->clust = clst;
 800ef36:	61ef      	str	r7, [r5, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800ef38:	2c00      	cmp	r4, #0
 800ef3a:	d1bf      	bne.n	800eebc <f_open+0x160>
 800ef3c:	05f3      	lsls	r3, r6, #23
 800ef3e:	d0f0      	beq.n	800ef22 <f_open+0x1c6>
					if ((sc = clst2sect(fs, clst)) == 0) {
 800ef40:	0039      	movs	r1, r7
 800ef42:	9807      	ldr	r0, [sp, #28]
 800ef44:	f7fe fc92 	bl	800d86c <clst2sect>
 800ef48:	2800      	cmp	r0, #0
 800ef4a:	d0ad      	beq.n	800eea8 <f_open+0x14c>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 800ef4c:	0a76      	lsrs	r6, r6, #9
 800ef4e:	1830      	adds	r0, r6, r0
 800ef50:	6228      	str	r0, [r5, #32]
 800ef52:	e7b3      	b.n	800eebc <f_open+0x160>
					clst = get_fat(&fp->obj, clst);
 800ef54:	0039      	movs	r1, r7
 800ef56:	6828      	ldr	r0, [r5, #0]
 800ef58:	f7fe ffba 	bl	800ded0 <get_fat.isra.12>
 800ef5c:	1b36      	subs	r6, r6, r4
 800ef5e:	0007      	movs	r7, r0
					if (clst <= 1) res = FR_INT_ERR;
 800ef60:	2801      	cmp	r0, #1
 800ef62:	d903      	bls.n	800ef6c <f_open+0x210>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800ef64:	1c43      	adds	r3, r0, #1
 800ef66:	d1e3      	bne.n	800ef30 <f_open+0x1d4>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 800ef68:	2401      	movs	r4, #1
 800ef6a:	e7e4      	b.n	800ef36 <f_open+0x1da>
					if (clst <= 1) res = FR_INT_ERR;
 800ef6c:	2402      	movs	r4, #2
 800ef6e:	e7e2      	b.n	800ef36 <f_open+0x1da>
 800ef70:	20001c9c 	.word	0x20001c9c

0800ef74 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 800ef74:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ef76:	b089      	sub	sp, #36	; 0x24
 800ef78:	9305      	str	r3, [sp, #20]
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 800ef7a:	2300      	movs	r3, #0
{
 800ef7c:	0017      	movs	r7, r2
	*br = 0;	/* Clear read byte counter */
 800ef7e:	9a05      	ldr	r2, [sp, #20]
{
 800ef80:	9101      	str	r1, [sp, #4]
	*br = 0;	/* Clear read byte counter */
 800ef82:	6013      	str	r3, [r2, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 800ef84:	a907      	add	r1, sp, #28
{
 800ef86:	0005      	movs	r5, r0
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 800ef88:	f7ff f90a 	bl	800e1a0 <validate>
 800ef8c:	1e04      	subs	r4, r0, #0
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800ef8e:	d102      	bne.n	800ef96 <f_read+0x22>
 800ef90:	7d6c      	ldrb	r4, [r5, #21]
 800ef92:	2c00      	cmp	r4, #0
 800ef94:	d002      	beq.n	800ef9c <f_read+0x28>
			fp->sect = sect;
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 800ef96:	0021      	movs	r1, r4
 800ef98:	9807      	ldr	r0, [sp, #28]
 800ef9a:	e043      	b.n	800f024 <f_read+0xb0>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800ef9c:	7d2b      	ldrb	r3, [r5, #20]
 800ef9e:	07db      	lsls	r3, r3, #31
 800efa0:	d407      	bmi.n	800efb2 <f_read+0x3e>
 800efa2:	2107      	movs	r1, #7
 800efa4:	9807      	ldr	r0, [sp, #28]
 800efa6:	f7ff f8ee 	bl	800e186 <unlock_fs>
 800efaa:	2407      	movs	r4, #7
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 800efac:	0020      	movs	r0, r4
 800efae:	b009      	add	sp, #36	; 0x24
 800efb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	remain = fp->obj.objsize - fp->fptr;
 800efb2:	68eb      	ldr	r3, [r5, #12]
 800efb4:	69aa      	ldr	r2, [r5, #24]
 800efb6:	1a9e      	subs	r6, r3, r2
 800efb8:	42be      	cmp	r6, r7
 800efba:	d900      	bls.n	800efbe <f_read+0x4a>
 800efbc:	003e      	movs	r6, r7
 800efbe:	9807      	ldr	r0, [sp, #28]
	for ( ;  btr;								/* Repeat until all data read */
 800efc0:	2e00      	cmp	r6, #0
 800efc2:	d101      	bne.n	800efc8 <f_read+0x54>
	LEAVE_FF(fs, FR_OK);
 800efc4:	0031      	movs	r1, r6
 800efc6:	e02d      	b.n	800f024 <f_read+0xb0>
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800efc8:	69a9      	ldr	r1, [r5, #24]
 800efca:	05cb      	lsls	r3, r1, #23
 800efcc:	d166      	bne.n	800f09c <f_read+0x128>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 800efce:	8943      	ldrh	r3, [r0, #10]
 800efd0:	0a4a      	lsrs	r2, r1, #9
 800efd2:	3b01      	subs	r3, #1
 800efd4:	401a      	ands	r2, r3
 800efd6:	9203      	str	r2, [sp, #12]
			if (csect == 0) {					/* On the cluster boundary? */
 800efd8:	d118      	bne.n	800f00c <f_read+0x98>
				if (fp->fptr == 0) {			/* On the top of the file? */
 800efda:	2900      	cmp	r1, #0
 800efdc:	d105      	bne.n	800efea <f_read+0x76>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 800efde:	68a8      	ldr	r0, [r5, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800efe0:	2801      	cmp	r0, #1
 800efe2:	d80e      	bhi.n	800f002 <f_read+0x8e>
 800efe4:	2402      	movs	r4, #2
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 800efe6:	756c      	strb	r4, [r5, #21]
 800efe8:	e7d5      	b.n	800ef96 <f_read+0x22>
					if (fp->cltbl) {
 800efea:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800efec:	2b00      	cmp	r3, #0
 800efee:	d003      	beq.n	800eff8 <f_read+0x84>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 800eff0:	0028      	movs	r0, r5
 800eff2:	f7fe fc47 	bl	800d884 <clmt_clust>
 800eff6:	e7f3      	b.n	800efe0 <f_read+0x6c>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 800eff8:	69e9      	ldr	r1, [r5, #28]
 800effa:	6828      	ldr	r0, [r5, #0]
 800effc:	f7fe ff68 	bl	800ded0 <get_fat.isra.12>
 800f000:	e7ee      	b.n	800efe0 <f_read+0x6c>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800f002:	1c43      	adds	r3, r0, #1
 800f004:	d101      	bne.n	800f00a <f_read+0x96>
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 800f006:	2401      	movs	r4, #1
 800f008:	e7ed      	b.n	800efe6 <f_read+0x72>
				fp->clust = clst;				/* Update current cluster */
 800f00a:	61e8      	str	r0, [r5, #28]
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 800f00c:	9b07      	ldr	r3, [sp, #28]
 800f00e:	69e9      	ldr	r1, [r5, #28]
 800f010:	0018      	movs	r0, r3
 800f012:	9302      	str	r3, [sp, #8]
 800f014:	f7fe fc2a 	bl	800d86c <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 800f018:	2800      	cmp	r0, #0
 800f01a:	d106      	bne.n	800f02a <f_read+0xb6>
 800f01c:	2402      	movs	r4, #2
 800f01e:	0021      	movs	r1, r4
 800f020:	9802      	ldr	r0, [sp, #8]
 800f022:	756c      	strb	r4, [r5, #21]
	LEAVE_FF(fs, FR_OK);
 800f024:	f7ff f8af 	bl	800e186 <unlock_fs>
 800f028:	e7c0      	b.n	800efac <f_read+0x38>
			sect += csect;
 800f02a:	9b03      	ldr	r3, [sp, #12]
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 800f02c:	0a77      	lsrs	r7, r6, #9
			sect += csect;
 800f02e:	181b      	adds	r3, r3, r0
 800f030:	9304      	str	r3, [sp, #16]
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 800f032:	2f00      	cmp	r7, #0
 800f034:	d030      	beq.n	800f098 <f_read+0x124>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800f036:	9b02      	ldr	r3, [sp, #8]
 800f038:	9a03      	ldr	r2, [sp, #12]
 800f03a:	895b      	ldrh	r3, [r3, #10]
 800f03c:	19d2      	adds	r2, r2, r7
 800f03e:	429a      	cmp	r2, r3
 800f040:	d901      	bls.n	800f046 <f_read+0xd2>
					cc = fs->csize - csect;
 800f042:	9a03      	ldr	r2, [sp, #12]
 800f044:	1a9f      	subs	r7, r3, r2
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800f046:	9b02      	ldr	r3, [sp, #8]
 800f048:	9a04      	ldr	r2, [sp, #16]
 800f04a:	7858      	ldrb	r0, [r3, #1]
 800f04c:	9901      	ldr	r1, [sp, #4]
 800f04e:	003b      	movs	r3, r7
 800f050:	f7fe fb9e 	bl	800d790 <disk_read>
 800f054:	2800      	cmp	r0, #0
 800f056:	d1d6      	bne.n	800f006 <f_read+0x92>
				if (fs->wflag && fs->winsect - sect < cc) {
 800f058:	9907      	ldr	r1, [sp, #28]
 800f05a:	78cb      	ldrb	r3, [r1, #3]
 800f05c:	2b00      	cmp	r3, #0
 800f05e:	d00c      	beq.n	800f07a <f_read+0x106>
 800f060:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 800f062:	9a04      	ldr	r2, [sp, #16]
 800f064:	1a98      	subs	r0, r3, r2
 800f066:	42b8      	cmp	r0, r7
 800f068:	d207      	bcs.n	800f07a <f_read+0x106>
 800f06a:	2280      	movs	r2, #128	; 0x80
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
 800f06c:	9b01      	ldr	r3, [sp, #4]
 800f06e:	0240      	lsls	r0, r0, #9
 800f070:	313c      	adds	r1, #60	; 0x3c
 800f072:	1818      	adds	r0, r3, r0
 800f074:	0092      	lsls	r2, r2, #2
 800f076:	f7fe fc3e 	bl	800d8f6 <mem_cpy.part.0>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 800f07a:	027f      	lsls	r7, r7, #9
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 800f07c:	9b05      	ldr	r3, [sp, #20]
 800f07e:	9a05      	ldr	r2, [sp, #20]
 800f080:	681b      	ldr	r3, [r3, #0]
 800f082:	1bf6      	subs	r6, r6, r7
 800f084:	9302      	str	r3, [sp, #8]
 800f086:	19db      	adds	r3, r3, r7
 800f088:	6013      	str	r3, [r2, #0]
 800f08a:	9b01      	ldr	r3, [sp, #4]
 800f08c:	19db      	adds	r3, r3, r7
 800f08e:	9301      	str	r3, [sp, #4]
 800f090:	69ab      	ldr	r3, [r5, #24]
 800f092:	19df      	adds	r7, r3, r7
 800f094:	61af      	str	r7, [r5, #24]
 800f096:	e792      	b.n	800efbe <f_read+0x4a>
			fp->sect = sect;
 800f098:	9b04      	ldr	r3, [sp, #16]
 800f09a:	622b      	str	r3, [r5, #32]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 800f09c:	2280      	movs	r2, #128	; 0x80
 800f09e:	69ab      	ldr	r3, [r5, #24]
 800f0a0:	0092      	lsls	r2, r2, #2
 800f0a2:	05db      	lsls	r3, r3, #23
 800f0a4:	0ddb      	lsrs	r3, r3, #23
 800f0a6:	1ad3      	subs	r3, r2, r3
 800f0a8:	0037      	movs	r7, r6
 800f0aa:	429e      	cmp	r6, r3
 800f0ac:	d900      	bls.n	800f0b0 <f_read+0x13c>
 800f0ae:	001f      	movs	r7, r3
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 800f0b0:	6a29      	ldr	r1, [r5, #32]
 800f0b2:	9807      	ldr	r0, [sp, #28]
 800f0b4:	f7fe fca3 	bl	800d9fe <move_window>
 800f0b8:	2800      	cmp	r0, #0
 800f0ba:	d1a4      	bne.n	800f006 <f_read+0x92>
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 800f0bc:	69ab      	ldr	r3, [r5, #24]
 800f0be:	9907      	ldr	r1, [sp, #28]
 800f0c0:	05db      	lsls	r3, r3, #23
 800f0c2:	0ddb      	lsrs	r3, r3, #23
 800f0c4:	313c      	adds	r1, #60	; 0x3c
 800f0c6:	18c9      	adds	r1, r1, r3
 800f0c8:	003a      	movs	r2, r7
 800f0ca:	9801      	ldr	r0, [sp, #4]
 800f0cc:	f7fe fc13 	bl	800d8f6 <mem_cpy.part.0>
 800f0d0:	e7d4      	b.n	800f07c <f_read+0x108>

0800f0d2 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 800f0d2:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f0d4:	b089      	sub	sp, #36	; 0x24
 800f0d6:	9305      	str	r3, [sp, #20]
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 800f0d8:	2300      	movs	r3, #0
{
 800f0da:	0017      	movs	r7, r2
	*bw = 0;	/* Clear write byte counter */
 800f0dc:	9a05      	ldr	r2, [sp, #20]
{
 800f0de:	9101      	str	r1, [sp, #4]
	*bw = 0;	/* Clear write byte counter */
 800f0e0:	6013      	str	r3, [r2, #0]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 800f0e2:	a907      	add	r1, sp, #28
{
 800f0e4:	0005      	movs	r5, r0
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 800f0e6:	f7ff f85b 	bl	800e1a0 <validate>
 800f0ea:	1e04      	subs	r4, r0, #0
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800f0ec:	d102      	bne.n	800f0f4 <f_write+0x22>
 800f0ee:	7d6c      	ldrb	r4, [r5, #21]
 800f0f0:	2c00      	cmp	r4, #0
 800f0f2:	d001      	beq.n	800f0f8 <f_write+0x26>
			fp->sect = sect;
		}
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 800f0f4:	0021      	movs	r1, r4
 800f0f6:	e033      	b.n	800f160 <f_write+0x8e>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 800f0f8:	7d2b      	ldrb	r3, [r5, #20]
 800f0fa:	079b      	lsls	r3, r3, #30
 800f0fc:	d407      	bmi.n	800f10e <f_write+0x3c>
 800f0fe:	2107      	movs	r1, #7
 800f100:	9807      	ldr	r0, [sp, #28]
 800f102:	f7ff f840 	bl	800e186 <unlock_fs>
 800f106:	2407      	movs	r4, #7
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */

	LEAVE_FF(fs, FR_OK);
}
 800f108:	0020      	movs	r0, r4
 800f10a:	b009      	add	sp, #36	; 0x24
 800f10c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 800f10e:	69ab      	ldr	r3, [r5, #24]
 800f110:	19da      	adds	r2, r3, r7
 800f112:	4293      	cmp	r3, r2
 800f114:	d900      	bls.n	800f118 <f_write+0x46>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 800f116:	43df      	mvns	r7, r3
	for ( ;  btw;							/* Repeat until all data written */
 800f118:	2f00      	cmp	r7, #0
 800f11a:	d01c      	beq.n	800f156 <f_write+0x84>
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 800f11c:	69a9      	ldr	r1, [r5, #24]
 800f11e:	05cb      	lsls	r3, r1, #23
 800f120:	d000      	beq.n	800f124 <f_write+0x52>
 800f122:	e08f      	b.n	800f244 <f_write+0x172>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 800f124:	9b07      	ldr	r3, [sp, #28]
 800f126:	895e      	ldrh	r6, [r3, #10]
 800f128:	0a4b      	lsrs	r3, r1, #9
 800f12a:	3e01      	subs	r6, #1
 800f12c:	4033      	ands	r3, r6
 800f12e:	9303      	str	r3, [sp, #12]
			if (csect == 0) {				/* On the cluster boundary? */
 800f130:	d128      	bne.n	800f184 <f_write+0xb2>
				if (fp->fptr == 0) {		/* On the top of the file? */
 800f132:	2900      	cmp	r1, #0
 800f134:	d107      	bne.n	800f146 <f_write+0x74>
					clst = fp->obj.sclust;	/* Follow from the origin */
 800f136:	68a8      	ldr	r0, [r5, #8]
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 800f138:	1e01      	subs	r1, r0, #0
					if (clst == 0) {		/* If no cluster is allocated, */
 800f13a:	d016      	beq.n	800f16a <f_write+0x98>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 800f13c:	2801      	cmp	r0, #1
 800f13e:	d118      	bne.n	800f172 <f_write+0xa0>
 800f140:	2402      	movs	r4, #2
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 800f142:	756c      	strb	r4, [r5, #21]
 800f144:	e7d6      	b.n	800f0f4 <f_write+0x22>
					if (fp->cltbl) {
 800f146:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800f148:	2b00      	cmp	r3, #0
 800f14a:	d00d      	beq.n	800f168 <f_write+0x96>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 800f14c:	0028      	movs	r0, r5
 800f14e:	f7fe fb99 	bl	800d884 <clmt_clust>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800f152:	2800      	cmp	r0, #0
 800f154:	d1f2      	bne.n	800f13c <f_write+0x6a>
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 800f156:	2340      	movs	r3, #64	; 0x40
	LEAVE_FF(fs, FR_OK);
 800f158:	2100      	movs	r1, #0
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 800f15a:	7d2a      	ldrb	r2, [r5, #20]
 800f15c:	4313      	orrs	r3, r2
 800f15e:	752b      	strb	r3, [r5, #20]
	LEAVE_FF(fs, FR_OK);
 800f160:	9807      	ldr	r0, [sp, #28]
 800f162:	f7ff f810 	bl	800e186 <unlock_fs>
 800f166:	e7cf      	b.n	800f108 <f_write+0x36>
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 800f168:	69e9      	ldr	r1, [r5, #28]
 800f16a:	0028      	movs	r0, r5
 800f16c:	f7fe ff5a 	bl	800e024 <create_chain>
 800f170:	e7ef      	b.n	800f152 <f_write+0x80>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800f172:	1c43      	adds	r3, r0, #1
 800f174:	d101      	bne.n	800f17a <f_write+0xa8>
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 800f176:	2401      	movs	r4, #1
 800f178:	e7e3      	b.n	800f142 <f_write+0x70>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 800f17a:	68ab      	ldr	r3, [r5, #8]
				fp->clust = clst;			/* Update current cluster */
 800f17c:	61e8      	str	r0, [r5, #28]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 800f17e:	2b00      	cmp	r3, #0
 800f180:	d100      	bne.n	800f184 <f_write+0xb2>
 800f182:	60a8      	str	r0, [r5, #8]
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
 800f184:	9807      	ldr	r0, [sp, #28]
 800f186:	6a2a      	ldr	r2, [r5, #32]
 800f188:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800f18a:	4293      	cmp	r3, r2
 800f18c:	d103      	bne.n	800f196 <f_write+0xc4>
 800f18e:	f7fe fc12 	bl	800d9b6 <sync_window>
 800f192:	2800      	cmp	r0, #0
 800f194:	d1ef      	bne.n	800f176 <f_write+0xa4>
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 800f196:	9e07      	ldr	r6, [sp, #28]
 800f198:	69e9      	ldr	r1, [r5, #28]
 800f19a:	0030      	movs	r0, r6
 800f19c:	f7fe fb66 	bl	800d86c <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 800f1a0:	2800      	cmp	r0, #0
 800f1a2:	d104      	bne.n	800f1ae <f_write+0xdc>
 800f1a4:	2402      	movs	r4, #2
 800f1a6:	0030      	movs	r0, r6
 800f1a8:	756c      	strb	r4, [r5, #21]
 800f1aa:	0021      	movs	r1, r4
 800f1ac:	e7d9      	b.n	800f162 <f_write+0x90>
			sect += csect;
 800f1ae:	9b03      	ldr	r3, [sp, #12]
 800f1b0:	181b      	adds	r3, r3, r0
 800f1b2:	9304      	str	r3, [sp, #16]
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 800f1b4:	0a7b      	lsrs	r3, r7, #9
 800f1b6:	9302      	str	r3, [sp, #8]
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 800f1b8:	d036      	beq.n	800f228 <f_write+0x156>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800f1ba:	9a03      	ldr	r2, [sp, #12]
 800f1bc:	0a79      	lsrs	r1, r7, #9
 800f1be:	8973      	ldrh	r3, [r6, #10]
 800f1c0:	1852      	adds	r2, r2, r1
 800f1c2:	429a      	cmp	r2, r3
 800f1c4:	d902      	bls.n	800f1cc <f_write+0xfa>
					cc = fs->csize - csect;
 800f1c6:	9a03      	ldr	r2, [sp, #12]
 800f1c8:	1a9b      	subs	r3, r3, r2
 800f1ca:	9302      	str	r3, [sp, #8]
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800f1cc:	7870      	ldrb	r0, [r6, #1]
 800f1ce:	9b02      	ldr	r3, [sp, #8]
 800f1d0:	9a04      	ldr	r2, [sp, #16]
 800f1d2:	9901      	ldr	r1, [sp, #4]
 800f1d4:	f7fe faea 	bl	800d7ac <disk_write>
 800f1d8:	1e06      	subs	r6, r0, #0
 800f1da:	d1cc      	bne.n	800f176 <f_write+0xa4>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
 800f1dc:	9807      	ldr	r0, [sp, #28]
 800f1de:	9a04      	ldr	r2, [sp, #16]
 800f1e0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800f1e2:	1a99      	subs	r1, r3, r2
 800f1e4:	9b02      	ldr	r3, [sp, #8]
 800f1e6:	4299      	cmp	r1, r3
 800f1e8:	d209      	bcs.n	800f1fe <f_write+0x12c>
 800f1ea:	2280      	movs	r2, #128	; 0x80
					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
 800f1ec:	9b01      	ldr	r3, [sp, #4]
 800f1ee:	0249      	lsls	r1, r1, #9
 800f1f0:	1859      	adds	r1, r3, r1
 800f1f2:	303c      	adds	r0, #60	; 0x3c
 800f1f4:	0092      	lsls	r2, r2, #2
 800f1f6:	f7fe fb7e 	bl	800d8f6 <mem_cpy.part.0>
					fs->wflag = 0;
 800f1fa:	9b07      	ldr	r3, [sp, #28]
 800f1fc:	70de      	strb	r6, [r3, #3]
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 800f1fe:	9b02      	ldr	r3, [sp, #8]
 800f200:	025e      	lsls	r6, r3, #9
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
 800f202:	9b05      	ldr	r3, [sp, #20]
 800f204:	9a05      	ldr	r2, [sp, #20]
 800f206:	681b      	ldr	r3, [r3, #0]
 800f208:	1bbf      	subs	r7, r7, r6
 800f20a:	9302      	str	r3, [sp, #8]
 800f20c:	199b      	adds	r3, r3, r6
 800f20e:	6013      	str	r3, [r2, #0]
 800f210:	9b01      	ldr	r3, [sp, #4]
 800f212:	199b      	adds	r3, r3, r6
 800f214:	9301      	str	r3, [sp, #4]
 800f216:	69ab      	ldr	r3, [r5, #24]
 800f218:	18f6      	adds	r6, r6, r3
 800f21a:	68eb      	ldr	r3, [r5, #12]
 800f21c:	61ae      	str	r6, [r5, #24]
 800f21e:	42b3      	cmp	r3, r6
 800f220:	d200      	bcs.n	800f224 <f_write+0x152>
 800f222:	0033      	movs	r3, r6
 800f224:	60eb      	str	r3, [r5, #12]
 800f226:	e777      	b.n	800f118 <f_write+0x46>
			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
 800f228:	69ab      	ldr	r3, [r5, #24]
 800f22a:	68ea      	ldr	r2, [r5, #12]
 800f22c:	4293      	cmp	r3, r2
 800f22e:	d307      	bcc.n	800f240 <f_write+0x16e>
				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
 800f230:	0030      	movs	r0, r6
 800f232:	f7fe fbc0 	bl	800d9b6 <sync_window>
 800f236:	2800      	cmp	r0, #0
 800f238:	d19d      	bne.n	800f176 <f_write+0xa4>
				fs->winsect = sect;
 800f23a:	9b07      	ldr	r3, [sp, #28]
 800f23c:	9a04      	ldr	r2, [sp, #16]
 800f23e:	639a      	str	r2, [r3, #56]	; 0x38
			fp->sect = sect;
 800f240:	9b04      	ldr	r3, [sp, #16]
 800f242:	622b      	str	r3, [r5, #32]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 800f244:	2280      	movs	r2, #128	; 0x80
 800f246:	69ab      	ldr	r3, [r5, #24]
 800f248:	0092      	lsls	r2, r2, #2
 800f24a:	05db      	lsls	r3, r3, #23
 800f24c:	0ddb      	lsrs	r3, r3, #23
 800f24e:	1ad3      	subs	r3, r2, r3
 800f250:	003e      	movs	r6, r7
 800f252:	429f      	cmp	r7, r3
 800f254:	d900      	bls.n	800f258 <f_write+0x186>
 800f256:	001e      	movs	r6, r3
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 800f258:	6a29      	ldr	r1, [r5, #32]
 800f25a:	9807      	ldr	r0, [sp, #28]
 800f25c:	f7fe fbcf 	bl	800d9fe <move_window>
 800f260:	2800      	cmp	r0, #0
 800f262:	d188      	bne.n	800f176 <f_write+0xa4>
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 800f264:	69ab      	ldr	r3, [r5, #24]
 800f266:	9807      	ldr	r0, [sp, #28]
 800f268:	05db      	lsls	r3, r3, #23
 800f26a:	0ddb      	lsrs	r3, r3, #23
 800f26c:	303c      	adds	r0, #60	; 0x3c
 800f26e:	18c0      	adds	r0, r0, r3
 800f270:	0032      	movs	r2, r6
 800f272:	9901      	ldr	r1, [sp, #4]
 800f274:	f7fe fb3f 	bl	800d8f6 <mem_cpy.part.0>
		fs->wflag = 1;
 800f278:	2201      	movs	r2, #1
 800f27a:	9b07      	ldr	r3, [sp, #28]
 800f27c:	70da      	strb	r2, [r3, #3]
 800f27e:	e7c0      	b.n	800f202 <f_write+0x130>

0800f280 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 800f280:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	FATFS *fs;
	DWORD tm;
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 800f282:	a901      	add	r1, sp, #4
{
 800f284:	0006      	movs	r6, r0
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 800f286:	f7fe ff8b 	bl	800e1a0 <validate>
 800f28a:	1e05      	subs	r5, r0, #0
	if (res == FR_OK) {
 800f28c:	d12d      	bne.n	800f2ea <f_sync+0x6a>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 800f28e:	2740      	movs	r7, #64	; 0x40
 800f290:	7d33      	ldrb	r3, [r6, #20]
 800f292:	423b      	tst	r3, r7
 800f294:	d029      	beq.n	800f2ea <f_sync+0x6a>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 800f296:	6a71      	ldr	r1, [r6, #36]	; 0x24
 800f298:	9801      	ldr	r0, [sp, #4]
 800f29a:	f7fe fbb0 	bl	800d9fe <move_window>
 800f29e:	1e05      	subs	r5, r0, #0
				if (res == FR_OK) {
 800f2a0:	d123      	bne.n	800f2ea <f_sync+0x6a>
					dir = fp->dir_ptr;
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
 800f2a2:	2320      	movs	r3, #32
					dir = fp->dir_ptr;
 800f2a4:	6ab4      	ldr	r4, [r6, #40]	; 0x28
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
 800f2a6:	7ae2      	ldrb	r2, [r4, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 800f2a8:	0021      	movs	r1, r4
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
 800f2aa:	4313      	orrs	r3, r2
 800f2ac:	72e3      	strb	r3, [r4, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 800f2ae:	68b2      	ldr	r2, [r6, #8]
 800f2b0:	6830      	ldr	r0, [r6, #0]
 800f2b2:	f7fe fb74 	bl	800d99e <st_clust.isra.6>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 800f2b6:	68f3      	ldr	r3, [r6, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 800f2b8:	75a5      	strb	r5, [r4, #22]
 800f2ba:	0a1a      	lsrs	r2, r3, #8
 800f2bc:	7723      	strb	r3, [r4, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 800f2be:	7762      	strb	r2, [r4, #29]
 800f2c0:	0c1a      	lsrs	r2, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800f2c2:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val;
 800f2c4:	77e3      	strb	r3, [r4, #31]
	*ptr++ = (BYTE)val; val >>= 8;
 800f2c6:	23a1      	movs	r3, #161	; 0xa1
 800f2c8:	77a2      	strb	r2, [r4, #30]
 800f2ca:	7623      	strb	r3, [r4, #24]
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
					st_word(dir + DIR_LstAccDate, 0);
					fs->wflag = 1;
 800f2cc:	9a01      	ldr	r2, [sp, #4]
	*ptr++ = (BYTE)val;
 800f2ce:	3b57      	subs	r3, #87	; 0x57
 800f2d0:	7663      	strb	r3, [r4, #25]
					fs->wflag = 1;
 800f2d2:	3b49      	subs	r3, #73	; 0x49
	*ptr++ = (BYTE)val; val >>= 8;
 800f2d4:	75e5      	strb	r5, [r4, #23]
	*ptr++ = (BYTE)val; val >>= 8;
 800f2d6:	74a5      	strb	r5, [r4, #18]
	*ptr++ = (BYTE)val;
 800f2d8:	74e5      	strb	r5, [r4, #19]
					fs->wflag = 1;
 800f2da:	70d3      	strb	r3, [r2, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 800f2dc:	9801      	ldr	r0, [sp, #4]
 800f2de:	f7ff fb77 	bl	800e9d0 <sync_fs>
 800f2e2:	0005      	movs	r5, r0
					fp->flag &= (BYTE)~FA_MODIFIED;
 800f2e4:	7d33      	ldrb	r3, [r6, #20]
 800f2e6:	43bb      	bics	r3, r7
 800f2e8:	7533      	strb	r3, [r6, #20]
				}
			}
		}
	}

	LEAVE_FF(fs, res);
 800f2ea:	0029      	movs	r1, r5
 800f2ec:	9801      	ldr	r0, [sp, #4]
 800f2ee:	f7fe ff4a 	bl	800e186 <unlock_fs>
}
 800f2f2:	0028      	movs	r0, r5
 800f2f4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800f2f6 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 800f2f6:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800f2f8:	0005      	movs	r5, r0
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 800f2fa:	f7ff ffc1 	bl	800f280 <f_sync>
 800f2fe:	1e04      	subs	r4, r0, #0
	if (res == FR_OK)
 800f300:	d10f      	bne.n	800f322 <f_close+0x2c>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 800f302:	a901      	add	r1, sp, #4
 800f304:	0028      	movs	r0, r5
 800f306:	f7fe ff4b 	bl	800e1a0 <validate>
 800f30a:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {
 800f30c:	d109      	bne.n	800f322 <f_close+0x2c>
#if FF_FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
 800f30e:	6928      	ldr	r0, [r5, #16]
 800f310:	f7fe fb1c 	bl	800d94c <dec_lock>
 800f314:	1e04      	subs	r4, r0, #0
			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
 800f316:	d100      	bne.n	800f31a <f_close+0x24>
 800f318:	6028      	str	r0, [r5, #0]
#else
			fp->obj.fs = 0;	/* Invalidate file object */
#endif
#if FF_FS_REENTRANT
			unlock_fs(fs, FR_OK);		/* Unlock volume */
 800f31a:	2100      	movs	r1, #0
 800f31c:	9801      	ldr	r0, [sp, #4]
 800f31e:	f7fe ff32 	bl	800e186 <unlock_fs>
#endif
		}
	}
	return res;
}
 800f322:	0020      	movs	r0, r4
 800f324:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0800f326 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 800f326:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f328:	b089      	sub	sp, #36	; 0x24
 800f32a:	000d      	movs	r5, r1
	FSIZE_t ifptr;
#if FF_USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 800f32c:	a907      	add	r1, sp, #28
{
 800f32e:	0004      	movs	r4, r0
	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 800f330:	f7fe ff36 	bl	800e1a0 <validate>
 800f334:	1e07      	subs	r7, r0, #0
	if (res == FR_OK) res = (FRESULT)fp->err;
 800f336:	d102      	bne.n	800f33e <f_lseek+0x18>
 800f338:	7d67      	ldrb	r7, [r4, #21]
#if FF_FS_EXFAT && !FF_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
 800f33a:	2f00      	cmp	r7, #0
 800f33c:	d002      	beq.n	800f344 <f_lseek+0x1e>
#endif
			fp->sect = nsect;
		}
	}

	LEAVE_FF(fs, res);
 800f33e:	0039      	movs	r1, r7
 800f340:	9807      	ldr	r0, [sp, #28]
 800f342:	e064      	b.n	800f40e <f_lseek+0xe8>
	if (fp->cltbl) {	/* Fast seek */
 800f344:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800f346:	2b00      	cmp	r3, #0
 800f348:	d100      	bne.n	800f34c <f_lseek+0x26>
 800f34a:	e072      	b.n	800f432 <f_lseek+0x10c>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 800f34c:	1c6a      	adds	r2, r5, #1
 800f34e:	d145      	bne.n	800f3dc <f_lseek+0xb6>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 800f350:	1d1e      	adds	r6, r3, #4
 800f352:	681b      	ldr	r3, [r3, #0]
 800f354:	3503      	adds	r5, #3
 800f356:	9303      	str	r3, [sp, #12]
			cl = fp->obj.sclust;		/* Origin of the chain */
 800f358:	68a3      	ldr	r3, [r4, #8]
 800f35a:	9301      	str	r3, [sp, #4]
			if (cl != 0) {
 800f35c:	2b00      	cmp	r3, #0
 800f35e:	d102      	bne.n	800f366 <f_lseek+0x40>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 800f360:	2502      	movs	r5, #2
 800f362:	e032      	b.n	800f3ca <f_lseek+0xa4>
 800f364:	9001      	str	r0, [sp, #4]
 800f366:	9b01      	ldr	r3, [sp, #4]
 800f368:	9a01      	ldr	r2, [sp, #4]
 800f36a:	9302      	str	r3, [sp, #8]
 800f36c:	2301      	movs	r3, #1
 800f36e:	1a9b      	subs	r3, r3, r2
 800f370:	9305      	str	r3, [sp, #20]
 800f372:	9a02      	ldr	r2, [sp, #8]
 800f374:	9b05      	ldr	r3, [sp, #20]
 800f376:	4694      	mov	ip, r2
						cl = get_fat(&fp->obj, cl);
 800f378:	0011      	movs	r1, r2
 800f37a:	4463      	add	r3, ip
 800f37c:	6820      	ldr	r0, [r4, #0]
 800f37e:	9304      	str	r3, [sp, #16]
 800f380:	f7fe fda6 	bl	800ded0 <get_fat.isra.12>
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 800f384:	2801      	cmp	r0, #1
 800f386:	d802      	bhi.n	800f38e <f_lseek+0x68>
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 800f388:	2702      	movs	r7, #2
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800f38a:	7567      	strb	r7, [r4, #21]
 800f38c:	e7d7      	b.n	800f33e <f_lseek+0x18>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800f38e:	1c43      	adds	r3, r0, #1
 800f390:	d109      	bne.n	800f3a6 <f_lseek+0x80>
 800f392:	2301      	movs	r3, #1
 800f394:	2101      	movs	r1, #1
 800f396:	7563      	strb	r3, [r4, #21]
 800f398:	9807      	ldr	r0, [sp, #28]
 800f39a:	f7fe fef4 	bl	800e186 <unlock_fs>
 800f39e:	2701      	movs	r7, #1
}
 800f3a0:	0038      	movs	r0, r7
 800f3a2:	b009      	add	sp, #36	; 0x24
 800f3a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
					} while (cl == pcl + 1);
 800f3a6:	9b02      	ldr	r3, [sp, #8]
 800f3a8:	9002      	str	r0, [sp, #8]
 800f3aa:	3301      	adds	r3, #1
 800f3ac:	4283      	cmp	r3, r0
 800f3ae:	d0e0      	beq.n	800f372 <f_lseek+0x4c>
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 800f3b0:	9b03      	ldr	r3, [sp, #12]
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 800f3b2:	3502      	adds	r5, #2
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 800f3b4:	42ab      	cmp	r3, r5
 800f3b6:	d304      	bcc.n	800f3c2 <f_lseek+0x9c>
						*tbl++ = ncl; *tbl++ = tcl;
 800f3b8:	9b04      	ldr	r3, [sp, #16]
 800f3ba:	6033      	str	r3, [r6, #0]
 800f3bc:	9b01      	ldr	r3, [sp, #4]
 800f3be:	6073      	str	r3, [r6, #4]
 800f3c0:	3608      	adds	r6, #8
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 800f3c2:	9b07      	ldr	r3, [sp, #28]
 800f3c4:	6a1b      	ldr	r3, [r3, #32]
 800f3c6:	4283      	cmp	r3, r0
 800f3c8:	d8cc      	bhi.n	800f364 <f_lseek+0x3e>
			*fp->cltbl = ulen;	/* Number of items used */
 800f3ca:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800f3cc:	601d      	str	r5, [r3, #0]
			if (ulen <= tlen) {
 800f3ce:	9b03      	ldr	r3, [sp, #12]
 800f3d0:	429d      	cmp	r5, r3
 800f3d2:	d900      	bls.n	800f3d6 <f_lseek+0xb0>
 800f3d4:	e0ad      	b.n	800f532 <f_lseek+0x20c>
				*tbl = 0;		/* Terminate table */
 800f3d6:	2300      	movs	r3, #0
 800f3d8:	6033      	str	r3, [r6, #0]
 800f3da:	e7b0      	b.n	800f33e <f_lseek+0x18>
 800f3dc:	68e6      	ldr	r6, [r4, #12]
 800f3de:	42ae      	cmp	r6, r5
 800f3e0:	d900      	bls.n	800f3e4 <f_lseek+0xbe>
 800f3e2:	002e      	movs	r6, r5
			fp->fptr = ofs;				/* Set file pointer */
 800f3e4:	61a6      	str	r6, [r4, #24]
			if (ofs > 0) {
 800f3e6:	2e00      	cmp	r6, #0
 800f3e8:	d0a9      	beq.n	800f33e <f_lseek+0x18>
 800f3ea:	9b07      	ldr	r3, [sp, #28]
				fp->clust = clmt_clust(fp, ofs - 1);
 800f3ec:	1e75      	subs	r5, r6, #1
 800f3ee:	0029      	movs	r1, r5
 800f3f0:	0020      	movs	r0, r4
 800f3f2:	9301      	str	r3, [sp, #4]
 800f3f4:	f7fe fa46 	bl	800d884 <clmt_clust>
 800f3f8:	0001      	movs	r1, r0
 800f3fa:	61e0      	str	r0, [r4, #28]
				dsc = clst2sect(fs, fp->clust);
 800f3fc:	9801      	ldr	r0, [sp, #4]
 800f3fe:	f7fe fa35 	bl	800d86c <clst2sect>
				if (dsc == 0) ABORT(fs, FR_INT_ERR);
 800f402:	2800      	cmp	r0, #0
 800f404:	d106      	bne.n	800f414 <f_lseek+0xee>
 800f406:	2702      	movs	r7, #2
 800f408:	0039      	movs	r1, r7
 800f40a:	9801      	ldr	r0, [sp, #4]
 800f40c:	7567      	strb	r7, [r4, #21]
	LEAVE_FF(fs, res);
 800f40e:	f7fe feba 	bl	800e186 <unlock_fs>
 800f412:	e7c5      	b.n	800f3a0 <f_lseek+0x7a>
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 800f414:	05f6      	lsls	r6, r6, #23
 800f416:	d100      	bne.n	800f41a <f_lseek+0xf4>
 800f418:	e791      	b.n	800f33e <f_lseek+0x18>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 800f41a:	9b01      	ldr	r3, [sp, #4]
 800f41c:	0a6d      	lsrs	r5, r5, #9
 800f41e:	895b      	ldrh	r3, [r3, #10]
 800f420:	3b01      	subs	r3, #1
 800f422:	401d      	ands	r5, r3
 800f424:	1828      	adds	r0, r5, r0
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 800f426:	6a23      	ldr	r3, [r4, #32]
 800f428:	4283      	cmp	r3, r0
 800f42a:	d100      	bne.n	800f42e <f_lseek+0x108>
 800f42c:	e787      	b.n	800f33e <f_lseek+0x18>
			fp->sect = nsect;
 800f42e:	6220      	str	r0, [r4, #32]
 800f430:	e785      	b.n	800f33e <f_lseek+0x18>
		if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 800f432:	68e3      	ldr	r3, [r4, #12]
 800f434:	42ab      	cmp	r3, r5
 800f436:	d203      	bcs.n	800f440 <f_lseek+0x11a>
 800f438:	7d22      	ldrb	r2, [r4, #20]
 800f43a:	0792      	lsls	r2, r2, #30
 800f43c:	d400      	bmi.n	800f440 <f_lseek+0x11a>
 800f43e:	001d      	movs	r5, r3
		fp->fptr = nsect = 0;
 800f440:	2200      	movs	r2, #0
		ifptr = fp->fptr;
 800f442:	69a3      	ldr	r3, [r4, #24]
		fp->fptr = nsect = 0;
 800f444:	61a2      	str	r2, [r4, #24]
		if (ofs > 0) {
 800f446:	4295      	cmp	r5, r2
 800f448:	d10f      	bne.n	800f46a <f_lseek+0x144>
		fp->fptr = nsect = 0;
 800f44a:	0028      	movs	r0, r5
 800f44c:	e009      	b.n	800f462 <f_lseek+0x13c>
 800f44e:	2000      	movs	r0, #0
		if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is extended */
 800f450:	69a5      	ldr	r5, [r4, #24]
 800f452:	68e3      	ldr	r3, [r4, #12]
 800f454:	429d      	cmp	r5, r3
 800f456:	d904      	bls.n	800f462 <f_lseek+0x13c>
			fp->flag |= FA_MODIFIED;
 800f458:	2340      	movs	r3, #64	; 0x40
 800f45a:	7d22      	ldrb	r2, [r4, #20]
			fp->obj.objsize = fp->fptr;
 800f45c:	60e5      	str	r5, [r4, #12]
			fp->flag |= FA_MODIFIED;
 800f45e:	4313      	orrs	r3, r2
 800f460:	7523      	strb	r3, [r4, #20]
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 800f462:	05ed      	lsls	r5, r5, #23
 800f464:	d100      	bne.n	800f468 <f_lseek+0x142>
 800f466:	e76a      	b.n	800f33e <f_lseek+0x18>
 800f468:	e7dd      	b.n	800f426 <f_lseek+0x100>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 800f46a:	9a07      	ldr	r2, [sp, #28]
 800f46c:	8956      	ldrh	r6, [r2, #10]
 800f46e:	0276      	lsls	r6, r6, #9
			if (ifptr > 0 &&
 800f470:	2b00      	cmp	r3, #0
 800f472:	d028      	beq.n	800f4c6 <f_lseek+0x1a0>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 800f474:	3b01      	subs	r3, #1
 800f476:	0031      	movs	r1, r6
 800f478:	1e68      	subs	r0, r5, #1
 800f47a:	9301      	str	r3, [sp, #4]
 800f47c:	f7f0 fe7c 	bl	8000178 <__udivsi3>
 800f480:	0031      	movs	r1, r6
 800f482:	9002      	str	r0, [sp, #8]
 800f484:	9801      	ldr	r0, [sp, #4]
 800f486:	f7f0 fe77 	bl	8000178 <__udivsi3>
			if (ifptr > 0 &&
 800f48a:	9b02      	ldr	r3, [sp, #8]
 800f48c:	4283      	cmp	r3, r0
 800f48e:	d31a      	bcc.n	800f4c6 <f_lseek+0x1a0>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 800f490:	9a01      	ldr	r2, [sp, #4]
 800f492:	4273      	negs	r3, r6
 800f494:	401a      	ands	r2, r3
				clst = fp->clust;
 800f496:	69e1      	ldr	r1, [r4, #28]
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 800f498:	61a2      	str	r2, [r4, #24]
				ofs -= fp->fptr;
 800f49a:	1aad      	subs	r5, r5, r2
			if (clst != 0) {
 800f49c:	2900      	cmp	r1, #0
 800f49e:	d0d6      	beq.n	800f44e <f_lseek+0x128>
 800f4a0:	69a3      	ldr	r3, [r4, #24]
				while (ofs > bcs) {						/* Cluster following loop */
 800f4a2:	42b5      	cmp	r5, r6
 800f4a4:	d820      	bhi.n	800f4e8 <f_lseek+0x1c2>
				fp->fptr += ofs;
 800f4a6:	69a3      	ldr	r3, [r4, #24]
 800f4a8:	195b      	adds	r3, r3, r5
 800f4aa:	61a3      	str	r3, [r4, #24]
				if (ofs % SS(fs)) {
 800f4ac:	05eb      	lsls	r3, r5, #23
 800f4ae:	d0ce      	beq.n	800f44e <f_lseek+0x128>
					nsect = clst2sect(fs, clst);	/* Current sector */
 800f4b0:	9e07      	ldr	r6, [sp, #28]
 800f4b2:	0030      	movs	r0, r6
 800f4b4:	f7fe f9da 	bl	800d86c <clst2sect>
					if (nsect == 0) ABORT(fs, FR_INT_ERR);
 800f4b8:	2800      	cmp	r0, #0
 800f4ba:	d137      	bne.n	800f52c <f_lseek+0x206>
 800f4bc:	2702      	movs	r7, #2
 800f4be:	0030      	movs	r0, r6
 800f4c0:	7567      	strb	r7, [r4, #21]
 800f4c2:	0039      	movs	r1, r7
 800f4c4:	e7a3      	b.n	800f40e <f_lseek+0xe8>
				clst = fp->obj.sclust;					/* start from the first cluster */
 800f4c6:	68a1      	ldr	r1, [r4, #8]
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 800f4c8:	2900      	cmp	r1, #0
 800f4ca:	d10b      	bne.n	800f4e4 <f_lseek+0x1be>
					clst = create_chain(&fp->obj, 0);
 800f4cc:	0020      	movs	r0, r4
 800f4ce:	f7fe fda9 	bl	800e024 <create_chain>
 800f4d2:	0001      	movs	r1, r0
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 800f4d4:	2801      	cmp	r0, #1
 800f4d6:	d100      	bne.n	800f4da <f_lseek+0x1b4>
 800f4d8:	e756      	b.n	800f388 <f_lseek+0x62>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800f4da:	1c43      	adds	r3, r0, #1
 800f4dc:	d101      	bne.n	800f4e2 <f_lseek+0x1bc>
 800f4de:	2701      	movs	r7, #1
 800f4e0:	e753      	b.n	800f38a <f_lseek+0x64>
					fp->obj.sclust = clst;
 800f4e2:	60a0      	str	r0, [r4, #8]
				fp->clust = clst;
 800f4e4:	61e1      	str	r1, [r4, #28]
 800f4e6:	e7d9      	b.n	800f49c <f_lseek+0x176>
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 800f4e8:	2202      	movs	r2, #2
					ofs -= bcs; fp->fptr += bcs;
 800f4ea:	199b      	adds	r3, r3, r6
 800f4ec:	61a3      	str	r3, [r4, #24]
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 800f4ee:	7d23      	ldrb	r3, [r4, #20]
					ofs -= bcs; fp->fptr += bcs;
 800f4f0:	1bad      	subs	r5, r5, r6
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 800f4f2:	4213      	tst	r3, r2
 800f4f4:	d006      	beq.n	800f504 <f_lseek+0x1de>
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 800f4f6:	0020      	movs	r0, r4
 800f4f8:	f7fe fd94 	bl	800e024 <create_chain>
 800f4fc:	1e01      	subs	r1, r0, #0
						if (clst == 0) {				/* Clip file size in case of disk full */
 800f4fe:	d105      	bne.n	800f50c <f_lseek+0x1e6>
							ofs = 0; break;
 800f500:	0005      	movs	r5, r0
 800f502:	e7d0      	b.n	800f4a6 <f_lseek+0x180>
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 800f504:	6820      	ldr	r0, [r4, #0]
 800f506:	f7fe fce3 	bl	800ded0 <get_fat.isra.12>
 800f50a:	0001      	movs	r1, r0
 800f50c:	9807      	ldr	r0, [sp, #28]
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800f50e:	1c4b      	adds	r3, r1, #1
 800f510:	d103      	bne.n	800f51a <f_lseek+0x1f4>
 800f512:	2701      	movs	r7, #1
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 800f514:	7567      	strb	r7, [r4, #21]
 800f516:	0039      	movs	r1, r7
 800f518:	e779      	b.n	800f40e <f_lseek+0xe8>
 800f51a:	2901      	cmp	r1, #1
 800f51c:	d902      	bls.n	800f524 <f_lseek+0x1fe>
 800f51e:	6a03      	ldr	r3, [r0, #32]
 800f520:	428b      	cmp	r3, r1
 800f522:	d801      	bhi.n	800f528 <f_lseek+0x202>
 800f524:	2702      	movs	r7, #2
 800f526:	e7f5      	b.n	800f514 <f_lseek+0x1ee>
					fp->clust = clst;
 800f528:	61e1      	str	r1, [r4, #28]
 800f52a:	e7b9      	b.n	800f4a0 <f_lseek+0x17a>
					nsect += (DWORD)(ofs / SS(fs));
 800f52c:	0a6d      	lsrs	r5, r5, #9
 800f52e:	1828      	adds	r0, r5, r0
 800f530:	e78e      	b.n	800f450 <f_lseek+0x12a>
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 800f532:	2711      	movs	r7, #17
 800f534:	e703      	b.n	800f33e <f_lseek+0x18>

0800f536 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 800f536:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f538:	b0a3      	sub	sp, #140	; 0x8c
 800f53a:	9003      	str	r0, [sp, #12]
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 800f53c:	2202      	movs	r2, #2
 800f53e:	a905      	add	r1, sp, #20
 800f540:	a803      	add	r0, sp, #12
 800f542:	f7fe fabd 	bl	800dac0 <find_volume>
 800f546:	1e04      	subs	r4, r0, #0
	if (res == FR_OK) {
 800f548:	d132      	bne.n	800f5b0 <f_unlink+0x7a>
		dj.obj.fs = fs;
		INIT_NAMBUF(fs);
 800f54a:	2080      	movs	r0, #128	; 0x80
		dj.obj.fs = fs;
 800f54c:	9b05      	ldr	r3, [sp, #20]
		INIT_NAMBUF(fs);
 800f54e:	0080      	lsls	r0, r0, #2
		dj.obj.fs = fs;
 800f550:	9306      	str	r3, [sp, #24]
		INIT_NAMBUF(fs);
 800f552:	f000 f865 	bl	800f620 <ff_memalloc>
		dj.obj.fs = fs;
 800f556:	ad06      	add	r5, sp, #24
		INIT_NAMBUF(fs);
 800f558:	9001      	str	r0, [sp, #4]
 800f55a:	2800      	cmp	r0, #0
 800f55c:	d107      	bne.n	800f56e <f_unlink+0x38>
 800f55e:	2111      	movs	r1, #17
 800f560:	9805      	ldr	r0, [sp, #20]
 800f562:	f7fe fe10 	bl	800e186 <unlock_fs>
 800f566:	3411      	adds	r4, #17
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 800f568:	0020      	movs	r0, r4
 800f56a:	b023      	add	sp, #140	; 0x8c
 800f56c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		INIT_NAMBUF(fs);
 800f56e:	9b05      	ldr	r3, [sp, #20]
 800f570:	9a01      	ldr	r2, [sp, #4]
		res = follow_path(&dj, path);		/* Follow the file path */
 800f572:	9903      	ldr	r1, [sp, #12]
		INIT_NAMBUF(fs);
 800f574:	60da      	str	r2, [r3, #12]
		res = follow_path(&dj, path);		/* Follow the file path */
 800f576:	0028      	movs	r0, r5
 800f578:	f7ff f88c 	bl	800e694 <follow_path>
 800f57c:	1e04      	subs	r4, r0, #0
		if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
 800f57e:	d114      	bne.n	800f5aa <f_unlink+0x74>
 800f580:	233f      	movs	r3, #63	; 0x3f
 800f582:	aa02      	add	r2, sp, #8
 800f584:	189b      	adds	r3, r3, r2
 800f586:	781e      	ldrb	r6, [r3, #0]
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 800f588:	3406      	adds	r4, #6
		if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
 800f58a:	06b3      	lsls	r3, r6, #26
 800f58c:	d40d      	bmi.n	800f5aa <f_unlink+0x74>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
 800f58e:	2102      	movs	r1, #2
 800f590:	0028      	movs	r0, r5
 800f592:	f7fe f9b9 	bl	800d908 <chk_lock>
 800f596:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {					/* The object is accessible */
 800f598:	d107      	bne.n	800f5aa <f_unlink+0x74>
			if (dj.fn[NSFLAG] & NS_NONAME) {
 800f59a:	b276      	sxtb	r6, r6
 800f59c:	2e00      	cmp	r6, #0
 800f59e:	db3d      	blt.n	800f61c <f_unlink+0xe6>
				if (dj.obj.attr & AM_RDO) {
 800f5a0:	79ab      	ldrb	r3, [r5, #6]
 800f5a2:	9302      	str	r3, [sp, #8]
 800f5a4:	07db      	lsls	r3, r3, #31
 800f5a6:	d508      	bpl.n	800f5ba <f_unlink+0x84>
					res = FR_DENIED;		/* Cannot remove R/O object */
 800f5a8:	2407      	movs	r4, #7
		FREE_NAMBUF();
 800f5aa:	9801      	ldr	r0, [sp, #4]
 800f5ac:	f000 f83c 	bl	800f628 <ff_memfree>
	LEAVE_FF(fs, res);
 800f5b0:	0021      	movs	r1, r4
 800f5b2:	9805      	ldr	r0, [sp, #20]
 800f5b4:	f7fe fde7 	bl	800e186 <unlock_fs>
 800f5b8:	e7d6      	b.n	800f568 <f_unlink+0x32>
					dclst = ld_clust(fs, dj.dir);
 800f5ba:	9f05      	ldr	r7, [sp, #20]
 800f5bc:	6a29      	ldr	r1, [r5, #32]
 800f5be:	7838      	ldrb	r0, [r7, #0]
 800f5c0:	f7fe f9de 	bl	800d980 <ld_clust.isra.5>
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 800f5c4:	9b02      	ldr	r3, [sp, #8]
					dclst = ld_clust(fs, dj.dir);
 800f5c6:	0006      	movs	r6, r0
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 800f5c8:	06db      	lsls	r3, r3, #27
 800f5ca:	d40b      	bmi.n	800f5e4 <f_unlink+0xae>
				res = dir_remove(&dj);			/* Remove the directory entry */
 800f5cc:	0028      	movs	r0, r5
 800f5ce:	f7fe ff87 	bl	800e4e0 <dir_remove>
 800f5d2:	1e04      	subs	r4, r0, #0
				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
 800f5d4:	d1e9      	bne.n	800f5aa <f_unlink+0x74>
 800f5d6:	2e00      	cmp	r6, #0
 800f5d8:	d118      	bne.n	800f60c <f_unlink+0xd6>
				if (res == FR_OK) res = sync_fs(fs);
 800f5da:	9805      	ldr	r0, [sp, #20]
 800f5dc:	f7ff f9f8 	bl	800e9d0 <sync_fs>
 800f5e0:	0004      	movs	r4, r0
 800f5e2:	e7e2      	b.n	800f5aa <f_unlink+0x74>
					if (dclst == fs->cdir) {		 	/* Is it the current directory? */
 800f5e4:	69fb      	ldr	r3, [r7, #28]
 800f5e6:	4283      	cmp	r3, r0
 800f5e8:	d0de      	beq.n	800f5a8 <f_unlink+0x72>
						sdj.obj.sclust = dclst;
 800f5ea:	9016      	str	r0, [sp, #88]	; 0x58
						res = dir_sdi(&sdj, 0);
 800f5ec:	0021      	movs	r1, r4
 800f5ee:	a814      	add	r0, sp, #80	; 0x50
						sdj.obj.fs = fs;				/* Open the sub-directory */
 800f5f0:	9714      	str	r7, [sp, #80]	; 0x50
						res = dir_sdi(&sdj, 0);
 800f5f2:	f7fe fccd 	bl	800df90 <dir_sdi>
 800f5f6:	1e04      	subs	r4, r0, #0
						if (res == FR_OK) {
 800f5f8:	d1d7      	bne.n	800f5aa <f_unlink+0x74>
							res = dir_read(&sdj, 0);			/* Read an item */
 800f5fa:	2100      	movs	r1, #0
 800f5fc:	a814      	add	r0, sp, #80	; 0x50
 800f5fe:	f7fe fed3 	bl	800e3a8 <dir_read>
 800f602:	1e04      	subs	r4, r0, #0
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 800f604:	d0d0      	beq.n	800f5a8 <f_unlink+0x72>
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 800f606:	2804      	cmp	r0, #4
 800f608:	d1cf      	bne.n	800f5aa <f_unlink+0x74>
 800f60a:	e7df      	b.n	800f5cc <f_unlink+0x96>
					res = remove_chain(&dj.obj, dclst, 0);
 800f60c:	0002      	movs	r2, r0
 800f60e:	0031      	movs	r1, r6
 800f610:	0028      	movs	r0, r5
 800f612:	f7fe fd7f 	bl	800e114 <remove_chain>
 800f616:	1e04      	subs	r4, r0, #0
				if (res == FR_OK) res = sync_fs(fs);
 800f618:	d1c7      	bne.n	800f5aa <f_unlink+0x74>
 800f61a:	e7de      	b.n	800f5da <f_unlink+0xa4>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 800f61c:	2406      	movs	r4, #6
 800f61e:	e7c4      	b.n	800f5aa <f_unlink+0x74>

0800f620 <ff_memalloc>:
/*------------------------------------------------------------------------*/

void* ff_memalloc (	/* Returns pointer to the allocated memory block (null on not enough core) */
	UINT msize		/* Number of bytes to allocate */
)
{
 800f620:	b510      	push	{r4, lr}
	return malloc(msize);	/* Allocate a new memory block with POSIX API */
 800f622:	f004 fdd9 	bl	80141d8 <malloc>
}
 800f626:	bd10      	pop	{r4, pc}

0800f628 <ff_memfree>:
/*------------------------------------------------------------------------*/

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
 800f628:	b510      	push	{r4, lr}
	free(mblock);	/* Free the memory block with POSIX API */
 800f62a:	f004 fddf 	bl	80141ec <free>
}
 800f62e:	bd10      	pop	{r4, pc}

0800f630 <ff_cre_syncobj>:

int ff_cre_syncobj (	/* 1:Function succeeded, 0:Could not create the sync object */
	BYTE vol,			/* Corresponding volume (logical drive number) */
	FF_SYNC_t *sobj		/* Pointer to return the created sync object */
)
{
 800f630:	b510      	push	{r4, lr}
	/* FreeRTOS */
	*sobj = xSemaphoreCreateMutex();
 800f632:	2001      	movs	r0, #1
{
 800f634:	000c      	movs	r4, r1
	*sobj = xSemaphoreCreateMutex();
 800f636:	f000 fbe5 	bl	800fe04 <xQueueCreateMutex>
 800f63a:	6020      	str	r0, [r4, #0]
	return (int)(*sobj != NULL);
 800f63c:	1e43      	subs	r3, r0, #1
 800f63e:	4198      	sbcs	r0, r3
}
 800f640:	bd10      	pop	{r4, pc}

0800f642 <ff_del_syncobj>:
*/

int ff_del_syncobj (	/* 1:Function succeeded, 0:Could not delete due to an error */
	FF_SYNC_t sobj		/* Sync object tied to the logical drive to be deleted */
)
{
 800f642:	b510      	push	{r4, lr}
	/* FreeRTOS */
  vSemaphoreDelete(sobj);
 800f644:	f000 fd7c 	bl	8010140 <vQueueDelete>
	return 1;
}
 800f648:	2001      	movs	r0, #1
 800f64a:	bd10      	pop	{r4, pc}

0800f64c <ff_req_grant>:
int ff_req_grant (	/* 1:Got a grant to access the volume, 0:Could not get a grant */
	FF_SYNC_t sobj	/* Sync object to wait */
)
{
	/* FreeRTOS */
	return (int)(xSemaphoreTake(sobj, FF_FS_TIMEOUT) == pdTRUE);
 800f64c:	2300      	movs	r3, #0
 800f64e:	22fa      	movs	r2, #250	; 0xfa
{
 800f650:	b510      	push	{r4, lr}
	return (int)(xSemaphoreTake(sobj, FF_FS_TIMEOUT) == pdTRUE);
 800f652:	0019      	movs	r1, r3
 800f654:	0092      	lsls	r2, r2, #2
 800f656:	f000 fc78 	bl	800ff4a <xQueueGenericReceive>
 800f65a:	3801      	subs	r0, #1
 800f65c:	4243      	negs	r3, r0
 800f65e:	4158      	adcs	r0, r3
}
 800f660:	bd10      	pop	{r4, pc}

0800f662 <ff_rel_grant>:
void ff_rel_grant (
	FF_SYNC_t sobj	/* Sync object to be signaled */
)
{
	/* FreeRTOS */
	xSemaphoreGive(sobj);
 800f662:	2300      	movs	r3, #0
{
 800f664:	b510      	push	{r4, lr}
	xSemaphoreGive(sobj);
 800f666:	001a      	movs	r2, r3
 800f668:	0019      	movs	r1, r3
 800f66a:	f000 fb3e 	bl	800fcea <xQueueGenericSend>
}
 800f66e:	bd10      	pop	{r4, pc}

0800f670 <ff_uni2oem>:
#if FF_CODE_PAGE != 0 && FF_CODE_PAGE < 900
WCHAR ff_uni2oem (	/* Returns OEM code character, zero on error */
	WCHAR	uni,	/* Unicode character to be converted */
	WORD	cp		/* Code page for the conversion */
)
{
 800f670:	b510      	push	{r4, lr}
	WCHAR c = 0;
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);


	if (uni < 0x80) {	/* ASCII char */
 800f672:	287f      	cmp	r0, #127	; 0x7f
 800f674:	d904      	bls.n	800f680 <ff_uni2oem+0x10>
		c = uni;

	} else {			/* Non-ASCII char */
		if (cp == FF_CODE_PAGE) {	/* Is it a valid code page? */
 800f676:	23b6      	movs	r3, #182	; 0xb6
 800f678:	33ff      	adds	r3, #255	; 0xff
 800f67a:	4299      	cmp	r1, r3
 800f67c:	d006      	beq.n	800f68c <ff_uni2oem+0x1c>
	WCHAR c = 0;
 800f67e:	2000      	movs	r0, #0
			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
			c = (c + 0x80) & 0xFF;
		}
	}
	return c;
}
 800f680:	bd10      	pop	{r4, pc}
 800f682:	3301      	adds	r3, #1
			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
 800f684:	2b80      	cmp	r3, #128	; 0x80
 800f686:	d103      	bne.n	800f690 <ff_uni2oem+0x20>
 800f688:	001a      	movs	r2, r3
 800f68a:	e006      	b.n	800f69a <ff_uni2oem+0x2a>
 800f68c:	2300      	movs	r3, #0
 800f68e:	4c04      	ldr	r4, [pc, #16]	; (800f6a0 <ff_uni2oem+0x30>)
 800f690:	0059      	lsls	r1, r3, #1
 800f692:	5a61      	ldrh	r1, [r4, r1]
 800f694:	b29a      	uxth	r2, r3
 800f696:	4281      	cmp	r1, r0
 800f698:	d1f3      	bne.n	800f682 <ff_uni2oem+0x12>
			c = (c + 0x80) & 0xFF;
 800f69a:	3280      	adds	r2, #128	; 0x80
 800f69c:	b2d0      	uxtb	r0, r2
 800f69e:	e7ef      	b.n	800f680 <ff_uni2oem+0x10>
 800f6a0:	0801c2ee 	.word	0x0801c2ee

0800f6a4 <ff_oem2uni>:
{
	WCHAR c = 0;
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);


	if (oem < 0x80) {	/* ASCII char */
 800f6a4:	287f      	cmp	r0, #127	; 0x7f
 800f6a6:	d90a      	bls.n	800f6be <ff_oem2uni+0x1a>
		c = oem;

	} else {			/* Extended char */
		if (cp == FF_CODE_PAGE) {	/* Is it a valid code page? */
 800f6a8:	23b6      	movs	r3, #182	; 0xb6
 800f6aa:	33ff      	adds	r3, #255	; 0xff
 800f6ac:	4299      	cmp	r1, r3
 800f6ae:	d107      	bne.n	800f6c0 <ff_oem2uni+0x1c>
			if (oem < 0x100) c = p[oem - 0x80];
 800f6b0:	28ff      	cmp	r0, #255	; 0xff
 800f6b2:	d805      	bhi.n	800f6c0 <ff_oem2uni+0x1c>
 800f6b4:	4b03      	ldr	r3, [pc, #12]	; (800f6c4 <ff_oem2uni+0x20>)
 800f6b6:	18c0      	adds	r0, r0, r3
 800f6b8:	4b03      	ldr	r3, [pc, #12]	; (800f6c8 <ff_oem2uni+0x24>)
 800f6ba:	0040      	lsls	r0, r0, #1
 800f6bc:	5a18      	ldrh	r0, [r3, r0]
		}
	}
	return c;
}
 800f6be:	4770      	bx	lr
	WCHAR c = 0;
 800f6c0:	2000      	movs	r0, #0
 800f6c2:	e7fc      	b.n	800f6be <ff_oem2uni+0x1a>
 800f6c4:	7fffff80 	.word	0x7fffff80
 800f6c8:	0801c2ee 	.word	0x0801c2ee

0800f6cc <ff_wtoupper>:
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = uni < 0x1000 ? cvt1 : cvt2;
 800f6cc:	4a1e      	ldr	r2, [pc, #120]	; (800f748 <ff_wtoupper+0x7c>)
{
 800f6ce:	b570      	push	{r4, r5, r6, lr}
 800f6d0:	0003      	movs	r3, r0
	p = uni < 0x1000 ? cvt1 : cvt2;
 800f6d2:	491e      	ldr	r1, [pc, #120]	; (800f74c <ff_wtoupper+0x80>)
 800f6d4:	4290      	cmp	r0, r2
 800f6d6:	d900      	bls.n	800f6da <ff_wtoupper+0xe>
 800f6d8:	491d      	ldr	r1, [pc, #116]	; (800f750 <ff_wtoupper+0x84>)
	for (;;) {
		bc = *p++;								/* Get block base */
		if (!bc || uni < bc) break;
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 800f6da:	25ff      	movs	r5, #255	; 0xff
		bc = *p++;								/* Get block base */
 800f6dc:	880a      	ldrh	r2, [r1, #0]
		if (!bc || uni < bc) break;
 800f6de:	2a00      	cmp	r2, #0
 800f6e0:	d015      	beq.n	800f70e <ff_wtoupper+0x42>
 800f6e2:	4293      	cmp	r3, r2
 800f6e4:	d313      	bcc.n	800f70e <ff_wtoupper+0x42>
 800f6e6:	3104      	adds	r1, #4
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 800f6e8:	1e88      	subs	r0, r1, #2
 800f6ea:	8804      	ldrh	r4, [r0, #0]
 800f6ec:	0a20      	lsrs	r0, r4, #8
 800f6ee:	402c      	ands	r4, r5
		if (uni < bc + nc) {	/* In the block? */
 800f6f0:	18a6      	adds	r6, r4, r2
 800f6f2:	42b3      	cmp	r3, r6
 800f6f4:	da22      	bge.n	800f73c <ff_wtoupper+0x70>
			switch (cmd) {
 800f6f6:	2808      	cmp	r0, #8
 800f6f8:	d809      	bhi.n	800f70e <ff_wtoupper+0x42>
 800f6fa:	f7f0 fd1f 	bl	800013c <__gnu_thumb1_case_uqi>
 800f6fe:	0a05      	.short	0x0a05
 800f700:	16141210 	.word	0x16141210
 800f704:	1a18      	.short	0x1a18
 800f706:	1c          	.byte	0x1c
 800f707:	00          	.byte	0x00
			case 0:	uni = p[uni - bc]; break;		/* Table conversion */
 800f708:	1a9b      	subs	r3, r3, r2
 800f70a:	005b      	lsls	r3, r3, #1
 800f70c:	5a5b      	ldrh	r3, [r3, r1]
		}
		if (!cmd) p += nc;
	}

	return uni;
}
 800f70e:	0018      	movs	r0, r3
 800f710:	bd70      	pop	{r4, r5, r6, pc}
			case 1:	uni -= (uni - bc) & 1; break;	/* Case pairs */
 800f712:	2101      	movs	r1, #1
 800f714:	1a9a      	subs	r2, r3, r2
 800f716:	400a      	ands	r2, r1
 800f718:	1a9b      	subs	r3, r3, r2
			case 8:	uni -= 0x1C60; break;			/* Shift -0x1C60 */
 800f71a:	b29b      	uxth	r3, r3
 800f71c:	e7f7      	b.n	800f70e <ff_wtoupper+0x42>
			case 2: uni -= 16; break;				/* Shift -16 */
 800f71e:	3b10      	subs	r3, #16
 800f720:	e7fb      	b.n	800f71a <ff_wtoupper+0x4e>
			case 3:	uni -= 32; break;				/* Shift -32 */
 800f722:	3b20      	subs	r3, #32
 800f724:	e7f9      	b.n	800f71a <ff_wtoupper+0x4e>
			case 4:	uni -= 48; break;				/* Shift -48 */
 800f726:	3b30      	subs	r3, #48	; 0x30
 800f728:	e7f7      	b.n	800f71a <ff_wtoupper+0x4e>
			case 5:	uni -= 26; break;				/* Shift -26 */
 800f72a:	3b1a      	subs	r3, #26
 800f72c:	e7f5      	b.n	800f71a <ff_wtoupper+0x4e>
			case 6:	uni += 8; break;				/* Shift +8 */
 800f72e:	3308      	adds	r3, #8
 800f730:	e7f3      	b.n	800f71a <ff_wtoupper+0x4e>
			case 7: uni -= 80; break;				/* Shift -80 */
 800f732:	3b50      	subs	r3, #80	; 0x50
 800f734:	e7f1      	b.n	800f71a <ff_wtoupper+0x4e>
			case 8:	uni -= 0x1C60; break;			/* Shift -0x1C60 */
 800f736:	4a07      	ldr	r2, [pc, #28]	; (800f754 <ff_wtoupper+0x88>)
 800f738:	189b      	adds	r3, r3, r2
 800f73a:	e7ee      	b.n	800f71a <ff_wtoupper+0x4e>
		if (!cmd) p += nc;
 800f73c:	2800      	cmp	r0, #0
 800f73e:	d1cd      	bne.n	800f6dc <ff_wtoupper+0x10>
 800f740:	0064      	lsls	r4, r4, #1
 800f742:	1909      	adds	r1, r1, r4
 800f744:	e7ca      	b.n	800f6dc <ff_wtoupper+0x10>
 800f746:	46c0      	nop			; (mov r8, r8)
 800f748:	00000fff 	.word	0x00000fff
 800f74c:	0801c040 	.word	0x0801c040
 800f750:	0801c232 	.word	0x0801c232
 800f754:	ffffe3a0 	.word	0xffffe3a0

0800f758 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 800f758:	b510      	push	{r4, lr}
  vTaskStartScheduler();
 800f75a:	f000 feed 	bl	8010538 <vTaskStartScheduler>
  
  return osOK;
}
 800f75e:	2000      	movs	r0, #0
 800f760:	bd10      	pop	{r4, pc}

0800f762 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 800f762:	b510      	push	{r4, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800f764:	2800      	cmp	r0, #0
 800f766:	d100      	bne.n	800f76a <osDelay+0x8>
 800f768:	3001      	adds	r0, #1
 800f76a:	f001 f809 	bl	8010780 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800f76e:	2000      	movs	r0, #0
 800f770:	bd10      	pop	{r4, pc}
	...

0800f774 <osMutexRelease>:
* @param mutex_id      mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexRelease (osMutexId mutex_id)
{
 800f774:	b513      	push	{r0, r1, r4, lr}
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 800f776:	2400      	movs	r4, #0
 800f778:	9401      	str	r4, [sp, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f77a:	f3ef 8105 	mrs	r1, IPSR
  
  if (inHandlerMode()) {
 800f77e:	42a1      	cmp	r1, r4
 800f780:	d00e      	beq.n	800f7a0 <osMutexRelease+0x2c>
    if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
 800f782:	a901      	add	r1, sp, #4
 800f784:	f000 fba7 	bl	800fed6 <xQueueGiveFromISR>
 800f788:	2801      	cmp	r0, #1
 800f78a:	d10f      	bne.n	800f7ac <osMutexRelease+0x38>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 800f78c:	9b01      	ldr	r3, [sp, #4]
 800f78e:	42a3      	cmp	r3, r4
 800f790:	d101      	bne.n	800f796 <osMutexRelease+0x22>
  osStatus result = osOK;
 800f792:	2000      	movs	r0, #0
  else if (xSemaphoreGive(mutex_id) != pdTRUE) 
  {
    result = osErrorOS;
  }
  return result;
}
 800f794:	bd16      	pop	{r1, r2, r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 800f796:	2280      	movs	r2, #128	; 0x80
 800f798:	4b05      	ldr	r3, [pc, #20]	; (800f7b0 <osMutexRelease+0x3c>)
 800f79a:	0552      	lsls	r2, r2, #21
 800f79c:	601a      	str	r2, [r3, #0]
 800f79e:	e7f8      	b.n	800f792 <osMutexRelease+0x1e>
  else if (xSemaphoreGive(mutex_id) != pdTRUE) 
 800f7a0:	000b      	movs	r3, r1
 800f7a2:	000a      	movs	r2, r1
 800f7a4:	f000 faa1 	bl	800fcea <xQueueGenericSend>
 800f7a8:	2801      	cmp	r0, #1
 800f7aa:	d0f2      	beq.n	800f792 <osMutexRelease+0x1e>
    result = osErrorOS;
 800f7ac:	20ff      	movs	r0, #255	; 0xff
 800f7ae:	e7f1      	b.n	800f794 <osMutexRelease+0x20>
 800f7b0:	e000ed04 	.word	0xe000ed04

0800f7b4 <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{
 800f7b4:	b510      	push	{r4, lr}
 800f7b6:	0008      	movs	r0, r1
  (void) semaphore_def;
  osSemaphoreId sema;
  
  if (count == 1) {
 800f7b8:	2901      	cmp	r1, #1
 800f7ba:	d10c      	bne.n	800f7d6 <osSemaphoreCreate+0x22>
    vSemaphoreCreateBinary(sema);
 800f7bc:	2203      	movs	r2, #3
 800f7be:	2100      	movs	r1, #0
 800f7c0:	f000 fa58 	bl	800fc74 <xQueueGenericCreate>
 800f7c4:	1e04      	subs	r4, r0, #0
 800f7c6:	d004      	beq.n	800f7d2 <osSemaphoreCreate+0x1e>
 800f7c8:	2300      	movs	r3, #0
 800f7ca:	001a      	movs	r2, r3
 800f7cc:	0019      	movs	r1, r3
 800f7ce:	f000 fa8c 	bl	800fcea <xQueueGenericSend>
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
  return xSemaphoreCreateCounting(count, 0);
#else
  return NULL;
#endif
}
 800f7d2:	0020      	movs	r0, r4
 800f7d4:	bd10      	pop	{r4, pc}
  return xSemaphoreCreateCounting(count, 0);
 800f7d6:	2100      	movs	r1, #0
 800f7d8:	f000 fa73 	bl	800fcc2 <xQueueCreateCountingSemaphore>
 800f7dc:	0004      	movs	r4, r0
 800f7de:	e7f8      	b.n	800f7d2 <osSemaphoreCreate+0x1e>

0800f7e0 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 800f7e0:	b513      	push	{r0, r1, r4, lr}
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 800f7e2:	2400      	movs	r4, #0
{
 800f7e4:	000a      	movs	r2, r1
  portBASE_TYPE taskWoken = pdFALSE;  
 800f7e6:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
    return osErrorParameter;
 800f7e8:	2380      	movs	r3, #128	; 0x80
  if (semaphore_id == NULL) {
 800f7ea:	42a0      	cmp	r0, r4
 800f7ec:	d00a      	beq.n	800f804 <osSemaphoreWait+0x24>
 800f7ee:	f3ef 8105 	mrs	r1, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 800f7f2:	42a1      	cmp	r1, r4
 800f7f4:	d011      	beq.n	800f81a <osSemaphoreWait+0x3a>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 800f7f6:	aa01      	add	r2, sp, #4
 800f7f8:	0021      	movs	r1, r4
 800f7fa:	f000 fc45 	bl	8010088 <xQueueReceiveFromISR>
 800f7fe:	2801      	cmp	r0, #1
 800f800:	d002      	beq.n	800f808 <osSemaphoreWait+0x28>
      return osErrorOS;
 800f802:	23ff      	movs	r3, #255	; 0xff
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
}
 800f804:	0018      	movs	r0, r3
 800f806:	bd16      	pop	{r1, r2, r4, pc}
	portEND_SWITCHING_ISR(taskWoken);
 800f808:	9b01      	ldr	r3, [sp, #4]
 800f80a:	2b00      	cmp	r3, #0
 800f80c:	d003      	beq.n	800f816 <osSemaphoreWait+0x36>
 800f80e:	2280      	movs	r2, #128	; 0x80
 800f810:	4b05      	ldr	r3, [pc, #20]	; (800f828 <osSemaphoreWait+0x48>)
 800f812:	0552      	lsls	r2, r2, #21
 800f814:	601a      	str	r2, [r3, #0]
  return osOK;
 800f816:	2300      	movs	r3, #0
 800f818:	e7f4      	b.n	800f804 <osSemaphoreWait+0x24>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 800f81a:	000b      	movs	r3, r1
 800f81c:	f000 fb95 	bl	800ff4a <xQueueGenericReceive>
 800f820:	2801      	cmp	r0, #1
 800f822:	d0f8      	beq.n	800f816 <osSemaphoreWait+0x36>
 800f824:	e7ed      	b.n	800f802 <osSemaphoreWait+0x22>
 800f826:	46c0      	nop			; (mov r8, r8)
 800f828:	e000ed04 	.word	0xe000ed04

0800f82c <osSemaphoreRelease>:
 800f82c:	b510      	push	{r4, lr}
 800f82e:	f7ff ffa1 	bl	800f774 <osMutexRelease>
 800f832:	bd10      	pop	{r4, pc}

0800f834 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 800f834:	b510      	push	{r4, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 800f836:	f001 f951 	bl	8010adc <xTaskGetSchedulerState>
 800f83a:	2801      	cmp	r0, #1
 800f83c:	d001      	beq.n	800f842 <osSystickHandler+0xe>
  {
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
 800f83e:	f001 fd59 	bl	80112f4 <xPortSysTickHandler>
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 800f842:	bd10      	pop	{r4, pc}

0800f844 <FreeRTOS_CLIRegisterCommand>:
static int8_t cOutputBuffer[ configCOMMAND_INT_MAX_OUTPUT_SIZE ];

/*-----------------------------------------------------------*/

portBASE_TYPE FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister )
{
 800f844:	b570      	push	{r4, r5, r6, lr}
 800f846:	1e05      	subs	r5, r0, #0
static CLI_Definition_List_Item_t *pxLastCommandInList = &xRegisteredCommands;
CLI_Definition_List_Item_t *pxNewListItem;
portBASE_TYPE xReturn = pdFAIL;

	/* Check the parameter is not NULL. */
	configASSERT( pxCommandToRegister );
 800f848:	d101      	bne.n	800f84e <FreeRTOS_CLIRegisterCommand+0xa>
 800f84a:	b672      	cpsid	i
 800f84c:	e7fe      	b.n	800f84c <FreeRTOS_CLIRegisterCommand+0x8>

	/* Create a new list item that will reference the command being registered. */
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
 800f84e:	2008      	movs	r0, #8
 800f850:	f001 fd88 	bl	8011364 <pvPortMalloc>
 800f854:	1e04      	subs	r4, r0, #0
	configASSERT( pxNewListItem );
 800f856:	d101      	bne.n	800f85c <FreeRTOS_CLIRegisterCommand+0x18>
 800f858:	b672      	cpsid	i
 800f85a:	e7fe      	b.n	800f85a <FreeRTOS_CLIRegisterCommand+0x16>

	if( pxNewListItem != NULL )
	{
		taskENTER_CRITICAL();
 800f85c:	f001 fd06 	bl	801126c <vPortEnterCritical>
			list item. */
			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;

			/* The new list item will get added to the end of the list, so
			pxNext has nowhere to point. */
			pxNewListItem->pxNext = NULL;
 800f860:	2300      	movs	r3, #0
 800f862:	6063      	str	r3, [r4, #4]

			/* Add the newly created list item to the end of the already existing
			list. */
			pxLastCommandInList->pxNext = pxNewListItem;
 800f864:	4b04      	ldr	r3, [pc, #16]	; (800f878 <FreeRTOS_CLIRegisterCommand+0x34>)
			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;
 800f866:	6025      	str	r5, [r4, #0]
			pxLastCommandInList->pxNext = pxNewListItem;
 800f868:	681a      	ldr	r2, [r3, #0]
 800f86a:	6054      	str	r4, [r2, #4]

			/* Set the end of list marker to the new list item. */
			pxLastCommandInList = pxNewListItem;
 800f86c:	601c      	str	r4, [r3, #0]
		}
		taskEXIT_CRITICAL();
 800f86e:	f001 fd09 	bl	8011284 <vPortExitCritical>

		xReturn = pdPASS;
	}

	return xReturn;
}
 800f872:	2001      	movs	r0, #1
 800f874:	bd70      	pop	{r4, r5, r6, pc}
 800f876:	46c0      	nop			; (mov r8, r8)
 800f878:	200000bc 	.word	0x200000bc

0800f87c <FreeRTOS_CLIProcessCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE FreeRTOS_CLIProcessCommand( const int8_t * const pcCommandInput, int8_t * pcWriteBuffer, size_t xWriteBufferLen  )
{
 800f87c:	b5f0      	push	{r4, r5, r6, r7, lr}
size_t xCommandStringLength;

	/* Note:  This function is not re-entrant.  It must not be called from more
	than one task. */

	if( pxCommand == NULL )
 800f87e:	4f31      	ldr	r7, [pc, #196]	; (800f944 <FreeRTOS_CLIProcessCommand+0xc8>)
{
 800f880:	b085      	sub	sp, #20
	if( pxCommand == NULL )
 800f882:	683b      	ldr	r3, [r7, #0]
{
 800f884:	0006      	movs	r6, r0
 800f886:	9101      	str	r1, [sp, #4]
 800f888:	9202      	str	r2, [sp, #8]
	if( pxCommand == NULL )
 800f88a:	2b00      	cmp	r3, #0
 800f88c:	d00d      	beq.n	800f8aa <FreeRTOS_CLIProcessCommand+0x2e>
portBASE_TYPE xReturn = pdTRUE;
 800f88e:	2401      	movs	r4, #1
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
 800f890:	4f2c      	ldr	r7, [pc, #176]	; (800f944 <FreeRTOS_CLIProcessCommand+0xc8>)
 800f892:	683d      	ldr	r5, [r7, #0]
 800f894:	2d00      	cmp	r5, #0
 800f896:	d04d      	beq.n	800f934 <FreeRTOS_CLIProcessCommand+0xb8>
 800f898:	2c00      	cmp	r4, #0
 800f89a:	d140      	bne.n	800f91e <FreeRTOS_CLIProcessCommand+0xa2>
	{
		/* The command was found, but the number of parameters with the command
		was incorrect. */
		strncpy( ( char * ) pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
 800f89c:	9a02      	ldr	r2, [sp, #8]
 800f89e:	492a      	ldr	r1, [pc, #168]	; (800f948 <FreeRTOS_CLIProcessCommand+0xcc>)
 800f8a0:	9801      	ldr	r0, [sp, #4]
 800f8a2:	f005 f930 	bl	8014b06 <strncpy>
		/* If xReturn is pdFALSE, then no further strings will be returned
		after this one, and	pxCommand can be reset to NULL ready to search
		for the next entered command. */
		if( xReturn == pdFALSE )
		{
			pxCommand = NULL;
 800f8a6:	603c      	str	r4, [r7, #0]
 800f8a8:	e041      	b.n	800f92e <FreeRTOS_CLIProcessCommand+0xb2>
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
 800f8aa:	4b28      	ldr	r3, [pc, #160]	; (800f94c <FreeRTOS_CLIProcessCommand+0xd0>)
 800f8ac:	603b      	str	r3, [r7, #0]
 800f8ae:	683c      	ldr	r4, [r7, #0]
 800f8b0:	2c00      	cmp	r4, #0
 800f8b2:	d0ec      	beq.n	800f88e <FreeRTOS_CLIProcessCommand+0x12>
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
 800f8b4:	6825      	ldr	r5, [r4, #0]
 800f8b6:	682b      	ldr	r3, [r5, #0]
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
 800f8b8:	0018      	movs	r0, r3
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
 800f8ba:	9303      	str	r3, [sp, #12]
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
 800f8bc:	f7f0 fc2c 	bl	8000118 <strlen>
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
 800f8c0:	2120      	movs	r1, #32
 800f8c2:	5c33      	ldrb	r3, [r6, r0]
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
 800f8c4:	0002      	movs	r2, r0
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
 800f8c6:	438b      	bics	r3, r1
 800f8c8:	d123      	bne.n	800f912 <FreeRTOS_CLIProcessCommand+0x96>
				if( strncmp( ( const char * ) pcCommandInput, ( const char * ) pcRegisteredCommandString, xCommandStringLength ) == 0 )
 800f8ca:	9903      	ldr	r1, [sp, #12]
 800f8cc:	0030      	movs	r0, r6
 800f8ce:	f005 f909 	bl	8014ae4 <strncmp>
 800f8d2:	2800      	cmp	r0, #0
 800f8d4:	d11d      	bne.n	800f912 <FreeRTOS_CLIProcessCommand+0x96>
					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
 800f8d6:	230c      	movs	r3, #12
 800f8d8:	56eb      	ldrsb	r3, [r5, r3]
 800f8da:	2b00      	cmp	r3, #0
 800f8dc:	dbd7      	blt.n	800f88e <FreeRTOS_CLIProcessCommand+0x12>
 800f8de:	0032      	movs	r2, r6
}
/*-----------------------------------------------------------*/

static int8_t prvGetNumberOfParameters( const int8_t * pcCommandString )
{
int8_t cParameters = 0;
 800f8e0:	0004      	movs	r4, r0
		if( ( *pcCommandString ) == ' ' )
		{
			if( xLastCharacterWasSpace != pdTRUE )
			{
				cParameters++;
				xLastCharacterWasSpace = pdTRUE;
 800f8e2:	2101      	movs	r1, #1
 800f8e4:	e007      	b.n	800f8f6 <FreeRTOS_CLIProcessCommand+0x7a>
		if( ( *pcCommandString ) == ' ' )
 800f8e6:	2d20      	cmp	r5, #32
 800f8e8:	d111      	bne.n	800f90e <FreeRTOS_CLIProcessCommand+0x92>
			if( xLastCharacterWasSpace != pdTRUE )
 800f8ea:	2801      	cmp	r0, #1
 800f8ec:	d002      	beq.n	800f8f4 <FreeRTOS_CLIProcessCommand+0x78>
				xLastCharacterWasSpace = pdTRUE;
 800f8ee:	0008      	movs	r0, r1
				cParameters++;
 800f8f0:	3401      	adds	r4, #1
 800f8f2:	b264      	sxtb	r4, r4
		else
		{
			xLastCharacterWasSpace = pdFALSE;
		}

		pcCommandString++;
 800f8f4:	3201      	adds	r2, #1
	while( *pcCommandString != 0x00 )
 800f8f6:	2500      	movs	r5, #0
 800f8f8:	5755      	ldrsb	r5, [r2, r5]
 800f8fa:	2d00      	cmp	r5, #0
 800f8fc:	d1f3      	bne.n	800f8e6 <FreeRTOS_CLIProcessCommand+0x6a>
	}

	/* If the command string ended with spaces, then there will have been too
	many parameters counted. */
	if( xLastCharacterWasSpace == pdTRUE )
 800f8fe:	2801      	cmp	r0, #1
 800f900:	d101      	bne.n	800f906 <FreeRTOS_CLIProcessCommand+0x8a>
	{
		cParameters--;
 800f902:	3c01      	subs	r4, #1
 800f904:	b264      	sxtb	r4, r4
						if( prvGetNumberOfParameters( pcCommandInput ) != pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters )
 800f906:	1b1c      	subs	r4, r3, r4
portBASE_TYPE xReturn = pdTRUE;
 800f908:	4263      	negs	r3, r4
 800f90a:	415c      	adcs	r4, r3
 800f90c:	e7c0      	b.n	800f890 <FreeRTOS_CLIProcessCommand+0x14>
			xLastCharacterWasSpace = pdFALSE;
 800f90e:	2000      	movs	r0, #0
 800f910:	e7f0      	b.n	800f8f4 <FreeRTOS_CLIProcessCommand+0x78>
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
 800f912:	6863      	ldr	r3, [r4, #4]
 800f914:	9303      	str	r3, [sp, #12]
 800f916:	9a03      	ldr	r2, [sp, #12]
 800f918:	4b0a      	ldr	r3, [pc, #40]	; (800f944 <FreeRTOS_CLIProcessCommand+0xc8>)
 800f91a:	601a      	str	r2, [r3, #0]
 800f91c:	e7c7      	b.n	800f8ae <FreeRTOS_CLIProcessCommand+0x32>
		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
 800f91e:	682b      	ldr	r3, [r5, #0]
 800f920:	0032      	movs	r2, r6
 800f922:	689b      	ldr	r3, [r3, #8]
 800f924:	9902      	ldr	r1, [sp, #8]
 800f926:	9801      	ldr	r0, [sp, #4]
 800f928:	4798      	blx	r3
 800f92a:	1e04      	subs	r4, r0, #0
		if( xReturn == pdFALSE )
 800f92c:	d0bb      	beq.n	800f8a6 <FreeRTOS_CLIProcessCommand+0x2a>
}
 800f92e:	0020      	movs	r0, r4
 800f930:	b005      	add	sp, #20
 800f932:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strncpy( ( char * ) pcWriteBuffer, ( const char * ) "Command not recognised.  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
 800f934:	9a02      	ldr	r2, [sp, #8]
 800f936:	4906      	ldr	r1, [pc, #24]	; (800f950 <FreeRTOS_CLIProcessCommand+0xd4>)
 800f938:	9801      	ldr	r0, [sp, #4]
 800f93a:	f005 f8e4 	bl	8014b06 <strncpy>
		xReturn = pdFALSE;
 800f93e:	002c      	movs	r4, r5
	return xReturn;
 800f940:	e7f5      	b.n	800f92e <FreeRTOS_CLIProcessCommand+0xb2>
 800f942:	46c0      	nop			; (mov r8, r8)
 800f944:	20001f14 	.word	0x20001f14
 800f948:	0801c3ee 	.word	0x0801c3ee
 800f94c:	200000c0 	.word	0x200000c0
 800f950:	0801c446 	.word	0x0801c446

0800f954 <FreeRTOS_CLIGetOutputBuffer>:
}
 800f954:	4800      	ldr	r0, [pc, #0]	; (800f958 <FreeRTOS_CLIGetOutputBuffer+0x4>)
 800f956:	4770      	bx	lr
 800f958:	20001cae 	.word	0x20001cae

0800f95c <FreeRTOS_CLIGetParameter>:
	*pxParameterStringLength = 0;
 800f95c:	2300      	movs	r3, #0
{
 800f95e:	b530      	push	{r4, r5, lr}
	*pxParameterStringLength = 0;
 800f960:	6013      	str	r3, [r2, #0]
	while( uxParametersFound < uxWantedParameter )
 800f962:	428b      	cmp	r3, r1
 800f964:	d101      	bne.n	800f96a <FreeRTOS_CLIGetParameter+0xe>
 800f966:	e01d      	b.n	800f9a4 <FreeRTOS_CLIGetParameter+0x48>
			pcCommandString++;
 800f968:	3001      	adds	r0, #1
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 800f96a:	2400      	movs	r4, #0
 800f96c:	5704      	ldrsb	r4, [r0, r4]
 800f96e:	2c00      	cmp	r4, #0
 800f970:	d018      	beq.n	800f9a4 <FreeRTOS_CLIGetParameter+0x48>
 800f972:	2c20      	cmp	r4, #32
 800f974:	d1f8      	bne.n	800f968 <FreeRTOS_CLIGetParameter+0xc>
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
 800f976:	2400      	movs	r4, #0
 800f978:	5704      	ldrsb	r4, [r0, r4]
 800f97a:	2c20      	cmp	r4, #32
 800f97c:	d007      	beq.n	800f98e <FreeRTOS_CLIGetParameter+0x32>
		if( *pcCommandString != 0x00 )
 800f97e:	2c00      	cmp	r4, #0
 800f980:	d010      	beq.n	800f9a4 <FreeRTOS_CLIGetParameter+0x48>
			uxParametersFound++;
 800f982:	3301      	adds	r3, #1
			if( uxParametersFound == uxWantedParameter )
 800f984:	4299      	cmp	r1, r3
 800f986:	d1ec      	bne.n	800f962 <FreeRTOS_CLIGetParameter+0x6>
 800f988:	0004      	movs	r4, r0
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 800f98a:	2520      	movs	r5, #32
 800f98c:	e004      	b.n	800f998 <FreeRTOS_CLIGetParameter+0x3c>
			pcCommandString++;
 800f98e:	3001      	adds	r0, #1
 800f990:	e7f1      	b.n	800f976 <FreeRTOS_CLIGetParameter+0x1a>
					( *pxParameterStringLength )++;
 800f992:	3301      	adds	r3, #1
 800f994:	6013      	str	r3, [r2, #0]
					pcCommandString++;
 800f996:	3401      	adds	r4, #1
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 800f998:	7821      	ldrb	r1, [r4, #0]
 800f99a:	6813      	ldr	r3, [r2, #0]
 800f99c:	43a9      	bics	r1, r5
 800f99e:	d1f8      	bne.n	800f992 <FreeRTOS_CLIGetParameter+0x36>
				if( *pxParameterStringLength == 0 )
 800f9a0:	2b00      	cmp	r3, #0
 800f9a2:	d100      	bne.n	800f9a6 <FreeRTOS_CLIGetParameter+0x4a>
					pcReturn = NULL;
 800f9a4:	2000      	movs	r0, #0
}
 800f9a6:	bd30      	pop	{r4, r5, pc}

0800f9a8 <prvHelpCommand>:
portBASE_TYPE xParameterStringLength1 = 0;
 800f9a8:	2300      	movs	r3, #0
{
 800f9aa:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f9ac:	b085      	sub	sp, #20
 800f9ae:	0004      	movs	r4, r0
 800f9b0:	000d      	movs	r5, r1
 800f9b2:	0010      	movs	r0, r2
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800f9b4:	2101      	movs	r1, #1
 800f9b6:	aa03      	add	r2, sp, #12
portBASE_TYPE xParameterStringLength1 = 0;
 800f9b8:	9303      	str	r3, [sp, #12]
	pcParameterString1 = ( int8_t * ) FreeRTOS_CLIGetParameter (pcCommandString, 1, &xParameterStringLength1);
 800f9ba:	f7ff ffcf 	bl	800f95c <FreeRTOS_CLIGetParameter>
	if (pcParameterString1 != NULL && !strncmp((const char *)pcParameterString1, "params", 6))
 800f9be:	2800      	cmp	r0, #0
 800f9c0:	d01f      	beq.n	800fa02 <prvHelpCommand+0x5a>
 800f9c2:	2206      	movs	r2, #6
 800f9c4:	4928      	ldr	r1, [pc, #160]	; (800fa68 <prvHelpCommand+0xc0>)
 800f9c6:	f005 f88d 	bl	8014ae4 <strncmp>
 800f9ca:	2800      	cmp	r0, #0
 800f9cc:	d116      	bne.n	800f9fc <prvHelpCommand+0x54>
		if( str == NumOfParamsHelpStrings )
 800f9ce:	4f27      	ldr	r7, [pc, #156]	; (800fa6c <prvHelpCommand+0xc4>)
 800f9d0:	783b      	ldrb	r3, [r7, #0]
 800f9d2:	2b07      	cmp	r3, #7
 800f9d4:	d100      	bne.n	800f9d8 <prvHelpCommand+0x30>
			str = 0;
 800f9d6:	7038      	strb	r0, [r7, #0]
		strncpy( ( char * ) pcWriteBuffer, ( const char * )pcParamsHelpString[str++], xWriteBufferLen );
 800f9d8:	783b      	ldrb	r3, [r7, #0]
 800f9da:	4925      	ldr	r1, [pc, #148]	; (800fa70 <prvHelpCommand+0xc8>)
 800f9dc:	1c5a      	adds	r2, r3, #1
 800f9de:	b2d2      	uxtb	r2, r2
 800f9e0:	009b      	lsls	r3, r3, #2
 800f9e2:	9201      	str	r2, [sp, #4]
 800f9e4:	703a      	strb	r2, [r7, #0]
 800f9e6:	5859      	ldr	r1, [r3, r1]
 800f9e8:	002a      	movs	r2, r5
 800f9ea:	0020      	movs	r0, r4
 800f9ec:	f005 f88b 	bl	8014b06 <strncpy>
		if( str == NumOfParamsHelpStrings )
 800f9f0:	9b01      	ldr	r3, [sp, #4]
			xReturn = pdTRUE;
 800f9f2:	2601      	movs	r6, #1
		if( str == NumOfParamsHelpStrings )
 800f9f4:	2b07      	cmp	r3, #7
 800f9f6:	d101      	bne.n	800f9fc <prvHelpCommand+0x54>
			xReturn = pdFALSE; str = 0;
 800f9f8:	2600      	movs	r6, #0
 800f9fa:	703e      	strb	r6, [r7, #0]
}
 800f9fc:	0030      	movs	r0, r6
 800f9fe:	b005      	add	sp, #20
 800fa00:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if( pxCommand == NULL )
 800fa02:	4e1c      	ldr	r6, [pc, #112]	; (800fa74 <prvHelpCommand+0xcc>)
 800fa04:	6833      	ldr	r3, [r6, #0]
 800fa06:	2b00      	cmp	r3, #0
 800fa08:	d104      	bne.n	800fa14 <prvHelpCommand+0x6c>
			pxCommand = &xRegisteredCommands;
 800fa0a:	4b1b      	ldr	r3, [pc, #108]	; (800fa78 <prvHelpCommand+0xd0>)
			counter = 1;
 800fa0c:	4a1b      	ldr	r2, [pc, #108]	; (800fa7c <prvHelpCommand+0xd4>)
			pxCommand = &xRegisteredCommands;
 800fa0e:	6033      	str	r3, [r6, #0]
			counter = 1;
 800fa10:	2301      	movs	r3, #1
 800fa12:	7013      	strb	r3, [r2, #0]
		if (counter > numOfBosCommands) {
 800fa14:	4b19      	ldr	r3, [pc, #100]	; (800fa7c <prvHelpCommand+0xd4>)
 800fa16:	6837      	ldr	r7, [r6, #0]
 800fa18:	781b      	ldrb	r3, [r3, #0]
 800fa1a:	9301      	str	r3, [sp, #4]
 800fa1c:	683b      	ldr	r3, [r7, #0]
 800fa1e:	9a01      	ldr	r2, [sp, #4]
 800fa20:	6859      	ldr	r1, [r3, #4]
 800fa22:	4b17      	ldr	r3, [pc, #92]	; (800fa80 <prvHelpCommand+0xd8>)
 800fa24:	781b      	ldrb	r3, [r3, #0]
 800fa26:	4293      	cmp	r3, r2
 800fa28:	d219      	bcs.n	800fa5e <prvHelpCommand+0xb6>
			strncpy( 8 + ( char * ) pcWriteBuffer, ( const char * ) pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen-8 );
 800fa2a:	002a      	movs	r2, r5
 800fa2c:	0020      	movs	r0, r4
 800fa2e:	3a08      	subs	r2, #8
 800fa30:	3008      	adds	r0, #8
 800fa32:	f005 f868 	bl	8014b06 <strncpy>
			strcpy(1 + ( char * ) pcWriteBuffer, ( char * ) modulePNstring[modulePN]);
 800fa36:	1c60      	adds	r0, r4, #1
 800fa38:	4912      	ldr	r1, [pc, #72]	; (800fa84 <prvHelpCommand+0xdc>)
 800fa3a:	f005 f84b 	bl	8014ad4 <strcpy>
			pcWriteBuffer[0] = '('; pcWriteBuffer[6] = ')'; pcWriteBuffer[7] = ' ';
 800fa3e:	2328      	movs	r3, #40	; 0x28
 800fa40:	7023      	strb	r3, [r4, #0]
 800fa42:	3301      	adds	r3, #1
 800fa44:	71a3      	strb	r3, [r4, #6]
 800fa46:	3b09      	subs	r3, #9
 800fa48:	71e3      	strb	r3, [r4, #7]
		pxCommand = pxCommand->pxNext;
 800fa4a:	687a      	ldr	r2, [r7, #4]
		counter++;
 800fa4c:	9b01      	ldr	r3, [sp, #4]
		pxCommand = pxCommand->pxNext;
 800fa4e:	6032      	str	r2, [r6, #0]
			xReturn = pdTRUE;
 800fa50:	0016      	movs	r6, r2
		counter++;
 800fa52:	490a      	ldr	r1, [pc, #40]	; (800fa7c <prvHelpCommand+0xd4>)
 800fa54:	3301      	adds	r3, #1
 800fa56:	700b      	strb	r3, [r1, #0]
			xReturn = pdTRUE;
 800fa58:	1e72      	subs	r2, r6, #1
 800fa5a:	4196      	sbcs	r6, r2
 800fa5c:	e7ce      	b.n	800f9fc <prvHelpCommand+0x54>
			strncpy( ( char * ) pcWriteBuffer, ( const char * ) pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
 800fa5e:	002a      	movs	r2, r5
 800fa60:	0020      	movs	r0, r4
 800fa62:	f005 f850 	bl	8014b06 <strncpy>
 800fa66:	e7f0      	b.n	800fa4a <prvHelpCommand+0xa2>
 800fa68:	08019bc4 	.word	0x08019bc4
 800fa6c:	20001f1c 	.word	0x20001f1c
 800fa70:	20000054 	.word	0x20000054
 800fa74:	20001f18 	.word	0x20001f18
 800fa78:	200000c0 	.word	0x200000c0
 800fa7c:	20001f12 	.word	0x20001f12
 800fa80:	20006ef4 	.word	0x20006ef4
 800fa84:	08019344 	.word	0x08019344

0800fa88 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800fa88:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800fa8a:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800fa8c:	3308      	adds	r3, #8
 800fa8e:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800fa90:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800fa92:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800fa94:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800fa96:	4252      	negs	r2, r2
 800fa98:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800fa9a:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800fa9c:	4770      	bx	lr

0800fa9e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800fa9e:	2300      	movs	r3, #0
 800faa0:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800faa2:	4770      	bx	lr

0800faa4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800faa4:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 800faa6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800faa8:	689a      	ldr	r2, [r3, #8]
 800faaa:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800faac:	689a      	ldr	r2, [r3, #8]
 800faae:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800fab0:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800fab2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800fab4:	6803      	ldr	r3, [r0, #0]
 800fab6:	3301      	adds	r3, #1
 800fab8:	6003      	str	r3, [r0, #0]
}
 800faba:	4770      	bx	lr

0800fabc <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800fabc:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800fabe:	680a      	ldr	r2, [r1, #0]
{
 800fac0:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800fac2:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
 800fac4:	1c54      	adds	r4, r2, #1
 800fac6:	d10b      	bne.n	800fae0 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
 800fac8:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800faca:	685a      	ldr	r2, [r3, #4]
 800facc:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800face:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800fad0:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800fad2:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800fad4:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800fad6:	6803      	ldr	r3, [r0, #0]
 800fad8:	3301      	adds	r3, #1
 800fada:	6003      	str	r3, [r0, #0]
}
 800fadc:	bd30      	pop	{r4, r5, pc}
 800fade:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800fae0:	685c      	ldr	r4, [r3, #4]
 800fae2:	6825      	ldr	r5, [r4, #0]
 800fae4:	4295      	cmp	r5, r2
 800fae6:	d9fa      	bls.n	800fade <vListInsert+0x22>
 800fae8:	e7ef      	b.n	800faca <vListInsert+0xe>

0800faea <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800faea:	6842      	ldr	r2, [r0, #4]
 800faec:	6881      	ldr	r1, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800faee:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800faf0:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800faf2:	6882      	ldr	r2, [r0, #8]
 800faf4:	6841      	ldr	r1, [r0, #4]
 800faf6:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800faf8:	685a      	ldr	r2, [r3, #4]
 800fafa:	4282      	cmp	r2, r0
 800fafc:	d101      	bne.n	800fb02 <uxListRemove+0x18>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800fafe:	6882      	ldr	r2, [r0, #8]
 800fb00:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800fb02:	2200      	movs	r2, #0
 800fb04:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800fb06:	681a      	ldr	r2, [r3, #0]
 800fb08:	1e50      	subs	r0, r2, #1
 800fb0a:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800fb0c:	4770      	bx	lr

0800fb0e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800fb0e:	b570      	push	{r4, r5, r6, lr}
 800fb10:	0015      	movs	r5, r2
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800fb12:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 800fb14:	0004      	movs	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800fb16:	2a00      	cmp	r2, #0
 800fb18:	d10c      	bne.n	800fb34 <prvCopyDataToQueue+0x26>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800fb1a:	6805      	ldr	r5, [r0, #0]
 800fb1c:	2d00      	cmp	r5, #0
 800fb1e:	d001      	beq.n	800fb24 <prvCopyDataToQueue+0x16>
BaseType_t xReturn = pdFALSE;
 800fb20:	2000      	movs	r0, #0
 800fb22:	e003      	b.n	800fb2c <prvCopyDataToQueue+0x1e>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 800fb24:	6840      	ldr	r0, [r0, #4]
 800fb26:	f001 f81f 	bl	8010b68 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 800fb2a:	6065      	str	r5, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 800fb2c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800fb2e:	3301      	adds	r3, #1
 800fb30:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
 800fb32:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 800fb34:	2d00      	cmp	r5, #0
 800fb36:	d10c      	bne.n	800fb52 <prvCopyDataToQueue+0x44>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800fb38:	6880      	ldr	r0, [r0, #8]
 800fb3a:	f004 fd8b 	bl	8014654 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800fb3e:	68a3      	ldr	r3, [r4, #8]
 800fb40:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800fb42:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800fb44:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800fb46:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800fb48:	4293      	cmp	r3, r2
 800fb4a:	d3e9      	bcc.n	800fb20 <prvCopyDataToQueue+0x12>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800fb4c:	6823      	ldr	r3, [r4, #0]
 800fb4e:	60a3      	str	r3, [r4, #8]
 800fb50:	e7e6      	b.n	800fb20 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800fb52:	68c0      	ldr	r0, [r0, #12]
 800fb54:	f004 fd7e 	bl	8014654 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800fb58:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800fb5a:	68e2      	ldr	r2, [r4, #12]
 800fb5c:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800fb5e:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800fb60:	18d2      	adds	r2, r2, r3
 800fb62:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800fb64:	428a      	cmp	r2, r1
 800fb66:	d202      	bcs.n	800fb6e <prvCopyDataToQueue+0x60>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800fb68:	6862      	ldr	r2, [r4, #4]
 800fb6a:	18d3      	adds	r3, r2, r3
 800fb6c:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800fb6e:	2d02      	cmp	r5, #2
 800fb70:	d1d6      	bne.n	800fb20 <prvCopyDataToQueue+0x12>
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 800fb72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800fb74:	2b00      	cmp	r3, #0
 800fb76:	d0d3      	beq.n	800fb20 <prvCopyDataToQueue+0x12>
				--( pxQueue->uxMessagesWaiting );
 800fb78:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800fb7a:	3b01      	subs	r3, #1
 800fb7c:	63a3      	str	r3, [r4, #56]	; 0x38
 800fb7e:	e7cf      	b.n	800fb20 <prvCopyDataToQueue+0x12>

0800fb80 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 800fb80:	0003      	movs	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800fb82:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 800fb84:	b510      	push	{r4, lr}
 800fb86:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800fb88:	2a00      	cmp	r2, #0
 800fb8a:	d00a      	beq.n	800fba2 <prvCopyDataFromQueue+0x22>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800fb8c:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800fb8e:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800fb90:	1889      	adds	r1, r1, r2
 800fb92:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800fb94:	42a1      	cmp	r1, r4
 800fb96:	d301      	bcc.n	800fb9c <prvCopyDataFromQueue+0x1c>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800fb98:	6819      	ldr	r1, [r3, #0]
 800fb9a:	60d9      	str	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800fb9c:	68d9      	ldr	r1, [r3, #12]
 800fb9e:	f004 fd59 	bl	8014654 <memcpy>
	}
}
 800fba2:	bd10      	pop	{r4, pc}

0800fba4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800fba4:	b510      	push	{r4, lr}
 800fba6:	0004      	movs	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800fba8:	f001 fb60 	bl	801126c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 800fbac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800fbae:	2b00      	cmp	r3, #0
 800fbb0:	dc0f      	bgt.n	800fbd2 <prvUnlockQueue+0x2e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 800fbb2:	2301      	movs	r3, #1
 800fbb4:	425b      	negs	r3, r3
 800fbb6:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 800fbb8:	f001 fb64 	bl	8011284 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800fbbc:	f001 fb56 	bl	801126c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 800fbc0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800fbc2:	2b00      	cmp	r3, #0
 800fbc4:	dc14      	bgt.n	800fbf0 <prvUnlockQueue+0x4c>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 800fbc6:	2301      	movs	r3, #1
 800fbc8:	425b      	negs	r3, r3
 800fbca:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 800fbcc:	f001 fb5a 	bl	8011284 <vPortExitCritical>
}
 800fbd0:	bd10      	pop	{r4, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800fbd2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fbd4:	2b00      	cmp	r3, #0
 800fbd6:	d0ec      	beq.n	800fbb2 <prvUnlockQueue+0xe>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800fbd8:	0020      	movs	r0, r4
 800fbda:	3024      	adds	r0, #36	; 0x24
 800fbdc:	f000 fefc 	bl	80109d8 <xTaskRemoveFromEventList>
 800fbe0:	2800      	cmp	r0, #0
 800fbe2:	d001      	beq.n	800fbe8 <prvUnlockQueue+0x44>
						vTaskMissedYield();
 800fbe4:	f000 ff74 	bl	8010ad0 <vTaskMissedYield>
			--( pxQueue->xTxLock );
 800fbe8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800fbea:	3b01      	subs	r3, #1
 800fbec:	64a3      	str	r3, [r4, #72]	; 0x48
 800fbee:	e7dd      	b.n	800fbac <prvUnlockQueue+0x8>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800fbf0:	6923      	ldr	r3, [r4, #16]
 800fbf2:	2b00      	cmp	r3, #0
 800fbf4:	d0e7      	beq.n	800fbc6 <prvUnlockQueue+0x22>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800fbf6:	0020      	movs	r0, r4
 800fbf8:	3010      	adds	r0, #16
 800fbfa:	f000 feed 	bl	80109d8 <xTaskRemoveFromEventList>
 800fbfe:	2800      	cmp	r0, #0
 800fc00:	d001      	beq.n	800fc06 <prvUnlockQueue+0x62>
					vTaskMissedYield();
 800fc02:	f000 ff65 	bl	8010ad0 <vTaskMissedYield>
				--( pxQueue->xRxLock );
 800fc06:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800fc08:	3b01      	subs	r3, #1
 800fc0a:	6463      	str	r3, [r4, #68]	; 0x44
 800fc0c:	e7d8      	b.n	800fbc0 <prvUnlockQueue+0x1c>

0800fc0e <xQueueGenericReset>:
{
 800fc0e:	b570      	push	{r4, r5, r6, lr}
 800fc10:	0004      	movs	r4, r0
 800fc12:	000d      	movs	r5, r1
	configASSERT( pxQueue );
 800fc14:	2800      	cmp	r0, #0
 800fc16:	d101      	bne.n	800fc1c <xQueueGenericReset+0xe>
 800fc18:	b672      	cpsid	i
 800fc1a:	e7fe      	b.n	800fc1a <xQueueGenericReset+0xc>
	taskENTER_CRITICAL();
 800fc1c:	f001 fb26 	bl	801126c <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800fc20:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800fc22:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800fc24:	6822      	ldr	r2, [r4, #0]
 800fc26:	434b      	muls	r3, r1
 800fc28:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800fc2a:	1a5b      	subs	r3, r3, r1
 800fc2c:	18d3      	adds	r3, r2, r3
 800fc2e:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
 800fc30:	2301      	movs	r3, #1
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800fc32:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800fc34:	2000      	movs	r0, #0
		pxQueue->xRxLock = queueUNLOCKED;
 800fc36:	425b      	negs	r3, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800fc38:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800fc3a:	60a2      	str	r2, [r4, #8]
		pxQueue->xRxLock = queueUNLOCKED;
 800fc3c:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 800fc3e:	64a3      	str	r3, [r4, #72]	; 0x48
		if( xNewQueue == pdFALSE )
 800fc40:	4285      	cmp	r5, r0
 800fc42:	d10e      	bne.n	800fc62 <xQueueGenericReset+0x54>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800fc44:	6923      	ldr	r3, [r4, #16]
 800fc46:	4283      	cmp	r3, r0
 800fc48:	d007      	beq.n	800fc5a <xQueueGenericReset+0x4c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 800fc4a:	0020      	movs	r0, r4
 800fc4c:	3010      	adds	r0, #16
 800fc4e:	f000 fec3 	bl	80109d8 <xTaskRemoveFromEventList>
 800fc52:	2801      	cmp	r0, #1
 800fc54:	d101      	bne.n	800fc5a <xQueueGenericReset+0x4c>
					queueYIELD_IF_USING_PREEMPTION();
 800fc56:	f001 fafd 	bl	8011254 <vPortYield>
	taskEXIT_CRITICAL();
 800fc5a:	f001 fb13 	bl	8011284 <vPortExitCritical>
}
 800fc5e:	2001      	movs	r0, #1
 800fc60:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800fc62:	0020      	movs	r0, r4
 800fc64:	3010      	adds	r0, #16
 800fc66:	f7ff ff0f 	bl	800fa88 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800fc6a:	0020      	movs	r0, r4
 800fc6c:	3024      	adds	r0, #36	; 0x24
 800fc6e:	f7ff ff0b 	bl	800fa88 <vListInitialise>
 800fc72:	e7f2      	b.n	800fc5a <xQueueGenericReset+0x4c>

0800fc74 <xQueueGenericCreate>:
{
 800fc74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fc76:	0006      	movs	r6, r0
 800fc78:	000d      	movs	r5, r1
 800fc7a:	0017      	movs	r7, r2
	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800fc7c:	2800      	cmp	r0, #0
 800fc7e:	d101      	bne.n	800fc84 <xQueueGenericCreate+0x10>
 800fc80:	b672      	cpsid	i
 800fc82:	e7fe      	b.n	800fc82 <xQueueGenericCreate+0xe>
		xQueueSizeInBytes = ( size_t ) 0;
 800fc84:	2000      	movs	r0, #0
	if( uxItemSize == ( UBaseType_t ) 0 )
 800fc86:	4281      	cmp	r1, r0
 800fc88:	d002      	beq.n	800fc90 <xQueueGenericCreate+0x1c>
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800fc8a:	0008      	movs	r0, r1
 800fc8c:	4370      	muls	r0, r6
 800fc8e:	3001      	adds	r0, #1
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800fc90:	3054      	adds	r0, #84	; 0x54
 800fc92:	f001 fb67 	bl	8011364 <pvPortMalloc>
 800fc96:	1e04      	subs	r4, r0, #0
	if( pcAllocatedBuffer != NULL )
 800fc98:	d101      	bne.n	800fc9e <xQueueGenericCreate+0x2a>
	configASSERT( xReturn );
 800fc9a:	b672      	cpsid	i
 800fc9c:	e7fe      	b.n	800fc9c <xQueueGenericCreate+0x28>
		if( uxItemSize == ( UBaseType_t ) 0 )
 800fc9e:	2d00      	cmp	r5, #0
 800fca0:	d10b      	bne.n	800fcba <xQueueGenericCreate+0x46>
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800fca2:	6020      	str	r0, [r4, #0]
		pxNewQueue->uxLength = uxQueueLength;
 800fca4:	63e6      	str	r6, [r4, #60]	; 0x3c
		pxNewQueue->uxItemSize = uxItemSize;
 800fca6:	6425      	str	r5, [r4, #64]	; 0x40
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800fca8:	2101      	movs	r1, #1
 800fcaa:	0020      	movs	r0, r4
 800fcac:	f7ff ffaf 	bl	800fc0e <xQueueGenericReset>
			pxNewQueue->ucQueueType = ucQueueType;
 800fcb0:	0023      	movs	r3, r4
 800fcb2:	3350      	adds	r3, #80	; 0x50
 800fcb4:	701f      	strb	r7, [r3, #0]
}
 800fcb6:	0020      	movs	r0, r4
 800fcb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
 800fcba:	0003      	movs	r3, r0
 800fcbc:	3354      	adds	r3, #84	; 0x54
 800fcbe:	6003      	str	r3, [r0, #0]
 800fcc0:	e7f0      	b.n	800fca4 <xQueueGenericCreate+0x30>

0800fcc2 <xQueueCreateCountingSemaphore>:
	{
 800fcc2:	b510      	push	{r4, lr}
 800fcc4:	000c      	movs	r4, r1
		configASSERT( uxMaxCount != 0 );
 800fcc6:	2800      	cmp	r0, #0
 800fcc8:	d101      	bne.n	800fcce <xQueueCreateCountingSemaphore+0xc>
 800fcca:	b672      	cpsid	i
 800fccc:	e7fe      	b.n	800fccc <xQueueCreateCountingSemaphore+0xa>
		configASSERT( uxInitialCount <= uxMaxCount );
 800fcce:	4288      	cmp	r0, r1
 800fcd0:	d201      	bcs.n	800fcd6 <xQueueCreateCountingSemaphore+0x14>
 800fcd2:	b672      	cpsid	i
 800fcd4:	e7fe      	b.n	800fcd4 <xQueueCreateCountingSemaphore+0x12>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 800fcd6:	2202      	movs	r2, #2
 800fcd8:	2100      	movs	r1, #0
 800fcda:	f7ff ffcb 	bl	800fc74 <xQueueGenericCreate>
		if( xHandle != NULL )
 800fcde:	2800      	cmp	r0, #0
 800fce0:	d001      	beq.n	800fce6 <xQueueCreateCountingSemaphore+0x24>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 800fce2:	6384      	str	r4, [r0, #56]	; 0x38
	}
 800fce4:	bd10      	pop	{r4, pc}
		configASSERT( xHandle );
 800fce6:	b672      	cpsid	i
 800fce8:	e7fe      	b.n	800fce8 <xQueueCreateCountingSemaphore+0x26>

0800fcea <xQueueGenericSend>:
{
 800fcea:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fcec:	b085      	sub	sp, #20
 800fcee:	0004      	movs	r4, r0
 800fcf0:	000f      	movs	r7, r1
 800fcf2:	9201      	str	r2, [sp, #4]
 800fcf4:	001d      	movs	r5, r3
	configASSERT( pxQueue );
 800fcf6:	2800      	cmp	r0, #0
 800fcf8:	d101      	bne.n	800fcfe <xQueueGenericSend+0x14>
 800fcfa:	b672      	cpsid	i
 800fcfc:	e7fe      	b.n	800fcfc <xQueueGenericSend+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800fcfe:	2900      	cmp	r1, #0
 800fd00:	d104      	bne.n	800fd0c <xQueueGenericSend+0x22>
 800fd02:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800fd04:	2b00      	cmp	r3, #0
 800fd06:	d001      	beq.n	800fd0c <xQueueGenericSend+0x22>
 800fd08:	b672      	cpsid	i
 800fd0a:	e7fe      	b.n	800fd0a <xQueueGenericSend+0x20>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800fd0c:	2d02      	cmp	r5, #2
 800fd0e:	d104      	bne.n	800fd1a <xQueueGenericSend+0x30>
 800fd10:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800fd12:	2b01      	cmp	r3, #1
 800fd14:	d001      	beq.n	800fd1a <xQueueGenericSend+0x30>
 800fd16:	b672      	cpsid	i
 800fd18:	e7fe      	b.n	800fd18 <xQueueGenericSend+0x2e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800fd1a:	f000 fedf 	bl	8010adc <xTaskGetSchedulerState>
 800fd1e:	2800      	cmp	r0, #0
 800fd20:	d104      	bne.n	800fd2c <xQueueGenericSend+0x42>
 800fd22:	9e01      	ldr	r6, [sp, #4]
 800fd24:	2e00      	cmp	r6, #0
 800fd26:	d04a      	beq.n	800fdbe <xQueueGenericSend+0xd4>
 800fd28:	b672      	cpsid	i
 800fd2a:	e7fe      	b.n	800fd2a <xQueueGenericSend+0x40>
 800fd2c:	2600      	movs	r6, #0
 800fd2e:	e046      	b.n	800fdbe <xQueueGenericSend+0xd4>
					else if( xYieldRequired != pdFALSE )
 800fd30:	2800      	cmp	r0, #0
 800fd32:	d05c      	beq.n	800fdee <xQueueGenericSend+0x104>
 800fd34:	e059      	b.n	800fdea <xQueueGenericSend+0x100>
				if( xTicksToWait == ( TickType_t ) 0 )
 800fd36:	9b01      	ldr	r3, [sp, #4]
 800fd38:	9300      	str	r3, [sp, #0]
 800fd3a:	2b00      	cmp	r3, #0
 800fd3c:	d103      	bne.n	800fd46 <xQueueGenericSend+0x5c>
					taskEXIT_CRITICAL();
 800fd3e:	f001 faa1 	bl	8011284 <vPortExitCritical>
			return errQUEUE_FULL;
 800fd42:	2000      	movs	r0, #0
 800fd44:	e056      	b.n	800fdf4 <xQueueGenericSend+0x10a>
				else if( xEntryTimeSet == pdFALSE )
 800fd46:	2e00      	cmp	r6, #0
 800fd48:	d102      	bne.n	800fd50 <xQueueGenericSend+0x66>
					vTaskSetTimeOutState( &xTimeOut );
 800fd4a:	a802      	add	r0, sp, #8
 800fd4c:	f000 fe80 	bl	8010a50 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800fd50:	f001 fa98 	bl	8011284 <vPortExitCritical>
		vTaskSuspendAll();
 800fd54:	f000 fc18 	bl	8010588 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800fd58:	f001 fa88 	bl	801126c <vPortEnterCritical>
 800fd5c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800fd5e:	3301      	adds	r3, #1
 800fd60:	d101      	bne.n	800fd66 <xQueueGenericSend+0x7c>
 800fd62:	2300      	movs	r3, #0
 800fd64:	6463      	str	r3, [r4, #68]	; 0x44
 800fd66:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800fd68:	3301      	adds	r3, #1
 800fd6a:	d101      	bne.n	800fd70 <xQueueGenericSend+0x86>
 800fd6c:	2300      	movs	r3, #0
 800fd6e:	64a3      	str	r3, [r4, #72]	; 0x48
 800fd70:	f001 fa88 	bl	8011284 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800fd74:	a901      	add	r1, sp, #4
 800fd76:	a802      	add	r0, sp, #8
 800fd78:	f000 fe7a 	bl	8010a70 <xTaskCheckForTimeOut>
 800fd7c:	2800      	cmp	r0, #0
 800fd7e:	d13b      	bne.n	800fdf8 <xQueueGenericSend+0x10e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800fd80:	f001 fa74 	bl	801126c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800fd84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800fd86:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800fd88:	4293      	cmp	r3, r2
 800fd8a:	d110      	bne.n	800fdae <xQueueGenericSend+0xc4>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800fd8c:	f001 fa7a 	bl	8011284 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800fd90:	0020      	movs	r0, r4
 800fd92:	9901      	ldr	r1, [sp, #4]
 800fd94:	3010      	adds	r0, #16
 800fd96:	f000 fde1 	bl	801095c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800fd9a:	0020      	movs	r0, r4
 800fd9c:	f7ff ff02 	bl	800fba4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800fda0:	f000 fc88 	bl	80106b4 <xTaskResumeAll>
 800fda4:	2800      	cmp	r0, #0
 800fda6:	d109      	bne.n	800fdbc <xQueueGenericSend+0xd2>
					portYIELD_WITHIN_API();
 800fda8:	f001 fa54 	bl	8011254 <vPortYield>
 800fdac:	e006      	b.n	800fdbc <xQueueGenericSend+0xd2>
	taskEXIT_CRITICAL();
 800fdae:	f001 fa69 	bl	8011284 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800fdb2:	0020      	movs	r0, r4
 800fdb4:	f7ff fef6 	bl	800fba4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800fdb8:	f000 fc7c 	bl	80106b4 <xTaskResumeAll>
 800fdbc:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 800fdbe:	f001 fa55 	bl	801126c <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800fdc2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800fdc4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800fdc6:	4293      	cmp	r3, r2
 800fdc8:	d301      	bcc.n	800fdce <xQueueGenericSend+0xe4>
 800fdca:	2d02      	cmp	r5, #2
 800fdcc:	d1b3      	bne.n	800fd36 <xQueueGenericSend+0x4c>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800fdce:	002a      	movs	r2, r5
 800fdd0:	0039      	movs	r1, r7
 800fdd2:	0020      	movs	r0, r4
 800fdd4:	f7ff fe9b 	bl	800fb0e <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800fdd8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fdda:	2b00      	cmp	r3, #0
 800fddc:	d0a8      	beq.n	800fd30 <xQueueGenericSend+0x46>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 800fdde:	0020      	movs	r0, r4
 800fde0:	3024      	adds	r0, #36	; 0x24
 800fde2:	f000 fdf9 	bl	80109d8 <xTaskRemoveFromEventList>
 800fde6:	2801      	cmp	r0, #1
 800fde8:	d101      	bne.n	800fdee <xQueueGenericSend+0x104>
							queueYIELD_IF_USING_PREEMPTION();
 800fdea:	f001 fa33 	bl	8011254 <vPortYield>
				taskEXIT_CRITICAL();
 800fdee:	f001 fa49 	bl	8011284 <vPortExitCritical>
				return pdPASS;
 800fdf2:	2001      	movs	r0, #1
}
 800fdf4:	b005      	add	sp, #20
 800fdf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800fdf8:	0020      	movs	r0, r4
 800fdfa:	f7ff fed3 	bl	800fba4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800fdfe:	f000 fc59 	bl	80106b4 <xTaskResumeAll>
 800fe02:	e79e      	b.n	800fd42 <xQueueGenericSend+0x58>

0800fe04 <xQueueCreateMutex>:
	{
 800fe04:	b570      	push	{r4, r5, r6, lr}
 800fe06:	0006      	movs	r6, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 800fe08:	2054      	movs	r0, #84	; 0x54
 800fe0a:	f001 faab 	bl	8011364 <pvPortMalloc>
 800fe0e:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
 800fe10:	d01d      	beq.n	800fe4e <xQueueCreateMutex+0x4a>
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 800fe12:	2301      	movs	r3, #1
			pxNewQueue->pxMutexHolder = NULL;
 800fe14:	2500      	movs	r5, #0
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 800fe16:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->xRxLock = queueUNLOCKED;
 800fe18:	3b02      	subs	r3, #2
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800fe1a:	6385      	str	r5, [r0, #56]	; 0x38
			pxNewQueue->xRxLock = queueUNLOCKED;
 800fe1c:	6443      	str	r3, [r0, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
 800fe1e:	6483      	str	r3, [r0, #72]	; 0x48
				pxNewQueue->ucQueueType = ucQueueType;
 800fe20:	0003      	movs	r3, r0
 800fe22:	3350      	adds	r3, #80	; 0x50
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 800fe24:	6405      	str	r5, [r0, #64]	; 0x40
			pxNewQueue->pxMutexHolder = NULL;
 800fe26:	6045      	str	r5, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800fe28:	6005      	str	r5, [r0, #0]
			pxNewQueue->pcWriteTo = NULL;
 800fe2a:	6085      	str	r5, [r0, #8]
			pxNewQueue->u.pcReadFrom = NULL;
 800fe2c:	60c5      	str	r5, [r0, #12]
				pxNewQueue->ucQueueType = ucQueueType;
 800fe2e:	701e      	strb	r6, [r3, #0]
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 800fe30:	3010      	adds	r0, #16
 800fe32:	f7ff fe29 	bl	800fa88 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 800fe36:	0020      	movs	r0, r4
 800fe38:	3024      	adds	r0, #36	; 0x24
 800fe3a:	f7ff fe25 	bl	800fa88 <vListInitialise>
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800fe3e:	002b      	movs	r3, r5
 800fe40:	002a      	movs	r2, r5
 800fe42:	0029      	movs	r1, r5
 800fe44:	0020      	movs	r0, r4
 800fe46:	f7ff ff50 	bl	800fcea <xQueueGenericSend>
	}
 800fe4a:	0020      	movs	r0, r4
 800fe4c:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxNewQueue );
 800fe4e:	b672      	cpsid	i
 800fe50:	e7fe      	b.n	800fe50 <xQueueCreateMutex+0x4c>

0800fe52 <xQueueGenericSendFromISR>:
{
 800fe52:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800fe54:	0004      	movs	r4, r0
 800fe56:	9100      	str	r1, [sp, #0]
 800fe58:	0017      	movs	r7, r2
 800fe5a:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800fe5c:	2800      	cmp	r0, #0
 800fe5e:	d101      	bne.n	800fe64 <xQueueGenericSendFromISR+0x12>
 800fe60:	b672      	cpsid	i
 800fe62:	e7fe      	b.n	800fe62 <xQueueGenericSendFromISR+0x10>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800fe64:	9b00      	ldr	r3, [sp, #0]
 800fe66:	2b00      	cmp	r3, #0
 800fe68:	d104      	bne.n	800fe74 <xQueueGenericSendFromISR+0x22>
 800fe6a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800fe6c:	2b00      	cmp	r3, #0
 800fe6e:	d001      	beq.n	800fe74 <xQueueGenericSendFromISR+0x22>
 800fe70:	b672      	cpsid	i
 800fe72:	e7fe      	b.n	800fe72 <xQueueGenericSendFromISR+0x20>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800fe74:	2e02      	cmp	r6, #2
 800fe76:	d104      	bne.n	800fe82 <xQueueGenericSendFromISR+0x30>
 800fe78:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800fe7a:	2b01      	cmp	r3, #1
 800fe7c:	d001      	beq.n	800fe82 <xQueueGenericSendFromISR+0x30>
 800fe7e:	b672      	cpsid	i
 800fe80:	e7fe      	b.n	800fe80 <xQueueGenericSendFromISR+0x2e>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800fe82:	f001 fa0d 	bl	80112a0 <ulSetInterruptMaskFromISR>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800fe86:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800fe88:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800fe8a:	9001      	str	r0, [sp, #4]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800fe8c:	4293      	cmp	r3, r2
 800fe8e:	d302      	bcc.n	800fe96 <xQueueGenericSendFromISR+0x44>
			xReturn = errQUEUE_FULL;
 800fe90:	2500      	movs	r5, #0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800fe92:	2e02      	cmp	r6, #2
 800fe94:	d116      	bne.n	800fec4 <xQueueGenericSendFromISR+0x72>
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800fe96:	0032      	movs	r2, r6
 800fe98:	9900      	ldr	r1, [sp, #0]
 800fe9a:	0020      	movs	r0, r4
 800fe9c:	f7ff fe37 	bl	800fb0e <prvCopyDataToQueue>
			if( pxQueue->xTxLock == queueUNLOCKED )
 800fea0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800fea2:	3301      	adds	r3, #1
 800fea4:	d113      	bne.n	800fece <xQueueGenericSendFromISR+0x7c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800fea6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fea8:	2b00      	cmp	r3, #0
 800feaa:	d101      	bne.n	800feb0 <xQueueGenericSendFromISR+0x5e>
			xReturn = pdPASS;
 800feac:	2501      	movs	r5, #1
 800feae:	e009      	b.n	800fec4 <xQueueGenericSendFromISR+0x72>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800feb0:	0020      	movs	r0, r4
 800feb2:	3024      	adds	r0, #36	; 0x24
 800feb4:	f000 fd90 	bl	80109d8 <xTaskRemoveFromEventList>
 800feb8:	2800      	cmp	r0, #0
 800feba:	d0f7      	beq.n	800feac <xQueueGenericSendFromISR+0x5a>
							if( pxHigherPriorityTaskWoken != NULL )
 800febc:	2f00      	cmp	r7, #0
 800febe:	d0f5      	beq.n	800feac <xQueueGenericSendFromISR+0x5a>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800fec0:	2501      	movs	r5, #1
 800fec2:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800fec4:	9801      	ldr	r0, [sp, #4]
 800fec6:	f001 f9f0 	bl	80112aa <vClearInterruptMaskFromISR>
}
 800feca:	0028      	movs	r0, r5
 800fecc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				++( pxQueue->xTxLock );
 800fece:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800fed0:	3301      	adds	r3, #1
 800fed2:	64a3      	str	r3, [r4, #72]	; 0x48
 800fed4:	e7ea      	b.n	800feac <xQueueGenericSendFromISR+0x5a>

0800fed6 <xQueueGiveFromISR>:
{
 800fed6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fed8:	0004      	movs	r4, r0
 800feda:	000f      	movs	r7, r1
	configASSERT( pxQueue );
 800fedc:	2800      	cmp	r0, #0
 800fede:	d101      	bne.n	800fee4 <xQueueGiveFromISR+0xe>
 800fee0:	b672      	cpsid	i
 800fee2:	e7fe      	b.n	800fee2 <xQueueGiveFromISR+0xc>
	configASSERT( pxQueue->uxItemSize == 0 );
 800fee4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800fee6:	2b00      	cmp	r3, #0
 800fee8:	d001      	beq.n	800feee <xQueueGiveFromISR+0x18>
 800feea:	b672      	cpsid	i
 800feec:	e7fe      	b.n	800feec <xQueueGiveFromISR+0x16>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 800feee:	6803      	ldr	r3, [r0, #0]
 800fef0:	2b00      	cmp	r3, #0
 800fef2:	d104      	bne.n	800fefe <xQueueGiveFromISR+0x28>
 800fef4:	6843      	ldr	r3, [r0, #4]
 800fef6:	2b00      	cmp	r3, #0
 800fef8:	d001      	beq.n	800fefe <xQueueGiveFromISR+0x28>
 800fefa:	b672      	cpsid	i
 800fefc:	e7fe      	b.n	800fefc <xQueueGiveFromISR+0x26>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800fefe:	f001 f9cf 	bl	80112a0 <ulSetInterruptMaskFromISR>
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800ff02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ff04:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800ff06:	0006      	movs	r6, r0
			xReturn = errQUEUE_FULL;
 800ff08:	2500      	movs	r5, #0
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800ff0a:	4293      	cmp	r3, r2
 800ff0c:	d214      	bcs.n	800ff38 <xQueueGiveFromISR+0x62>
			++( pxQueue->uxMessagesWaiting );
 800ff0e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ff10:	3301      	adds	r3, #1
 800ff12:	63a3      	str	r3, [r4, #56]	; 0x38
			if( pxQueue->xTxLock == queueUNLOCKED )
 800ff14:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800ff16:	3301      	adds	r3, #1
 800ff18:	d113      	bne.n	800ff42 <xQueueGiveFromISR+0x6c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800ff1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ff1c:	42ab      	cmp	r3, r5
 800ff1e:	d101      	bne.n	800ff24 <xQueueGiveFromISR+0x4e>
			xReturn = pdPASS;
 800ff20:	2501      	movs	r5, #1
 800ff22:	e009      	b.n	800ff38 <xQueueGiveFromISR+0x62>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ff24:	0020      	movs	r0, r4
 800ff26:	3024      	adds	r0, #36	; 0x24
 800ff28:	f000 fd56 	bl	80109d8 <xTaskRemoveFromEventList>
 800ff2c:	2800      	cmp	r0, #0
 800ff2e:	d0f7      	beq.n	800ff20 <xQueueGiveFromISR+0x4a>
							if( pxHigherPriorityTaskWoken != NULL )
 800ff30:	2f00      	cmp	r7, #0
 800ff32:	d0f5      	beq.n	800ff20 <xQueueGiveFromISR+0x4a>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800ff34:	2501      	movs	r5, #1
 800ff36:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800ff38:	0030      	movs	r0, r6
 800ff3a:	f001 f9b6 	bl	80112aa <vClearInterruptMaskFromISR>
}
 800ff3e:	0028      	movs	r0, r5
 800ff40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				++( pxQueue->xTxLock );
 800ff42:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800ff44:	3301      	adds	r3, #1
 800ff46:	64a3      	str	r3, [r4, #72]	; 0x48
 800ff48:	e7ea      	b.n	800ff20 <xQueueGiveFromISR+0x4a>

0800ff4a <xQueueGenericReceive>:
{
 800ff4a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ff4c:	b085      	sub	sp, #20
 800ff4e:	0004      	movs	r4, r0
 800ff50:	000f      	movs	r7, r1
 800ff52:	9201      	str	r2, [sp, #4]
 800ff54:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
 800ff56:	2800      	cmp	r0, #0
 800ff58:	d101      	bne.n	800ff5e <xQueueGenericReceive+0x14>
 800ff5a:	b672      	cpsid	i
 800ff5c:	e7fe      	b.n	800ff5c <xQueueGenericReceive+0x12>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800ff5e:	2900      	cmp	r1, #0
 800ff60:	d104      	bne.n	800ff6c <xQueueGenericReceive+0x22>
 800ff62:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800ff64:	2b00      	cmp	r3, #0
 800ff66:	d001      	beq.n	800ff6c <xQueueGenericReceive+0x22>
 800ff68:	b672      	cpsid	i
 800ff6a:	e7fe      	b.n	800ff6a <xQueueGenericReceive+0x20>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800ff6c:	f000 fdb6 	bl	8010adc <xTaskGetSchedulerState>
 800ff70:	2800      	cmp	r0, #0
 800ff72:	d104      	bne.n	800ff7e <xQueueGenericReceive+0x34>
 800ff74:	9e01      	ldr	r6, [sp, #4]
 800ff76:	2e00      	cmp	r6, #0
 800ff78:	d05a      	beq.n	8010030 <xQueueGenericReceive+0xe6>
 800ff7a:	b672      	cpsid	i
 800ff7c:	e7fe      	b.n	800ff7c <xQueueGenericReceive+0x32>
 800ff7e:	2600      	movs	r6, #0
 800ff80:	e056      	b.n	8010030 <xQueueGenericReceive+0xe6>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800ff82:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800ff84:	60e5      	str	r5, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800ff86:	2b00      	cmp	r3, #0
 800ff88:	d073      	beq.n	8010072 <xQueueGenericReceive+0x128>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ff8a:	0020      	movs	r0, r4
 800ff8c:	3024      	adds	r0, #36	; 0x24
 800ff8e:	f000 fd23 	bl	80109d8 <xTaskRemoveFromEventList>
 800ff92:	2800      	cmp	r0, #0
 800ff94:	d06d      	beq.n	8010072 <xQueueGenericReceive+0x128>
 800ff96:	e06a      	b.n	801006e <xQueueGenericReceive+0x124>
				if( xTicksToWait == ( TickType_t ) 0 )
 800ff98:	9d01      	ldr	r5, [sp, #4]
 800ff9a:	2d00      	cmp	r5, #0
 800ff9c:	d103      	bne.n	800ffa6 <xQueueGenericReceive+0x5c>
					taskEXIT_CRITICAL();
 800ff9e:	f001 f971 	bl	8011284 <vPortExitCritical>
			return errQUEUE_EMPTY;
 800ffa2:	2000      	movs	r0, #0
 800ffa4:	e068      	b.n	8010078 <xQueueGenericReceive+0x12e>
				else if( xEntryTimeSet == pdFALSE )
 800ffa6:	2e00      	cmp	r6, #0
 800ffa8:	d102      	bne.n	800ffb0 <xQueueGenericReceive+0x66>
					vTaskSetTimeOutState( &xTimeOut );
 800ffaa:	a802      	add	r0, sp, #8
 800ffac:	f000 fd50 	bl	8010a50 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800ffb0:	f001 f968 	bl	8011284 <vPortExitCritical>
		vTaskSuspendAll();
 800ffb4:	f000 fae8 	bl	8010588 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800ffb8:	f001 f958 	bl	801126c <vPortEnterCritical>
 800ffbc:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800ffbe:	3301      	adds	r3, #1
 800ffc0:	d101      	bne.n	800ffc6 <xQueueGenericReceive+0x7c>
 800ffc2:	2300      	movs	r3, #0
 800ffc4:	6463      	str	r3, [r4, #68]	; 0x44
 800ffc6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800ffc8:	3301      	adds	r3, #1
 800ffca:	d101      	bne.n	800ffd0 <xQueueGenericReceive+0x86>
 800ffcc:	2300      	movs	r3, #0
 800ffce:	64a3      	str	r3, [r4, #72]	; 0x48
 800ffd0:	f001 f958 	bl	8011284 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800ffd4:	a901      	add	r1, sp, #4
 800ffd6:	a802      	add	r0, sp, #8
 800ffd8:	f000 fd4a 	bl	8010a70 <xTaskCheckForTimeOut>
 800ffdc:	2800      	cmp	r0, #0
 800ffde:	d14d      	bne.n	801007c <xQueueGenericReceive+0x132>
	taskENTER_CRITICAL();
 800ffe0:	f001 f944 	bl	801126c <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800ffe4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ffe6:	2b00      	cmp	r3, #0
 800ffe8:	d11a      	bne.n	8010020 <xQueueGenericReceive+0xd6>
	taskEXIT_CRITICAL();
 800ffea:	f001 f94b 	bl	8011284 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800ffee:	6823      	ldr	r3, [r4, #0]
 800fff0:	2b00      	cmp	r3, #0
 800fff2:	d106      	bne.n	8010002 <xQueueGenericReceive+0xb8>
						taskENTER_CRITICAL();
 800fff4:	f001 f93a 	bl	801126c <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800fff8:	6860      	ldr	r0, [r4, #4]
 800fffa:	f000 fd7f 	bl	8010afc <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 800fffe:	f001 f941 	bl	8011284 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8010002:	0020      	movs	r0, r4
 8010004:	9901      	ldr	r1, [sp, #4]
 8010006:	3024      	adds	r0, #36	; 0x24
 8010008:	f000 fca8 	bl	801095c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 801000c:	0020      	movs	r0, r4
 801000e:	f7ff fdc9 	bl	800fba4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8010012:	f000 fb4f 	bl	80106b4 <xTaskResumeAll>
 8010016:	2800      	cmp	r0, #0
 8010018:	d109      	bne.n	801002e <xQueueGenericReceive+0xe4>
					portYIELD_WITHIN_API();
 801001a:	f001 f91b 	bl	8011254 <vPortYield>
 801001e:	e006      	b.n	801002e <xQueueGenericReceive+0xe4>
	taskEXIT_CRITICAL();
 8010020:	f001 f930 	bl	8011284 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8010024:	0020      	movs	r0, r4
 8010026:	f7ff fdbd 	bl	800fba4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 801002a:	f000 fb43 	bl	80106b4 <xTaskResumeAll>
 801002e:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8010030:	f001 f91c 	bl	801126c <vPortEnterCritical>
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8010034:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8010036:	2b00      	cmp	r3, #0
 8010038:	d0ae      	beq.n	800ff98 <xQueueGenericReceive+0x4e>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 801003a:	0039      	movs	r1, r7
 801003c:	0020      	movs	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 801003e:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8010040:	f7ff fd9e 	bl	800fb80 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 8010044:	9b00      	ldr	r3, [sp, #0]
 8010046:	2b00      	cmp	r3, #0
 8010048:	d19b      	bne.n	800ff82 <xQueueGenericReceive+0x38>
					--( pxQueue->uxMessagesWaiting );
 801004a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801004c:	3b01      	subs	r3, #1
 801004e:	63a3      	str	r3, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8010050:	6823      	ldr	r3, [r4, #0]
 8010052:	2b00      	cmp	r3, #0
 8010054:	d102      	bne.n	801005c <xQueueGenericReceive+0x112>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8010056:	f000 fe61 	bl	8010d1c <pvTaskIncrementMutexHeldCount>
 801005a:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801005c:	6923      	ldr	r3, [r4, #16]
 801005e:	2b00      	cmp	r3, #0
 8010060:	d007      	beq.n	8010072 <xQueueGenericReceive+0x128>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8010062:	0020      	movs	r0, r4
 8010064:	3010      	adds	r0, #16
 8010066:	f000 fcb7 	bl	80109d8 <xTaskRemoveFromEventList>
 801006a:	2801      	cmp	r0, #1
 801006c:	d101      	bne.n	8010072 <xQueueGenericReceive+0x128>
							queueYIELD_IF_USING_PREEMPTION();
 801006e:	f001 f8f1 	bl	8011254 <vPortYield>
				taskEXIT_CRITICAL();
 8010072:	f001 f907 	bl	8011284 <vPortExitCritical>
				return pdPASS;
 8010076:	2001      	movs	r0, #1
}
 8010078:	b005      	add	sp, #20
 801007a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 801007c:	0020      	movs	r0, r4
 801007e:	f7ff fd91 	bl	800fba4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8010082:	f000 fb17 	bl	80106b4 <xTaskResumeAll>
 8010086:	e78c      	b.n	800ffa2 <xQueueGenericReceive+0x58>

08010088 <xQueueReceiveFromISR>:
{
 8010088:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801008a:	0004      	movs	r4, r0
 801008c:	000f      	movs	r7, r1
 801008e:	0016      	movs	r6, r2
	configASSERT( pxQueue );
 8010090:	2800      	cmp	r0, #0
 8010092:	d101      	bne.n	8010098 <xQueueReceiveFromISR+0x10>
 8010094:	b672      	cpsid	i
 8010096:	e7fe      	b.n	8010096 <xQueueReceiveFromISR+0xe>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8010098:	2900      	cmp	r1, #0
 801009a:	d104      	bne.n	80100a6 <xQueueReceiveFromISR+0x1e>
 801009c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 801009e:	2b00      	cmp	r3, #0
 80100a0:	d001      	beq.n	80100a6 <xQueueReceiveFromISR+0x1e>
 80100a2:	b672      	cpsid	i
 80100a4:	e7fe      	b.n	80100a4 <xQueueReceiveFromISR+0x1c>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80100a6:	f001 f8fb 	bl	80112a0 <ulSetInterruptMaskFromISR>
			xReturn = pdFAIL;
 80100aa:	2500      	movs	r5, #0
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80100ac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80100ae:	9001      	str	r0, [sp, #4]
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80100b0:	42ab      	cmp	r3, r5
 80100b2:	d018      	beq.n	80100e6 <xQueueReceiveFromISR+0x5e>
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80100b4:	0039      	movs	r1, r7
 80100b6:	0020      	movs	r0, r4
 80100b8:	f7ff fd62 	bl	800fb80 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 80100bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80100be:	3b01      	subs	r3, #1
 80100c0:	63a3      	str	r3, [r4, #56]	; 0x38
			if( pxQueue->xRxLock == queueUNLOCKED )
 80100c2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80100c4:	3301      	adds	r3, #1
 80100c6:	d113      	bne.n	80100f0 <xQueueReceiveFromISR+0x68>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80100c8:	6923      	ldr	r3, [r4, #16]
 80100ca:	42ab      	cmp	r3, r5
 80100cc:	d101      	bne.n	80100d2 <xQueueReceiveFromISR+0x4a>
			xReturn = pdPASS;
 80100ce:	2501      	movs	r5, #1
 80100d0:	e009      	b.n	80100e6 <xQueueReceiveFromISR+0x5e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80100d2:	0020      	movs	r0, r4
 80100d4:	3010      	adds	r0, #16
 80100d6:	f000 fc7f 	bl	80109d8 <xTaskRemoveFromEventList>
 80100da:	2800      	cmp	r0, #0
 80100dc:	d0f7      	beq.n	80100ce <xQueueReceiveFromISR+0x46>
						if( pxHigherPriorityTaskWoken != NULL )
 80100de:	2e00      	cmp	r6, #0
 80100e0:	d0f5      	beq.n	80100ce <xQueueReceiveFromISR+0x46>
							*pxHigherPriorityTaskWoken = pdTRUE;
 80100e2:	2501      	movs	r5, #1
 80100e4:	6035      	str	r5, [r6, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80100e6:	9801      	ldr	r0, [sp, #4]
 80100e8:	f001 f8df 	bl	80112aa <vClearInterruptMaskFromISR>
}
 80100ec:	0028      	movs	r0, r5
 80100ee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				++( pxQueue->xRxLock );
 80100f0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80100f2:	3301      	adds	r3, #1
 80100f4:	6463      	str	r3, [r4, #68]	; 0x44
 80100f6:	e7ea      	b.n	80100ce <xQueueReceiveFromISR+0x46>

080100f8 <vQueueAddToRegistry>:
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80100f8:	2300      	movs	r3, #0
	{
 80100fa:	b570      	push	{r4, r5, r6, lr}
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 80100fc:	4a06      	ldr	r2, [pc, #24]	; (8010118 <vQueueAddToRegistry+0x20>)
 80100fe:	00dd      	lsls	r5, r3, #3
 8010100:	18ac      	adds	r4, r5, r2
 8010102:	6826      	ldr	r6, [r4, #0]
 8010104:	2e00      	cmp	r6, #0
 8010106:	d102      	bne.n	801010e <vQueueAddToRegistry+0x16>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8010108:	50a9      	str	r1, [r5, r2]
				xQueueRegistry[ ux ].xHandle = xQueue;
 801010a:	6060      	str	r0, [r4, #4]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 801010c:	bd70      	pop	{r4, r5, r6, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 801010e:	3301      	adds	r3, #1
 8010110:	2b08      	cmp	r3, #8
 8010112:	d1f4      	bne.n	80100fe <vQueueAddToRegistry+0x6>
 8010114:	e7fa      	b.n	801010c <vQueueAddToRegistry+0x14>
 8010116:	46c0      	nop			; (mov r8, r8)
 8010118:	20007a78 	.word	0x20007a78

0801011c <vQueueUnregisterQueue>:
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 801011c:	2300      	movs	r3, #0
	{
 801011e:	b510      	push	{r4, lr}
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 8010120:	4a06      	ldr	r2, [pc, #24]	; (801013c <vQueueUnregisterQueue+0x20>)
 8010122:	00d9      	lsls	r1, r3, #3
 8010124:	188c      	adds	r4, r1, r2
 8010126:	6864      	ldr	r4, [r4, #4]
 8010128:	4284      	cmp	r4, r0
 801012a:	d102      	bne.n	8010132 <vQueueUnregisterQueue+0x16>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 801012c:	2300      	movs	r3, #0
 801012e:	508b      	str	r3, [r1, r2]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8010130:	bd10      	pop	{r4, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8010132:	3301      	adds	r3, #1
 8010134:	2b08      	cmp	r3, #8
 8010136:	d1f4      	bne.n	8010122 <vQueueUnregisterQueue+0x6>
 8010138:	e7fa      	b.n	8010130 <vQueueUnregisterQueue+0x14>
 801013a:	46c0      	nop			; (mov r8, r8)
 801013c:	20007a78 	.word	0x20007a78

08010140 <vQueueDelete>:
{
 8010140:	b510      	push	{r4, lr}
 8010142:	1e04      	subs	r4, r0, #0
	configASSERT( pxQueue );
 8010144:	d101      	bne.n	801014a <vQueueDelete+0xa>
 8010146:	b672      	cpsid	i
 8010148:	e7fe      	b.n	8010148 <vQueueDelete+0x8>
		vQueueUnregisterQueue( pxQueue );
 801014a:	f7ff ffe7 	bl	801011c <vQueueUnregisterQueue>
	vPortFree( pxQueue );
 801014e:	0020      	movs	r0, r4
 8010150:	f001 f988 	bl	8011464 <vPortFree>
}
 8010154:	bd10      	pop	{r4, pc}

08010156 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
 8010156:	b570      	push	{r4, r5, r6, lr}
 8010158:	0004      	movs	r4, r0
 801015a:	000d      	movs	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 801015c:	f001 f886 	bl	801126c <vPortEnterCritical>
 8010160:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8010162:	3301      	adds	r3, #1
 8010164:	d101      	bne.n	801016a <vQueueWaitForMessageRestricted+0x14>
 8010166:	2300      	movs	r3, #0
 8010168:	6463      	str	r3, [r4, #68]	; 0x44
 801016a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 801016c:	3301      	adds	r3, #1
 801016e:	d101      	bne.n	8010174 <vQueueWaitForMessageRestricted+0x1e>
 8010170:	2300      	movs	r3, #0
 8010172:	64a3      	str	r3, [r4, #72]	; 0x48
 8010174:	f001 f886 	bl	8011284 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8010178:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801017a:	2b00      	cmp	r3, #0
 801017c:	d104      	bne.n	8010188 <vQueueWaitForMessageRestricted+0x32>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 801017e:	0020      	movs	r0, r4
 8010180:	0029      	movs	r1, r5
 8010182:	3024      	adds	r0, #36	; 0x24
 8010184:	f000 fc0e 	bl	80109a4 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8010188:	0020      	movs	r0, r4
 801018a:	f7ff fd0b 	bl	800fba4 <prvUnlockQueue>
	}
 801018e:	bd70      	pop	{r4, r5, r6, pc}

08010190 <prvWriteNameToBuffer>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
	{
 8010190:	b510      	push	{r4, lr}
 8010192:	0004      	movs	r4, r0
	BaseType_t x;

		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );
 8010194:	f004 fc9e 	bl	8014ad4 <strcpy>

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
 8010198:	0020      	movs	r0, r4
 801019a:	f7ef ffbd 	bl	8000118 <strlen>
		{
			pcBuffer[ x ] = ' ';
 801019e:	2220      	movs	r2, #32
 80101a0:	1820      	adds	r0, r4, r0
		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
 80101a2:	1b03      	subs	r3, r0, r4
 80101a4:	2b0b      	cmp	r3, #11
 80101a6:	dd02      	ble.n	80101ae <prvWriteNameToBuffer+0x1e>
		}

		/* Terminate. */
		pcBuffer[ x ] = 0x00;
 80101a8:	2300      	movs	r3, #0
 80101aa:	7003      	strb	r3, [r0, #0]

		/* Return the new end of string. */
		return &( pcBuffer[ x ] );
	}
 80101ac:	bd10      	pop	{r4, pc}
			pcBuffer[ x ] = ' ';
 80101ae:	7002      	strb	r2, [r0, #0]
 80101b0:	3001      	adds	r0, #1
 80101b2:	e7f6      	b.n	80101a2 <prvWriteNameToBuffer+0x12>

080101b4 <prvResetNextTaskUnblockTime>:
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80101b4:	4a07      	ldr	r2, [pc, #28]	; (80101d4 <prvResetNextTaskUnblockTime+0x20>)
 80101b6:	6813      	ldr	r3, [r2, #0]
 80101b8:	6819      	ldr	r1, [r3, #0]
 80101ba:	4b07      	ldr	r3, [pc, #28]	; (80101d8 <prvResetNextTaskUnblockTime+0x24>)
 80101bc:	2900      	cmp	r1, #0
 80101be:	d103      	bne.n	80101c8 <prvResetNextTaskUnblockTime+0x14>
		xNextTaskUnblockTime = portMAX_DELAY;
 80101c0:	2201      	movs	r2, #1
 80101c2:	4252      	negs	r2, r2
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 80101c4:	601a      	str	r2, [r3, #0]
}
 80101c6:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80101c8:	6812      	ldr	r2, [r2, #0]
 80101ca:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 80101cc:	68d2      	ldr	r2, [r2, #12]
 80101ce:	6852      	ldr	r2, [r2, #4]
 80101d0:	e7f8      	b.n	80101c4 <prvResetNextTaskUnblockTime+0x10>
 80101d2:	46c0      	nop			; (mov r8, r8)
 80101d4:	20001f24 	.word	0x20001f24
 80101d8:	200000c8 	.word	0x200000c8

080101dc <prvAddCurrentTaskToDelayedList>:
{
 80101dc:	b510      	push	{r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80101de:	4b0d      	ldr	r3, [pc, #52]	; (8010214 <prvAddCurrentTaskToDelayedList+0x38>)
{
 80101e0:	0004      	movs	r4, r0
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80101e2:	681a      	ldr	r2, [r3, #0]
 80101e4:	6050      	str	r0, [r2, #4]
	if( xTimeToWake < xTickCount )
 80101e6:	4a0c      	ldr	r2, [pc, #48]	; (8010218 <prvAddCurrentTaskToDelayedList+0x3c>)
 80101e8:	6812      	ldr	r2, [r2, #0]
 80101ea:	4282      	cmp	r2, r0
 80101ec:	d906      	bls.n	80101fc <prvAddCurrentTaskToDelayedList+0x20>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80101ee:	4a0b      	ldr	r2, [pc, #44]	; (801021c <prvAddCurrentTaskToDelayedList+0x40>)
 80101f0:	6810      	ldr	r0, [r2, #0]
 80101f2:	6819      	ldr	r1, [r3, #0]
 80101f4:	3104      	adds	r1, #4
 80101f6:	f7ff fc61 	bl	800fabc <vListInsert>
}
 80101fa:	bd10      	pop	{r4, pc}
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80101fc:	4a08      	ldr	r2, [pc, #32]	; (8010220 <prvAddCurrentTaskToDelayedList+0x44>)
 80101fe:	6810      	ldr	r0, [r2, #0]
 8010200:	6819      	ldr	r1, [r3, #0]
 8010202:	3104      	adds	r1, #4
 8010204:	f7ff fc5a 	bl	800fabc <vListInsert>
		if( xTimeToWake < xNextTaskUnblockTime )
 8010208:	4b06      	ldr	r3, [pc, #24]	; (8010224 <prvAddCurrentTaskToDelayedList+0x48>)
 801020a:	681a      	ldr	r2, [r3, #0]
 801020c:	42a2      	cmp	r2, r4
 801020e:	d9f4      	bls.n	80101fa <prvAddCurrentTaskToDelayedList+0x1e>
			xNextTaskUnblockTime = xTimeToWake;
 8010210:	601c      	str	r4, [r3, #0]
}
 8010212:	e7f2      	b.n	80101fa <prvAddCurrentTaskToDelayedList+0x1e>
 8010214:	20001f20 	.word	0x20001f20
 8010218:	20002040 	.word	0x20002040
 801021c:	20001f28 	.word	0x20001f28
 8010220:	20001f24 	.word	0x20001f24
 8010224:	200000c8 	.word	0x200000c8

08010228 <xTaskGenericCreate.part.5>:
BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
 8010228:	b5f0      	push	{r4, r5, r6, r7, lr}
 801022a:	b085      	sub	sp, #20
 801022c:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 801022e:	9002      	str	r0, [sp, #8]
 8010230:	000e      	movs	r6, r1
 8010232:	0014      	movs	r4, r2
 8010234:	9303      	str	r3, [sp, #12]
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8010236:	2f00      	cmp	r7, #0
 8010238:	d105      	bne.n	8010246 <xTaskGenericCreate.part.5+0x1e>
 801023a:	0090      	lsls	r0, r2, #2
 801023c:	f001 f892 	bl	8011364 <pvPortMalloc>
 8010240:	1e07      	subs	r7, r0, #0
		if( pxStack != NULL )
 8010242:	d100      	bne.n	8010246 <xTaskGenericCreate.part.5+0x1e>
 8010244:	e098      	b.n	8010378 <xTaskGenericCreate.part.5+0x150>
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8010246:	2060      	movs	r0, #96	; 0x60
 8010248:	f001 f88c 	bl	8011364 <pvPortMalloc>
 801024c:	1e05      	subs	r5, r0, #0
			if( pxNewTCB != NULL )
 801024e:	d100      	bne.n	8010252 <xTaskGenericCreate.part.5+0x2a>
 8010250:	e08f      	b.n	8010372 <xTaskGenericCreate.part.5+0x14a>
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 8010252:	00a4      	lsls	r4, r4, #2
				pxNewTCB->pxStack = pxStack;
 8010254:	6307      	str	r7, [r0, #48]	; 0x30
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 8010256:	0022      	movs	r2, r4
 8010258:	21a5      	movs	r1, #165	; 0xa5
 801025a:	0038      	movs	r0, r7
 801025c:	f004 fa03 	bl	8014666 <memset>
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8010260:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8010262:	3c04      	subs	r4, #4
 8010264:	191c      	adds	r4, r3, r4
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8010266:	2307      	movs	r3, #7
 8010268:	439c      	bics	r4, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 801026a:	2300      	movs	r3, #0
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 801026c:	9400      	str	r4, [sp, #0]
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 801026e:	001a      	movs	r2, r3
 8010270:	5cf1      	ldrb	r1, [r6, r3]
 8010272:	3234      	adds	r2, #52	; 0x34
 8010274:	54a9      	strb	r1, [r5, r2]
		if( pcName[ x ] == 0x00 )
 8010276:	5cf2      	ldrb	r2, [r6, r3]
 8010278:	2a00      	cmp	r2, #0
 801027a:	d002      	beq.n	8010282 <xTaskGenericCreate.part.5+0x5a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 801027c:	3301      	adds	r3, #1
 801027e:	2b0d      	cmp	r3, #13
 8010280:	d1f5      	bne.n	801026e <xTaskGenericCreate.part.5+0x46>
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8010282:	002b      	movs	r3, r5
 8010284:	2700      	movs	r7, #0
 8010286:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8010288:	3340      	adds	r3, #64	; 0x40
 801028a:	701f      	strb	r7, [r3, #0]
 801028c:	2c06      	cmp	r4, #6
 801028e:	d900      	bls.n	8010292 <xTaskGenericCreate.part.5+0x6a>
 8010290:	2406      	movs	r4, #6
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8010292:	1d2b      	adds	r3, r5, #4
 8010294:	0018      	movs	r0, r3
	pxTCB->uxPriority = uxPriority;
 8010296:	62ec      	str	r4, [r5, #44]	; 0x2c
		pxTCB->uxBasePriority = uxPriority;
 8010298:	64ec      	str	r4, [r5, #76]	; 0x4c
		pxTCB->uxMutexesHeld = 0;
 801029a:	652f      	str	r7, [r5, #80]	; 0x50
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 801029c:	9301      	str	r3, [sp, #4]
 801029e:	f7ff fbfe 	bl	800fa9e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 80102a2:	0028      	movs	r0, r5
 80102a4:	3018      	adds	r0, #24
 80102a6:	f7ff fbfa 	bl	800fa9e <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80102aa:	2307      	movs	r3, #7
 80102ac:	1b1c      	subs	r4, r3, r4
		pxTCB->eNotifyState = eNotWaitingNotification;
 80102ae:	002b      	movs	r3, r5
 80102b0:	335c      	adds	r3, #92	; 0x5c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 80102b2:	612d      	str	r5, [r5, #16]
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80102b4:	61ac      	str	r4, [r5, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 80102b6:	626d      	str	r5, [r5, #36]	; 0x24
		pxTCB->ulRunTimeCounter = 0UL;
 80102b8:	656f      	str	r7, [r5, #84]	; 0x54
		pxTCB->ulNotifiedValue = 0;
 80102ba:	65af      	str	r7, [r5, #88]	; 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80102bc:	9a03      	ldr	r2, [sp, #12]
		pxTCB->eNotifyState = eNotWaitingNotification;
 80102be:	701f      	strb	r7, [r3, #0]
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80102c0:	9902      	ldr	r1, [sp, #8]
 80102c2:	9800      	ldr	r0, [sp, #0]
 80102c4:	f000 ff8a 	bl	80111dc <pxPortInitialiseStack>
		if( ( void * ) pxCreatedTask != NULL )
 80102c8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80102ca:	6028      	str	r0, [r5, #0]
		if( ( void * ) pxCreatedTask != NULL )
 80102cc:	2b00      	cmp	r3, #0
 80102ce:	d000      	beq.n	80102d2 <xTaskGenericCreate.part.5+0xaa>
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80102d0:	601d      	str	r5, [r3, #0]
		taskENTER_CRITICAL();
 80102d2:	f000 ffcb 	bl	801126c <vPortEnterCritical>
			uxCurrentNumberOfTasks++;
 80102d6:	4b2f      	ldr	r3, [pc, #188]	; (8010394 <xTaskGenericCreate.part.5+0x16c>)
			if( pxCurrentTCB == NULL )
 80102d8:	4c2f      	ldr	r4, [pc, #188]	; (8010398 <xTaskGenericCreate.part.5+0x170>)
			uxCurrentNumberOfTasks++;
 80102da:	681a      	ldr	r2, [r3, #0]
 80102dc:	3201      	adds	r2, #1
 80102de:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
 80102e0:	6826      	ldr	r6, [r4, #0]
 80102e2:	2e00      	cmp	r6, #0
 80102e4:	d14b      	bne.n	801037e <xTaskGenericCreate.part.5+0x156>
				pxCurrentTCB =  pxNewTCB;
 80102e6:	6025      	str	r5, [r4, #0]
				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 80102e8:	681b      	ldr	r3, [r3, #0]
 80102ea:	2b01      	cmp	r3, #1
 80102ec:	d11e      	bne.n	801032c <xTaskGenericCreate.part.5+0x104>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80102ee:	2714      	movs	r7, #20
 80102f0:	0038      	movs	r0, r7
 80102f2:	4370      	muls	r0, r6
 80102f4:	4b29      	ldr	r3, [pc, #164]	; (801039c <xTaskGenericCreate.part.5+0x174>)
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80102f6:	3601      	adds	r6, #1
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80102f8:	1818      	adds	r0, r3, r0
 80102fa:	f7ff fbc5 	bl	800fa88 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80102fe:	2e07      	cmp	r6, #7
 8010300:	d1f6      	bne.n	80102f0 <xTaskGenericCreate.part.5+0xc8>
	vListInitialise( &xDelayedTaskList1 );
 8010302:	4f27      	ldr	r7, [pc, #156]	; (80103a0 <xTaskGenericCreate.part.5+0x178>)
 8010304:	0038      	movs	r0, r7
 8010306:	f7ff fbbf 	bl	800fa88 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 801030a:	4e26      	ldr	r6, [pc, #152]	; (80103a4 <xTaskGenericCreate.part.5+0x17c>)
 801030c:	0030      	movs	r0, r6
 801030e:	f7ff fbbb 	bl	800fa88 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8010312:	4825      	ldr	r0, [pc, #148]	; (80103a8 <xTaskGenericCreate.part.5+0x180>)
 8010314:	f7ff fbb8 	bl	800fa88 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8010318:	4824      	ldr	r0, [pc, #144]	; (80103ac <xTaskGenericCreate.part.5+0x184>)
 801031a:	f7ff fbb5 	bl	800fa88 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 801031e:	4824      	ldr	r0, [pc, #144]	; (80103b0 <xTaskGenericCreate.part.5+0x188>)
 8010320:	f7ff fbb2 	bl	800fa88 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8010324:	4b23      	ldr	r3, [pc, #140]	; (80103b4 <xTaskGenericCreate.part.5+0x18c>)
 8010326:	601f      	str	r7, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8010328:	4b23      	ldr	r3, [pc, #140]	; (80103b8 <xTaskGenericCreate.part.5+0x190>)
 801032a:	601e      	str	r6, [r3, #0]
			uxTaskNumber++;
 801032c:	4a23      	ldr	r2, [pc, #140]	; (80103bc <xTaskGenericCreate.part.5+0x194>)
 801032e:	6813      	ldr	r3, [r2, #0]
 8010330:	3301      	adds	r3, #1
 8010332:	6013      	str	r3, [r2, #0]
			prvAddTaskToReadyList( pxNewTCB );
 8010334:	4a22      	ldr	r2, [pc, #136]	; (80103c0 <xTaskGenericCreate.part.5+0x198>)
				pxNewTCB->uxTCBNumber = uxTaskNumber;
 8010336:	646b      	str	r3, [r5, #68]	; 0x44
			prvAddTaskToReadyList( pxNewTCB );
 8010338:	6811      	ldr	r1, [r2, #0]
 801033a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 801033c:	428b      	cmp	r3, r1
 801033e:	d900      	bls.n	8010342 <xTaskGenericCreate.part.5+0x11a>
 8010340:	6013      	str	r3, [r2, #0]
 8010342:	2014      	movs	r0, #20
 8010344:	4358      	muls	r0, r3
 8010346:	4b15      	ldr	r3, [pc, #84]	; (801039c <xTaskGenericCreate.part.5+0x174>)
 8010348:	9901      	ldr	r1, [sp, #4]
 801034a:	1818      	adds	r0, r3, r0
 801034c:	f7ff fbaa 	bl	800faa4 <vListInsertEnd>
		taskEXIT_CRITICAL();
 8010350:	f000 ff98 	bl	8011284 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8010354:	4b1b      	ldr	r3, [pc, #108]	; (80103c4 <xTaskGenericCreate.part.5+0x19c>)
			xReturn = pdPASS;
 8010356:	2601      	movs	r6, #1
		if( xSchedulerRunning != pdFALSE )
 8010358:	681b      	ldr	r3, [r3, #0]
 801035a:	2b00      	cmp	r3, #0
 801035c:	d006      	beq.n	801036c <xTaskGenericCreate.part.5+0x144>
			if( pxCurrentTCB->uxPriority < uxPriority )
 801035e:	6823      	ldr	r3, [r4, #0]
 8010360:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010362:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010364:	429a      	cmp	r2, r3
 8010366:	d901      	bls.n	801036c <xTaskGenericCreate.part.5+0x144>
				taskYIELD_IF_USING_PREEMPTION();
 8010368:	f000 ff74 	bl	8011254 <vPortYield>
}
 801036c:	0030      	movs	r0, r6
 801036e:	b005      	add	sp, #20
 8010370:	bdf0      	pop	{r4, r5, r6, r7, pc}
				vPortFree( pxStack );
 8010372:	0038      	movs	r0, r7
 8010374:	f001 f876 	bl	8011464 <vPortFree>
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8010378:	2601      	movs	r6, #1
 801037a:	4276      	negs	r6, r6
 801037c:	e7f6      	b.n	801036c <xTaskGenericCreate.part.5+0x144>
				if( xSchedulerRunning == pdFALSE )
 801037e:	4b11      	ldr	r3, [pc, #68]	; (80103c4 <xTaskGenericCreate.part.5+0x19c>)
 8010380:	681b      	ldr	r3, [r3, #0]
 8010382:	2b00      	cmp	r3, #0
 8010384:	d1d2      	bne.n	801032c <xTaskGenericCreate.part.5+0x104>
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8010386:	6823      	ldr	r3, [r4, #0]
 8010388:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801038a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801038c:	429a      	cmp	r2, r3
 801038e:	d3cd      	bcc.n	801032c <xTaskGenericCreate.part.5+0x104>
						pxCurrentTCB = pxNewTCB;
 8010390:	6025      	str	r5, [r4, #0]
 8010392:	e7cb      	b.n	801032c <xTaskGenericCreate.part.5+0x104>
 8010394:	20001fbc 	.word	0x20001fbc
 8010398:	20001f20 	.word	0x20001f20
 801039c:	20001f2c 	.word	0x20001f2c
 80103a0:	20001fd4 	.word	0x20001fd4
 80103a4:	20001fe8 	.word	0x20001fe8
 80103a8:	20002000 	.word	0x20002000
 80103ac:	2000202c 	.word	0x2000202c
 80103b0:	20002018 	.word	0x20002018
 80103b4:	20001f24 	.word	0x20001f24
 80103b8:	20001f28 	.word	0x20001f28
 80103bc:	20001fc8 	.word	0x20001fc8
 80103c0:	20001fd0 	.word	0x20001fd0
 80103c4:	20002014 	.word	0x20002014

080103c8 <prvListTaskWithinSingleList>:
	{
 80103c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80103ca:	680d      	ldr	r5, [r1, #0]
 80103cc:	2d00      	cmp	r5, #0
 80103ce:	d03a      	beq.n	8010446 <prvListTaskWithinSingleList+0x7e>
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 80103d0:	684b      	ldr	r3, [r1, #4]
 80103d2:	685c      	ldr	r4, [r3, #4]
 80103d4:	2308      	movs	r3, #8
 80103d6:	469c      	mov	ip, r3
 80103d8:	448c      	add	ip, r1
 80103da:	604c      	str	r4, [r1, #4]
 80103dc:	4564      	cmp	r4, ip
 80103de:	d101      	bne.n	80103e4 <prvListTaskWithinSingleList+0x1c>
 80103e0:	68cb      	ldr	r3, [r1, #12]
 80103e2:	604b      	str	r3, [r1, #4]
 80103e4:	684b      	ldr	r3, [r1, #4]
	UBaseType_t uxTask = 0;
 80103e6:	2500      	movs	r5, #0
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 80103e8:	68db      	ldr	r3, [r3, #12]
 80103ea:	9300      	str	r3, [sp, #0]
 80103ec:	0003      	movs	r3, r0
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 80103ee:	6848      	ldr	r0, [r1, #4]
 80103f0:	6840      	ldr	r0, [r0, #4]
 80103f2:	6048      	str	r0, [r1, #4]
 80103f4:	4584      	cmp	ip, r0
 80103f6:	d101      	bne.n	80103fc <prvListTaskWithinSingleList+0x34>
 80103f8:	68c8      	ldr	r0, [r1, #12]
 80103fa:	6048      	str	r0, [r1, #4]
 80103fc:	6848      	ldr	r0, [r1, #4]
 80103fe:	68c4      	ldr	r4, [r0, #12]
				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
 8010400:	0020      	movs	r0, r4
 8010402:	3034      	adds	r0, #52	; 0x34
				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
 8010404:	601c      	str	r4, [r3, #0]
				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
 8010406:	6058      	str	r0, [r3, #4]
				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
 8010408:	6c60      	ldr	r0, [r4, #68]	; 0x44
				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
 801040a:	731a      	strb	r2, [r3, #12]
				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
 801040c:	6098      	str	r0, [r3, #8]
				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
 801040e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8010410:	6118      	str	r0, [r3, #16]
					if( eState == eSuspended )
 8010412:	2a03      	cmp	r2, #3
 8010414:	d104      	bne.n	8010420 <prvListTaskWithinSingleList+0x58>
						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
 8010416:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8010418:	2800      	cmp	r0, #0
 801041a:	d001      	beq.n	8010420 <prvListTaskWithinSingleList+0x58>
							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
 801041c:	2002      	movs	r0, #2
 801041e:	7318      	strb	r0, [r3, #12]
					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
 8010420:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8010422:	6158      	str	r0, [r3, #20]
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
 8010424:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8010426:	6198      	str	r0, [r3, #24]
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
 8010428:	6b27      	ldr	r7, [r4, #48]	; 0x30
 801042a:	0038      	movs	r0, r7
 801042c:	1bc6      	subs	r6, r0, r7
 801042e:	9601      	str	r6, [sp, #4]
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8010430:	7806      	ldrb	r6, [r0, #0]
 8010432:	2ea5      	cmp	r6, #165	; 0xa5
 8010434:	d009      	beq.n	801044a <prvListTaskWithinSingleList+0x82>
		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 8010436:	9801      	ldr	r0, [sp, #4]
				uxTask++;
 8010438:	3501      	adds	r5, #1
		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 801043a:	0886      	lsrs	r6, r0, #2
			} while( pxNextTCB != pxFirstTCB );
 801043c:	9800      	ldr	r0, [sp, #0]
		return ( uint16_t ) ulCount;
 801043e:	839e      	strh	r6, [r3, #28]
 8010440:	3320      	adds	r3, #32
			} while( pxNextTCB != pxFirstTCB );
 8010442:	42a0      	cmp	r0, r4
 8010444:	d1d3      	bne.n	80103ee <prvListTaskWithinSingleList+0x26>
	}
 8010446:	0028      	movs	r0, r5
 8010448:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			pucStackByte -= portSTACK_GROWTH;
 801044a:	3001      	adds	r0, #1
 801044c:	e7ee      	b.n	801042c <prvListTaskWithinSingleList+0x64>

0801044e <xTaskGenericCreate>:
{
 801044e:	b530      	push	{r4, r5, lr}
 8010450:	b085      	sub	sp, #20
 8010452:	9c08      	ldr	r4, [sp, #32]
	configASSERT( pxTaskCode );
 8010454:	2800      	cmp	r0, #0
 8010456:	d101      	bne.n	801045c <xTaskGenericCreate+0xe>
 8010458:	b672      	cpsid	i
 801045a:	e7fe      	b.n	801045a <xTaskGenericCreate+0xc>
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
 801045c:	2c06      	cmp	r4, #6
 801045e:	d901      	bls.n	8010464 <xTaskGenericCreate+0x16>
 8010460:	b672      	cpsid	i
 8010462:	e7fe      	b.n	8010462 <xTaskGenericCreate+0x14>
 8010464:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8010466:	9400      	str	r4, [sp, #0]
 8010468:	9502      	str	r5, [sp, #8]
 801046a:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801046c:	9501      	str	r5, [sp, #4]
 801046e:	f7ff fedb 	bl	8010228 <xTaskGenericCreate.part.5>
}
 8010472:	b005      	add	sp, #20
 8010474:	bd30      	pop	{r4, r5, pc}
	...

08010478 <uxTaskPriorityGet>:
	{
 8010478:	b510      	push	{r4, lr}
 801047a:	0004      	movs	r4, r0
		taskENTER_CRITICAL();
 801047c:	f000 fef6 	bl	801126c <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
 8010480:	2c00      	cmp	r4, #0
 8010482:	d101      	bne.n	8010488 <uxTaskPriorityGet+0x10>
 8010484:	4b03      	ldr	r3, [pc, #12]	; (8010494 <uxTaskPriorityGet+0x1c>)
 8010486:	681c      	ldr	r4, [r3, #0]
			uxReturn = pxTCB->uxPriority;
 8010488:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		taskEXIT_CRITICAL();
 801048a:	f000 fefb 	bl	8011284 <vPortExitCritical>
	}
 801048e:	0020      	movs	r0, r4
 8010490:	bd10      	pop	{r4, pc}
 8010492:	46c0      	nop			; (mov r8, r8)
 8010494:	20001f20 	.word	0x20001f20

08010498 <vTaskPrioritySet>:
	{
 8010498:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801049a:	0004      	movs	r4, r0
 801049c:	000d      	movs	r5, r1
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 801049e:	2906      	cmp	r1, #6
 80104a0:	d901      	bls.n	80104a6 <vTaskPrioritySet+0xe>
 80104a2:	b672      	cpsid	i
 80104a4:	e7fe      	b.n	80104a4 <vTaskPrioritySet+0xc>
		taskENTER_CRITICAL();
 80104a6:	f000 fee1 	bl	801126c <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
 80104aa:	2c00      	cmp	r4, #0
 80104ac:	d101      	bne.n	80104b2 <vTaskPrioritySet+0x1a>
 80104ae:	4b1f      	ldr	r3, [pc, #124]	; (801052c <vTaskPrioritySet+0x94>)
 80104b0:	681c      	ldr	r4, [r3, #0]
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 80104b2:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
			if( uxCurrentBasePriority != uxNewPriority )
 80104b4:	4295      	cmp	r5, r2
 80104b6:	d031      	beq.n	801051c <vTaskPrioritySet+0x84>
 80104b8:	4b1c      	ldr	r3, [pc, #112]	; (801052c <vTaskPrioritySet+0x94>)
				if( uxNewPriority > uxCurrentBasePriority )
 80104ba:	d932      	bls.n	8010522 <vTaskPrioritySet+0x8a>
 80104bc:	2100      	movs	r1, #0
					if( pxTCB != pxCurrentTCB )
 80104be:	6818      	ldr	r0, [r3, #0]
	BaseType_t xYieldRequired = pdFALSE;
 80104c0:	000e      	movs	r6, r1
					if( pxTCB != pxCurrentTCB )
 80104c2:	42a0      	cmp	r0, r4
 80104c4:	d004      	beq.n	80104d0 <vTaskPrioritySet+0x38>
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 80104c6:	681b      	ldr	r3, [r3, #0]
 80104c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80104ca:	429d      	cmp	r5, r3
 80104cc:	4149      	adcs	r1, r1
 80104ce:	000e      	movs	r6, r1
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 80104d0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 80104d2:	428a      	cmp	r2, r1
 80104d4:	d100      	bne.n	80104d8 <vTaskPrioritySet+0x40>
						pxTCB->uxPriority = uxNewPriority;
 80104d6:	62e5      	str	r5, [r4, #44]	; 0x2c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80104d8:	69a3      	ldr	r3, [r4, #24]
					pxTCB->uxBasePriority = uxNewPriority;
 80104da:	64e5      	str	r5, [r4, #76]	; 0x4c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80104dc:	2b00      	cmp	r3, #0
 80104de:	db02      	blt.n	80104e6 <vTaskPrioritySet+0x4e>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80104e0:	2207      	movs	r2, #7
 80104e2:	1b55      	subs	r5, r2, r5
 80104e4:	61a5      	str	r5, [r4, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80104e6:	2314      	movs	r3, #20
 80104e8:	434b      	muls	r3, r1
 80104ea:	4d11      	ldr	r5, [pc, #68]	; (8010530 <vTaskPrioritySet+0x98>)
 80104ec:	6962      	ldr	r2, [r4, #20]
 80104ee:	195b      	adds	r3, r3, r5
 80104f0:	429a      	cmp	r2, r3
 80104f2:	d10f      	bne.n	8010514 <vTaskPrioritySet+0x7c>
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80104f4:	1d27      	adds	r7, r4, #4
 80104f6:	0038      	movs	r0, r7
 80104f8:	f7ff faf7 	bl	800faea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80104fc:	4a0d      	ldr	r2, [pc, #52]	; (8010534 <vTaskPrioritySet+0x9c>)
 80104fe:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8010500:	6811      	ldr	r1, [r2, #0]
 8010502:	428b      	cmp	r3, r1
 8010504:	d900      	bls.n	8010508 <vTaskPrioritySet+0x70>
 8010506:	6013      	str	r3, [r2, #0]
 8010508:	2014      	movs	r0, #20
 801050a:	4358      	muls	r0, r3
 801050c:	0039      	movs	r1, r7
 801050e:	1828      	adds	r0, r5, r0
 8010510:	f7ff fac8 	bl	800faa4 <vListInsertEnd>
				if( xYieldRequired == pdTRUE )
 8010514:	2e01      	cmp	r6, #1
 8010516:	d101      	bne.n	801051c <vTaskPrioritySet+0x84>
					taskYIELD_IF_USING_PREEMPTION();
 8010518:	f000 fe9c 	bl	8011254 <vPortYield>
		taskEXIT_CRITICAL();
 801051c:	f000 feb2 	bl	8011284 <vPortExitCritical>
	}
 8010520:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				else if( pxTCB == pxCurrentTCB )
 8010522:	681e      	ldr	r6, [r3, #0]
 8010524:	1b36      	subs	r6, r6, r4
							xYieldRequired = pdTRUE;
 8010526:	4273      	negs	r3, r6
 8010528:	415e      	adcs	r6, r3
 801052a:	e7d1      	b.n	80104d0 <vTaskPrioritySet+0x38>
 801052c:	20001f20 	.word	0x20001f20
 8010530:	20001f2c 	.word	0x20001f2c
 8010534:	20001fd0 	.word	0x20001fd0

08010538 <vTaskStartScheduler>:
{
 8010538:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 801053a:	2400      	movs	r4, #0
 801053c:	22a0      	movs	r2, #160	; 0xa0
 801053e:	9402      	str	r4, [sp, #8]
 8010540:	9401      	str	r4, [sp, #4]
 8010542:	9400      	str	r4, [sp, #0]
 8010544:	0023      	movs	r3, r4
 8010546:	0052      	lsls	r2, r2, #1
 8010548:	490b      	ldr	r1, [pc, #44]	; (8010578 <vTaskStartScheduler+0x40>)
 801054a:	480c      	ldr	r0, [pc, #48]	; (801057c <vTaskStartScheduler+0x44>)
 801054c:	f7ff fe6c 	bl	8010228 <xTaskGenericCreate.part.5>
		if( xReturn == pdPASS )
 8010550:	2801      	cmp	r0, #1
 8010552:	d10d      	bne.n	8010570 <vTaskStartScheduler+0x38>
			xReturn = xTimerCreateTimerTask();
 8010554:	f000 fcd4 	bl	8010f00 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8010558:	2801      	cmp	r0, #1
 801055a:	d109      	bne.n	8010570 <vTaskStartScheduler+0x38>
		portDISABLE_INTERRUPTS();
 801055c:	b672      	cpsid	i
		xSchedulerRunning = pdTRUE;
 801055e:	4b08      	ldr	r3, [pc, #32]	; (8010580 <vTaskStartScheduler+0x48>)
 8010560:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8010562:	4b08      	ldr	r3, [pc, #32]	; (8010584 <vTaskStartScheduler+0x4c>)
 8010564:	601c      	str	r4, [r3, #0]
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 8010566:	f7f6 fd87 	bl	8007078 <vMainConfigureTimerForRunTimeStats>
		if( xPortStartScheduler() != pdFALSE )
 801056a:	f000 fe49 	bl	8011200 <xPortStartScheduler>
}
 801056e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
		configASSERT( xReturn );
 8010570:	2800      	cmp	r0, #0
 8010572:	d1fc      	bne.n	801056e <vTaskStartScheduler+0x36>
 8010574:	b672      	cpsid	i
 8010576:	e7fe      	b.n	8010576 <vTaskStartScheduler+0x3e>
 8010578:	0801c553 	.word	0x0801c553
 801057c:	080107c9 	.word	0x080107c9
 8010580:	20002014 	.word	0x20002014
 8010584:	20002040 	.word	0x20002040

08010588 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8010588:	4a02      	ldr	r2, [pc, #8]	; (8010594 <vTaskSuspendAll+0xc>)
 801058a:	6813      	ldr	r3, [r2, #0]
 801058c:	3301      	adds	r3, #1
 801058e:	6013      	str	r3, [r2, #0]
}
 8010590:	4770      	bx	lr
 8010592:	46c0      	nop			; (mov r8, r8)
 8010594:	20001fc4 	.word	0x20001fc4

08010598 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8010598:	4b01      	ldr	r3, [pc, #4]	; (80105a0 <xTaskGetTickCount+0x8>)
 801059a:	6818      	ldr	r0, [r3, #0]
}
 801059c:	4770      	bx	lr
 801059e:	46c0      	nop			; (mov r8, r8)
 80105a0:	20002040 	.word	0x20002040

080105a4 <xTaskGetTickCountFromISR>:
 80105a4:	4b01      	ldr	r3, [pc, #4]	; (80105ac <xTaskGetTickCountFromISR+0x8>)
 80105a6:	6818      	ldr	r0, [r3, #0]
 80105a8:	4770      	bx	lr
 80105aa:	46c0      	nop			; (mov r8, r8)
 80105ac:	20002040 	.word	0x20002040

080105b0 <xTaskIncrementTick>:
{
 80105b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80105b2:	4b35      	ldr	r3, [pc, #212]	; (8010688 <xTaskIncrementTick+0xd8>)
 80105b4:	681b      	ldr	r3, [r3, #0]
 80105b6:	2b00      	cmp	r3, #0
 80105b8:	d15f      	bne.n	801067a <xTaskIncrementTick+0xca>
		++xTickCount;
 80105ba:	4b34      	ldr	r3, [pc, #208]	; (801068c <xTaskIncrementTick+0xdc>)
 80105bc:	681a      	ldr	r2, [r3, #0]
 80105be:	3201      	adds	r2, #1
 80105c0:	601a      	str	r2, [r3, #0]
			const TickType_t xConstTickCount = xTickCount;
 80105c2:	681b      	ldr	r3, [r3, #0]
 80105c4:	9300      	str	r3, [sp, #0]
			if( xConstTickCount == ( TickType_t ) 0U )
 80105c6:	2b00      	cmp	r3, #0
 80105c8:	d111      	bne.n	80105ee <xTaskIncrementTick+0x3e>
				taskSWITCH_DELAYED_LISTS();
 80105ca:	4b31      	ldr	r3, [pc, #196]	; (8010690 <xTaskIncrementTick+0xe0>)
 80105cc:	681a      	ldr	r2, [r3, #0]
 80105ce:	6812      	ldr	r2, [r2, #0]
 80105d0:	2a00      	cmp	r2, #0
 80105d2:	d001      	beq.n	80105d8 <xTaskIncrementTick+0x28>
 80105d4:	b672      	cpsid	i
 80105d6:	e7fe      	b.n	80105d6 <xTaskIncrementTick+0x26>
 80105d8:	4a2e      	ldr	r2, [pc, #184]	; (8010694 <xTaskIncrementTick+0xe4>)
 80105da:	6819      	ldr	r1, [r3, #0]
 80105dc:	6810      	ldr	r0, [r2, #0]
 80105de:	6018      	str	r0, [r3, #0]
 80105e0:	6011      	str	r1, [r2, #0]
 80105e2:	4a2d      	ldr	r2, [pc, #180]	; (8010698 <xTaskIncrementTick+0xe8>)
 80105e4:	6813      	ldr	r3, [r2, #0]
 80105e6:	3301      	adds	r3, #1
 80105e8:	6013      	str	r3, [r2, #0]
 80105ea:	f7ff fde3 	bl	80101b4 <prvResetNextTaskUnblockTime>
			if( xConstTickCount >= xNextTaskUnblockTime )
 80105ee:	4e2b      	ldr	r6, [pc, #172]	; (801069c <xTaskIncrementTick+0xec>)
 80105f0:	9a00      	ldr	r2, [sp, #0]
 80105f2:	6833      	ldr	r3, [r6, #0]
 80105f4:	4f2a      	ldr	r7, [pc, #168]	; (80106a0 <xTaskIncrementTick+0xf0>)
BaseType_t xSwitchRequired = pdFALSE;
 80105f6:	2400      	movs	r4, #0
			if( xConstTickCount >= xNextTaskUnblockTime )
 80105f8:	4293      	cmp	r3, r2
 80105fa:	d935      	bls.n	8010668 <xTaskIncrementTick+0xb8>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80105fc:	683b      	ldr	r3, [r7, #0]
 80105fe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8010600:	2314      	movs	r3, #20
 8010602:	4353      	muls	r3, r2
 8010604:	4a27      	ldr	r2, [pc, #156]	; (80106a4 <xTaskIncrementTick+0xf4>)
 8010606:	58d3      	ldr	r3, [r2, r3]
 8010608:	2b01      	cmp	r3, #1
 801060a:	d900      	bls.n	801060e <xTaskIncrementTick+0x5e>
				xSwitchRequired = pdTRUE;
 801060c:	2401      	movs	r4, #1
		if( xYieldPending != pdFALSE )
 801060e:	4b26      	ldr	r3, [pc, #152]	; (80106a8 <xTaskIncrementTick+0xf8>)
 8010610:	681b      	ldr	r3, [r3, #0]
 8010612:	2b00      	cmp	r3, #0
 8010614:	d000      	beq.n	8010618 <xTaskIncrementTick+0x68>
			xSwitchRequired = pdTRUE;
 8010616:	2401      	movs	r4, #1
}
 8010618:	0020      	movs	r0, r4
 801061a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 801061c:	681b      	ldr	r3, [r3, #0]
						if( xConstTickCount < xItemValue )
 801061e:	9a00      	ldr	r2, [sp, #0]
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8010620:	68db      	ldr	r3, [r3, #12]
 8010622:	68dd      	ldr	r5, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8010624:	686b      	ldr	r3, [r5, #4]
						if( xConstTickCount < xItemValue )
 8010626:	429a      	cmp	r2, r3
 8010628:	d325      	bcc.n	8010676 <xTaskIncrementTick+0xc6>
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 801062a:	1d2b      	adds	r3, r5, #4
 801062c:	0018      	movs	r0, r3
 801062e:	9301      	str	r3, [sp, #4]
 8010630:	f7ff fa5b 	bl	800faea <uxListRemove>
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8010634:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8010636:	2b00      	cmp	r3, #0
 8010638:	d003      	beq.n	8010642 <xTaskIncrementTick+0x92>
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801063a:	0028      	movs	r0, r5
 801063c:	3018      	adds	r0, #24
 801063e:	f7ff fa54 	bl	800faea <uxListRemove>
						prvAddTaskToReadyList( pxTCB );
 8010642:	4b1a      	ldr	r3, [pc, #104]	; (80106ac <xTaskIncrementTick+0xfc>)
 8010644:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8010646:	681a      	ldr	r2, [r3, #0]
 8010648:	4290      	cmp	r0, r2
 801064a:	d900      	bls.n	801064e <xTaskIncrementTick+0x9e>
 801064c:	6018      	str	r0, [r3, #0]
 801064e:	2314      	movs	r3, #20
 8010650:	4358      	muls	r0, r3
 8010652:	4b14      	ldr	r3, [pc, #80]	; (80106a4 <xTaskIncrementTick+0xf4>)
 8010654:	1d29      	adds	r1, r5, #4
 8010656:	1818      	adds	r0, r3, r0
 8010658:	f7ff fa24 	bl	800faa4 <vListInsertEnd>
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801065c:	683b      	ldr	r3, [r7, #0]
 801065e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8010660:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010662:	429a      	cmp	r2, r3
 8010664:	d300      	bcc.n	8010668 <xTaskIncrementTick+0xb8>
								xSwitchRequired = pdTRUE;
 8010666:	2401      	movs	r4, #1
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8010668:	4b09      	ldr	r3, [pc, #36]	; (8010690 <xTaskIncrementTick+0xe0>)
 801066a:	681a      	ldr	r2, [r3, #0]
 801066c:	6812      	ldr	r2, [r2, #0]
 801066e:	2a00      	cmp	r2, #0
 8010670:	d1d4      	bne.n	801061c <xTaskIncrementTick+0x6c>
						xNextTaskUnblockTime = portMAX_DELAY;
 8010672:	2301      	movs	r3, #1
 8010674:	425b      	negs	r3, r3
							xNextTaskUnblockTime = xItemValue;
 8010676:	6033      	str	r3, [r6, #0]
							break;
 8010678:	e7c0      	b.n	80105fc <xTaskIncrementTick+0x4c>
		++uxPendedTicks;
 801067a:	4a0d      	ldr	r2, [pc, #52]	; (80106b0 <xTaskIncrementTick+0x100>)
BaseType_t xSwitchRequired = pdFALSE;
 801067c:	2400      	movs	r4, #0
		++uxPendedTicks;
 801067e:	6813      	ldr	r3, [r2, #0]
 8010680:	3301      	adds	r3, #1
 8010682:	6013      	str	r3, [r2, #0]
 8010684:	e7c3      	b.n	801060e <xTaskIncrementTick+0x5e>
 8010686:	46c0      	nop			; (mov r8, r8)
 8010688:	20001fc4 	.word	0x20001fc4
 801068c:	20002040 	.word	0x20002040
 8010690:	20001f24 	.word	0x20001f24
 8010694:	20001f28 	.word	0x20001f28
 8010698:	20001ffc 	.word	0x20001ffc
 801069c:	200000c8 	.word	0x200000c8
 80106a0:	20001f20 	.word	0x20001f20
 80106a4:	20001f2c 	.word	0x20001f2c
 80106a8:	20002044 	.word	0x20002044
 80106ac:	20001fd0 	.word	0x20001fd0
 80106b0:	20001fc0 	.word	0x20001fc0

080106b4 <xTaskResumeAll>:
{
 80106b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
 80106b6:	4c2a      	ldr	r4, [pc, #168]	; (8010760 <xTaskResumeAll+0xac>)
 80106b8:	6823      	ldr	r3, [r4, #0]
 80106ba:	2b00      	cmp	r3, #0
 80106bc:	d101      	bne.n	80106c2 <xTaskResumeAll+0xe>
 80106be:	b672      	cpsid	i
 80106c0:	e7fe      	b.n	80106c0 <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
 80106c2:	f000 fdd3 	bl	801126c <vPortEnterCritical>
		--uxSchedulerSuspended;
 80106c6:	6823      	ldr	r3, [r4, #0]
 80106c8:	3b01      	subs	r3, #1
 80106ca:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80106cc:	6823      	ldr	r3, [r4, #0]
 80106ce:	2b00      	cmp	r3, #0
 80106d0:	d004      	beq.n	80106dc <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
 80106d2:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80106d4:	f000 fdd6 	bl	8011284 <vPortExitCritical>
}
 80106d8:	0020      	movs	r0, r4
 80106da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80106dc:	4b21      	ldr	r3, [pc, #132]	; (8010764 <xTaskResumeAll+0xb0>)
 80106de:	681b      	ldr	r3, [r3, #0]
 80106e0:	2b00      	cmp	r3, #0
 80106e2:	d0f6      	beq.n	80106d2 <xTaskResumeAll+0x1e>
					prvAddTaskToReadyList( pxTCB );
 80106e4:	2614      	movs	r6, #20
						xYieldPending = pdTRUE;
 80106e6:	2701      	movs	r7, #1
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80106e8:	4b1f      	ldr	r3, [pc, #124]	; (8010768 <xTaskResumeAll+0xb4>)
 80106ea:	681a      	ldr	r2, [r3, #0]
 80106ec:	2a00      	cmp	r2, #0
 80106ee:	d10b      	bne.n	8010708 <xTaskResumeAll+0x54>
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 80106f0:	4c1e      	ldr	r4, [pc, #120]	; (801076c <xTaskResumeAll+0xb8>)
							xYieldPending = pdTRUE;
 80106f2:	2501      	movs	r5, #1
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 80106f4:	6823      	ldr	r3, [r4, #0]
 80106f6:	2b00      	cmp	r3, #0
 80106f8:	d12e      	bne.n	8010758 <xTaskResumeAll+0xa4>
				if( xYieldPending == pdTRUE )
 80106fa:	4b1d      	ldr	r3, [pc, #116]	; (8010770 <xTaskResumeAll+0xbc>)
 80106fc:	681c      	ldr	r4, [r3, #0]
 80106fe:	2c01      	cmp	r4, #1
 8010700:	d1e7      	bne.n	80106d2 <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
 8010702:	f000 fda7 	bl	8011254 <vPortYield>
 8010706:	e7e5      	b.n	80106d4 <xTaskResumeAll+0x20>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8010708:	68db      	ldr	r3, [r3, #12]
 801070a:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801070c:	0020      	movs	r0, r4
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 801070e:	1d25      	adds	r5, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8010710:	3018      	adds	r0, #24
 8010712:	f7ff f9ea 	bl	800faea <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8010716:	0028      	movs	r0, r5
 8010718:	f7ff f9e7 	bl	800faea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 801071c:	4b15      	ldr	r3, [pc, #84]	; (8010774 <xTaskResumeAll+0xc0>)
 801071e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8010720:	681a      	ldr	r2, [r3, #0]
 8010722:	4290      	cmp	r0, r2
 8010724:	d900      	bls.n	8010728 <xTaskResumeAll+0x74>
 8010726:	6018      	str	r0, [r3, #0]
 8010728:	4370      	muls	r0, r6
 801072a:	4b13      	ldr	r3, [pc, #76]	; (8010778 <xTaskResumeAll+0xc4>)
 801072c:	0029      	movs	r1, r5
 801072e:	18c0      	adds	r0, r0, r3
 8010730:	f7ff f9b8 	bl	800faa4 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8010734:	4b11      	ldr	r3, [pc, #68]	; (801077c <xTaskResumeAll+0xc8>)
 8010736:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8010738:	681b      	ldr	r3, [r3, #0]
 801073a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801073c:	429a      	cmp	r2, r3
 801073e:	d3d3      	bcc.n	80106e8 <xTaskResumeAll+0x34>
						xYieldPending = pdTRUE;
 8010740:	4b0b      	ldr	r3, [pc, #44]	; (8010770 <xTaskResumeAll+0xbc>)
 8010742:	601f      	str	r7, [r3, #0]
 8010744:	e7d0      	b.n	80106e8 <xTaskResumeAll+0x34>
						if( xTaskIncrementTick() != pdFALSE )
 8010746:	f7ff ff33 	bl	80105b0 <xTaskIncrementTick>
 801074a:	2800      	cmp	r0, #0
 801074c:	d001      	beq.n	8010752 <xTaskResumeAll+0x9e>
							xYieldPending = pdTRUE;
 801074e:	4b08      	ldr	r3, [pc, #32]	; (8010770 <xTaskResumeAll+0xbc>)
 8010750:	601d      	str	r5, [r3, #0]
						--uxPendedTicks;
 8010752:	6823      	ldr	r3, [r4, #0]
 8010754:	3b01      	subs	r3, #1
 8010756:	6023      	str	r3, [r4, #0]
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8010758:	6823      	ldr	r3, [r4, #0]
 801075a:	2b00      	cmp	r3, #0
 801075c:	d1f3      	bne.n	8010746 <xTaskResumeAll+0x92>
 801075e:	e7cc      	b.n	80106fa <xTaskResumeAll+0x46>
 8010760:	20001fc4 	.word	0x20001fc4
 8010764:	20001fbc 	.word	0x20001fbc
 8010768:	20002000 	.word	0x20002000
 801076c:	20001fc0 	.word	0x20001fc0
 8010770:	20002044 	.word	0x20002044
 8010774:	20001fd0 	.word	0x20001fd0
 8010778:	20001f2c 	.word	0x20001f2c
 801077c:	20001f20 	.word	0x20001f20

08010780 <vTaskDelay>:
	{
 8010780:	b570      	push	{r4, r5, r6, lr}
 8010782:	1e05      	subs	r5, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
 8010784:	d102      	bne.n	801078c <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
 8010786:	f000 fd65 	bl	8011254 <vPortYield>
	}
 801078a:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 801078c:	4b0b      	ldr	r3, [pc, #44]	; (80107bc <vTaskDelay+0x3c>)
 801078e:	681b      	ldr	r3, [r3, #0]
 8010790:	2b00      	cmp	r3, #0
 8010792:	d001      	beq.n	8010798 <vTaskDelay+0x18>
 8010794:	b672      	cpsid	i
 8010796:	e7fe      	b.n	8010796 <vTaskDelay+0x16>
			vTaskSuspendAll();
 8010798:	f7ff fef6 	bl	8010588 <vTaskSuspendAll>
				xTimeToWake = xTickCount + xTicksToDelay;
 801079c:	4b08      	ldr	r3, [pc, #32]	; (80107c0 <vTaskDelay+0x40>)
 801079e:	681c      	ldr	r4, [r3, #0]
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80107a0:	4b08      	ldr	r3, [pc, #32]	; (80107c4 <vTaskDelay+0x44>)
				xTimeToWake = xTickCount + xTicksToDelay;
 80107a2:	1964      	adds	r4, r4, r5
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80107a4:	6818      	ldr	r0, [r3, #0]
 80107a6:	3004      	adds	r0, #4
 80107a8:	f7ff f99f 	bl	800faea <uxListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 80107ac:	0020      	movs	r0, r4
 80107ae:	f7ff fd15 	bl	80101dc <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 80107b2:	f7ff ff7f 	bl	80106b4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80107b6:	2800      	cmp	r0, #0
 80107b8:	d0e5      	beq.n	8010786 <vTaskDelay+0x6>
 80107ba:	e7e6      	b.n	801078a <vTaskDelay+0xa>
 80107bc:	20001fc4 	.word	0x20001fc4
 80107c0:	20002040 	.word	0x20002040
 80107c4:	20001f20 	.word	0x20001f20

080107c8 <prvIdleTask>:
{
 80107c8:	b570      	push	{r4, r5, r6, lr}
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 80107ca:	4c15      	ldr	r4, [pc, #84]	; (8010820 <prvIdleTask+0x58>)
 80107cc:	6823      	ldr	r3, [r4, #0]
 80107ce:	2b00      	cmp	r3, #0
 80107d0:	d106      	bne.n	80107e0 <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80107d2:	4b14      	ldr	r3, [pc, #80]	; (8010824 <prvIdleTask+0x5c>)
 80107d4:	681b      	ldr	r3, [r3, #0]
 80107d6:	2b01      	cmp	r3, #1
 80107d8:	d9f7      	bls.n	80107ca <prvIdleTask+0x2>
				taskYIELD();
 80107da:	f000 fd3b 	bl	8011254 <vPortYield>
 80107de:	e7f4      	b.n	80107ca <prvIdleTask+0x2>
			vTaskSuspendAll();
 80107e0:	f7ff fed2 	bl	8010588 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80107e4:	4d10      	ldr	r5, [pc, #64]	; (8010828 <prvIdleTask+0x60>)
 80107e6:	682e      	ldr	r6, [r5, #0]
			( void ) xTaskResumeAll();
 80107e8:	f7ff ff64 	bl	80106b4 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 80107ec:	2e00      	cmp	r6, #0
 80107ee:	d0ec      	beq.n	80107ca <prvIdleTask+0x2>
				taskENTER_CRITICAL();
 80107f0:	f000 fd3c 	bl	801126c <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 80107f4:	68eb      	ldr	r3, [r5, #12]
 80107f6:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80107f8:	1d28      	adds	r0, r5, #4
 80107fa:	f7ff f976 	bl	800faea <uxListRemove>
					--uxCurrentNumberOfTasks;
 80107fe:	4a0b      	ldr	r2, [pc, #44]	; (801082c <prvIdleTask+0x64>)
 8010800:	6813      	ldr	r3, [r2, #0]
 8010802:	3b01      	subs	r3, #1
 8010804:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
 8010806:	6823      	ldr	r3, [r4, #0]
 8010808:	3b01      	subs	r3, #1
 801080a:	6023      	str	r3, [r4, #0]
				taskEXIT_CRITICAL();
 801080c:	f000 fd3a 	bl	8011284 <vPortExitCritical>
			vPortFreeAligned( pxTCB->pxStack );
 8010810:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8010812:	f000 fe27 	bl	8011464 <vPortFree>
		vPortFree( pxTCB );
 8010816:	0028      	movs	r0, r5
 8010818:	f000 fe24 	bl	8011464 <vPortFree>
 801081c:	e7d5      	b.n	80107ca <prvIdleTask+0x2>
 801081e:	46c0      	nop			; (mov r8, r8)
 8010820:	20001fcc 	.word	0x20001fcc
 8010824:	20001f2c 	.word	0x20001f2c
 8010828:	2000202c 	.word	0x2000202c
 801082c:	20001fbc 	.word	0x20001fbc

08010830 <uxTaskGetSystemState>:
	{
 8010830:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8010832:	0005      	movs	r5, r0
 8010834:	000e      	movs	r6, r1
 8010836:	0017      	movs	r7, r2
		vTaskSuspendAll();
 8010838:	f7ff fea6 	bl	8010588 <vTaskSuspendAll>
			if( uxArraySize >= uxCurrentNumberOfTasks )
 801083c:	4b1d      	ldr	r3, [pc, #116]	; (80108b4 <uxTaskGetSystemState+0x84>)
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 801083e:	2400      	movs	r4, #0
			if( uxArraySize >= uxCurrentNumberOfTasks )
 8010840:	681b      	ldr	r3, [r3, #0]
 8010842:	42b3      	cmp	r3, r6
 8010844:	d832      	bhi.n	80108ac <uxTaskGetSystemState+0x7c>
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 8010846:	0026      	movs	r6, r4
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 8010848:	4b1b      	ldr	r3, [pc, #108]	; (80108b8 <uxTaskGetSystemState+0x88>)
 801084a:	3378      	adds	r3, #120	; 0x78
 801084c:	9301      	str	r3, [sp, #4]
 801084e:	9b01      	ldr	r3, [sp, #4]
 8010850:	0170      	lsls	r0, r6, #5
 8010852:	1919      	adds	r1, r3, r4
 8010854:	1828      	adds	r0, r5, r0
 8010856:	2201      	movs	r2, #1
 8010858:	3c14      	subs	r4, #20
 801085a:	f7ff fdb5 	bl	80103c8 <prvListTaskWithinSingleList>
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801085e:	0023      	movs	r3, r4
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 8010860:	1836      	adds	r6, r6, r0
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8010862:	338c      	adds	r3, #140	; 0x8c
 8010864:	d1f3      	bne.n	801084e <uxTaskGetSystemState+0x1e>
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8010866:	4b15      	ldr	r3, [pc, #84]	; (80108bc <uxTaskGetSystemState+0x8c>)
 8010868:	0170      	lsls	r0, r6, #5
 801086a:	6819      	ldr	r1, [r3, #0]
 801086c:	2202      	movs	r2, #2
 801086e:	1828      	adds	r0, r5, r0
 8010870:	f7ff fdaa 	bl	80103c8 <prvListTaskWithinSingleList>
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 8010874:	4b12      	ldr	r3, [pc, #72]	; (80108c0 <uxTaskGetSystemState+0x90>)
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8010876:	1836      	adds	r6, r6, r0
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 8010878:	0170      	lsls	r0, r6, #5
 801087a:	6819      	ldr	r1, [r3, #0]
 801087c:	2202      	movs	r2, #2
 801087e:	1828      	adds	r0, r5, r0
 8010880:	f7ff fda2 	bl	80103c8 <prvListTaskWithinSingleList>
 8010884:	1836      	adds	r6, r6, r0
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 8010886:	0170      	lsls	r0, r6, #5
 8010888:	2204      	movs	r2, #4
 801088a:	490e      	ldr	r1, [pc, #56]	; (80108c4 <uxTaskGetSystemState+0x94>)
 801088c:	1828      	adds	r0, r5, r0
 801088e:	f7ff fd9b 	bl	80103c8 <prvListTaskWithinSingleList>
 8010892:	1836      	adds	r6, r6, r0
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 8010894:	0170      	lsls	r0, r6, #5
 8010896:	1828      	adds	r0, r5, r0
 8010898:	2203      	movs	r2, #3
 801089a:	490b      	ldr	r1, [pc, #44]	; (80108c8 <uxTaskGetSystemState+0x98>)
 801089c:	f7ff fd94 	bl	80103c8 <prvListTaskWithinSingleList>
 80108a0:	1834      	adds	r4, r6, r0
					if( pulTotalRunTime != NULL )
 80108a2:	2f00      	cmp	r7, #0
 80108a4:	d002      	beq.n	80108ac <uxTaskGetSystemState+0x7c>
							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 80108a6:	f7f6 fbf7 	bl	8007098 <ulMainGetRunTimeCounterValue>
 80108aa:	6038      	str	r0, [r7, #0]
		( void ) xTaskResumeAll();
 80108ac:	f7ff ff02 	bl	80106b4 <xTaskResumeAll>
	}
 80108b0:	0020      	movs	r0, r4
 80108b2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80108b4:	20001fbc 	.word	0x20001fbc
 80108b8:	20001f2c 	.word	0x20001f2c
 80108bc:	20001f24 	.word	0x20001f24
 80108c0:	20001f28 	.word	0x20001f28
 80108c4:	2000202c 	.word	0x2000202c
 80108c8:	20002018 	.word	0x20002018

080108cc <vTaskSwitchContext>:
{
 80108cc:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80108ce:	4b1d      	ldr	r3, [pc, #116]	; (8010944 <vTaskSwitchContext+0x78>)
 80108d0:	681a      	ldr	r2, [r3, #0]
 80108d2:	4b1d      	ldr	r3, [pc, #116]	; (8010948 <vTaskSwitchContext+0x7c>)
 80108d4:	2a00      	cmp	r2, #0
 80108d6:	d002      	beq.n	80108de <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
 80108d8:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80108da:	601a      	str	r2, [r3, #0]
}
 80108dc:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 80108de:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 80108e0:	f7f6 fbda 	bl	8007098 <ulMainGetRunTimeCounterValue>
				if( ulTotalRunTime > ulTaskSwitchedInTime )
 80108e4:	4a19      	ldr	r2, [pc, #100]	; (801094c <vTaskSwitchContext+0x80>)
 80108e6:	6813      	ldr	r3, [r2, #0]
 80108e8:	4298      	cmp	r0, r3
 80108ea:	d905      	bls.n	80108f8 <vTaskSwitchContext+0x2c>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
 80108ec:	4918      	ldr	r1, [pc, #96]	; (8010950 <vTaskSwitchContext+0x84>)
 80108ee:	6809      	ldr	r1, [r1, #0]
 80108f0:	6d4c      	ldr	r4, [r1, #84]	; 0x54
 80108f2:	1ae3      	subs	r3, r4, r3
 80108f4:	181b      	adds	r3, r3, r0
 80108f6:	654b      	str	r3, [r1, #84]	; 0x54
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80108f8:	2314      	movs	r3, #20
				ulTaskSwitchedInTime = ulTotalRunTime;
 80108fa:	6010      	str	r0, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80108fc:	4915      	ldr	r1, [pc, #84]	; (8010954 <vTaskSwitchContext+0x88>)
 80108fe:	4a16      	ldr	r2, [pc, #88]	; (8010958 <vTaskSwitchContext+0x8c>)
 8010900:	6808      	ldr	r0, [r1, #0]
 8010902:	4358      	muls	r0, r3
 8010904:	5880      	ldr	r0, [r0, r2]
 8010906:	2800      	cmp	r0, #0
 8010908:	d012      	beq.n	8010930 <vTaskSwitchContext+0x64>
 801090a:	680c      	ldr	r4, [r1, #0]
 801090c:	4363      	muls	r3, r4
 801090e:	18d1      	adds	r1, r2, r3
 8010910:	6848      	ldr	r0, [r1, #4]
 8010912:	3308      	adds	r3, #8
 8010914:	6840      	ldr	r0, [r0, #4]
 8010916:	189b      	adds	r3, r3, r2
 8010918:	6048      	str	r0, [r1, #4]
 801091a:	4298      	cmp	r0, r3
 801091c:	d101      	bne.n	8010922 <vTaskSwitchContext+0x56>
 801091e:	6843      	ldr	r3, [r0, #4]
 8010920:	604b      	str	r3, [r1, #4]
 8010922:	2314      	movs	r3, #20
 8010924:	4363      	muls	r3, r4
 8010926:	18d2      	adds	r2, r2, r3
 8010928:	6853      	ldr	r3, [r2, #4]
 801092a:	68da      	ldr	r2, [r3, #12]
 801092c:	4b08      	ldr	r3, [pc, #32]	; (8010950 <vTaskSwitchContext+0x84>)
 801092e:	e7d4      	b.n	80108da <vTaskSwitchContext+0xe>
 8010930:	6808      	ldr	r0, [r1, #0]
 8010932:	2800      	cmp	r0, #0
 8010934:	d101      	bne.n	801093a <vTaskSwitchContext+0x6e>
 8010936:	b672      	cpsid	i
 8010938:	e7fe      	b.n	8010938 <vTaskSwitchContext+0x6c>
 801093a:	6808      	ldr	r0, [r1, #0]
 801093c:	3801      	subs	r0, #1
 801093e:	6008      	str	r0, [r1, #0]
 8010940:	e7de      	b.n	8010900 <vTaskSwitchContext+0x34>
 8010942:	46c0      	nop			; (mov r8, r8)
 8010944:	20001fc4 	.word	0x20001fc4
 8010948:	20002044 	.word	0x20002044
 801094c:	20001fb8 	.word	0x20001fb8
 8010950:	20001f20 	.word	0x20001f20
 8010954:	20001fd0 	.word	0x20001fd0
 8010958:	20001f2c 	.word	0x20001f2c

0801095c <vTaskPlaceOnEventList>:
{
 801095c:	b570      	push	{r4, r5, r6, lr}
 801095e:	000d      	movs	r5, r1
	configASSERT( pxEventList );
 8010960:	2800      	cmp	r0, #0
 8010962:	d101      	bne.n	8010968 <vTaskPlaceOnEventList+0xc>
 8010964:	b672      	cpsid	i
 8010966:	e7fe      	b.n	8010966 <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8010968:	4c0b      	ldr	r4, [pc, #44]	; (8010998 <vTaskPlaceOnEventList+0x3c>)
 801096a:	6821      	ldr	r1, [r4, #0]
 801096c:	3118      	adds	r1, #24
 801096e:	f7ff f8a5 	bl	800fabc <vListInsert>
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8010972:	6820      	ldr	r0, [r4, #0]
 8010974:	3004      	adds	r0, #4
 8010976:	f7ff f8b8 	bl	800faea <uxListRemove>
		if( xTicksToWait == portMAX_DELAY )
 801097a:	1c6b      	adds	r3, r5, #1
 801097c:	d105      	bne.n	801098a <vTaskPlaceOnEventList+0x2e>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 801097e:	6821      	ldr	r1, [r4, #0]
 8010980:	4806      	ldr	r0, [pc, #24]	; (801099c <vTaskPlaceOnEventList+0x40>)
 8010982:	3104      	adds	r1, #4
 8010984:	f7ff f88e 	bl	800faa4 <vListInsertEnd>
}
 8010988:	bd70      	pop	{r4, r5, r6, pc}
			xTimeToWake = xTickCount + xTicksToWait;
 801098a:	4b05      	ldr	r3, [pc, #20]	; (80109a0 <vTaskPlaceOnEventList+0x44>)
 801098c:	6818      	ldr	r0, [r3, #0]
 801098e:	1940      	adds	r0, r0, r5
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8010990:	f7ff fc24 	bl	80101dc <prvAddCurrentTaskToDelayedList>
}
 8010994:	e7f8      	b.n	8010988 <vTaskPlaceOnEventList+0x2c>
 8010996:	46c0      	nop			; (mov r8, r8)
 8010998:	20001f20 	.word	0x20001f20
 801099c:	20002018 	.word	0x20002018
 80109a0:	20002040 	.word	0x20002040

080109a4 <vTaskPlaceOnEventListRestricted>:
	{
 80109a4:	b570      	push	{r4, r5, r6, lr}
 80109a6:	000c      	movs	r4, r1
		configASSERT( pxEventList );
 80109a8:	2800      	cmp	r0, #0
 80109aa:	d101      	bne.n	80109b0 <vTaskPlaceOnEventListRestricted+0xc>
 80109ac:	b672      	cpsid	i
 80109ae:	e7fe      	b.n	80109ae <vTaskPlaceOnEventListRestricted+0xa>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80109b0:	4d07      	ldr	r5, [pc, #28]	; (80109d0 <vTaskPlaceOnEventListRestricted+0x2c>)
 80109b2:	6829      	ldr	r1, [r5, #0]
 80109b4:	3118      	adds	r1, #24
 80109b6:	f7ff f875 	bl	800faa4 <vListInsertEnd>
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80109ba:	6828      	ldr	r0, [r5, #0]
 80109bc:	3004      	adds	r0, #4
 80109be:	f7ff f894 	bl	800faea <uxListRemove>
		xTimeToWake = xTickCount + xTicksToWait;
 80109c2:	4b04      	ldr	r3, [pc, #16]	; (80109d4 <vTaskPlaceOnEventListRestricted+0x30>)
 80109c4:	6818      	ldr	r0, [r3, #0]
 80109c6:	1900      	adds	r0, r0, r4
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 80109c8:	f7ff fc08 	bl	80101dc <prvAddCurrentTaskToDelayedList>
	}
 80109cc:	bd70      	pop	{r4, r5, r6, pc}
 80109ce:	46c0      	nop			; (mov r8, r8)
 80109d0:	20001f20 	.word	0x20001f20
 80109d4:	20002040 	.word	0x20002040

080109d8 <xTaskRemoveFromEventList>:
{
 80109d8:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80109da:	68c3      	ldr	r3, [r0, #12]
 80109dc:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 80109de:	2c00      	cmp	r4, #0
 80109e0:	d101      	bne.n	80109e6 <xTaskRemoveFromEventList+0xe>
 80109e2:	b672      	cpsid	i
 80109e4:	e7fe      	b.n	80109e4 <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80109e6:	0025      	movs	r5, r4
 80109e8:	3518      	adds	r5, #24
 80109ea:	0028      	movs	r0, r5
 80109ec:	f7ff f87d 	bl	800faea <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80109f0:	4b11      	ldr	r3, [pc, #68]	; (8010a38 <xTaskRemoveFromEventList+0x60>)
 80109f2:	681b      	ldr	r3, [r3, #0]
 80109f4:	2b00      	cmp	r3, #0
 80109f6:	d11b      	bne.n	8010a30 <xTaskRemoveFromEventList+0x58>
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 80109f8:	1d25      	adds	r5, r4, #4
 80109fa:	0028      	movs	r0, r5
 80109fc:	f7ff f875 	bl	800faea <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8010a00:	4a0e      	ldr	r2, [pc, #56]	; (8010a3c <xTaskRemoveFromEventList+0x64>)
 8010a02:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8010a04:	6811      	ldr	r1, [r2, #0]
 8010a06:	428b      	cmp	r3, r1
 8010a08:	d900      	bls.n	8010a0c <xTaskRemoveFromEventList+0x34>
 8010a0a:	6013      	str	r3, [r2, #0]
 8010a0c:	2014      	movs	r0, #20
 8010a0e:	0029      	movs	r1, r5
 8010a10:	4358      	muls	r0, r3
 8010a12:	4b0b      	ldr	r3, [pc, #44]	; (8010a40 <xTaskRemoveFromEventList+0x68>)
 8010a14:	18c0      	adds	r0, r0, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8010a16:	f7ff f845 	bl	800faa4 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8010a1a:	4b0a      	ldr	r3, [pc, #40]	; (8010a44 <xTaskRemoveFromEventList+0x6c>)
 8010a1c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8010a1e:	681b      	ldr	r3, [r3, #0]
		xReturn = pdFALSE;
 8010a20:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8010a22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010a24:	429a      	cmp	r2, r3
 8010a26:	d902      	bls.n	8010a2e <xTaskRemoveFromEventList+0x56>
		xYieldPending = pdTRUE;
 8010a28:	4b07      	ldr	r3, [pc, #28]	; (8010a48 <xTaskRemoveFromEventList+0x70>)
 8010a2a:	3001      	adds	r0, #1
 8010a2c:	6018      	str	r0, [r3, #0]
}
 8010a2e:	bd70      	pop	{r4, r5, r6, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8010a30:	0029      	movs	r1, r5
 8010a32:	4806      	ldr	r0, [pc, #24]	; (8010a4c <xTaskRemoveFromEventList+0x74>)
 8010a34:	e7ef      	b.n	8010a16 <xTaskRemoveFromEventList+0x3e>
 8010a36:	46c0      	nop			; (mov r8, r8)
 8010a38:	20001fc4 	.word	0x20001fc4
 8010a3c:	20001fd0 	.word	0x20001fd0
 8010a40:	20001f2c 	.word	0x20001f2c
 8010a44:	20001f20 	.word	0x20001f20
 8010a48:	20002044 	.word	0x20002044
 8010a4c:	20002000 	.word	0x20002000

08010a50 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 8010a50:	2800      	cmp	r0, #0
 8010a52:	d101      	bne.n	8010a58 <vTaskSetTimeOutState+0x8>
 8010a54:	b672      	cpsid	i
 8010a56:	e7fe      	b.n	8010a56 <vTaskSetTimeOutState+0x6>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8010a58:	4b03      	ldr	r3, [pc, #12]	; (8010a68 <vTaskSetTimeOutState+0x18>)
 8010a5a:	681b      	ldr	r3, [r3, #0]
 8010a5c:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8010a5e:	4b03      	ldr	r3, [pc, #12]	; (8010a6c <vTaskSetTimeOutState+0x1c>)
 8010a60:	681b      	ldr	r3, [r3, #0]
 8010a62:	6043      	str	r3, [r0, #4]
}
 8010a64:	4770      	bx	lr
 8010a66:	46c0      	nop			; (mov r8, r8)
 8010a68:	20001ffc 	.word	0x20001ffc
 8010a6c:	20002040 	.word	0x20002040

08010a70 <xTaskCheckForTimeOut>:
{
 8010a70:	b570      	push	{r4, r5, r6, lr}
 8010a72:	0004      	movs	r4, r0
 8010a74:	000d      	movs	r5, r1
	configASSERT( pxTimeOut );
 8010a76:	2800      	cmp	r0, #0
 8010a78:	d101      	bne.n	8010a7e <xTaskCheckForTimeOut+0xe>
 8010a7a:	b672      	cpsid	i
 8010a7c:	e7fe      	b.n	8010a7c <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 8010a7e:	2900      	cmp	r1, #0
 8010a80:	d101      	bne.n	8010a86 <xTaskCheckForTimeOut+0x16>
 8010a82:	b672      	cpsid	i
 8010a84:	e7fe      	b.n	8010a84 <xTaskCheckForTimeOut+0x14>
	taskENTER_CRITICAL();
 8010a86:	f000 fbf1 	bl	801126c <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8010a8a:	4b0f      	ldr	r3, [pc, #60]	; (8010ac8 <xTaskCheckForTimeOut+0x58>)
				xReturn = pdFALSE;
 8010a8c:	2600      	movs	r6, #0
		const TickType_t xConstTickCount = xTickCount;
 8010a8e:	6819      	ldr	r1, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 8010a90:	682b      	ldr	r3, [r5, #0]
 8010a92:	1c5a      	adds	r2, r3, #1
 8010a94:	d013      	beq.n	8010abe <xTaskCheckForTimeOut+0x4e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8010a96:	4a0d      	ldr	r2, [pc, #52]	; (8010acc <xTaskCheckForTimeOut+0x5c>)
 8010a98:	6826      	ldr	r6, [r4, #0]
 8010a9a:	6810      	ldr	r0, [r2, #0]
 8010a9c:	6862      	ldr	r2, [r4, #4]
 8010a9e:	4286      	cmp	r6, r0
 8010aa0:	d002      	beq.n	8010aa8 <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
 8010aa2:	2601      	movs	r6, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8010aa4:	4291      	cmp	r1, r2
 8010aa6:	d20a      	bcs.n	8010abe <xTaskCheckForTimeOut+0x4e>
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 8010aa8:	1a88      	subs	r0, r1, r2
			xReturn = pdTRUE;
 8010aaa:	2601      	movs	r6, #1
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 8010aac:	4283      	cmp	r3, r0
 8010aae:	d906      	bls.n	8010abe <xTaskCheckForTimeOut+0x4e>
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 8010ab0:	1a5b      	subs	r3, r3, r1
 8010ab2:	189b      	adds	r3, r3, r2
 8010ab4:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8010ab6:	0020      	movs	r0, r4
 8010ab8:	f7ff ffca 	bl	8010a50 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 8010abc:	2600      	movs	r6, #0
	taskEXIT_CRITICAL();
 8010abe:	f000 fbe1 	bl	8011284 <vPortExitCritical>
}
 8010ac2:	0030      	movs	r0, r6
 8010ac4:	bd70      	pop	{r4, r5, r6, pc}
 8010ac6:	46c0      	nop			; (mov r8, r8)
 8010ac8:	20002040 	.word	0x20002040
 8010acc:	20001ffc 	.word	0x20001ffc

08010ad0 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8010ad0:	2201      	movs	r2, #1
 8010ad2:	4b01      	ldr	r3, [pc, #4]	; (8010ad8 <vTaskMissedYield+0x8>)
 8010ad4:	601a      	str	r2, [r3, #0]
}
 8010ad6:	4770      	bx	lr
 8010ad8:	20002044 	.word	0x20002044

08010adc <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8010adc:	4b05      	ldr	r3, [pc, #20]	; (8010af4 <xTaskGetSchedulerState+0x18>)
			xReturn = taskSCHEDULER_NOT_STARTED;
 8010ade:	2001      	movs	r0, #1
		if( xSchedulerRunning == pdFALSE )
 8010ae0:	681b      	ldr	r3, [r3, #0]
 8010ae2:	2b00      	cmp	r3, #0
 8010ae4:	d004      	beq.n	8010af0 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8010ae6:	4b04      	ldr	r3, [pc, #16]	; (8010af8 <xTaskGetSchedulerState+0x1c>)
 8010ae8:	6818      	ldr	r0, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
 8010aea:	4243      	negs	r3, r0
 8010aec:	4158      	adcs	r0, r3
 8010aee:	0040      	lsls	r0, r0, #1
	}
 8010af0:	4770      	bx	lr
 8010af2:	46c0      	nop			; (mov r8, r8)
 8010af4:	20002014 	.word	0x20002014
 8010af8:	20001fc4 	.word	0x20001fc4

08010afc <vTaskPriorityInherit>:
	{
 8010afc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010afe:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
 8010b00:	d029      	beq.n	8010b56 <vTaskPriorityInherit+0x5a>
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8010b02:	4e16      	ldr	r6, [pc, #88]	; (8010b5c <vTaskPriorityInherit+0x60>)
 8010b04:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8010b06:	6833      	ldr	r3, [r6, #0]
 8010b08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010b0a:	4299      	cmp	r1, r3
 8010b0c:	d223      	bcs.n	8010b56 <vTaskPriorityInherit+0x5a>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8010b0e:	6983      	ldr	r3, [r0, #24]
 8010b10:	2b00      	cmp	r3, #0
 8010b12:	db04      	blt.n	8010b1e <vTaskPriorityInherit+0x22>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8010b14:	2207      	movs	r2, #7
 8010b16:	6833      	ldr	r3, [r6, #0]
 8010b18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010b1a:	1ad2      	subs	r2, r2, r3
 8010b1c:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8010b1e:	2314      	movs	r3, #20
 8010b20:	434b      	muls	r3, r1
 8010b22:	4d0f      	ldr	r5, [pc, #60]	; (8010b60 <vTaskPriorityInherit+0x64>)
 8010b24:	6962      	ldr	r2, [r4, #20]
 8010b26:	195b      	adds	r3, r3, r5
 8010b28:	429a      	cmp	r2, r3
 8010b2a:	d111      	bne.n	8010b50 <vTaskPriorityInherit+0x54>
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8010b2c:	1d27      	adds	r7, r4, #4
 8010b2e:	0038      	movs	r0, r7
 8010b30:	f7fe ffdb 	bl	800faea <uxListRemove>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8010b34:	6833      	ldr	r3, [r6, #0]
 8010b36:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8010b38:	4b0a      	ldr	r3, [pc, #40]	; (8010b64 <vTaskPriorityInherit+0x68>)
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8010b3a:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8010b3c:	681a      	ldr	r2, [r3, #0]
 8010b3e:	4290      	cmp	r0, r2
 8010b40:	d80a      	bhi.n	8010b58 <vTaskPriorityInherit+0x5c>
 8010b42:	2314      	movs	r3, #20
 8010b44:	4358      	muls	r0, r3
 8010b46:	0039      	movs	r1, r7
 8010b48:	1828      	adds	r0, r5, r0
 8010b4a:	f7fe ffab 	bl	800faa4 <vListInsertEnd>
	}
 8010b4e:	e002      	b.n	8010b56 <vTaskPriorityInherit+0x5a>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8010b50:	6833      	ldr	r3, [r6, #0]
 8010b52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010b54:	62e3      	str	r3, [r4, #44]	; 0x2c
	}
 8010b56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					prvAddTaskToReadyList( pxTCB );
 8010b58:	6018      	str	r0, [r3, #0]
 8010b5a:	e7f2      	b.n	8010b42 <vTaskPriorityInherit+0x46>
 8010b5c:	20001f20 	.word	0x20001f20
 8010b60:	20001f2c 	.word	0x20001f2c
 8010b64:	20001fd0 	.word	0x20001fd0

08010b68 <xTaskPriorityDisinherit>:
	{
 8010b68:	b570      	push	{r4, r5, r6, lr}
		if( pxMutexHolder != NULL )
 8010b6a:	2800      	cmp	r0, #0
 8010b6c:	d101      	bne.n	8010b72 <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 8010b6e:	2000      	movs	r0, #0
	}
 8010b70:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( pxTCB == pxCurrentTCB );
 8010b72:	4b15      	ldr	r3, [pc, #84]	; (8010bc8 <xTaskPriorityDisinherit+0x60>)
 8010b74:	681c      	ldr	r4, [r3, #0]
 8010b76:	4284      	cmp	r4, r0
 8010b78:	d001      	beq.n	8010b7e <xTaskPriorityDisinherit+0x16>
 8010b7a:	b672      	cpsid	i
 8010b7c:	e7fe      	b.n	8010b7c <xTaskPriorityDisinherit+0x14>
			configASSERT( pxTCB->uxMutexesHeld );
 8010b7e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010b80:	2b00      	cmp	r3, #0
 8010b82:	d101      	bne.n	8010b88 <xTaskPriorityDisinherit+0x20>
 8010b84:	b672      	cpsid	i
 8010b86:	e7fe      	b.n	8010b86 <xTaskPriorityDisinherit+0x1e>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8010b88:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8010b8a:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
			( pxTCB->uxMutexesHeld )--;
 8010b8c:	3b01      	subs	r3, #1
 8010b8e:	6523      	str	r3, [r4, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8010b90:	428a      	cmp	r2, r1
 8010b92:	d0ec      	beq.n	8010b6e <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8010b94:	2b00      	cmp	r3, #0
 8010b96:	d1ea      	bne.n	8010b6e <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8010b98:	1d25      	adds	r5, r4, #4
 8010b9a:	0028      	movs	r0, r5
 8010b9c:	f7fe ffa5 	bl	800faea <uxListRemove>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8010ba0:	2207      	movs	r2, #7
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8010ba2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8010ba4:	1ad2      	subs	r2, r2, r3
 8010ba6:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8010ba8:	4a08      	ldr	r2, [pc, #32]	; (8010bcc <xTaskPriorityDisinherit+0x64>)
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8010baa:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8010bac:	6811      	ldr	r1, [r2, #0]
 8010bae:	428b      	cmp	r3, r1
 8010bb0:	d900      	bls.n	8010bb4 <xTaskPriorityDisinherit+0x4c>
 8010bb2:	6013      	str	r3, [r2, #0]
 8010bb4:	2014      	movs	r0, #20
 8010bb6:	4358      	muls	r0, r3
 8010bb8:	4b05      	ldr	r3, [pc, #20]	; (8010bd0 <xTaskPriorityDisinherit+0x68>)
 8010bba:	0029      	movs	r1, r5
 8010bbc:	18c0      	adds	r0, r0, r3
 8010bbe:	f7fe ff71 	bl	800faa4 <vListInsertEnd>
					xReturn = pdTRUE;
 8010bc2:	2001      	movs	r0, #1
		return xReturn;
 8010bc4:	e7d4      	b.n	8010b70 <xTaskPriorityDisinherit+0x8>
 8010bc6:	46c0      	nop			; (mov r8, r8)
 8010bc8:	20001f20 	.word	0x20001f20
 8010bcc:	20001fd0 	.word	0x20001fd0
 8010bd0:	20001f2c 	.word	0x20001f2c

08010bd4 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	void vTaskList( char * pcWriteBuffer )
	{
 8010bd4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
		 * through a call to vTaskList().
		 */


		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = 0x00;
 8010bd6:	2600      	movs	r6, #0

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
 8010bd8:	4b23      	ldr	r3, [pc, #140]	; (8010c68 <vTaskList+0x94>)
		*pcWriteBuffer = 0x00;
 8010bda:	7006      	strb	r6, [r0, #0]
		uxArraySize = uxCurrentNumberOfTasks;
 8010bdc:	681a      	ldr	r2, [r3, #0]
	{
 8010bde:	0005      	movs	r5, r0
		uxArraySize = uxCurrentNumberOfTasks;
 8010be0:	9202      	str	r2, [sp, #8]

		/* Allocate an array index for each task. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
 8010be2:	6818      	ldr	r0, [r3, #0]
 8010be4:	0140      	lsls	r0, r0, #5
 8010be6:	f000 fbbd 	bl	8011364 <pvPortMalloc>
 8010bea:	0004      	movs	r4, r0

		if( pxTaskStatusArray != NULL )
 8010bec:	42b0      	cmp	r0, r6
 8010bee:	d00c      	beq.n	8010c0a <vTaskList+0x36>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
 8010bf0:	9902      	ldr	r1, [sp, #8]
 8010bf2:	0032      	movs	r2, r6
 8010bf4:	f7ff fe1c 	bl	8010830 <uxTaskGetSystemState>
 8010bf8:	9002      	str	r0, [sp, #8]

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
 8010bfa:	9603      	str	r6, [sp, #12]
 8010bfc:	9a03      	ldr	r2, [sp, #12]
 8010bfe:	9b02      	ldr	r3, [sp, #8]
 8010c00:	429a      	cmp	r2, r3
 8010c02:	d303      	bcc.n	8010c0c <vTaskList+0x38>
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
				pcWriteBuffer += strlen( pcWriteBuffer );
			}

			/* Free the array again. */
			vPortFree( pxTaskStatusArray );
 8010c04:	0020      	movs	r0, r4
 8010c06:	f000 fc2d 	bl	8011464 <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8010c0a:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
				switch( pxTaskStatusArray[ x ].eCurrentState )
 8010c0c:	9b03      	ldr	r3, [sp, #12]
 8010c0e:	2600      	movs	r6, #0
 8010c10:	015b      	lsls	r3, r3, #5
 8010c12:	18e3      	adds	r3, r4, r3
 8010c14:	7b1b      	ldrb	r3, [r3, #12]
 8010c16:	3b01      	subs	r3, #1
 8010c18:	b2db      	uxtb	r3, r3
 8010c1a:	2b03      	cmp	r3, #3
 8010c1c:	d801      	bhi.n	8010c22 <vTaskList+0x4e>
 8010c1e:	4a13      	ldr	r2, [pc, #76]	; (8010c6c <vTaskList+0x98>)
 8010c20:	5cd6      	ldrb	r6, [r2, r3]
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
 8010c22:	9b03      	ldr	r3, [sp, #12]
 8010c24:	0028      	movs	r0, r5
 8010c26:	015b      	lsls	r3, r3, #5
 8010c28:	18e3      	adds	r3, r4, r3
 8010c2a:	6859      	ldr	r1, [r3, #4]
 8010c2c:	f7ff fab0 	bl	8010190 <prvWriteNameToBuffer>
 8010c30:	0005      	movs	r5, r0
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
 8010c32:	9b03      	ldr	r3, [sp, #12]
 8010c34:	9a03      	ldr	r2, [sp, #12]
 8010c36:	9903      	ldr	r1, [sp, #12]
 8010c38:	0152      	lsls	r2, r2, #5
 8010c3a:	0149      	lsls	r1, r1, #5
 8010c3c:	1861      	adds	r1, r4, r1
 8010c3e:	6889      	ldr	r1, [r1, #8]
 8010c40:	18a2      	adds	r2, r4, r2
 8010c42:	9101      	str	r1, [sp, #4]
 8010c44:	8b92      	ldrh	r2, [r2, #28]
 8010c46:	015b      	lsls	r3, r3, #5
 8010c48:	9200      	str	r2, [sp, #0]
 8010c4a:	18e3      	adds	r3, r4, r3
 8010c4c:	691b      	ldr	r3, [r3, #16]
 8010c4e:	0032      	movs	r2, r6
 8010c50:	4907      	ldr	r1, [pc, #28]	; (8010c70 <vTaskList+0x9c>)
 8010c52:	f003 ff03 	bl	8014a5c <sprintf>
				pcWriteBuffer += strlen( pcWriteBuffer );
 8010c56:	0028      	movs	r0, r5
 8010c58:	f7ef fa5e 	bl	8000118 <strlen>
			for( x = 0; x < uxArraySize; x++ )
 8010c5c:	9b03      	ldr	r3, [sp, #12]
				pcWriteBuffer += strlen( pcWriteBuffer );
 8010c5e:	182d      	adds	r5, r5, r0
			for( x = 0; x < uxArraySize; x++ )
 8010c60:	3301      	adds	r3, #1
 8010c62:	9303      	str	r3, [sp, #12]
 8010c64:	e7ca      	b.n	8010bfc <vTaskList+0x28>
 8010c66:	46c0      	nop			; (mov r8, r8)
 8010c68:	20001fbc 	.word	0x20001fbc
 8010c6c:	0801c528 	.word	0x0801c528
 8010c70:	0801c544 	.word	0x0801c544

08010c74 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	void vTaskGetRunTimeStats( char *pcWriteBuffer )
	{
 8010c74:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
		 * directly to get access to raw stats data, rather than indirectly
		 * through a call to vTaskGetRunTimeStats().
		 */

		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = 0x00;
 8010c76:	2600      	movs	r6, #0

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
 8010c78:	4b25      	ldr	r3, [pc, #148]	; (8010d10 <vTaskGetRunTimeStats+0x9c>)
		*pcWriteBuffer = 0x00;
 8010c7a:	7006      	strb	r6, [r0, #0]
		uxArraySize = uxCurrentNumberOfTasks;
 8010c7c:	681a      	ldr	r2, [r3, #0]
	{
 8010c7e:	0005      	movs	r5, r0
		uxArraySize = uxCurrentNumberOfTasks;
 8010c80:	9201      	str	r2, [sp, #4]

		/* Allocate an array index for each task. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
 8010c82:	6818      	ldr	r0, [r3, #0]
 8010c84:	0140      	lsls	r0, r0, #5
 8010c86:	f000 fb6d 	bl	8011364 <pvPortMalloc>
 8010c8a:	0004      	movs	r4, r0

		if( pxTaskStatusArray != NULL )
 8010c8c:	42b0      	cmp	r0, r6
 8010c8e:	d00e      	beq.n	8010cae <vTaskGetRunTimeStats+0x3a>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
 8010c90:	9901      	ldr	r1, [sp, #4]
 8010c92:	aa03      	add	r2, sp, #12
 8010c94:	f7ff fdcc 	bl	8010830 <uxTaskGetSystemState>

			/* For percentage calculations. */
			ulTotalTime /= 100UL;
 8010c98:	2164      	movs	r1, #100	; 0x64
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
 8010c9a:	9001      	str	r0, [sp, #4]
			ulTotalTime /= 100UL;
 8010c9c:	9803      	ldr	r0, [sp, #12]
 8010c9e:	f7ef fa6b 	bl	8000178 <__udivsi3>
 8010ca2:	9003      	str	r0, [sp, #12]

			/* Avoid divide by zero errors. */
			if( ulTotalTime > 0 )
 8010ca4:	42b0      	cmp	r0, r6
 8010ca6:	d103      	bne.n	8010cb0 <vTaskGetRunTimeStats+0x3c>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Free the array again. */
			vPortFree( pxTaskStatusArray );
 8010ca8:	0020      	movs	r0, r4
 8010caa:	f000 fbdb 	bl	8011464 <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8010cae:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
				for( x = 0; x < uxArraySize; x++ )
 8010cb0:	9602      	str	r6, [sp, #8]
 8010cb2:	9a02      	ldr	r2, [sp, #8]
 8010cb4:	9b01      	ldr	r3, [sp, #4]
 8010cb6:	429a      	cmp	r2, r3
 8010cb8:	d2f6      	bcs.n	8010ca8 <vTaskGetRunTimeStats+0x34>
					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
 8010cba:	9b02      	ldr	r3, [sp, #8]
 8010cbc:	9903      	ldr	r1, [sp, #12]
 8010cbe:	015b      	lsls	r3, r3, #5
 8010cc0:	18e3      	adds	r3, r4, r3
 8010cc2:	6998      	ldr	r0, [r3, #24]
 8010cc4:	f7ef fa58 	bl	8000178 <__udivsi3>
					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
 8010cc8:	9b02      	ldr	r3, [sp, #8]
					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
 8010cca:	0006      	movs	r6, r0
					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
 8010ccc:	015b      	lsls	r3, r3, #5
 8010cce:	18e3      	adds	r3, r4, r3
 8010cd0:	0028      	movs	r0, r5
 8010cd2:	6859      	ldr	r1, [r3, #4]
 8010cd4:	f7ff fa5c 	bl	8010190 <prvWriteNameToBuffer>
 8010cd8:	0005      	movs	r5, r0
					if( ulStatsAsPercentage > 0UL )
 8010cda:	2e00      	cmp	r6, #0
 8010cdc:	d00f      	beq.n	8010cfe <vTaskGetRunTimeStats+0x8a>
							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
 8010cde:	9a02      	ldr	r2, [sp, #8]
 8010ce0:	0033      	movs	r3, r6
 8010ce2:	0152      	lsls	r2, r2, #5
 8010ce4:	18a2      	adds	r2, r4, r2
 8010ce6:	6992      	ldr	r2, [r2, #24]
 8010ce8:	490a      	ldr	r1, [pc, #40]	; (8010d14 <vTaskGetRunTimeStats+0xa0>)
 8010cea:	f003 feb7 	bl	8014a5c <sprintf>
					pcWriteBuffer += strlen( pcWriteBuffer );
 8010cee:	0028      	movs	r0, r5
 8010cf0:	f7ef fa12 	bl	8000118 <strlen>
				for( x = 0; x < uxArraySize; x++ )
 8010cf4:	9b02      	ldr	r3, [sp, #8]
					pcWriteBuffer += strlen( pcWriteBuffer );
 8010cf6:	182d      	adds	r5, r5, r0
				for( x = 0; x < uxArraySize; x++ )
 8010cf8:	3301      	adds	r3, #1
 8010cfa:	9302      	str	r3, [sp, #8]
 8010cfc:	e7d9      	b.n	8010cb2 <vTaskGetRunTimeStats+0x3e>
							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
 8010cfe:	9b02      	ldr	r3, [sp, #8]
 8010d00:	4905      	ldr	r1, [pc, #20]	; (8010d18 <vTaskGetRunTimeStats+0xa4>)
 8010d02:	015b      	lsls	r3, r3, #5
 8010d04:	18e3      	adds	r3, r4, r3
 8010d06:	699a      	ldr	r2, [r3, #24]
 8010d08:	f003 fea8 	bl	8014a5c <sprintf>
 8010d0c:	e7ef      	b.n	8010cee <vTaskGetRunTimeStats+0x7a>
 8010d0e:	46c0      	nop			; (mov r8, r8)
 8010d10:	20001fbc 	.word	0x20001fbc
 8010d14:	0801c52c 	.word	0x0801c52c
 8010d18:	0801c538 	.word	0x0801c538

08010d1c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 8010d1c:	4b04      	ldr	r3, [pc, #16]	; (8010d30 <pvTaskIncrementMutexHeldCount+0x14>)
 8010d1e:	681a      	ldr	r2, [r3, #0]
 8010d20:	2a00      	cmp	r2, #0
 8010d22:	d003      	beq.n	8010d2c <pvTaskIncrementMutexHeldCount+0x10>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 8010d24:	6819      	ldr	r1, [r3, #0]
 8010d26:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 8010d28:	3201      	adds	r2, #1
 8010d2a:	650a      	str	r2, [r1, #80]	; 0x50
		}

		return pxCurrentTCB;
 8010d2c:	6818      	ldr	r0, [r3, #0]
	}
 8010d2e:	4770      	bx	lr
 8010d30:	20001f20 	.word	0x20001f20

08010d34 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 8010d34:	b570      	push	{r4, r5, r6, lr}
 8010d36:	0006      	movs	r6, r0
 8010d38:	000d      	movs	r5, r1
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 8010d3a:	f000 fa97 	bl	801126c <vPortEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 8010d3e:	4c1c      	ldr	r4, [pc, #112]	; (8010db0 <ulTaskNotifyTake+0x7c>)
 8010d40:	6823      	ldr	r3, [r4, #0]
 8010d42:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010d44:	2b00      	cmp	r3, #0
 8010d46:	d112      	bne.n	8010d6e <ulTaskNotifyTake+0x3a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
 8010d48:	2201      	movs	r2, #1
 8010d4a:	6823      	ldr	r3, [r4, #0]
 8010d4c:	335c      	adds	r3, #92	; 0x5c
 8010d4e:	701a      	strb	r2, [r3, #0]

				if( xTicksToWait > ( TickType_t ) 0 )
 8010d50:	2d00      	cmp	r5, #0
 8010d52:	d00c      	beq.n	8010d6e <ulTaskNotifyTake+0x3a>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8010d54:	6820      	ldr	r0, [r4, #0]
 8010d56:	3004      	adds	r0, #4
 8010d58:	f7fe fec7 	bl	800faea <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
 8010d5c:	1c6b      	adds	r3, r5, #1
 8010d5e:	d11b      	bne.n	8010d98 <ulTaskNotifyTake+0x64>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8010d60:	6821      	ldr	r1, [r4, #0]
 8010d62:	4814      	ldr	r0, [pc, #80]	; (8010db4 <ulTaskNotifyTake+0x80>)
 8010d64:	3104      	adds	r1, #4
 8010d66:	f7fe fe9d 	bl	800faa4 <vListInsertEnd>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 8010d6a:	f000 fa73 	bl	8011254 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8010d6e:	f000 fa89 	bl	8011284 <vPortExitCritical>

		taskENTER_CRITICAL();
 8010d72:	f000 fa7b 	bl	801126c <vPortEnterCritical>
		{
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 8010d76:	6823      	ldr	r3, [r4, #0]
 8010d78:	6d9d      	ldr	r5, [r3, #88]	; 0x58

			if( ulReturn != 0UL )
 8010d7a:	2d00      	cmp	r5, #0
 8010d7c:	d004      	beq.n	8010d88 <ulTaskNotifyTake+0x54>
			{
				if( xClearCountOnExit != pdFALSE )
 8010d7e:	2e00      	cmp	r6, #0
 8010d80:	d010      	beq.n	8010da4 <ulTaskNotifyTake+0x70>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 8010d82:	2200      	movs	r2, #0
 8010d84:	6823      	ldr	r3, [r4, #0]
 8010d86:	659a      	str	r2, [r3, #88]	; 0x58
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 8010d88:	2200      	movs	r2, #0
 8010d8a:	6823      	ldr	r3, [r4, #0]
 8010d8c:	335c      	adds	r3, #92	; 0x5c
 8010d8e:	701a      	strb	r2, [r3, #0]
		}
		taskEXIT_CRITICAL();
 8010d90:	f000 fa78 	bl	8011284 <vPortExitCritical>

		return ulReturn;
	}
 8010d94:	0028      	movs	r0, r5
 8010d96:	bd70      	pop	{r4, r5, r6, pc}
							xTimeToWake = xTickCount + xTicksToWait;
 8010d98:	4b07      	ldr	r3, [pc, #28]	; (8010db8 <ulTaskNotifyTake+0x84>)
 8010d9a:	6818      	ldr	r0, [r3, #0]
 8010d9c:	1940      	adds	r0, r0, r5
							prvAddCurrentTaskToDelayedList( xTimeToWake );
 8010d9e:	f7ff fa1d 	bl	80101dc <prvAddCurrentTaskToDelayedList>
 8010da2:	e7e2      	b.n	8010d6a <ulTaskNotifyTake+0x36>
					( pxCurrentTCB->ulNotifiedValue )--;
 8010da4:	6822      	ldr	r2, [r4, #0]
 8010da6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8010da8:	3b01      	subs	r3, #1
 8010daa:	6593      	str	r3, [r2, #88]	; 0x58
 8010dac:	e7ec      	b.n	8010d88 <ulTaskNotifyTake+0x54>
 8010dae:	46c0      	nop			; (mov r8, r8)
 8010db0:	20001f20 	.word	0x20001f20
 8010db4:	20002018 	.word	0x20002018
 8010db8:	20002040 	.word	0x20002040

08010dbc <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 8010dbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010dbe:	0004      	movs	r4, r0
 8010dc0:	000d      	movs	r5, r1
 8010dc2:	0016      	movs	r6, r2
 8010dc4:	001f      	movs	r7, r3
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;

		configASSERT( xTaskToNotify );
 8010dc6:	2800      	cmp	r0, #0
 8010dc8:	d101      	bne.n	8010dce <xTaskGenericNotify+0x12>
 8010dca:	b672      	cpsid	i
 8010dcc:	e7fe      	b.n	8010dcc <xTaskGenericNotify+0x10>
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
 8010dce:	f000 fa4d 	bl	801126c <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 8010dd2:	2f00      	cmp	r7, #0
 8010dd4:	d001      	beq.n	8010dda <xTaskGenericNotify+0x1e>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 8010dd6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8010dd8:	603b      	str	r3, [r7, #0]
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
 8010dda:	0022      	movs	r2, r4

			pxTCB->eNotifyState = eNotified;
 8010ddc:	2102      	movs	r1, #2
			eOriginalNotifyState = pxTCB->eNotifyState;
 8010dde:	325c      	adds	r2, #92	; 0x5c
 8010de0:	7813      	ldrb	r3, [r2, #0]

			switch( eAction )
 8010de2:	1e70      	subs	r0, r6, #1
			eOriginalNotifyState = pxTCB->eNotifyState;
 8010de4:	b2db      	uxtb	r3, r3
			pxTCB->eNotifyState = eNotified;
 8010de6:	7011      	strb	r1, [r2, #0]
			switch( eAction )
 8010de8:	2803      	cmp	r0, #3
 8010dea:	d80a      	bhi.n	8010e02 <xTaskGenericNotify+0x46>
 8010dec:	f7ef f9a6 	bl	800013c <__gnu_thumb1_case_uqi>
 8010df0:	10040602 	.word	0x10040602
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 8010df4:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8010df6:	4315      	orrs	r5, r2
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
					{
						pxTCB->ulNotifiedValue = ulValue;
 8010df8:	65a5      	str	r5, [r4, #88]	; 0x58
 8010dfa:	e002      	b.n	8010e02 <xTaskGenericNotify+0x46>
					( pxTCB->ulNotifiedValue )++;
 8010dfc:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8010dfe:	3201      	adds	r2, #1
 8010e00:	65a2      	str	r2, [r4, #88]	; 0x58
			}


			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
 8010e02:	2b01      	cmp	r3, #1
 8010e04:	d008      	beq.n	8010e18 <xTaskGenericNotify+0x5c>
 8010e06:	2401      	movs	r4, #1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8010e08:	f000 fa3c 	bl	8011284 <vPortExitCritical>

		return xReturn;
	}
 8010e0c:	0020      	movs	r0, r4
 8010e0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					if( eOriginalNotifyState != eNotified )
 8010e10:	2b02      	cmp	r3, #2
 8010e12:	d1f1      	bne.n	8010df8 <xTaskGenericNotify+0x3c>
						xReturn = pdFAIL;
 8010e14:	2400      	movs	r4, #0
 8010e16:	e7f7      	b.n	8010e08 <xTaskGenericNotify+0x4c>
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8010e18:	1d25      	adds	r5, r4, #4
 8010e1a:	0028      	movs	r0, r5
 8010e1c:	f7fe fe65 	bl	800faea <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 8010e20:	4a0d      	ldr	r2, [pc, #52]	; (8010e58 <xTaskGenericNotify+0x9c>)
 8010e22:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8010e24:	6811      	ldr	r1, [r2, #0]
 8010e26:	428b      	cmp	r3, r1
 8010e28:	d900      	bls.n	8010e2c <xTaskGenericNotify+0x70>
 8010e2a:	6013      	str	r3, [r2, #0]
 8010e2c:	2014      	movs	r0, #20
 8010e2e:	4358      	muls	r0, r3
 8010e30:	4b0a      	ldr	r3, [pc, #40]	; (8010e5c <xTaskGenericNotify+0xa0>)
 8010e32:	0029      	movs	r1, r5
 8010e34:	18c0      	adds	r0, r0, r3
 8010e36:	f7fe fe35 	bl	800faa4 <vListInsertEnd>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8010e3a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8010e3c:	2b00      	cmp	r3, #0
 8010e3e:	d001      	beq.n	8010e44 <xTaskGenericNotify+0x88>
 8010e40:	b672      	cpsid	i
 8010e42:	e7fe      	b.n	8010e42 <xTaskGenericNotify+0x86>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8010e44:	4b06      	ldr	r3, [pc, #24]	; (8010e60 <xTaskGenericNotify+0xa4>)
 8010e46:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8010e48:	681b      	ldr	r3, [r3, #0]
 8010e4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010e4c:	429a      	cmp	r2, r3
 8010e4e:	d9da      	bls.n	8010e06 <xTaskGenericNotify+0x4a>
					taskYIELD_IF_USING_PREEMPTION();
 8010e50:	f000 fa00 	bl	8011254 <vPortYield>
 8010e54:	e7d7      	b.n	8010e06 <xTaskGenericNotify+0x4a>
 8010e56:	46c0      	nop			; (mov r8, r8)
 8010e58:	20001fd0 	.word	0x20001fd0
 8010e5c:	20001f2c 	.word	0x20001f2c
 8010e60:	20001f20 	.word	0x20001f20

08010e64 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8010e64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8010e66:	f000 fa01 	bl	801126c <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8010e6a:	4c10      	ldr	r4, [pc, #64]	; (8010eac <prvCheckForValidListAndQueue+0x48>)
 8010e6c:	6825      	ldr	r5, [r4, #0]
 8010e6e:	2d00      	cmp	r5, #0
 8010e70:	d118      	bne.n	8010ea4 <prvCheckForValidListAndQueue+0x40>
		{
			vListInitialise( &xActiveTimerList1 );
 8010e72:	4f0f      	ldr	r7, [pc, #60]	; (8010eb0 <prvCheckForValidListAndQueue+0x4c>)
 8010e74:	0038      	movs	r0, r7
 8010e76:	f7fe fe07 	bl	800fa88 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8010e7a:	4e0e      	ldr	r6, [pc, #56]	; (8010eb4 <prvCheckForValidListAndQueue+0x50>)
 8010e7c:	0030      	movs	r0, r6
 8010e7e:	f7fe fe03 	bl	800fa88 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 8010e82:	4b0d      	ldr	r3, [pc, #52]	; (8010eb8 <prvCheckForValidListAndQueue+0x54>)
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8010e84:	002a      	movs	r2, r5
			pxCurrentTimerList = &xActiveTimerList1;
 8010e86:	601f      	str	r7, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 8010e88:	4b0c      	ldr	r3, [pc, #48]	; (8010ebc <prvCheckForValidListAndQueue+0x58>)
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8010e8a:	2110      	movs	r1, #16
 8010e8c:	2004      	movs	r0, #4
			pxOverflowTimerList = &xActiveTimerList2;
 8010e8e:	601e      	str	r6, [r3, #0]
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8010e90:	f7fe fef0 	bl	800fc74 <xQueueGenericCreate>
 8010e94:	6020      	str	r0, [r4, #0]
			configASSERT( xTimerQueue );
 8010e96:	2800      	cmp	r0, #0
 8010e98:	d101      	bne.n	8010e9e <prvCheckForValidListAndQueue+0x3a>
 8010e9a:	b672      	cpsid	i
 8010e9c:	e7fe      	b.n	8010e9c <prvCheckForValidListAndQueue+0x38>

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8010e9e:	4908      	ldr	r1, [pc, #32]	; (8010ec0 <prvCheckForValidListAndQueue+0x5c>)
 8010ea0:	f7ff f92a 	bl	80100f8 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8010ea4:	f000 f9ee 	bl	8011284 <vPortExitCritical>
}
 8010ea8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010eaa:	46c0      	nop			; (mov r8, r8)
 8010eac:	2000207c 	.word	0x2000207c
 8010eb0:	20002050 	.word	0x20002050
 8010eb4:	20002064 	.word	0x20002064
 8010eb8:	20002048 	.word	0x20002048
 8010ebc:	2000204c 	.word	0x2000204c
 8010ec0:	0801c558 	.word	0x0801c558

08010ec4 <prvInsertTimerInActiveList>:
{
 8010ec4:	b510      	push	{r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8010ec6:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8010ec8:	6100      	str	r0, [r0, #16]
	if( xNextExpiryTime <= xTimeNow )
 8010eca:	4291      	cmp	r1, r2
 8010ecc:	d80c      	bhi.n	8010ee8 <prvInsertTimerInActiveList+0x24>
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 8010ece:	1ad2      	subs	r2, r2, r3
 8010ed0:	6983      	ldr	r3, [r0, #24]
			xProcessTimerNow = pdTRUE;
 8010ed2:	2401      	movs	r4, #1
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 8010ed4:	429a      	cmp	r2, r3
 8010ed6:	d205      	bcs.n	8010ee4 <prvInsertTimerInActiveList+0x20>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8010ed8:	4b07      	ldr	r3, [pc, #28]	; (8010ef8 <prvInsertTimerInActiveList+0x34>)
 8010eda:	1d01      	adds	r1, r0, #4
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8010edc:	6818      	ldr	r0, [r3, #0]
 8010ede:	f7fe fded 	bl	800fabc <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 8010ee2:	2400      	movs	r4, #0
}
 8010ee4:	0020      	movs	r0, r4
 8010ee6:	bd10      	pop	{r4, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8010ee8:	429a      	cmp	r2, r3
 8010eea:	d202      	bcs.n	8010ef2 <prvInsertTimerInActiveList+0x2e>
			xProcessTimerNow = pdTRUE;
 8010eec:	2401      	movs	r4, #1
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8010eee:	4299      	cmp	r1, r3
 8010ef0:	d2f8      	bcs.n	8010ee4 <prvInsertTimerInActiveList+0x20>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8010ef2:	1d01      	adds	r1, r0, #4
 8010ef4:	4b01      	ldr	r3, [pc, #4]	; (8010efc <prvInsertTimerInActiveList+0x38>)
 8010ef6:	e7f1      	b.n	8010edc <prvInsertTimerInActiveList+0x18>
 8010ef8:	2000204c 	.word	0x2000204c
 8010efc:	20002048 	.word	0x20002048

08010f00 <xTimerCreateTimerTask>:
{
 8010f00:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	prvCheckForValidListAndQueue();
 8010f02:	f7ff ffaf 	bl	8010e64 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 8010f06:	4b0b      	ldr	r3, [pc, #44]	; (8010f34 <xTimerCreateTimerTask+0x34>)
 8010f08:	681b      	ldr	r3, [r3, #0]
 8010f0a:	2b00      	cmp	r3, #0
 8010f0c:	d101      	bne.n	8010f12 <xTimerCreateTimerTask+0x12>
	configASSERT( xReturn );
 8010f0e:	b672      	cpsid	i
 8010f10:	e7fe      	b.n	8010f10 <xTimerCreateTimerTask+0x10>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 8010f12:	2203      	movs	r2, #3
 8010f14:	2300      	movs	r3, #0
 8010f16:	9200      	str	r2, [sp, #0]
 8010f18:	323e      	adds	r2, #62	; 0x3e
 8010f1a:	9303      	str	r3, [sp, #12]
 8010f1c:	9302      	str	r3, [sp, #8]
 8010f1e:	9301      	str	r3, [sp, #4]
 8010f20:	32ff      	adds	r2, #255	; 0xff
 8010f22:	4905      	ldr	r1, [pc, #20]	; (8010f38 <xTimerCreateTimerTask+0x38>)
 8010f24:	4805      	ldr	r0, [pc, #20]	; (8010f3c <xTimerCreateTimerTask+0x3c>)
 8010f26:	f7ff fa92 	bl	801044e <xTaskGenericCreate>
	configASSERT( xReturn );
 8010f2a:	2800      	cmp	r0, #0
 8010f2c:	d0ef      	beq.n	8010f0e <xTimerCreateTimerTask+0xe>
}
 8010f2e:	b005      	add	sp, #20
 8010f30:	bd00      	pop	{pc}
 8010f32:	46c0      	nop			; (mov r8, r8)
 8010f34:	2000207c 	.word	0x2000207c
 8010f38:	0801c55d 	.word	0x0801c55d
 8010f3c:	08011021 	.word	0x08011021

08010f40 <xTimerCreate>:
{
 8010f40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8010f42:	0007      	movs	r7, r0
 8010f44:	000d      	movs	r5, r1
 8010f46:	0016      	movs	r6, r2
 8010f48:	9301      	str	r3, [sp, #4]
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
 8010f4a:	2900      	cmp	r1, #0
 8010f4c:	d012      	beq.n	8010f74 <xTimerCreate+0x34>
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 8010f4e:	202c      	movs	r0, #44	; 0x2c
 8010f50:	f000 fa08 	bl	8011364 <pvPortMalloc>
 8010f54:	1e04      	subs	r4, r0, #0
		if( pxNewTimer != NULL )
 8010f56:	d00b      	beq.n	8010f70 <xTimerCreate+0x30>
			prvCheckForValidListAndQueue();
 8010f58:	f7ff ff84 	bl	8010e64 <prvCheckForValidListAndQueue>
			pxNewTimer->pvTimerID = pvTimerID;
 8010f5c:	9b01      	ldr	r3, [sp, #4]
			pxNewTimer->pcTimerName = pcTimerName;
 8010f5e:	6027      	str	r7, [r4, #0]
			pxNewTimer->pvTimerID = pvTimerID;
 8010f60:	6223      	str	r3, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8010f62:	9b08      	ldr	r3, [sp, #32]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8010f64:	61a5      	str	r5, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
 8010f66:	61e6      	str	r6, [r4, #28]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8010f68:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8010f6a:	1d20      	adds	r0, r4, #4
 8010f6c:	f7fe fd97 	bl	800fa9e <vListInitialiseItem>
}
 8010f70:	0020      	movs	r0, r4
 8010f72:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8010f74:	b672      	cpsid	i
 8010f76:	e7fe      	b.n	8010f76 <xTimerCreate+0x36>

08010f78 <xTimerGenericCommand>:
{
 8010f78:	b5f0      	push	{r4, r5, r6, r7, lr}
	if( xTimerQueue != NULL )
 8010f7a:	4d0f      	ldr	r5, [pc, #60]	; (8010fb8 <xTimerGenericCommand+0x40>)
{
 8010f7c:	0006      	movs	r6, r0
	if( xTimerQueue != NULL )
 8010f7e:	682c      	ldr	r4, [r5, #0]
{
 8010f80:	0017      	movs	r7, r2
 8010f82:	b085      	sub	sp, #20
 8010f84:	001a      	movs	r2, r3
BaseType_t xReturn = pdFAIL;
 8010f86:	1e20      	subs	r0, r4, #0
	if( xTimerQueue != NULL )
 8010f88:	d00f      	beq.n	8010faa <xTimerGenericCommand+0x32>
		xMessage.xMessageID = xCommandID;
 8010f8a:	9100      	str	r1, [sp, #0]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8010f8c:	9701      	str	r7, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 8010f8e:	9602      	str	r6, [sp, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8010f90:	2905      	cmp	r1, #5
 8010f92:	dc0c      	bgt.n	8010fae <xTimerGenericCommand+0x36>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8010f94:	f7ff fda2 	bl	8010adc <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8010f98:	2300      	movs	r3, #0
 8010f9a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8010f9c:	2802      	cmp	r0, #2
 8010f9e:	d000      	beq.n	8010fa2 <xTimerGenericCommand+0x2a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8010fa0:	001a      	movs	r2, r3
 8010fa2:	4669      	mov	r1, sp
 8010fa4:	6828      	ldr	r0, [r5, #0]
 8010fa6:	f7fe fea0 	bl	800fcea <xQueueGenericSend>
}
 8010faa:	b005      	add	sp, #20
 8010fac:	bdf0      	pop	{r4, r5, r6, r7, pc}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8010fae:	2300      	movs	r3, #0
 8010fb0:	4669      	mov	r1, sp
 8010fb2:	f7fe ff4e 	bl	800fe52 <xQueueGenericSendFromISR>
 8010fb6:	e7f8      	b.n	8010faa <xTimerGenericCommand+0x32>
 8010fb8:	2000207c 	.word	0x2000207c

08010fbc <prvSwitchTimerLists>:
{
 8010fbc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8010fbe:	4d16      	ldr	r5, [pc, #88]	; (8011018 <prvSwitchTimerLists+0x5c>)
 8010fc0:	682b      	ldr	r3, [r5, #0]
 8010fc2:	681a      	ldr	r2, [r3, #0]
 8010fc4:	2a00      	cmp	r2, #0
 8010fc6:	d104      	bne.n	8010fd2 <prvSwitchTimerLists+0x16>
	pxCurrentTimerList = pxOverflowTimerList;
 8010fc8:	4a14      	ldr	r2, [pc, #80]	; (801101c <prvSwitchTimerLists+0x60>)
 8010fca:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
 8010fcc:	6013      	str	r3, [r2, #0]
	pxCurrentTimerList = pxOverflowTimerList;
 8010fce:	6029      	str	r1, [r5, #0]
}
 8010fd0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8010fd2:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8010fd4:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8010fd6:	681e      	ldr	r6, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8010fd8:	1d27      	adds	r7, r4, #4
 8010fda:	0038      	movs	r0, r7
 8010fdc:	f7fe fd85 	bl	800faea <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8010fe0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8010fe2:	0020      	movs	r0, r4
 8010fe4:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8010fe6:	69e3      	ldr	r3, [r4, #28]
 8010fe8:	2b01      	cmp	r3, #1
 8010fea:	d1e8      	bne.n	8010fbe <prvSwitchTimerLists+0x2>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8010fec:	69a3      	ldr	r3, [r4, #24]
 8010fee:	18f3      	adds	r3, r6, r3
			if( xReloadTime > xNextExpireTime )
 8010ff0:	429e      	cmp	r6, r3
 8010ff2:	d206      	bcs.n	8011002 <prvSwitchTimerLists+0x46>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8010ff4:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8010ff6:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8010ff8:	0039      	movs	r1, r7
 8010ffa:	6828      	ldr	r0, [r5, #0]
 8010ffc:	f7fe fd5e 	bl	800fabc <vListInsert>
 8011000:	e7dd      	b.n	8010fbe <prvSwitchTimerLists+0x2>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8011002:	2100      	movs	r1, #0
 8011004:	0032      	movs	r2, r6
 8011006:	9100      	str	r1, [sp, #0]
 8011008:	000b      	movs	r3, r1
 801100a:	0020      	movs	r0, r4
 801100c:	f7ff ffb4 	bl	8010f78 <xTimerGenericCommand>
				configASSERT( xResult );
 8011010:	2800      	cmp	r0, #0
 8011012:	d1d4      	bne.n	8010fbe <prvSwitchTimerLists+0x2>
 8011014:	b672      	cpsid	i
 8011016:	e7fe      	b.n	8011016 <prvSwitchTimerLists+0x5a>
 8011018:	20002048 	.word	0x20002048
 801101c:	2000204c 	.word	0x2000204c

08011020 <prvTimerTask>:
{
 8011020:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011022:	b089      	sub	sp, #36	; 0x24
		xNextExpireTime = ( TickType_t ) 0U;
 8011024:	2400      	movs	r4, #0
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8011026:	4f57      	ldr	r7, [pc, #348]	; (8011184 <prvTimerTask+0x164>)
 8011028:	683b      	ldr	r3, [r7, #0]
 801102a:	681a      	ldr	r2, [r3, #0]
 801102c:	9203      	str	r2, [sp, #12]
	if( *pxListWasEmpty == pdFALSE )
 801102e:	42a2      	cmp	r2, r4
 8011030:	d001      	beq.n	8011036 <prvTimerTask+0x16>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8011032:	68db      	ldr	r3, [r3, #12]
 8011034:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
 8011036:	f7ff faa7 	bl	8010588 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 801103a:	f7ff faad 	bl	8010598 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801103e:	4e52      	ldr	r6, [pc, #328]	; (8011188 <prvTimerTask+0x168>)
	xTimeNow = xTaskGetTickCount();
 8011040:	0005      	movs	r5, r0
	if( xTimeNow < xLastTime )
 8011042:	6833      	ldr	r3, [r6, #0]
 8011044:	4298      	cmp	r0, r3
 8011046:	d23c      	bcs.n	80110c2 <prvTimerTask+0xa2>
		prvSwitchTimerLists();
 8011048:	f7ff ffb8 	bl	8010fbc <prvSwitchTimerLists>
	xLastTime = xTimeNow;
 801104c:	6035      	str	r5, [r6, #0]
			( void ) xTaskResumeAll();
 801104e:	f7ff fb31 	bl	80106b4 <xTaskResumeAll>
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8011052:	2300      	movs	r3, #0
 8011054:	484d      	ldr	r0, [pc, #308]	; (801118c <prvTimerTask+0x16c>)
 8011056:	001a      	movs	r2, r3
 8011058:	a904      	add	r1, sp, #16
 801105a:	6800      	ldr	r0, [r0, #0]
 801105c:	f7fe ff75 	bl	800ff4a <xQueueGenericReceive>
 8011060:	2800      	cmp	r0, #0
 8011062:	d0df      	beq.n	8011024 <prvTimerTask+0x4>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 8011064:	9b04      	ldr	r3, [sp, #16]
 8011066:	2b00      	cmp	r3, #0
 8011068:	da04      	bge.n	8011074 <prvTimerTask+0x54>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 801106a:	9b05      	ldr	r3, [sp, #20]
 801106c:	9907      	ldr	r1, [sp, #28]
 801106e:	9806      	ldr	r0, [sp, #24]
 8011070:	9303      	str	r3, [sp, #12]
 8011072:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8011074:	9b04      	ldr	r3, [sp, #16]
 8011076:	9303      	str	r3, [sp, #12]
 8011078:	2b00      	cmp	r3, #0
 801107a:	dbea      	blt.n	8011052 <prvTimerTask+0x32>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 801107c:	9c06      	ldr	r4, [sp, #24]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 801107e:	6963      	ldr	r3, [r4, #20]
 8011080:	2b00      	cmp	r3, #0
 8011082:	d002      	beq.n	801108a <prvTimerTask+0x6a>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8011084:	1d20      	adds	r0, r4, #4
 8011086:	f7fe fd30 	bl	800faea <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 801108a:	f7ff fa85 	bl	8010598 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801108e:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
 8011090:	0005      	movs	r5, r0
	if( xTimeNow < xLastTime )
 8011092:	4298      	cmp	r0, r3
 8011094:	d201      	bcs.n	801109a <prvTimerTask+0x7a>
		prvSwitchTimerLists();
 8011096:	f7ff ff91 	bl	8010fbc <prvSwitchTimerLists>
 801109a:	9b04      	ldr	r3, [sp, #16]
	xLastTime = xTimeNow;
 801109c:	6035      	str	r5, [r6, #0]
 801109e:	2b09      	cmp	r3, #9
 80110a0:	d8d7      	bhi.n	8011052 <prvTimerTask+0x32>
 80110a2:	2201      	movs	r2, #1
 80110a4:	2784      	movs	r7, #132	; 0x84
 80110a6:	409a      	lsls	r2, r3
 80110a8:	00bf      	lsls	r7, r7, #2
 80110aa:	0013      	movs	r3, r2
 80110ac:	4017      	ands	r7, r2
 80110ae:	d15b      	bne.n	8011168 <prvTimerTask+0x148>
 80110b0:	22c7      	movs	r2, #199	; 0xc7
 80110b2:	4213      	tst	r3, r2
 80110b4:	d13a      	bne.n	801112c <prvTimerTask+0x10c>
 80110b6:	069b      	lsls	r3, r3, #26
 80110b8:	d5cb      	bpl.n	8011052 <prvTimerTask+0x32>
					vPortFree( pxTimer );
 80110ba:	0020      	movs	r0, r4
 80110bc:	f000 f9d2 	bl	8011464 <vPortFree>
 80110c0:	e7c7      	b.n	8011052 <prvTimerTask+0x32>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80110c2:	9b03      	ldr	r3, [sp, #12]
	xLastTime = xTimeNow;
 80110c4:	6030      	str	r0, [r6, #0]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80110c6:	2b00      	cmp	r3, #0
 80110c8:	d024      	beq.n	8011114 <prvTimerTask+0xf4>
 80110ca:	4284      	cmp	r4, r0
 80110cc:	d822      	bhi.n	8011114 <prvTimerTask+0xf4>
				( void ) xTaskResumeAll();
 80110ce:	f7ff faf1 	bl	80106b4 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 80110d2:	683b      	ldr	r3, [r7, #0]
 80110d4:	68db      	ldr	r3, [r3, #12]
 80110d6:	68df      	ldr	r7, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80110d8:	1d38      	adds	r0, r7, #4
 80110da:	f7fe fd06 	bl	800faea <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 80110de:	69fb      	ldr	r3, [r7, #28]
 80110e0:	2b01      	cmp	r3, #1
 80110e2:	d113      	bne.n	801110c <prvTimerTask+0xec>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 80110e4:	69bb      	ldr	r3, [r7, #24]
 80110e6:	002a      	movs	r2, r5
 80110e8:	18e1      	adds	r1, r4, r3
 80110ea:	0038      	movs	r0, r7
 80110ec:	0023      	movs	r3, r4
 80110ee:	f7ff fee9 	bl	8010ec4 <prvInsertTimerInActiveList>
 80110f2:	2801      	cmp	r0, #1
 80110f4:	d10a      	bne.n	801110c <prvTimerTask+0xec>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80110f6:	2100      	movs	r1, #0
 80110f8:	0022      	movs	r2, r4
 80110fa:	9100      	str	r1, [sp, #0]
 80110fc:	000b      	movs	r3, r1
 80110fe:	0038      	movs	r0, r7
 8011100:	f7ff ff3a 	bl	8010f78 <xTimerGenericCommand>
			configASSERT( xResult );
 8011104:	2800      	cmp	r0, #0
 8011106:	d101      	bne.n	801110c <prvTimerTask+0xec>
 8011108:	b672      	cpsid	i
 801110a:	e7fe      	b.n	801110a <prvTimerTask+0xea>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801110c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801110e:	0038      	movs	r0, r7
 8011110:	4798      	blx	r3
 8011112:	e79e      	b.n	8011052 <prvTimerTask+0x32>
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 8011114:	4b1d      	ldr	r3, [pc, #116]	; (801118c <prvTimerTask+0x16c>)
 8011116:	1b61      	subs	r1, r4, r5
 8011118:	6818      	ldr	r0, [r3, #0]
 801111a:	f7ff f81c 	bl	8010156 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 801111e:	f7ff fac9 	bl	80106b4 <xTaskResumeAll>
 8011122:	2800      	cmp	r0, #0
 8011124:	d195      	bne.n	8011052 <prvTimerTask+0x32>
					portYIELD_WITHIN_API();
 8011126:	f000 f895 	bl	8011254 <vPortYield>
 801112a:	e792      	b.n	8011052 <prvTimerTask+0x32>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
 801112c:	9b05      	ldr	r3, [sp, #20]
 801112e:	69a2      	ldr	r2, [r4, #24]
 8011130:	0020      	movs	r0, r4
 8011132:	1899      	adds	r1, r3, r2
 8011134:	002a      	movs	r2, r5
 8011136:	9303      	str	r3, [sp, #12]
 8011138:	f7ff fec4 	bl	8010ec4 <prvInsertTimerInActiveList>
 801113c:	2801      	cmp	r0, #1
 801113e:	d188      	bne.n	8011052 <prvTimerTask+0x32>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8011140:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8011142:	0020      	movs	r0, r4
 8011144:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8011146:	69e3      	ldr	r3, [r4, #28]
 8011148:	2b01      	cmp	r3, #1
 801114a:	d182      	bne.n	8011052 <prvTimerTask+0x32>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 801114c:	69a3      	ldr	r3, [r4, #24]
 801114e:	9a05      	ldr	r2, [sp, #20]
 8011150:	9700      	str	r7, [sp, #0]
 8011152:	18d2      	adds	r2, r2, r3
 8011154:	0039      	movs	r1, r7
 8011156:	003b      	movs	r3, r7
 8011158:	0020      	movs	r0, r4
 801115a:	f7ff ff0d 	bl	8010f78 <xTimerGenericCommand>
							configASSERT( xResult );
 801115e:	2800      	cmp	r0, #0
 8011160:	d000      	beq.n	8011164 <prvTimerTask+0x144>
 8011162:	e776      	b.n	8011052 <prvTimerTask+0x32>
 8011164:	b672      	cpsid	i
 8011166:	e7fe      	b.n	8011166 <prvTimerTask+0x146>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8011168:	9905      	ldr	r1, [sp, #20]
 801116a:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 801116c:	2900      	cmp	r1, #0
 801116e:	d101      	bne.n	8011174 <prvTimerTask+0x154>
 8011170:	b672      	cpsid	i
 8011172:	e7fe      	b.n	8011172 <prvTimerTask+0x152>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8011174:	1949      	adds	r1, r1, r5
 8011176:	002b      	movs	r3, r5
 8011178:	002a      	movs	r2, r5
 801117a:	0020      	movs	r0, r4
 801117c:	f7ff fea2 	bl	8010ec4 <prvInsertTimerInActiveList>
 8011180:	e767      	b.n	8011052 <prvTimerTask+0x32>
 8011182:	46c0      	nop			; (mov r8, r8)
 8011184:	20002048 	.word	0x20002048
 8011188:	20002078 	.word	0x20002078
 801118c:	2000207c 	.word	0x2000207c

08011190 <pvTimerGetTimerID>:
	return xTimerIsInActiveList;
} /*lint !e818 Can't be pointer to const due to the typedef. */
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
 8011190:	b510      	push	{r4, lr}
 8011192:	1e04      	subs	r4, r0, #0
Timer_t * const pxTimer = ( Timer_t * ) xTimer;
void *pvReturn;

	configASSERT( xTimer );
 8011194:	d101      	bne.n	801119a <pvTimerGetTimerID+0xa>
 8011196:	b672      	cpsid	i
 8011198:	e7fe      	b.n	8011198 <pvTimerGetTimerID+0x8>

	taskENTER_CRITICAL();
 801119a:	f000 f867 	bl	801126c <vPortEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
 801119e:	6a24      	ldr	r4, [r4, #32]
	}
	taskEXIT_CRITICAL();
 80111a0:	f000 f870 	bl	8011284 <vPortExitCritical>

	return pvReturn;
}
 80111a4:	0020      	movs	r0, r4
 80111a6:	bd10      	pop	{r4, pc}

080111a8 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 80111a8:	4b03      	ldr	r3, [pc, #12]	; (80111b8 <prvTaskExitError+0x10>)
 80111aa:	681b      	ldr	r3, [r3, #0]
 80111ac:	3301      	adds	r3, #1
 80111ae:	d001      	beq.n	80111b4 <prvTaskExitError+0xc>
 80111b0:	b672      	cpsid	i
 80111b2:	e7fe      	b.n	80111b2 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
 80111b4:	b672      	cpsid	i
 80111b6:	e7fe      	b.n	80111b6 <prvTaskExitError+0xe>
 80111b8:	200000cc 	.word	0x200000cc

080111bc <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 80111bc:	4a06      	ldr	r2, [pc, #24]	; (80111d8 <pxCurrentTCBConst2>)
 80111be:	6813      	ldr	r3, [r2, #0]
 80111c0:	6818      	ldr	r0, [r3, #0]
 80111c2:	3020      	adds	r0, #32
 80111c4:	f380 8809 	msr	PSP, r0
 80111c8:	2002      	movs	r0, #2
 80111ca:	f380 8814 	msr	CONTROL, r0
 80111ce:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 80111d0:	46ae      	mov	lr, r5
 80111d2:	b662      	cpsie	i
 80111d4:	bd00      	pop	{pc}
 80111d6:	46c0      	nop			; (mov r8, r8)

080111d8 <pxCurrentTCBConst2>:
 80111d8:	20001f20 	.word	0x20001f20

080111dc <pxPortInitialiseStack>:
{
 80111dc:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80111de:	2480      	movs	r4, #128	; 0x80
 80111e0:	1f03      	subs	r3, r0, #4
 80111e2:	0464      	lsls	r4, r4, #17
 80111e4:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 80111e6:	3b04      	subs	r3, #4
 80111e8:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80111ea:	4903      	ldr	r1, [pc, #12]	; (80111f8 <pxPortInitialiseStack+0x1c>)
 80111ec:	3b04      	subs	r3, #4
 80111ee:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80111f0:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 80111f2:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80111f4:	601a      	str	r2, [r3, #0]
}
 80111f6:	bd10      	pop	{r4, pc}
 80111f8:	080111a9 	.word	0x080111a9

080111fc <SVC_Handler>:
}
 80111fc:	4770      	bx	lr
	...

08011200 <xPortStartScheduler>:
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8011200:	22ff      	movs	r2, #255	; 0xff
{
 8011202:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8011204:	4b0e      	ldr	r3, [pc, #56]	; (8011240 <xPortStartScheduler+0x40>)
 8011206:	0412      	lsls	r2, r2, #16
 8011208:	6819      	ldr	r1, [r3, #0]
 801120a:	430a      	orrs	r2, r1
 801120c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 801120e:	22ff      	movs	r2, #255	; 0xff
 8011210:	6819      	ldr	r1, [r3, #0]
 8011212:	0612      	lsls	r2, r2, #24
 8011214:	430a      	orrs	r2, r1
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8011216:	21fa      	movs	r1, #250	; 0xfa
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8011218:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 801121a:	4b0a      	ldr	r3, [pc, #40]	; (8011244 <xPortStartScheduler+0x44>)
 801121c:	0089      	lsls	r1, r1, #2
 801121e:	6818      	ldr	r0, [r3, #0]
 8011220:	f7ee ffaa 	bl	8000178 <__udivsi3>
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8011224:	2207      	movs	r2, #7
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8011226:	4b08      	ldr	r3, [pc, #32]	; (8011248 <xPortStartScheduler+0x48>)
 8011228:	3801      	subs	r0, #1
 801122a:	6018      	str	r0, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 801122c:	4b07      	ldr	r3, [pc, #28]	; (801124c <xPortStartScheduler+0x4c>)
 801122e:	601a      	str	r2, [r3, #0]
	uxCriticalNesting = 0;
 8011230:	2200      	movs	r2, #0
 8011232:	4b07      	ldr	r3, [pc, #28]	; (8011250 <xPortStartScheduler+0x50>)
 8011234:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
 8011236:	f7ff ffc1 	bl	80111bc <vPortStartFirstTask>
	prvTaskExitError();
 801123a:	f7ff ffb5 	bl	80111a8 <prvTaskExitError>
 801123e:	46c0      	nop			; (mov r8, r8)
 8011240:	e000ed20 	.word	0xe000ed20
 8011244:	200000a0 	.word	0x200000a0
 8011248:	e000e014 	.word	0xe000e014
 801124c:	e000e010 	.word	0xe000e010
 8011250:	200000cc 	.word	0x200000cc

08011254 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 8011254:	2280      	movs	r2, #128	; 0x80
 8011256:	4b04      	ldr	r3, [pc, #16]	; (8011268 <vPortYield+0x14>)
 8011258:	0552      	lsls	r2, r2, #21
 801125a:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
 801125c:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8011260:	f3bf 8f6f 	isb	sy
}
 8011264:	4770      	bx	lr
 8011266:	46c0      	nop			; (mov r8, r8)
 8011268:	e000ed04 	.word	0xe000ed04

0801126c <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
 801126c:	b672      	cpsid	i
    uxCriticalNesting++;
 801126e:	4a04      	ldr	r2, [pc, #16]	; (8011280 <vPortEnterCritical+0x14>)
 8011270:	6813      	ldr	r3, [r2, #0]
 8011272:	3301      	adds	r3, #1
 8011274:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 8011276:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 801127a:	f3bf 8f6f 	isb	sy
}
 801127e:	4770      	bx	lr
 8011280:	200000cc 	.word	0x200000cc

08011284 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8011284:	4a05      	ldr	r2, [pc, #20]	; (801129c <vPortExitCritical+0x18>)
 8011286:	6813      	ldr	r3, [r2, #0]
 8011288:	2b00      	cmp	r3, #0
 801128a:	d101      	bne.n	8011290 <vPortExitCritical+0xc>
 801128c:	b672      	cpsid	i
 801128e:	e7fe      	b.n	801128e <vPortExitCritical+0xa>
    uxCriticalNesting--;
 8011290:	3b01      	subs	r3, #1
 8011292:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 8011294:	2b00      	cmp	r3, #0
 8011296:	d100      	bne.n	801129a <vPortExitCritical+0x16>
        portENABLE_INTERRUPTS();
 8011298:	b662      	cpsie	i
}
 801129a:	4770      	bx	lr
 801129c:	200000cc 	.word	0x200000cc

080112a0 <ulSetInterruptMaskFromISR>:
	__asm volatile(
 80112a0:	f3ef 8010 	mrs	r0, PRIMASK
 80112a4:	b672      	cpsid	i
 80112a6:	4770      	bx	lr
}
 80112a8:	2000      	movs	r0, #0

080112aa <vClearInterruptMaskFromISR>:
	__asm volatile(
 80112aa:	f380 8810 	msr	PRIMASK, r0
 80112ae:	4770      	bx	lr

080112b0 <PendSV_Handler>:
	__asm volatile
 80112b0:	f3ef 8009 	mrs	r0, PSP
 80112b4:	4b0e      	ldr	r3, [pc, #56]	; (80112f0 <pxCurrentTCBConst>)
 80112b6:	681a      	ldr	r2, [r3, #0]
 80112b8:	3820      	subs	r0, #32
 80112ba:	6010      	str	r0, [r2, #0]
 80112bc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 80112be:	4644      	mov	r4, r8
 80112c0:	464d      	mov	r5, r9
 80112c2:	4656      	mov	r6, sl
 80112c4:	465f      	mov	r7, fp
 80112c6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 80112c8:	b508      	push	{r3, lr}
 80112ca:	b672      	cpsid	i
 80112cc:	f7ff fafe 	bl	80108cc <vTaskSwitchContext>
 80112d0:	b662      	cpsie	i
 80112d2:	bc0c      	pop	{r2, r3}
 80112d4:	6811      	ldr	r1, [r2, #0]
 80112d6:	6808      	ldr	r0, [r1, #0]
 80112d8:	3010      	adds	r0, #16
 80112da:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 80112dc:	46a0      	mov	r8, r4
 80112de:	46a9      	mov	r9, r5
 80112e0:	46b2      	mov	sl, r6
 80112e2:	46bb      	mov	fp, r7
 80112e4:	f380 8809 	msr	PSP, r0
 80112e8:	3820      	subs	r0, #32
 80112ea:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 80112ec:	4718      	bx	r3
 80112ee:	46c0      	nop			; (mov r8, r8)

080112f0 <pxCurrentTCBConst>:
 80112f0:	20001f20 	.word	0x20001f20

080112f4 <xPortSysTickHandler>:
{
 80112f4:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 80112f6:	f7ff ffd3 	bl	80112a0 <ulSetInterruptMaskFromISR>
 80112fa:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
 80112fc:	f7ff f958 	bl	80105b0 <xTaskIncrementTick>
 8011300:	2800      	cmp	r0, #0
 8011302:	d003      	beq.n	801130c <xPortSysTickHandler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8011304:	2280      	movs	r2, #128	; 0x80
 8011306:	4b03      	ldr	r3, [pc, #12]	; (8011314 <xPortSysTickHandler+0x20>)
 8011308:	0552      	lsls	r2, r2, #21
 801130a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 801130c:	0020      	movs	r0, r4
 801130e:	f7ff ffcc 	bl	80112aa <vClearInterruptMaskFromISR>
}
 8011312:	bd10      	pop	{r4, pc}
 8011314:	e000ed04 	.word	0xe000ed04

08011318 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8011318:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 801131a:	4b10      	ldr	r3, [pc, #64]	; (801135c <prvInsertBlockIntoFreeList+0x44>)
 801131c:	681a      	ldr	r2, [r3, #0]
 801131e:	4282      	cmp	r2, r0
 8011320:	d319      	bcc.n	8011356 <prvInsertBlockIntoFreeList+0x3e>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8011322:	685c      	ldr	r4, [r3, #4]
 8011324:	1919      	adds	r1, r3, r4
 8011326:	4288      	cmp	r0, r1
 8011328:	d103      	bne.n	8011332 <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801132a:	6841      	ldr	r1, [r0, #4]
 801132c:	0018      	movs	r0, r3
 801132e:	1909      	adds	r1, r1, r4
 8011330:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8011332:	6841      	ldr	r1, [r0, #4]
 8011334:	1844      	adds	r4, r0, r1
 8011336:	42a2      	cmp	r2, r4
 8011338:	d108      	bne.n	801134c <prvInsertBlockIntoFreeList+0x34>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 801133a:	4c09      	ldr	r4, [pc, #36]	; (8011360 <prvInsertBlockIntoFreeList+0x48>)
 801133c:	6824      	ldr	r4, [r4, #0]
 801133e:	42a2      	cmp	r2, r4
 8011340:	d004      	beq.n	801134c <prvInsertBlockIntoFreeList+0x34>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8011342:	6852      	ldr	r2, [r2, #4]
 8011344:	1852      	adds	r2, r2, r1
 8011346:	6042      	str	r2, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8011348:	681a      	ldr	r2, [r3, #0]
 801134a:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 801134c:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 801134e:	4298      	cmp	r0, r3
 8011350:	d000      	beq.n	8011354 <prvInsertBlockIntoFreeList+0x3c>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8011352:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8011354:	bd10      	pop	{r4, pc}
 8011356:	0013      	movs	r3, r2
 8011358:	e7e0      	b.n	801131c <prvInsertBlockIntoFreeList+0x4>
 801135a:	46c0      	nop			; (mov r8, r8)
 801135c:	20006eb0 	.word	0x20006eb0
 8011360:	20002080 	.word	0x20002080

08011364 <pvPortMalloc>:
{
 8011364:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8011366:	0004      	movs	r4, r0
	vTaskSuspendAll();
 8011368:	f7ff f90e 	bl	8010588 <vTaskSuspendAll>
		if( pxEnd == NULL )
 801136c:	4a36      	ldr	r2, [pc, #216]	; (8011448 <pvPortMalloc+0xe4>)
 801136e:	4837      	ldr	r0, [pc, #220]	; (801144c <pvPortMalloc+0xe8>)
 8011370:	6813      	ldr	r3, [r2, #0]
 8011372:	2b00      	cmp	r3, #0
 8011374:	d11c      	bne.n	80113b0 <pvPortMalloc+0x4c>
	if( ( ulAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8011376:	2507      	movs	r5, #7
	ulAddress = ( uint32_t ) ucHeap;
 8011378:	4935      	ldr	r1, [pc, #212]	; (8011450 <pvPortMalloc+0xec>)
 801137a:	4b36      	ldr	r3, [pc, #216]	; (8011454 <pvPortMalloc+0xf0>)
 801137c:	18cb      	adds	r3, r1, r3
	if( ( ulAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 801137e:	4229      	tst	r1, r5
 8011380:	d040      	beq.n	8011404 <pvPortMalloc+0xa0>
		ulAddress += ( portBYTE_ALIGNMENT - 1 );
 8011382:	1949      	adds	r1, r1, r5
		ulAddress &= ~( ( uint32_t ) portBYTE_ALIGNMENT_MASK );
 8011384:	43a9      	bics	r1, r5
		xTotalHeapSize -= ulAddress - ( uint32_t ) ucHeap;
 8011386:	1a5b      	subs	r3, r3, r1
	xStart.xBlockSize = ( size_t ) 0;
 8011388:	2500      	movs	r5, #0
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 801138a:	4e33      	ldr	r6, [pc, #204]	; (8011458 <pvPortMalloc+0xf4>)
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
 801138c:	18cb      	adds	r3, r1, r3
	xStart.xBlockSize = ( size_t ) 0;
 801138e:	6075      	str	r5, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8011390:	6031      	str	r1, [r6, #0]
	ulAddress &= ~( ( uint32_t ) portBYTE_ALIGNMENT_MASK );
 8011392:	2607      	movs	r6, #7
	ulAddress -= xHeapStructSize;
 8011394:	3b08      	subs	r3, #8
	ulAddress &= ~( ( uint32_t ) portBYTE_ALIGNMENT_MASK );
 8011396:	43b3      	bics	r3, r6
	pxEnd->pxNextFreeBlock = NULL;
 8011398:	601d      	str	r5, [r3, #0]
	pxEnd->xBlockSize = 0;
 801139a:	605d      	str	r5, [r3, #4]
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
 801139c:	1a5d      	subs	r5, r3, r1
	pxEnd = ( void * ) ulAddress;
 801139e:	6013      	str	r3, [r2, #0]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 80113a0:	c128      	stmia	r1!, {r3, r5}
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80113a2:	4b2e      	ldr	r3, [pc, #184]	; (801145c <pvPortMalloc+0xf8>)
 80113a4:	601d      	str	r5, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80113a6:	4b2e      	ldr	r3, [pc, #184]	; (8011460 <pvPortMalloc+0xfc>)
 80113a8:	601d      	str	r5, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80113aa:	2380      	movs	r3, #128	; 0x80
 80113ac:	061b      	lsls	r3, r3, #24
 80113ae:	6003      	str	r3, [r0, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 80113b0:	6806      	ldr	r6, [r0, #0]
 80113b2:	4234      	tst	r4, r6
 80113b4:	d143      	bne.n	801143e <pvPortMalloc+0xda>
			if( xWantedSize > 0 )
 80113b6:	2c00      	cmp	r4, #0
 80113b8:	d041      	beq.n	801143e <pvPortMalloc+0xda>
				xWantedSize += xHeapStructSize;
 80113ba:	0023      	movs	r3, r4
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80113bc:	2107      	movs	r1, #7
				xWantedSize += xHeapStructSize;
 80113be:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80113c0:	420b      	tst	r3, r1
 80113c2:	d001      	beq.n	80113c8 <pvPortMalloc+0x64>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 80113c4:	438b      	bics	r3, r1
 80113c6:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 80113c8:	2b00      	cmp	r3, #0
 80113ca:	d038      	beq.n	801143e <pvPortMalloc+0xda>
 80113cc:	4f24      	ldr	r7, [pc, #144]	; (8011460 <pvPortMalloc+0xfc>)
 80113ce:	683d      	ldr	r5, [r7, #0]
 80113d0:	429d      	cmp	r5, r3
 80113d2:	d334      	bcc.n	801143e <pvPortMalloc+0xda>
				pxBlock = xStart.pxNextFreeBlock;
 80113d4:	4920      	ldr	r1, [pc, #128]	; (8011458 <pvPortMalloc+0xf4>)
 80113d6:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80113d8:	6860      	ldr	r0, [r4, #4]
 80113da:	4298      	cmp	r0, r3
 80113dc:	d202      	bcs.n	80113e4 <pvPortMalloc+0x80>
 80113de:	6820      	ldr	r0, [r4, #0]
 80113e0:	2800      	cmp	r0, #0
 80113e2:	d111      	bne.n	8011408 <pvPortMalloc+0xa4>
				if( pxBlock != pxEnd )
 80113e4:	6812      	ldr	r2, [r2, #0]
 80113e6:	42a2      	cmp	r2, r4
 80113e8:	d029      	beq.n	801143e <pvPortMalloc+0xda>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80113ea:	680a      	ldr	r2, [r1, #0]
 80113ec:	9201      	str	r2, [sp, #4]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80113ee:	6822      	ldr	r2, [r4, #0]
 80113f0:	600a      	str	r2, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80113f2:	6862      	ldr	r2, [r4, #4]
 80113f4:	1ad2      	subs	r2, r2, r3
 80113f6:	2a10      	cmp	r2, #16
 80113f8:	d90d      	bls.n	8011416 <pvPortMalloc+0xb2>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80113fa:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80113fc:	0741      	lsls	r1, r0, #29
 80113fe:	d006      	beq.n	801140e <pvPortMalloc+0xaa>
 8011400:	b672      	cpsid	i
 8011402:	e7fe      	b.n	8011402 <pvPortMalloc+0x9e>
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8011404:	4b13      	ldr	r3, [pc, #76]	; (8011454 <pvPortMalloc+0xf0>)
 8011406:	e7bf      	b.n	8011388 <pvPortMalloc+0x24>
 8011408:	0021      	movs	r1, r4
 801140a:	0004      	movs	r4, r0
 801140c:	e7e4      	b.n	80113d8 <pvPortMalloc+0x74>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 801140e:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8011410:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8011412:	f7ff ff81 	bl	8011318 <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8011416:	4a11      	ldr	r2, [pc, #68]	; (801145c <pvPortMalloc+0xf8>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8011418:	6863      	ldr	r3, [r4, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 801141a:	6811      	ldr	r1, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 801141c:	1aed      	subs	r5, r5, r3
 801141e:	603d      	str	r5, [r7, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8011420:	428d      	cmp	r5, r1
 8011422:	d200      	bcs.n	8011426 <pvPortMalloc+0xc2>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8011424:	6015      	str	r5, [r2, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8011426:	431e      	orrs	r6, r3
					pxBlock->pxNextFreeBlock = NULL;
 8011428:	2300      	movs	r3, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 801142a:	9d01      	ldr	r5, [sp, #4]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 801142c:	6066      	str	r6, [r4, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 801142e:	3508      	adds	r5, #8
					pxBlock->pxNextFreeBlock = NULL;
 8011430:	6023      	str	r3, [r4, #0]
	( void ) xTaskResumeAll();
 8011432:	f7ff f93f 	bl	80106b4 <xTaskResumeAll>
	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8011436:	076b      	lsls	r3, r5, #29
 8011438:	d003      	beq.n	8011442 <pvPortMalloc+0xde>
 801143a:	b672      	cpsid	i
 801143c:	e7fe      	b.n	801143c <pvPortMalloc+0xd8>
void *pvReturn = NULL;
 801143e:	2500      	movs	r5, #0
 8011440:	e7f7      	b.n	8011432 <pvPortMalloc+0xce>
}
 8011442:	0028      	movs	r0, r5
 8011444:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8011446:	46c0      	nop			; (mov r8, r8)
 8011448:	20002080 	.word	0x20002080
 801144c:	20006ea4 	.word	0x20006ea4
 8011450:	20002084 	.word	0x20002084
 8011454:	00004e20 	.word	0x00004e20
 8011458:	20006eb0 	.word	0x20006eb0
 801145c:	20006eac 	.word	0x20006eac
 8011460:	20006ea8 	.word	0x20006ea8

08011464 <vPortFree>:
{
 8011464:	b510      	push	{r4, lr}
	if( pv != NULL )
 8011466:	2800      	cmp	r0, #0
 8011468:	d01b      	beq.n	80114a2 <vPortFree+0x3e>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 801146a:	4a0e      	ldr	r2, [pc, #56]	; (80114a4 <vPortFree+0x40>)
 801146c:	3808      	subs	r0, #8
 801146e:	6843      	ldr	r3, [r0, #4]
 8011470:	6812      	ldr	r2, [r2, #0]
 8011472:	0004      	movs	r4, r0
 8011474:	421a      	tst	r2, r3
 8011476:	d101      	bne.n	801147c <vPortFree+0x18>
 8011478:	b672      	cpsid	i
 801147a:	e7fe      	b.n	801147a <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 801147c:	6801      	ldr	r1, [r0, #0]
 801147e:	2900      	cmp	r1, #0
 8011480:	d001      	beq.n	8011486 <vPortFree+0x22>
 8011482:	b672      	cpsid	i
 8011484:	e7fe      	b.n	8011484 <vPortFree+0x20>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8011486:	4393      	bics	r3, r2
 8011488:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
 801148a:	f7ff f87d 	bl	8010588 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 801148e:	4a06      	ldr	r2, [pc, #24]	; (80114a8 <vPortFree+0x44>)
 8011490:	6863      	ldr	r3, [r4, #4]
 8011492:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8011494:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
 8011496:	185b      	adds	r3, r3, r1
 8011498:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 801149a:	f7ff ff3d 	bl	8011318 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 801149e:	f7ff f909 	bl	80106b4 <xTaskResumeAll>
}
 80114a2:	bd10      	pop	{r4, pc}
 80114a4:	20006ea4 	.word	0x20006ea4
 80114a8:	20006ea8 	.word	0x20006ea8

080114ac <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80114ac:	b510      	push	{r4, lr}
 80114ae:	0004      	movs	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80114b0:	f001 fad0 	bl	8012a54 <HAL_RCC_GetHCLKFreq>
 80114b4:	21fa      	movs	r1, #250	; 0xfa
 80114b6:	0089      	lsls	r1, r1, #2
 80114b8:	f7ee fe5e 	bl	8000178 <__udivsi3>
 80114bc:	f000 f87e 	bl	80115bc <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 80114c0:	2001      	movs	r0, #1
 80114c2:	2200      	movs	r2, #0
 80114c4:	0021      	movs	r1, r4
 80114c6:	4240      	negs	r0, r0
 80114c8:	f000 f83a 	bl	8011540 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 80114cc:	2000      	movs	r0, #0
 80114ce:	bd10      	pop	{r4, pc}

080114d0 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80114d0:	2310      	movs	r3, #16
{
 80114d2:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80114d4:	4a05      	ldr	r2, [pc, #20]	; (80114ec <HAL_Init+0x1c>)
  HAL_InitTick(TICK_INT_PRIORITY);
 80114d6:	2000      	movs	r0, #0
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80114d8:	6811      	ldr	r1, [r2, #0]
 80114da:	430b      	orrs	r3, r1
 80114dc:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 80114de:	f7ff ffe5 	bl	80114ac <HAL_InitTick>
  HAL_MspInit();
 80114e2:	f000 ff27 	bl	8012334 <HAL_MspInit>
}
 80114e6:	2000      	movs	r0, #0
 80114e8:	bd10      	pop	{r4, pc}
 80114ea:	46c0      	nop			; (mov r8, r8)
 80114ec:	40022000 	.word	0x40022000

080114f0 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80114f0:	4a02      	ldr	r2, [pc, #8]	; (80114fc <HAL_IncTick+0xc>)
 80114f2:	6813      	ldr	r3, [r2, #0]
 80114f4:	3301      	adds	r3, #1
 80114f6:	6013      	str	r3, [r2, #0]
}
 80114f8:	4770      	bx	lr
 80114fa:	46c0      	nop			; (mov r8, r8)
 80114fc:	20006eb8 	.word	0x20006eb8

08011500 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8011500:	4b01      	ldr	r3, [pc, #4]	; (8011508 <HAL_GetTick+0x8>)
 8011502:	6818      	ldr	r0, [r3, #0]
}
 8011504:	4770      	bx	lr
 8011506:	46c0      	nop			; (mov r8, r8)
 8011508:	20006eb8 	.word	0x20006eb8

0801150c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 801150c:	b513      	push	{r0, r1, r4, lr}
 801150e:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8011510:	f7ff fff6 	bl	8011500 <HAL_GetTick>
 8011514:	0004      	movs	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8011516:	f7ff fff3 	bl	8011500 <HAL_GetTick>
 801151a:	9b01      	ldr	r3, [sp, #4]
 801151c:	1b00      	subs	r0, r0, r4
 801151e:	4298      	cmp	r0, r3
 8011520:	d3f9      	bcc.n	8011516 <HAL_Delay+0xa>
  {
  }
}
 8011522:	bd13      	pop	{r0, r1, r4, pc}

08011524 <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
 8011524:	4b01      	ldr	r3, [pc, #4]	; (801152c <HAL_GetREVID+0x8>)
 8011526:	6818      	ldr	r0, [r3, #0]
 8011528:	0c00      	lsrs	r0, r0, #16
}
 801152a:	4770      	bx	lr
 801152c:	40015800 	.word	0x40015800

08011530 <HAL_GetDEVID>:
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
 8011530:	4b02      	ldr	r3, [pc, #8]	; (801153c <HAL_GetDEVID+0xc>)
 8011532:	6818      	ldr	r0, [r3, #0]
 8011534:	0500      	lsls	r0, r0, #20
 8011536:	0d00      	lsrs	r0, r0, #20
}
 8011538:	4770      	bx	lr
 801153a:	46c0      	nop			; (mov r8, r8)
 801153c:	40015800 	.word	0x40015800

08011540 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8011540:	b530      	push	{r4, r5, lr}
 8011542:	25ff      	movs	r5, #255	; 0xff
 8011544:	2403      	movs	r4, #3
 8011546:	002a      	movs	r2, r5
 8011548:	b2c3      	uxtb	r3, r0
 801154a:	401c      	ands	r4, r3
 801154c:	00e4      	lsls	r4, r4, #3
 801154e:	40a2      	lsls	r2, r4
 8011550:	0189      	lsls	r1, r1, #6
 8011552:	4029      	ands	r1, r5
 8011554:	43d2      	mvns	r2, r2
 8011556:	40a1      	lsls	r1, r4
  if((int32_t)(IRQn) < 0) {
 8011558:	2800      	cmp	r0, #0
 801155a:	da0b      	bge.n	8011574 <HAL_NVIC_SetPriority+0x34>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 801155c:	200f      	movs	r0, #15
 801155e:	4003      	ands	r3, r0
 8011560:	3b08      	subs	r3, #8
 8011562:	480a      	ldr	r0, [pc, #40]	; (801158c <HAL_NVIC_SetPriority+0x4c>)
 8011564:	089b      	lsrs	r3, r3, #2
 8011566:	009b      	lsls	r3, r3, #2
 8011568:	181b      	adds	r3, r3, r0
 801156a:	69d8      	ldr	r0, [r3, #28]
 801156c:	4002      	ands	r2, r0
 801156e:	4311      	orrs	r1, r2
 8011570:	61d9      	str	r1, [r3, #28]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 8011572:	bd30      	pop	{r4, r5, pc}
 8011574:	4b06      	ldr	r3, [pc, #24]	; (8011590 <HAL_NVIC_SetPriority+0x50>)
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8011576:	0880      	lsrs	r0, r0, #2
 8011578:	0080      	lsls	r0, r0, #2
 801157a:	18c0      	adds	r0, r0, r3
 801157c:	23c0      	movs	r3, #192	; 0xc0
 801157e:	009b      	lsls	r3, r3, #2
 8011580:	58c4      	ldr	r4, [r0, r3]
 8011582:	4022      	ands	r2, r4
 8011584:	4311      	orrs	r1, r2
 8011586:	50c1      	str	r1, [r0, r3]
 8011588:	e7f3      	b.n	8011572 <HAL_NVIC_SetPriority+0x32>
 801158a:	46c0      	nop			; (mov r8, r8)
 801158c:	e000ed00 	.word	0xe000ed00
 8011590:	e000e100 	.word	0xe000e100

08011594 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8011594:	231f      	movs	r3, #31
 8011596:	4018      	ands	r0, r3
 8011598:	3b1e      	subs	r3, #30
 801159a:	4083      	lsls	r3, r0
 801159c:	4a01      	ldr	r2, [pc, #4]	; (80115a4 <HAL_NVIC_EnableIRQ+0x10>)
 801159e:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80115a0:	4770      	bx	lr
 80115a2:	46c0      	nop			; (mov r8, r8)
 80115a4:	e000e100 	.word	0xe000e100

080115a8 <HAL_NVIC_DisableIRQ>:
  NVIC->ICER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80115a8:	231f      	movs	r3, #31
 80115aa:	4018      	ands	r0, r3
 80115ac:	3b1e      	subs	r3, #30
 80115ae:	4083      	lsls	r3, r0
 80115b0:	4a01      	ldr	r2, [pc, #4]	; (80115b8 <HAL_NVIC_DisableIRQ+0x10>)
 80115b2:	67d3      	str	r3, [r2, #124]	; 0x7c
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 80115b4:	4770      	bx	lr
 80115b6:	46c0      	nop			; (mov r8, r8)
 80115b8:	e000e104 	.word	0xe000e104

080115bc <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 80115bc:	4a09      	ldr	r2, [pc, #36]	; (80115e4 <HAL_SYSTICK_Config+0x28>)
 80115be:	1e43      	subs	r3, r0, #1
 80115c0:	2001      	movs	r0, #1
 80115c2:	4293      	cmp	r3, r2
 80115c4:	d80d      	bhi.n	80115e2 <HAL_SYSTICK_Config+0x26>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80115c6:	21c0      	movs	r1, #192	; 0xc0

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80115c8:	4a07      	ldr	r2, [pc, #28]	; (80115e8 <HAL_SYSTICK_Config+0x2c>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80115ca:	4808      	ldr	r0, [pc, #32]	; (80115ec <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80115cc:	6053      	str	r3, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80115ce:	6a03      	ldr	r3, [r0, #32]
 80115d0:	0609      	lsls	r1, r1, #24
 80115d2:	021b      	lsls	r3, r3, #8
 80115d4:	0a1b      	lsrs	r3, r3, #8
 80115d6:	430b      	orrs	r3, r1
 80115d8:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80115da:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80115dc:	2307      	movs	r3, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80115de:	6090      	str	r0, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80115e0:	6013      	str	r3, [r2, #0]
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80115e2:	4770      	bx	lr
 80115e4:	00ffffff 	.word	0x00ffffff
 80115e8:	e000e010 	.word	0xe000e010
 80115ec:	e000ed00 	.word	0xe000ed00

080115f0 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 80115f0:	4b05      	ldr	r3, [pc, #20]	; (8011608 <HAL_SYSTICK_CLKSourceConfig+0x18>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80115f2:	681a      	ldr	r2, [r3, #0]
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 80115f4:	2804      	cmp	r0, #4
 80115f6:	d102      	bne.n	80115fe <HAL_SYSTICK_CLKSourceConfig+0xe>
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80115f8:	4310      	orrs	r0, r2
 80115fa:	6018      	str	r0, [r3, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
 80115fc:	4770      	bx	lr
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 80115fe:	2104      	movs	r1, #4
 8011600:	438a      	bics	r2, r1
 8011602:	601a      	str	r2, [r3, #0]
}
 8011604:	e7fa      	b.n	80115fc <HAL_SYSTICK_CLKSourceConfig+0xc>
 8011606:	46c0      	nop			; (mov r8, r8)
 8011608:	e000e010 	.word	0xe000e010

0801160c <CRC_Handle_8>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 801160c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801160e:	000e      	movs	r6, r1
  uint32_t i = 0; /* input data buffer index */
  
   /* Processing time optimization: 4 bytes are entered in a row with a single word write,
    * last bytes must be carefully fed to the CRC calculator to ensure a correct type
    * handling by the IP */
   for(i = 0; i < (BufferLength/4); i++)
 8011610:	0895      	lsrs	r5, r2, #2
 8011612:	00ad      	lsls	r5, r5, #2
 8011614:	186b      	adds	r3, r5, r1
 8011616:	9301      	str	r3, [sp, #4]
 8011618:	9c01      	ldr	r4, [sp, #4]
 801161a:	6803      	ldr	r3, [r0, #0]
 801161c:	42a6      	cmp	r6, r4
 801161e:	d109      	bne.n	8011634 <CRC_Handle_8+0x28>
   {
      hcrc->Instance->DR = ((uint32_t)pBuffer[4*i]<<24) | ((uint32_t)pBuffer[4*i+1]<<16) | ((uint32_t)pBuffer[4*i+2]<<8) | (uint32_t)pBuffer[4*i+3];      
   }
   /* last bytes specific handling */
   if ((BufferLength%4) != 0)
 8011620:	2403      	movs	r4, #3
 8011622:	4022      	ands	r2, r4
 8011624:	d003      	beq.n	801162e <CRC_Handle_8+0x22>
   {
     if  (BufferLength%4 == 1)
 8011626:	2a01      	cmp	r2, #1
 8011628:	d111      	bne.n	801164e <CRC_Handle_8+0x42>
     {
       *(uint8_t*) (&hcrc->Instance->DR) = pBuffer[4*i];
 801162a:	5d4a      	ldrb	r2, [r1, r5]
 801162c:	701a      	strb	r2, [r3, #0]
       *(uint8_t*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
     }
   }
  
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 801162e:	6803      	ldr	r3, [r0, #0]
 8011630:	6818      	ldr	r0, [r3, #0]
}
 8011632:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      hcrc->Instance->DR = ((uint32_t)pBuffer[4*i]<<24) | ((uint32_t)pBuffer[4*i+1]<<16) | ((uint32_t)pBuffer[4*i+2]<<8) | (uint32_t)pBuffer[4*i+3];      
 8011634:	7834      	ldrb	r4, [r6, #0]
 8011636:	7877      	ldrb	r7, [r6, #1]
 8011638:	0624      	lsls	r4, r4, #24
 801163a:	043f      	lsls	r7, r7, #16
 801163c:	433c      	orrs	r4, r7
 801163e:	78f7      	ldrb	r7, [r6, #3]
 8011640:	433c      	orrs	r4, r7
 8011642:	78b7      	ldrb	r7, [r6, #2]
 8011644:	3604      	adds	r6, #4
 8011646:	023f      	lsls	r7, r7, #8
 8011648:	433c      	orrs	r4, r7
 801164a:	601c      	str	r4, [r3, #0]
 801164c:	e7e4      	b.n	8011618 <CRC_Handle_8+0xc>
 801164e:	186c      	adds	r4, r5, r1
       *(uint16_t*) (&hcrc->Instance->DR) = ((uint16_t)pBuffer[4*i]<<8) | (uint16_t)pBuffer[4*i+1];
 8011650:	5d49      	ldrb	r1, [r1, r5]
 8011652:	0209      	lsls	r1, r1, #8
     if  (BufferLength%4 == 2)
 8011654:	2a02      	cmp	r2, #2
 8011656:	d103      	bne.n	8011660 <CRC_Handle_8+0x54>
       *(uint16_t*) (&hcrc->Instance->DR) = ((uint16_t)pBuffer[4*i]<<8) | (uint16_t)pBuffer[4*i+1];
 8011658:	7862      	ldrb	r2, [r4, #1]
 801165a:	430a      	orrs	r2, r1
 801165c:	801a      	strh	r2, [r3, #0]
 801165e:	e7e6      	b.n	801162e <CRC_Handle_8+0x22>
       *(uint16_t*) (&hcrc->Instance->DR) = ((uint16_t)pBuffer[4*i]<<8) | (uint16_t)pBuffer[4*i+1];
 8011660:	7862      	ldrb	r2, [r4, #1]
 8011662:	430a      	orrs	r2, r1
 8011664:	801a      	strh	r2, [r3, #0]
       *(uint8_t*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 8011666:	78a3      	ldrb	r3, [r4, #2]
 8011668:	6802      	ldr	r2, [r0, #0]
 801166a:	7013      	strb	r3, [r2, #0]
 801166c:	e7df      	b.n	801162e <CRC_Handle_8+0x22>

0801166e <CRC_Handle_16>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */  
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 801166e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8011670:	000d      	movs	r5, r1
  uint32_t i = 0;  /* input data buffer index */
  
  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure 
   * a correct type handling by the IP */
  for(i = 0; i < (BufferLength/2); i++)
 8011672:	2600      	movs	r6, #0
{
 8011674:	9201      	str	r2, [sp, #4]
  for(i = 0; i < (BufferLength/2); i++)
 8011676:	0854      	lsrs	r4, r2, #1
 8011678:	6807      	ldr	r7, [r0, #0]
 801167a:	42b4      	cmp	r4, r6
 801167c:	d108      	bne.n	8011690 <CRC_Handle_16+0x22>
  {
    hcrc->Instance->DR = (pBuffer[2*i]<<16) | pBuffer[2*i+1];     
  }
  if ((BufferLength%2) != 0)
 801167e:	9b01      	ldr	r3, [sp, #4]
 8011680:	07db      	lsls	r3, r3, #31
 8011682:	d502      	bpl.n	801168a <CRC_Handle_16+0x1c>
  {
    *(uint16_t*) (&hcrc->Instance->DR) = pBuffer[2*i]; 
 8011684:	00a4      	lsls	r4, r4, #2
 8011686:	5a63      	ldrh	r3, [r4, r1]
 8011688:	803b      	strh	r3, [r7, #0]
  }
   
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 801168a:	6803      	ldr	r3, [r0, #0]
 801168c:	6818      	ldr	r0, [r3, #0]
}
 801168e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    hcrc->Instance->DR = (pBuffer[2*i]<<16) | pBuffer[2*i+1];     
 8011690:	882b      	ldrh	r3, [r5, #0]
  for(i = 0; i < (BufferLength/2); i++)
 8011692:	3601      	adds	r6, #1
    hcrc->Instance->DR = (pBuffer[2*i]<<16) | pBuffer[2*i+1];     
 8011694:	041b      	lsls	r3, r3, #16
 8011696:	001a      	movs	r2, r3
 8011698:	886b      	ldrh	r3, [r5, #2]
 801169a:	3504      	adds	r5, #4
 801169c:	431a      	orrs	r2, r3
 801169e:	603a      	str	r2, [r7, #0]
 80116a0:	e7ea      	b.n	8011678 <CRC_Handle_16+0xa>

080116a2 <HAL_CRC_Init>:
{
 80116a2:	b510      	push	{r4, lr}
 80116a4:	1e04      	subs	r4, r0, #0
  if(hcrc == NULL)
 80116a6:	d101      	bne.n	80116ac <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 80116a8:	2001      	movs	r0, #1
}
 80116aa:	bd10      	pop	{r4, pc}
  if(hcrc->State == HAL_CRC_STATE_RESET)
 80116ac:	7f43      	ldrb	r3, [r0, #29]
 80116ae:	b2db      	uxtb	r3, r3
 80116b0:	2b00      	cmp	r3, #0
 80116b2:	d102      	bne.n	80116ba <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 80116b4:	7703      	strb	r3, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 80116b6:	f7fa fc4b 	bl	800bf50 <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY; 
 80116ba:	2302      	movs	r3, #2
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 80116bc:	0020      	movs	r0, r4
  hcrc->State = HAL_CRC_STATE_BUSY; 
 80116be:	7763      	strb	r3, [r4, #29]
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 80116c0:	f000 f89e 	bl	8011800 <HAL_CRCEx_Init>
 80116c4:	2800      	cmp	r0, #0
 80116c6:	d1ef      	bne.n	80116a8 <HAL_CRC_Init+0x6>
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 80116c8:	7962      	ldrb	r2, [r4, #5]
 80116ca:	6823      	ldr	r3, [r4, #0]
 80116cc:	2a00      	cmp	r2, #0
 80116ce:	d112      	bne.n	80116f6 <HAL_CRC_Init+0x54>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);  
 80116d0:	3a01      	subs	r2, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 80116d2:	2160      	movs	r1, #96	; 0x60
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 80116d4:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 80116d6:	6822      	ldr	r2, [r4, #0]
 80116d8:	6893      	ldr	r3, [r2, #8]
 80116da:	438b      	bics	r3, r1
 80116dc:	6961      	ldr	r1, [r4, #20]
 80116de:	430b      	orrs	r3, r1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 80116e0:	2180      	movs	r1, #128	; 0x80
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 80116e2:	6093      	str	r3, [r2, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 80116e4:	6822      	ldr	r2, [r4, #0]
 80116e6:	6893      	ldr	r3, [r2, #8]
 80116e8:	438b      	bics	r3, r1
 80116ea:	69a1      	ldr	r1, [r4, #24]
 80116ec:	430b      	orrs	r3, r1
 80116ee:	6093      	str	r3, [r2, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 80116f0:	2301      	movs	r3, #1
 80116f2:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 80116f4:	e7d9      	b.n	80116aa <HAL_CRC_Init+0x8>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 80116f6:	6922      	ldr	r2, [r4, #16]
 80116f8:	e7eb      	b.n	80116d2 <HAL_CRC_Init+0x30>

080116fa <HAL_CRC_Accumulate>:
{
 80116fa:	2302      	movs	r3, #2
 80116fc:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hcrc); 
 80116fe:	7f05      	ldrb	r5, [r0, #28]
{
 8011700:	0004      	movs	r4, r0
  __HAL_LOCK(hcrc); 
 8011702:	0018      	movs	r0, r3
 8011704:	2d01      	cmp	r5, #1
 8011706:	d017      	beq.n	8011738 <HAL_CRC_Accumulate+0x3e>
  hcrc->State = HAL_CRC_STATE_BUSY;
 8011708:	7763      	strb	r3, [r4, #29]
  switch (hcrc->InputDataFormat)
 801170a:	6a23      	ldr	r3, [r4, #32]
  __HAL_LOCK(hcrc); 
 801170c:	3801      	subs	r0, #1
 801170e:	7720      	strb	r0, [r4, #28]
  switch (hcrc->InputDataFormat)
 8011710:	2b02      	cmp	r3, #2
 8011712:	d015      	beq.n	8011740 <HAL_CRC_Accumulate+0x46>
 8011714:	2b03      	cmp	r3, #3
 8011716:	d005      	beq.n	8011724 <HAL_CRC_Accumulate+0x2a>
 8011718:	4283      	cmp	r3, r0
 801171a:	d115      	bne.n	8011748 <HAL_CRC_Accumulate+0x4e>
      temp = CRC_Handle_8(hcrc, (uint8_t*)pBuffer, BufferLength);
 801171c:	0020      	movs	r0, r4
 801171e:	f7ff ff75 	bl	801160c <CRC_Handle_8>
      break;
 8011722:	e005      	b.n	8011730 <HAL_CRC_Accumulate+0x36>
 8011724:	0092      	lsls	r2, r2, #2
 8011726:	188a      	adds	r2, r1, r2
 8011728:	6823      	ldr	r3, [r4, #0]
      for(index = 0; index < BufferLength; index++)
 801172a:	4291      	cmp	r1, r2
 801172c:	d105      	bne.n	801173a <HAL_CRC_Accumulate+0x40>
      temp = hcrc->Instance->DR;
 801172e:	6818      	ldr	r0, [r3, #0]
  hcrc->State = HAL_CRC_STATE_READY; 
 8011730:	2301      	movs	r3, #1
 8011732:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hcrc);
 8011734:	2300      	movs	r3, #0
 8011736:	7723      	strb	r3, [r4, #28]
}
 8011738:	bd70      	pop	{r4, r5, r6, pc}
        hcrc->Instance->DR = pBuffer[index];
 801173a:	c901      	ldmia	r1!, {r0}
 801173c:	6018      	str	r0, [r3, #0]
 801173e:	e7f3      	b.n	8011728 <HAL_CRC_Accumulate+0x2e>
      temp = CRC_Handle_16(hcrc, (uint16_t*)pBuffer, BufferLength);
 8011740:	0020      	movs	r0, r4
 8011742:	f7ff ff94 	bl	801166e <CRC_Handle_16>
      break;
 8011746:	e7f3      	b.n	8011730 <HAL_CRC_Accumulate+0x36>
  uint32_t temp = 0;  /* CRC output (read from hcrc->Instance->DR register) */
 8011748:	2000      	movs	r0, #0
 801174a:	e7f1      	b.n	8011730 <HAL_CRC_Accumulate+0x36>

0801174c <HAL_CRC_Calculate>:
{
 801174c:	b570      	push	{r4, r5, r6, lr}
 801174e:	2502      	movs	r5, #2
  __HAL_LOCK(hcrc); 
 8011750:	7f03      	ldrb	r3, [r0, #28]
{
 8011752:	0004      	movs	r4, r0
  __HAL_LOCK(hcrc); 
 8011754:	0028      	movs	r0, r5
 8011756:	2b01      	cmp	r3, #1
 8011758:	d01c      	beq.n	8011794 <HAL_CRC_Calculate+0x48>
 801175a:	2301      	movs	r3, #1
  __HAL_CRC_DR_RESET(hcrc);
 801175c:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hcrc); 
 801175e:	7723      	strb	r3, [r4, #28]
  hcrc->State = HAL_CRC_STATE_BUSY;
 8011760:	7765      	strb	r5, [r4, #29]
  __HAL_CRC_DR_RESET(hcrc);
 8011762:	6885      	ldr	r5, [r0, #8]
 8011764:	432b      	orrs	r3, r5
 8011766:	6083      	str	r3, [r0, #8]
  switch (hcrc->InputDataFormat)
 8011768:	6a23      	ldr	r3, [r4, #32]
 801176a:	2b02      	cmp	r3, #2
 801176c:	d016      	beq.n	801179c <HAL_CRC_Calculate+0x50>
 801176e:	2b03      	cmp	r3, #3
 8011770:	d006      	beq.n	8011780 <HAL_CRC_Calculate+0x34>
  uint32_t temp = 0;  /* CRC output (read from hcrc->Instance->DR register) */
 8011772:	2000      	movs	r0, #0
  switch (hcrc->InputDataFormat)
 8011774:	2b01      	cmp	r3, #1
 8011776:	d109      	bne.n	801178c <HAL_CRC_Calculate+0x40>
      temp = CRC_Handle_8(hcrc, (uint8_t*)pBuffer, BufferLength);
 8011778:	0020      	movs	r0, r4
 801177a:	f7ff ff47 	bl	801160c <CRC_Handle_8>
      break;
 801177e:	e005      	b.n	801178c <HAL_CRC_Calculate+0x40>
 8011780:	0092      	lsls	r2, r2, #2
 8011782:	188a      	adds	r2, r1, r2
 8011784:	6823      	ldr	r3, [r4, #0]
      for(index = 0; index < BufferLength; index++)
 8011786:	4291      	cmp	r1, r2
 8011788:	d105      	bne.n	8011796 <HAL_CRC_Calculate+0x4a>
      temp = hcrc->Instance->DR;
 801178a:	6818      	ldr	r0, [r3, #0]
  hcrc->State = HAL_CRC_STATE_READY; 
 801178c:	2301      	movs	r3, #1
 801178e:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hcrc);
 8011790:	2300      	movs	r3, #0
 8011792:	7723      	strb	r3, [r4, #28]
}
 8011794:	bd70      	pop	{r4, r5, r6, pc}
        hcrc->Instance->DR = pBuffer[index];
 8011796:	c901      	ldmia	r1!, {r0}
 8011798:	6018      	str	r0, [r3, #0]
 801179a:	e7f3      	b.n	8011784 <HAL_CRC_Calculate+0x38>
      temp = CRC_Handle_16(hcrc, (uint16_t*)pBuffer, BufferLength);
 801179c:	0020      	movs	r0, r4
 801179e:	f7ff ff66 	bl	801166e <CRC_Handle_16>
      break;
 80117a2:	e7f3      	b.n	801178c <HAL_CRC_Calculate+0x40>

080117a4 <HAL_CRCEx_Polynomial_Set>:
  *          @arg CRC_POLYLENGTH_16B: 16-bit long CRC (generating polynomial of degree 16)
  *          @arg CRC_POLYLENGTH_32B: 32-bit long CRC (generating polynomial of degree 32)                
  * @retval HAL status
  */                                   
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 80117a4:	b530      	push	{r4, r5, lr}
  uint32_t msb = 31; /* polynomial degree is 32 at most, so msb is initialized to max value */
 80117a6:	231f      	movs	r3, #31
{
 80117a8:	0004      	movs	r4, r0
   * definition. HAL_ERROR is reported if Pol degree is 
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while (((Pol & (1U << msb)) == 0) && (msb-- > 0))
 80117aa:	2001      	movs	r0, #1
 80117ac:	0005      	movs	r5, r0
 80117ae:	409d      	lsls	r5, r3
 80117b0:	4229      	tst	r1, r5
 80117b2:	d109      	bne.n	80117c8 <HAL_CRCEx_Polynomial_Set+0x24>
 80117b4:	3b01      	subs	r3, #1
 80117b6:	d2f9      	bcs.n	80117ac <HAL_CRCEx_Polynomial_Set+0x8>
  {}

  switch (PolyLength)
 80117b8:	2a10      	cmp	r2, #16
 80117ba:	d003      	beq.n	80117c4 <HAL_CRCEx_Polynomial_Set+0x20>
 80117bc:	2a18      	cmp	r2, #24
 80117be:	d001      	beq.n	80117c4 <HAL_CRCEx_Polynomial_Set+0x20>
 80117c0:	2a08      	cmp	r2, #8
 80117c2:	d112      	bne.n	80117ea <HAL_CRCEx_Polynomial_Set+0x46>
  {
    case CRC_POLYLENGTH_7B:
      if (msb >= HAL_CRC_LENGTH_7B)
      {
        return  HAL_ERROR;
 80117c4:	2001      	movs	r0, #1
 80117c6:	e00c      	b.n	80117e2 <HAL_CRCEx_Polynomial_Set+0x3e>
  switch (PolyLength)
 80117c8:	2a10      	cmp	r2, #16
 80117ca:	d00b      	beq.n	80117e4 <HAL_CRCEx_Polynomial_Set+0x40>
 80117cc:	2a18      	cmp	r2, #24
 80117ce:	d005      	beq.n	80117dc <HAL_CRCEx_Polynomial_Set+0x38>
 80117d0:	2a08      	cmp	r2, #8
 80117d2:	d10a      	bne.n	80117ea <HAL_CRCEx_Polynomial_Set+0x46>
        return  HAL_ERROR;
 80117d4:	2001      	movs	r0, #1
      { 
        return  HAL_ERROR;
      }
      break;
    case CRC_POLYLENGTH_16B:
      if (msb >= HAL_CRC_LENGTH_16B)
 80117d6:	2b0f      	cmp	r3, #15
 80117d8:	d907      	bls.n	80117ea <HAL_CRCEx_Polynomial_Set+0x46>
 80117da:	e002      	b.n	80117e2 <HAL_CRCEx_Polynomial_Set+0x3e>
        return  HAL_ERROR;
 80117dc:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_7B)
 80117de:	2b06      	cmp	r3, #6
 80117e0:	d903      	bls.n	80117ea <HAL_CRCEx_Polynomial_Set+0x46>
  /* set generating polynomial size */
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
  
  /* Return function status */
  return HAL_OK;
}
 80117e2:	bd30      	pop	{r4, r5, pc}
        return  HAL_ERROR;
 80117e4:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_8B)
 80117e6:	2b07      	cmp	r3, #7
 80117e8:	d8fb      	bhi.n	80117e2 <HAL_CRCEx_Polynomial_Set+0x3e>
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
 80117ea:	2018      	movs	r0, #24
  WRITE_REG(hcrc->Instance->POL, Pol);
 80117ec:	6823      	ldr	r3, [r4, #0]
 80117ee:	6159      	str	r1, [r3, #20]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
 80117f0:	6821      	ldr	r1, [r4, #0]
 80117f2:	688b      	ldr	r3, [r1, #8]
 80117f4:	4383      	bics	r3, r0
 80117f6:	431a      	orrs	r2, r3
 80117f8:	608a      	str	r2, [r1, #8]
 80117fa:	2000      	movs	r0, #0
 80117fc:	e7f1      	b.n	80117e2 <HAL_CRCEx_Polynomial_Set+0x3e>
	...

08011800 <HAL_CRCEx_Init>:
{
 8011800:	b510      	push	{r4, lr}
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8011802:	7903      	ldrb	r3, [r0, #4]
 8011804:	2b00      	cmp	r3, #0
 8011806:	d109      	bne.n	801181c <HAL_CRCEx_Init+0x1c>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8011808:	6802      	ldr	r2, [r0, #0]
 801180a:	4908      	ldr	r1, [pc, #32]	; (801182c <HAL_CRCEx_Init+0x2c>)
 801180c:	6151      	str	r1, [r2, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 801180e:	6801      	ldr	r1, [r0, #0]
 8011810:	2018      	movs	r0, #24
 8011812:	688a      	ldr	r2, [r1, #8]
 8011814:	4382      	bics	r2, r0
   return HAL_OK;
 8011816:	0018      	movs	r0, r3
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8011818:	608a      	str	r2, [r1, #8]
}
 801181a:	bd10      	pop	{r4, pc}
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 801181c:	68c2      	ldr	r2, [r0, #12]
 801181e:	6881      	ldr	r1, [r0, #8]
 8011820:	f7ff ffc0 	bl	80117a4 <HAL_CRCEx_Polynomial_Set>
 8011824:	1e43      	subs	r3, r0, #1
 8011826:	4198      	sbcs	r0, r3
      return HAL_ERROR;
 8011828:	b2c0      	uxtb	r0, r0
 801182a:	e7f6      	b.n	801181a <HAL_CRCEx_Init+0x1a>
 801182c:	04c11db7 	.word	0x04c11db7

08011830 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 8011830:	0002      	movs	r2, r0
 8011832:	b530      	push	{r4, r5, lr}
  uint32_t tmp = 0;
  
  /* Check the DMA handle allocation */
  if(hdma == NULL)
  {
    return HAL_ERROR;
 8011834:	2001      	movs	r0, #1
  if(hdma == NULL)
 8011836:	2a00      	cmp	r2, #0
 8011838:	d01f      	beq.n	801187a <HAL_DMA_Init+0x4a>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(hdma->State == HAL_DMA_STATE_RESET)
 801183a:	1c91      	adds	r1, r2, #2
 801183c:	7fcb      	ldrb	r3, [r1, #31]
 801183e:	b2db      	uxtb	r3, r3
 8011840:	2b00      	cmp	r3, #0
 8011842:	d101      	bne.n	8011848 <HAL_DMA_Init+0x18>
  {  
    /* Allocate lock resource and initialize it */
    hdma->Lock = HAL_UNLOCKED;
 8011844:	1810      	adds	r0, r2, r0
 8011846:	77c3      	strb	r3, [r0, #31]
  }
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8011848:	2302      	movs	r3, #2
 801184a:	77cb      	strb	r3, [r1, #31]

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 801184c:	6810      	ldr	r0, [r2, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 801184e:	4b0b      	ldr	r3, [pc, #44]	; (801187c <HAL_DMA_Init+0x4c>)
  tmp = hdma->Instance->CCR;
 8011850:	6804      	ldr	r4, [r0, #0]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8011852:	6895      	ldr	r5, [r2, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8011854:	401c      	ands	r4, r3
  tmp |=  hdma->Init.Direction        |
 8011856:	6853      	ldr	r3, [r2, #4]
 8011858:	432b      	orrs	r3, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 801185a:	68d5      	ldr	r5, [r2, #12]
 801185c:	432b      	orrs	r3, r5
 801185e:	6915      	ldr	r5, [r2, #16]
 8011860:	432b      	orrs	r3, r5
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8011862:	6955      	ldr	r5, [r2, #20]
 8011864:	432b      	orrs	r3, r5
 8011866:	6995      	ldr	r5, [r2, #24]
 8011868:	432b      	orrs	r3, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 801186a:	69d5      	ldr	r5, [r2, #28]
 801186c:	432b      	orrs	r3, r5
  tmp |=  hdma->Init.Direction        |
 801186e:	4323      	orrs	r3, r4

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 8011870:	6003      	str	r3, [r0, #0]
  
  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8011872:	2000      	movs	r0, #0

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 8011874:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8011876:	6350      	str	r0, [r2, #52]	; 0x34
  hdma->State  = HAL_DMA_STATE_READY;
 8011878:	77cb      	strb	r3, [r1, #31]
  
  return HAL_OK;
}  
 801187a:	bd30      	pop	{r4, r5, pc}
 801187c:	ffffc00f 	.word	0xffffc00f

08011880 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8011880:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011882:	2502      	movs	r5, #2
  /* Process locked */
  __HAL_LOCK(hdma);
 8011884:	1c47      	adds	r7, r0, #1
 8011886:	7ffe      	ldrb	r6, [r7, #31]
 8011888:	002c      	movs	r4, r5
 801188a:	2e01      	cmp	r6, #1
 801188c:	d025      	beq.n	80118da <HAL_DMA_Start_IT+0x5a>
 801188e:	2601      	movs	r6, #1

  /* Change DMA peripheral state */  
  hdma->State = HAL_DMA_STATE_BUSY;  
 8011890:	1944      	adds	r4, r0, r5
  __HAL_LOCK(hdma);
 8011892:	77fe      	strb	r6, [r7, #31]
  hdma->State = HAL_DMA_STATE_BUSY;  
 8011894:	77e5      	strb	r5, [r4, #31]

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8011896:	6805      	ldr	r5, [r0, #0]
 8011898:	682c      	ldr	r4, [r5, #0]
 801189a:	43b4      	bics	r4, r6
 801189c:	602c      	str	r4, [r5, #0]
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{  
  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 801189e:	6804      	ldr	r4, [r0, #0]
 80118a0:	6063      	str	r3, [r4, #4]
  
  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80118a2:	6844      	ldr	r4, [r0, #4]
 80118a4:	6803      	ldr	r3, [r0, #0]
 80118a6:	2c10      	cmp	r4, #16
 80118a8:	d119      	bne.n	80118de <HAL_DMA_Start_IT+0x5e>
  {   
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 80118aa:	609a      	str	r2, [r3, #8]
    
    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
 80118ac:	6803      	ldr	r3, [r0, #0]
 80118ae:	60d9      	str	r1, [r3, #12]
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
 80118b0:	2302      	movs	r3, #2
 80118b2:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;    
 80118b4:	2400      	movs	r4, #0
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
 80118b6:	6811      	ldr	r1, [r2, #0]
 80118b8:	430b      	orrs	r3, r1
 80118ba:	6013      	str	r3, [r2, #0]
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);  
 80118bc:	2304      	movs	r3, #4
 80118be:	6802      	ldr	r2, [r0, #0]
 80118c0:	6811      	ldr	r1, [r2, #0]
 80118c2:	430b      	orrs	r3, r1
 80118c4:	6013      	str	r3, [r2, #0]
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TE);
 80118c6:	2308      	movs	r3, #8
 80118c8:	6802      	ldr	r2, [r0, #0]
 80118ca:	6811      	ldr	r1, [r2, #0]
 80118cc:	430b      	orrs	r3, r1
 80118ce:	6013      	str	r3, [r2, #0]
  __HAL_DMA_ENABLE(hdma);   
 80118d0:	2301      	movs	r3, #1
 80118d2:	6802      	ldr	r2, [r0, #0]
 80118d4:	6811      	ldr	r1, [r2, #0]
 80118d6:	430b      	orrs	r3, r1
 80118d8:	6013      	str	r3, [r2, #0]
} 
 80118da:	0020      	movs	r0, r4
 80118dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 80118de:	6099      	str	r1, [r3, #8]
    
    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 80118e0:	6803      	ldr	r3, [r0, #0]
 80118e2:	60da      	str	r2, [r3, #12]
 80118e4:	e7e4      	b.n	80118b0 <HAL_DMA_Start_IT+0x30>

080118e6 <HAL_DMA_Abort>:
{
 80118e6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_DMA_DISABLE(hdma);
 80118e8:	2501      	movs	r5, #1
 80118ea:	6802      	ldr	r2, [r0, #0]
{
 80118ec:	0004      	movs	r4, r0
  __HAL_DMA_DISABLE(hdma);
 80118ee:	6813      	ldr	r3, [r2, #0]
    if((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 80118f0:	27fa      	movs	r7, #250	; 0xfa
  __HAL_DMA_DISABLE(hdma);
 80118f2:	43ab      	bics	r3, r5
 80118f4:	6013      	str	r3, [r2, #0]
  tickstart = HAL_GetTick();
 80118f6:	f7ff fe03 	bl	8011500 <HAL_GetTick>
 80118fa:	0006      	movs	r6, r0
    if((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 80118fc:	00bf      	lsls	r7, r7, #2
  while((hdma->Instance->CCR & DMA_CCR_EN) != 0) 
 80118fe:	6823      	ldr	r3, [r4, #0]
 8011900:	6818      	ldr	r0, [r3, #0]
 8011902:	4028      	ands	r0, r5
 8011904:	d104      	bne.n	8011910 <HAL_DMA_Abort+0x2a>
  hdma->State = HAL_DMA_STATE_READY; 
 8011906:	1ca3      	adds	r3, r4, #2
  __HAL_UNLOCK(hdma);
 8011908:	3401      	adds	r4, #1
  hdma->State = HAL_DMA_STATE_READY; 
 801190a:	77dd      	strb	r5, [r3, #31]
  __HAL_UNLOCK(hdma);
 801190c:	77e0      	strb	r0, [r4, #31]
  return HAL_OK; 
 801190e:	e00e      	b.n	801192e <HAL_DMA_Abort+0x48>
    if((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 8011910:	f7ff fdf6 	bl	8011500 <HAL_GetTick>
 8011914:	1b80      	subs	r0, r0, r6
 8011916:	42b8      	cmp	r0, r7
 8011918:	d9f1      	bls.n	80118fe <HAL_DMA_Abort+0x18>
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TIMEOUT);
 801191a:	2320      	movs	r3, #32
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 801191c:	2003      	movs	r0, #3
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TIMEOUT);
 801191e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8011920:	4313      	orrs	r3, r2
 8011922:	6363      	str	r3, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8011924:	1ca3      	adds	r3, r4, #2
 8011926:	77d8      	strb	r0, [r3, #31]
      __HAL_UNLOCK(hdma);
 8011928:	2300      	movs	r3, #0
 801192a:	3401      	adds	r4, #1
 801192c:	77e3      	strb	r3, [r4, #31]
}
 801192e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08011930 <HAL_DMA_IRQHandler>:
{        
 8011930:	b570      	push	{r4, r5, r6, lr}
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8011932:	4dc1      	ldr	r5, [pc, #772]	; (8011c38 <HAL_DMA_IRQHandler+0x308>)
 8011934:	6803      	ldr	r3, [r0, #0]
{        
 8011936:	0004      	movs	r4, r0
 8011938:	4ec0      	ldr	r6, [pc, #768]	; (8011c3c <HAL_DMA_IRQHandler+0x30c>)
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 801193a:	42ab      	cmp	r3, r5
 801193c:	d800      	bhi.n	8011940 <HAL_DMA_IRQHandler+0x10>
 801193e:	e1ab      	b.n	8011c98 <HAL_DMA_IRQHandler+0x368>
 8011940:	4abf      	ldr	r2, [pc, #764]	; (8011c40 <HAL_DMA_IRQHandler+0x310>)
 8011942:	6811      	ldr	r1, [r2, #0]
 8011944:	2208      	movs	r2, #8
 8011946:	42b3      	cmp	r3, r6
 8011948:	d02c      	beq.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 801194a:	48be      	ldr	r0, [pc, #760]	; (8011c44 <HAL_DMA_IRQHandler+0x314>)
 801194c:	3278      	adds	r2, #120	; 0x78
 801194e:	4283      	cmp	r3, r0
 8011950:	d028      	beq.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 8011952:	4abd      	ldr	r2, [pc, #756]	; (8011c48 <HAL_DMA_IRQHandler+0x318>)
 8011954:	4293      	cmp	r3, r2
 8011956:	d100      	bne.n	801195a <HAL_DMA_IRQHandler+0x2a>
 8011958:	e19b      	b.n	8011c92 <HAL_DMA_IRQHandler+0x362>
 801195a:	4abc      	ldr	r2, [pc, #752]	; (8011c4c <HAL_DMA_IRQHandler+0x31c>)
 801195c:	4293      	cmp	r3, r2
 801195e:	d100      	bne.n	8011962 <HAL_DMA_IRQHandler+0x32>
 8011960:	e18b      	b.n	8011c7a <HAL_DMA_IRQHandler+0x34a>
 8011962:	4abb      	ldr	r2, [pc, #748]	; (8011c50 <HAL_DMA_IRQHandler+0x320>)
 8011964:	4293      	cmp	r3, r2
 8011966:	d100      	bne.n	801196a <HAL_DMA_IRQHandler+0x3a>
 8011968:	e18a      	b.n	8011c80 <HAL_DMA_IRQHandler+0x350>
 801196a:	4aba      	ldr	r2, [pc, #744]	; (8011c54 <HAL_DMA_IRQHandler+0x324>)
 801196c:	4293      	cmp	r3, r2
 801196e:	d100      	bne.n	8011972 <HAL_DMA_IRQHandler+0x42>
 8011970:	e189      	b.n	8011c86 <HAL_DMA_IRQHandler+0x356>
 8011972:	42ab      	cmp	r3, r5
 8011974:	d100      	bne.n	8011978 <HAL_DMA_IRQHandler+0x48>
 8011976:	e189      	b.n	8011c8c <HAL_DMA_IRQHandler+0x35c>
 8011978:	48b7      	ldr	r0, [pc, #732]	; (8011c58 <HAL_DMA_IRQHandler+0x328>)
 801197a:	2208      	movs	r2, #8
 801197c:	4283      	cmp	r3, r0
 801197e:	d011      	beq.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 8011980:	48b6      	ldr	r0, [pc, #728]	; (8011c5c <HAL_DMA_IRQHandler+0x32c>)
 8011982:	3278      	adds	r2, #120	; 0x78
 8011984:	4283      	cmp	r3, r0
 8011986:	d00d      	beq.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 8011988:	4ab5      	ldr	r2, [pc, #724]	; (8011c60 <HAL_DMA_IRQHandler+0x330>)
 801198a:	4293      	cmp	r3, r2
 801198c:	d100      	bne.n	8011990 <HAL_DMA_IRQHandler+0x60>
 801198e:	e180      	b.n	8011c92 <HAL_DMA_IRQHandler+0x362>
 8011990:	4ab4      	ldr	r2, [pc, #720]	; (8011c64 <HAL_DMA_IRQHandler+0x334>)
 8011992:	189a      	adds	r2, r3, r2
 8011994:	4250      	negs	r0, r2
 8011996:	4142      	adcs	r2, r0
 8011998:	48b3      	ldr	r0, [pc, #716]	; (8011c68 <HAL_DMA_IRQHandler+0x338>)
 801199a:	4252      	negs	r2, r2
 801199c:	4002      	ands	r2, r0
 801199e:	2080      	movs	r0, #128	; 0x80
 80119a0:	0300      	lsls	r0, r0, #12
 80119a2:	1812      	adds	r2, r2, r0
 80119a4:	420a      	tst	r2, r1
 80119a6:	d04a      	beq.n	8011a3e <HAL_DMA_IRQHandler+0x10e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 80119a8:	2208      	movs	r2, #8
 80119aa:	6819      	ldr	r1, [r3, #0]
 80119ac:	4211      	tst	r1, r2
 80119ae:	d042      	beq.n	8011a36 <HAL_DMA_IRQHandler+0x106>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 80119b0:	6819      	ldr	r1, [r3, #0]
 80119b2:	4391      	bics	r1, r2
 80119b4:	6019      	str	r1, [r3, #0]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80119b6:	6821      	ldr	r1, [r4, #0]
 80119b8:	0013      	movs	r3, r2
 80119ba:	42a9      	cmp	r1, r5
 80119bc:	d800      	bhi.n	80119c0 <HAL_DMA_IRQHandler+0x90>
 80119be:	e1e8      	b.n	8011d92 <HAL_DMA_IRQHandler+0x462>
 80119c0:	42b1      	cmp	r1, r6
 80119c2:	d027      	beq.n	8011a14 <HAL_DMA_IRQHandler+0xe4>
 80119c4:	4a9f      	ldr	r2, [pc, #636]	; (8011c44 <HAL_DMA_IRQHandler+0x314>)
 80119c6:	3378      	adds	r3, #120	; 0x78
 80119c8:	4291      	cmp	r1, r2
 80119ca:	d023      	beq.n	8011a14 <HAL_DMA_IRQHandler+0xe4>
 80119cc:	4b9e      	ldr	r3, [pc, #632]	; (8011c48 <HAL_DMA_IRQHandler+0x318>)
 80119ce:	4299      	cmp	r1, r3
 80119d0:	d100      	bne.n	80119d4 <HAL_DMA_IRQHandler+0xa4>
 80119d2:	e1d8      	b.n	8011d86 <HAL_DMA_IRQHandler+0x456>
 80119d4:	4b9d      	ldr	r3, [pc, #628]	; (8011c4c <HAL_DMA_IRQHandler+0x31c>)
 80119d6:	4299      	cmp	r1, r3
 80119d8:	d01a      	beq.n	8011a10 <HAL_DMA_IRQHandler+0xe0>
 80119da:	4b9d      	ldr	r3, [pc, #628]	; (8011c50 <HAL_DMA_IRQHandler+0x320>)
 80119dc:	4299      	cmp	r1, r3
 80119de:	d100      	bne.n	80119e2 <HAL_DMA_IRQHandler+0xb2>
 80119e0:	e1d4      	b.n	8011d8c <HAL_DMA_IRQHandler+0x45c>
 80119e2:	4b9c      	ldr	r3, [pc, #624]	; (8011c54 <HAL_DMA_IRQHandler+0x324>)
 80119e4:	4299      	cmp	r1, r3
 80119e6:	d100      	bne.n	80119ea <HAL_DMA_IRQHandler+0xba>
 80119e8:	e1c7      	b.n	8011d7a <HAL_DMA_IRQHandler+0x44a>
 80119ea:	42a9      	cmp	r1, r5
 80119ec:	d100      	bne.n	80119f0 <HAL_DMA_IRQHandler+0xc0>
 80119ee:	e1c7      	b.n	8011d80 <HAL_DMA_IRQHandler+0x450>
 80119f0:	4a99      	ldr	r2, [pc, #612]	; (8011c58 <HAL_DMA_IRQHandler+0x328>)
 80119f2:	2308      	movs	r3, #8
 80119f4:	4291      	cmp	r1, r2
 80119f6:	d00d      	beq.n	8011a14 <HAL_DMA_IRQHandler+0xe4>
 80119f8:	4a98      	ldr	r2, [pc, #608]	; (8011c5c <HAL_DMA_IRQHandler+0x32c>)
 80119fa:	3378      	adds	r3, #120	; 0x78
 80119fc:	4291      	cmp	r1, r2
 80119fe:	d009      	beq.n	8011a14 <HAL_DMA_IRQHandler+0xe4>
 8011a00:	4b97      	ldr	r3, [pc, #604]	; (8011c60 <HAL_DMA_IRQHandler+0x330>)
 8011a02:	4299      	cmp	r1, r3
 8011a04:	d100      	bne.n	8011a08 <HAL_DMA_IRQHandler+0xd8>
 8011a06:	e1be      	b.n	8011d86 <HAL_DMA_IRQHandler+0x456>
 8011a08:	4b98      	ldr	r3, [pc, #608]	; (8011c6c <HAL_DMA_IRQHandler+0x33c>)
 8011a0a:	4299      	cmp	r1, r3
 8011a0c:	d000      	beq.n	8011a10 <HAL_DMA_IRQHandler+0xe0>
 8011a0e:	e1bd      	b.n	8011d8c <HAL_DMA_IRQHandler+0x45c>
 8011a10:	2380      	movs	r3, #128	; 0x80
 8011a12:	021b      	lsls	r3, r3, #8
 8011a14:	4a8a      	ldr	r2, [pc, #552]	; (8011c40 <HAL_DMA_IRQHandler+0x310>)
 8011a16:	6053      	str	r3, [r2, #4]
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 8011a18:	2301      	movs	r3, #1
 8011a1a:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8011a1c:	4313      	orrs	r3, r2
      hdma->State = HAL_DMA_STATE_ERROR;    
 8011a1e:	2204      	movs	r2, #4
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 8011a20:	6363      	str	r3, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_ERROR;    
 8011a22:	1ca3      	adds	r3, r4, #2
 8011a24:	77da      	strb	r2, [r3, #31]
      __HAL_UNLOCK(hdma); 
 8011a26:	2200      	movs	r2, #0
 8011a28:	1c63      	adds	r3, r4, #1
 8011a2a:	77da      	strb	r2, [r3, #31]
      if (hdma->XferErrorCallback != (void (*)(DMA_HandleTypeDef *))NULL)
 8011a2c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8011a2e:	4293      	cmp	r3, r2
 8011a30:	d001      	beq.n	8011a36 <HAL_DMA_IRQHandler+0x106>
        hdma->XferErrorCallback(hdma);
 8011a32:	0020      	movs	r0, r4
 8011a34:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8011a36:	6823      	ldr	r3, [r4, #0]
 8011a38:	42ab      	cmp	r3, r5
 8011a3a:	d800      	bhi.n	8011a3e <HAL_DMA_IRQHandler+0x10e>
 8011a3c:	e15b      	b.n	8011cf6 <HAL_DMA_IRQHandler+0x3c6>
 8011a3e:	4a80      	ldr	r2, [pc, #512]	; (8011c40 <HAL_DMA_IRQHandler+0x310>)
 8011a40:	6811      	ldr	r1, [r2, #0]
 8011a42:	2204      	movs	r2, #4
 8011a44:	42b3      	cmp	r3, r6
 8011a46:	d02c      	beq.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011a48:	487e      	ldr	r0, [pc, #504]	; (8011c44 <HAL_DMA_IRQHandler+0x314>)
 8011a4a:	323c      	adds	r2, #60	; 0x3c
 8011a4c:	4283      	cmp	r3, r0
 8011a4e:	d028      	beq.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011a50:	4a7d      	ldr	r2, [pc, #500]	; (8011c48 <HAL_DMA_IRQHandler+0x318>)
 8011a52:	4293      	cmp	r3, r2
 8011a54:	d100      	bne.n	8011a58 <HAL_DMA_IRQHandler+0x128>
 8011a56:	e1da      	b.n	8011e0e <HAL_DMA_IRQHandler+0x4de>
 8011a58:	4a7c      	ldr	r2, [pc, #496]	; (8011c4c <HAL_DMA_IRQHandler+0x31c>)
 8011a5a:	4293      	cmp	r3, r2
 8011a5c:	d100      	bne.n	8011a60 <HAL_DMA_IRQHandler+0x130>
 8011a5e:	e1ca      	b.n	8011df6 <HAL_DMA_IRQHandler+0x4c6>
 8011a60:	4a7b      	ldr	r2, [pc, #492]	; (8011c50 <HAL_DMA_IRQHandler+0x320>)
 8011a62:	4293      	cmp	r3, r2
 8011a64:	d100      	bne.n	8011a68 <HAL_DMA_IRQHandler+0x138>
 8011a66:	e1c9      	b.n	8011dfc <HAL_DMA_IRQHandler+0x4cc>
 8011a68:	4a7a      	ldr	r2, [pc, #488]	; (8011c54 <HAL_DMA_IRQHandler+0x324>)
 8011a6a:	4293      	cmp	r3, r2
 8011a6c:	d100      	bne.n	8011a70 <HAL_DMA_IRQHandler+0x140>
 8011a6e:	e1c8      	b.n	8011e02 <HAL_DMA_IRQHandler+0x4d2>
 8011a70:	42ab      	cmp	r3, r5
 8011a72:	d100      	bne.n	8011a76 <HAL_DMA_IRQHandler+0x146>
 8011a74:	e1c8      	b.n	8011e08 <HAL_DMA_IRQHandler+0x4d8>
 8011a76:	4878      	ldr	r0, [pc, #480]	; (8011c58 <HAL_DMA_IRQHandler+0x328>)
 8011a78:	2204      	movs	r2, #4
 8011a7a:	4283      	cmp	r3, r0
 8011a7c:	d011      	beq.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011a7e:	4877      	ldr	r0, [pc, #476]	; (8011c5c <HAL_DMA_IRQHandler+0x32c>)
 8011a80:	323c      	adds	r2, #60	; 0x3c
 8011a82:	4283      	cmp	r3, r0
 8011a84:	d00d      	beq.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011a86:	4a76      	ldr	r2, [pc, #472]	; (8011c60 <HAL_DMA_IRQHandler+0x330>)
 8011a88:	4293      	cmp	r3, r2
 8011a8a:	d100      	bne.n	8011a8e <HAL_DMA_IRQHandler+0x15e>
 8011a8c:	e1bf      	b.n	8011e0e <HAL_DMA_IRQHandler+0x4de>
 8011a8e:	4a75      	ldr	r2, [pc, #468]	; (8011c64 <HAL_DMA_IRQHandler+0x334>)
 8011a90:	189a      	adds	r2, r3, r2
 8011a92:	4250      	negs	r0, r2
 8011a94:	4142      	adcs	r2, r0
 8011a96:	4876      	ldr	r0, [pc, #472]	; (8011c70 <HAL_DMA_IRQHandler+0x340>)
 8011a98:	4252      	negs	r2, r2
 8011a9a:	4002      	ands	r2, r0
 8011a9c:	2080      	movs	r0, #128	; 0x80
 8011a9e:	02c0      	lsls	r0, r0, #11
 8011aa0:	1812      	adds	r2, r2, r0
 8011aa2:	420a      	tst	r2, r1
 8011aa4:	d100      	bne.n	8011aa8 <HAL_DMA_IRQHandler+0x178>
 8011aa6:	e24f      	b.n	8011f48 <HAL_DMA_IRQHandler+0x618>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8011aa8:	2104      	movs	r1, #4
 8011aaa:	681a      	ldr	r2, [r3, #0]
 8011aac:	420a      	tst	r2, r1
 8011aae:	d03e      	beq.n	8011b2e <HAL_DMA_IRQHandler+0x1fe>
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8011ab0:	681a      	ldr	r2, [r3, #0]
 8011ab2:	0692      	lsls	r2, r2, #26
 8011ab4:	d402      	bmi.n	8011abc <HAL_DMA_IRQHandler+0x18c>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8011ab6:	681a      	ldr	r2, [r3, #0]
 8011ab8:	438a      	bics	r2, r1
 8011aba:	601a      	str	r2, [r3, #0]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8011abc:	6823      	ldr	r3, [r4, #0]
 8011abe:	2204      	movs	r2, #4
 8011ac0:	42ab      	cmp	r3, r5
 8011ac2:	d800      	bhi.n	8011ac6 <HAL_DMA_IRQHandler+0x196>
 8011ac4:	e1c1      	b.n	8011e4a <HAL_DMA_IRQHandler+0x51a>
 8011ac6:	42b3      	cmp	r3, r6
 8011ac8:	d027      	beq.n	8011b1a <HAL_DMA_IRQHandler+0x1ea>
 8011aca:	495e      	ldr	r1, [pc, #376]	; (8011c44 <HAL_DMA_IRQHandler+0x314>)
 8011acc:	323c      	adds	r2, #60	; 0x3c
 8011ace:	428b      	cmp	r3, r1
 8011ad0:	d023      	beq.n	8011b1a <HAL_DMA_IRQHandler+0x1ea>
 8011ad2:	4a5d      	ldr	r2, [pc, #372]	; (8011c48 <HAL_DMA_IRQHandler+0x318>)
 8011ad4:	4293      	cmp	r3, r2
 8011ad6:	d100      	bne.n	8011ada <HAL_DMA_IRQHandler+0x1aa>
 8011ad8:	e1b1      	b.n	8011e3e <HAL_DMA_IRQHandler+0x50e>
 8011ada:	4a5c      	ldr	r2, [pc, #368]	; (8011c4c <HAL_DMA_IRQHandler+0x31c>)
 8011adc:	4293      	cmp	r3, r2
 8011ade:	d01a      	beq.n	8011b16 <HAL_DMA_IRQHandler+0x1e6>
 8011ae0:	4a5b      	ldr	r2, [pc, #364]	; (8011c50 <HAL_DMA_IRQHandler+0x320>)
 8011ae2:	4293      	cmp	r3, r2
 8011ae4:	d100      	bne.n	8011ae8 <HAL_DMA_IRQHandler+0x1b8>
 8011ae6:	e1ad      	b.n	8011e44 <HAL_DMA_IRQHandler+0x514>
 8011ae8:	4a5a      	ldr	r2, [pc, #360]	; (8011c54 <HAL_DMA_IRQHandler+0x324>)
 8011aea:	4293      	cmp	r3, r2
 8011aec:	d100      	bne.n	8011af0 <HAL_DMA_IRQHandler+0x1c0>
 8011aee:	e1a0      	b.n	8011e32 <HAL_DMA_IRQHandler+0x502>
 8011af0:	42ab      	cmp	r3, r5
 8011af2:	d100      	bne.n	8011af6 <HAL_DMA_IRQHandler+0x1c6>
 8011af4:	e1a0      	b.n	8011e38 <HAL_DMA_IRQHandler+0x508>
 8011af6:	4958      	ldr	r1, [pc, #352]	; (8011c58 <HAL_DMA_IRQHandler+0x328>)
 8011af8:	2204      	movs	r2, #4
 8011afa:	428b      	cmp	r3, r1
 8011afc:	d00d      	beq.n	8011b1a <HAL_DMA_IRQHandler+0x1ea>
 8011afe:	4957      	ldr	r1, [pc, #348]	; (8011c5c <HAL_DMA_IRQHandler+0x32c>)
 8011b00:	323c      	adds	r2, #60	; 0x3c
 8011b02:	428b      	cmp	r3, r1
 8011b04:	d009      	beq.n	8011b1a <HAL_DMA_IRQHandler+0x1ea>
 8011b06:	4a56      	ldr	r2, [pc, #344]	; (8011c60 <HAL_DMA_IRQHandler+0x330>)
 8011b08:	4293      	cmp	r3, r2
 8011b0a:	d100      	bne.n	8011b0e <HAL_DMA_IRQHandler+0x1de>
 8011b0c:	e197      	b.n	8011e3e <HAL_DMA_IRQHandler+0x50e>
 8011b0e:	4a57      	ldr	r2, [pc, #348]	; (8011c6c <HAL_DMA_IRQHandler+0x33c>)
 8011b10:	4293      	cmp	r3, r2
 8011b12:	d000      	beq.n	8011b16 <HAL_DMA_IRQHandler+0x1e6>
 8011b14:	e196      	b.n	8011e44 <HAL_DMA_IRQHandler+0x514>
 8011b16:	2280      	movs	r2, #128	; 0x80
 8011b18:	01d2      	lsls	r2, r2, #7
 8011b1a:	4b49      	ldr	r3, [pc, #292]	; (8011c40 <HAL_DMA_IRQHandler+0x310>)
 8011b1c:	605a      	str	r2, [r3, #4]
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8011b1e:	2211      	movs	r2, #17
 8011b20:	1ca3      	adds	r3, r4, #2
 8011b22:	77da      	strb	r2, [r3, #31]
      if(hdma->XferHalfCpltCallback != (void (*)(DMA_HandleTypeDef *))NULL)
 8011b24:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8011b26:	2b00      	cmp	r3, #0
 8011b28:	d001      	beq.n	8011b2e <HAL_DMA_IRQHandler+0x1fe>
        hdma->XferHalfCpltCallback(hdma);
 8011b2a:	0020      	movs	r0, r4
 8011b2c:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8011b2e:	6822      	ldr	r2, [r4, #0]
 8011b30:	42aa      	cmp	r2, r5
 8011b32:	d800      	bhi.n	8011b36 <HAL_DMA_IRQHandler+0x206>
 8011b34:	e110      	b.n	8011d58 <HAL_DMA_IRQHandler+0x428>
 8011b36:	4b42      	ldr	r3, [pc, #264]	; (8011c40 <HAL_DMA_IRQHandler+0x310>)
 8011b38:	6818      	ldr	r0, [r3, #0]
 8011b3a:	2302      	movs	r3, #2
 8011b3c:	42b2      	cmp	r2, r6
 8011b3e:	d02c      	beq.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
 8011b40:	4940      	ldr	r1, [pc, #256]	; (8011c44 <HAL_DMA_IRQHandler+0x314>)
 8011b42:	331e      	adds	r3, #30
 8011b44:	428a      	cmp	r2, r1
 8011b46:	d028      	beq.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
 8011b48:	4b3f      	ldr	r3, [pc, #252]	; (8011c48 <HAL_DMA_IRQHandler+0x318>)
 8011b4a:	429a      	cmp	r2, r3
 8011b4c:	d100      	bne.n	8011b50 <HAL_DMA_IRQHandler+0x220>
 8011b4e:	e1ba      	b.n	8011ec6 <HAL_DMA_IRQHandler+0x596>
 8011b50:	4b3e      	ldr	r3, [pc, #248]	; (8011c4c <HAL_DMA_IRQHandler+0x31c>)
 8011b52:	429a      	cmp	r2, r3
 8011b54:	d100      	bne.n	8011b58 <HAL_DMA_IRQHandler+0x228>
 8011b56:	e1aa      	b.n	8011eae <HAL_DMA_IRQHandler+0x57e>
 8011b58:	4b3d      	ldr	r3, [pc, #244]	; (8011c50 <HAL_DMA_IRQHandler+0x320>)
 8011b5a:	429a      	cmp	r2, r3
 8011b5c:	d100      	bne.n	8011b60 <HAL_DMA_IRQHandler+0x230>
 8011b5e:	e1a9      	b.n	8011eb4 <HAL_DMA_IRQHandler+0x584>
 8011b60:	4b3c      	ldr	r3, [pc, #240]	; (8011c54 <HAL_DMA_IRQHandler+0x324>)
 8011b62:	429a      	cmp	r2, r3
 8011b64:	d100      	bne.n	8011b68 <HAL_DMA_IRQHandler+0x238>
 8011b66:	e1a8      	b.n	8011eba <HAL_DMA_IRQHandler+0x58a>
 8011b68:	42aa      	cmp	r2, r5
 8011b6a:	d100      	bne.n	8011b6e <HAL_DMA_IRQHandler+0x23e>
 8011b6c:	e1a8      	b.n	8011ec0 <HAL_DMA_IRQHandler+0x590>
 8011b6e:	493a      	ldr	r1, [pc, #232]	; (8011c58 <HAL_DMA_IRQHandler+0x328>)
 8011b70:	2302      	movs	r3, #2
 8011b72:	428a      	cmp	r2, r1
 8011b74:	d011      	beq.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
 8011b76:	4939      	ldr	r1, [pc, #228]	; (8011c5c <HAL_DMA_IRQHandler+0x32c>)
 8011b78:	331e      	adds	r3, #30
 8011b7a:	428a      	cmp	r2, r1
 8011b7c:	d00d      	beq.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
 8011b7e:	4b38      	ldr	r3, [pc, #224]	; (8011c60 <HAL_DMA_IRQHandler+0x330>)
 8011b80:	429a      	cmp	r2, r3
 8011b82:	d100      	bne.n	8011b86 <HAL_DMA_IRQHandler+0x256>
 8011b84:	e19f      	b.n	8011ec6 <HAL_DMA_IRQHandler+0x596>
 8011b86:	4b37      	ldr	r3, [pc, #220]	; (8011c64 <HAL_DMA_IRQHandler+0x334>)
 8011b88:	18d1      	adds	r1, r2, r3
 8011b8a:	424b      	negs	r3, r1
 8011b8c:	4159      	adcs	r1, r3
 8011b8e:	4b39      	ldr	r3, [pc, #228]	; (8011c74 <HAL_DMA_IRQHandler+0x344>)
 8011b90:	4249      	negs	r1, r1
 8011b92:	400b      	ands	r3, r1
 8011b94:	2180      	movs	r1, #128	; 0x80
 8011b96:	0289      	lsls	r1, r1, #10
 8011b98:	185b      	adds	r3, r3, r1
 8011b9a:	4003      	ands	r3, r0
 8011b9c:	1e59      	subs	r1, r3, #1
 8011b9e:	418b      	sbcs	r3, r1
 8011ba0:	b2db      	uxtb	r3, r3
 8011ba2:	2b00      	cmp	r3, #0
 8011ba4:	d068      	beq.n	8011c78 <HAL_DMA_IRQHandler+0x348>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8011ba6:	2102      	movs	r1, #2
 8011ba8:	6813      	ldr	r3, [r2, #0]
 8011baa:	420b      	tst	r3, r1
 8011bac:	d064      	beq.n	8011c78 <HAL_DMA_IRQHandler+0x348>
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8011bae:	6813      	ldr	r3, [r2, #0]
 8011bb0:	069b      	lsls	r3, r3, #26
 8011bb2:	d402      	bmi.n	8011bba <HAL_DMA_IRQHandler+0x28a>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 8011bb4:	6813      	ldr	r3, [r2, #0]
 8011bb6:	438b      	bics	r3, r1
 8011bb8:	6013      	str	r3, [r2, #0]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8011bba:	6823      	ldr	r3, [r4, #0]
 8011bbc:	2202      	movs	r2, #2
 8011bbe:	42ab      	cmp	r3, r5
 8011bc0:	d800      	bhi.n	8011bc4 <HAL_DMA_IRQHandler+0x294>
 8011bc2:	e18f      	b.n	8011ee4 <HAL_DMA_IRQHandler+0x5b4>
 8011bc4:	42b3      	cmp	r3, r6
 8011bc6:	d027      	beq.n	8011c18 <HAL_DMA_IRQHandler+0x2e8>
 8011bc8:	491e      	ldr	r1, [pc, #120]	; (8011c44 <HAL_DMA_IRQHandler+0x314>)
 8011bca:	321e      	adds	r2, #30
 8011bcc:	428b      	cmp	r3, r1
 8011bce:	d023      	beq.n	8011c18 <HAL_DMA_IRQHandler+0x2e8>
 8011bd0:	4a1d      	ldr	r2, [pc, #116]	; (8011c48 <HAL_DMA_IRQHandler+0x318>)
 8011bd2:	4293      	cmp	r3, r2
 8011bd4:	d100      	bne.n	8011bd8 <HAL_DMA_IRQHandler+0x2a8>
 8011bd6:	e17f      	b.n	8011ed8 <HAL_DMA_IRQHandler+0x5a8>
 8011bd8:	4a1c      	ldr	r2, [pc, #112]	; (8011c4c <HAL_DMA_IRQHandler+0x31c>)
 8011bda:	4293      	cmp	r3, r2
 8011bdc:	d01a      	beq.n	8011c14 <HAL_DMA_IRQHandler+0x2e4>
 8011bde:	4a1c      	ldr	r2, [pc, #112]	; (8011c50 <HAL_DMA_IRQHandler+0x320>)
 8011be0:	4293      	cmp	r3, r2
 8011be2:	d100      	bne.n	8011be6 <HAL_DMA_IRQHandler+0x2b6>
 8011be4:	e17b      	b.n	8011ede <HAL_DMA_IRQHandler+0x5ae>
 8011be6:	4a1b      	ldr	r2, [pc, #108]	; (8011c54 <HAL_DMA_IRQHandler+0x324>)
 8011be8:	4293      	cmp	r3, r2
 8011bea:	d100      	bne.n	8011bee <HAL_DMA_IRQHandler+0x2be>
 8011bec:	e16e      	b.n	8011ecc <HAL_DMA_IRQHandler+0x59c>
 8011bee:	42ab      	cmp	r3, r5
 8011bf0:	d100      	bne.n	8011bf4 <HAL_DMA_IRQHandler+0x2c4>
 8011bf2:	e16e      	b.n	8011ed2 <HAL_DMA_IRQHandler+0x5a2>
 8011bf4:	4918      	ldr	r1, [pc, #96]	; (8011c58 <HAL_DMA_IRQHandler+0x328>)
 8011bf6:	2202      	movs	r2, #2
 8011bf8:	428b      	cmp	r3, r1
 8011bfa:	d00d      	beq.n	8011c18 <HAL_DMA_IRQHandler+0x2e8>
 8011bfc:	4917      	ldr	r1, [pc, #92]	; (8011c5c <HAL_DMA_IRQHandler+0x32c>)
 8011bfe:	321e      	adds	r2, #30
 8011c00:	428b      	cmp	r3, r1
 8011c02:	d009      	beq.n	8011c18 <HAL_DMA_IRQHandler+0x2e8>
 8011c04:	4a16      	ldr	r2, [pc, #88]	; (8011c60 <HAL_DMA_IRQHandler+0x330>)
 8011c06:	4293      	cmp	r3, r2
 8011c08:	d100      	bne.n	8011c0c <HAL_DMA_IRQHandler+0x2dc>
 8011c0a:	e165      	b.n	8011ed8 <HAL_DMA_IRQHandler+0x5a8>
 8011c0c:	4a17      	ldr	r2, [pc, #92]	; (8011c6c <HAL_DMA_IRQHandler+0x33c>)
 8011c0e:	4293      	cmp	r3, r2
 8011c10:	d000      	beq.n	8011c14 <HAL_DMA_IRQHandler+0x2e4>
 8011c12:	e164      	b.n	8011ede <HAL_DMA_IRQHandler+0x5ae>
 8011c14:	2280      	movs	r2, #128	; 0x80
 8011c16:	0192      	lsls	r2, r2, #6
 8011c18:	4b09      	ldr	r3, [pc, #36]	; (8011c40 <HAL_DMA_IRQHandler+0x310>)
 8011c1a:	605a      	str	r2, [r3, #4]
      hdma->State = HAL_DMA_STATE_READY;    
 8011c1c:	2201      	movs	r2, #1
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_NONE);
 8011c1e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8011c20:	6363      	str	r3, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;    
 8011c22:	1ca3      	adds	r3, r4, #2
 8011c24:	77da      	strb	r2, [r3, #31]
      __HAL_UNLOCK(hdma);
 8011c26:	18a3      	adds	r3, r4, r2
 8011c28:	2200      	movs	r2, #0
 8011c2a:	77da      	strb	r2, [r3, #31]
      if(hdma->XferCpltCallback != (void (*)(DMA_HandleTypeDef *))NULL)
 8011c2c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8011c2e:	4293      	cmp	r3, r2
 8011c30:	d022      	beq.n	8011c78 <HAL_DMA_IRQHandler+0x348>
        hdma->XferCpltCallback(hdma);
 8011c32:	0020      	movs	r0, r4
 8011c34:	4798      	blx	r3
 8011c36:	e01f      	b.n	8011c78 <HAL_DMA_IRQHandler+0x348>
 8011c38:	40020080 	.word	0x40020080
 8011c3c:	40020008 	.word	0x40020008
 8011c40:	40020400 	.word	0x40020400
 8011c44:	4002001c 	.word	0x4002001c
 8011c48:	40020030 	.word	0x40020030
 8011c4c:	40020044 	.word	0x40020044
 8011c50:	40020058 	.word	0x40020058
 8011c54:	4002006c 	.word	0x4002006c
 8011c58:	40020408 	.word	0x40020408
 8011c5c:	4002041c 	.word	0x4002041c
 8011c60:	40020430 	.word	0x40020430
 8011c64:	bffdfbbc 	.word	0xbffdfbbc
 8011c68:	fff88000 	.word	0xfff88000
 8011c6c:	40020444 	.word	0x40020444
 8011c70:	fffc4000 	.word	0xfffc4000
 8011c74:	fffe2000 	.word	0xfffe2000
}  
 8011c78:	bd70      	pop	{r4, r5, r6, pc}
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8011c7a:	2280      	movs	r2, #128	; 0x80
 8011c7c:	0212      	lsls	r2, r2, #8
 8011c7e:	e691      	b.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 8011c80:	2280      	movs	r2, #128	; 0x80
 8011c82:	0312      	lsls	r2, r2, #12
 8011c84:	e68e      	b.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 8011c86:	2280      	movs	r2, #128	; 0x80
 8011c88:	0412      	lsls	r2, r2, #16
 8011c8a:	e68b      	b.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 8011c8c:	2280      	movs	r2, #128	; 0x80
 8011c8e:	0512      	lsls	r2, r2, #20
 8011c90:	e688      	b.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 8011c92:	2280      	movs	r2, #128	; 0x80
 8011c94:	0112      	lsls	r2, r2, #4
 8011c96:	e685      	b.n	80119a4 <HAL_DMA_IRQHandler+0x74>
 8011c98:	4aac      	ldr	r2, [pc, #688]	; (8011f4c <HAL_DMA_IRQHandler+0x61c>)
 8011c9a:	6811      	ldr	r1, [r2, #0]
 8011c9c:	2208      	movs	r2, #8
 8011c9e:	42b3      	cmp	r3, r6
 8011ca0:	d026      	beq.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
 8011ca2:	48ab      	ldr	r0, [pc, #684]	; (8011f50 <HAL_DMA_IRQHandler+0x620>)
 8011ca4:	3278      	adds	r2, #120	; 0x78
 8011ca6:	4283      	cmp	r3, r0
 8011ca8:	d022      	beq.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
 8011caa:	4aaa      	ldr	r2, [pc, #680]	; (8011f54 <HAL_DMA_IRQHandler+0x624>)
 8011cac:	4293      	cmp	r3, r2
 8011cae:	d061      	beq.n	8011d74 <HAL_DMA_IRQHandler+0x444>
 8011cb0:	4aa9      	ldr	r2, [pc, #676]	; (8011f58 <HAL_DMA_IRQHandler+0x628>)
 8011cb2:	4293      	cmp	r3, r2
 8011cb4:	d052      	beq.n	8011d5c <HAL_DMA_IRQHandler+0x42c>
 8011cb6:	4aa9      	ldr	r2, [pc, #676]	; (8011f5c <HAL_DMA_IRQHandler+0x62c>)
 8011cb8:	4293      	cmp	r3, r2
 8011cba:	d052      	beq.n	8011d62 <HAL_DMA_IRQHandler+0x432>
 8011cbc:	4aa8      	ldr	r2, [pc, #672]	; (8011f60 <HAL_DMA_IRQHandler+0x630>)
 8011cbe:	4293      	cmp	r3, r2
 8011cc0:	d052      	beq.n	8011d68 <HAL_DMA_IRQHandler+0x438>
 8011cc2:	42ab      	cmp	r3, r5
 8011cc4:	d053      	beq.n	8011d6e <HAL_DMA_IRQHandler+0x43e>
 8011cc6:	48a7      	ldr	r0, [pc, #668]	; (8011f64 <HAL_DMA_IRQHandler+0x634>)
 8011cc8:	2208      	movs	r2, #8
 8011cca:	4283      	cmp	r3, r0
 8011ccc:	d010      	beq.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
 8011cce:	48a6      	ldr	r0, [pc, #664]	; (8011f68 <HAL_DMA_IRQHandler+0x638>)
 8011cd0:	3278      	adds	r2, #120	; 0x78
 8011cd2:	4283      	cmp	r3, r0
 8011cd4:	d00c      	beq.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
 8011cd6:	4aa5      	ldr	r2, [pc, #660]	; (8011f6c <HAL_DMA_IRQHandler+0x63c>)
 8011cd8:	4293      	cmp	r3, r2
 8011cda:	d04b      	beq.n	8011d74 <HAL_DMA_IRQHandler+0x444>
 8011cdc:	4aa4      	ldr	r2, [pc, #656]	; (8011f70 <HAL_DMA_IRQHandler+0x640>)
 8011cde:	189a      	adds	r2, r3, r2
 8011ce0:	4250      	negs	r0, r2
 8011ce2:	4142      	adcs	r2, r0
 8011ce4:	48a3      	ldr	r0, [pc, #652]	; (8011f74 <HAL_DMA_IRQHandler+0x644>)
 8011ce6:	4252      	negs	r2, r2
 8011ce8:	4002      	ands	r2, r0
 8011cea:	2080      	movs	r0, #128	; 0x80
 8011cec:	0300      	lsls	r0, r0, #12
 8011cee:	1812      	adds	r2, r2, r0
 8011cf0:	420a      	tst	r2, r1
 8011cf2:	d000      	beq.n	8011cf6 <HAL_DMA_IRQHandler+0x3c6>
 8011cf4:	e658      	b.n	80119a8 <HAL_DMA_IRQHandler+0x78>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8011cf6:	4a95      	ldr	r2, [pc, #596]	; (8011f4c <HAL_DMA_IRQHandler+0x61c>)
 8011cf8:	6811      	ldr	r1, [r2, #0]
 8011cfa:	2204      	movs	r2, #4
 8011cfc:	42b3      	cmp	r3, r6
 8011cfe:	d027      	beq.n	8011d50 <HAL_DMA_IRQHandler+0x420>
 8011d00:	4893      	ldr	r0, [pc, #588]	; (8011f50 <HAL_DMA_IRQHandler+0x620>)
 8011d02:	323c      	adds	r2, #60	; 0x3c
 8011d04:	4283      	cmp	r3, r0
 8011d06:	d023      	beq.n	8011d50 <HAL_DMA_IRQHandler+0x420>
 8011d08:	4a92      	ldr	r2, [pc, #584]	; (8011f54 <HAL_DMA_IRQHandler+0x624>)
 8011d0a:	4293      	cmp	r3, r2
 8011d0c:	d100      	bne.n	8011d10 <HAL_DMA_IRQHandler+0x3e0>
 8011d0e:	e08d      	b.n	8011e2c <HAL_DMA_IRQHandler+0x4fc>
 8011d10:	4a91      	ldr	r2, [pc, #580]	; (8011f58 <HAL_DMA_IRQHandler+0x628>)
 8011d12:	4293      	cmp	r3, r2
 8011d14:	d07e      	beq.n	8011e14 <HAL_DMA_IRQHandler+0x4e4>
 8011d16:	4a91      	ldr	r2, [pc, #580]	; (8011f5c <HAL_DMA_IRQHandler+0x62c>)
 8011d18:	4293      	cmp	r3, r2
 8011d1a:	d07e      	beq.n	8011e1a <HAL_DMA_IRQHandler+0x4ea>
 8011d1c:	4a90      	ldr	r2, [pc, #576]	; (8011f60 <HAL_DMA_IRQHandler+0x630>)
 8011d1e:	4293      	cmp	r3, r2
 8011d20:	d07e      	beq.n	8011e20 <HAL_DMA_IRQHandler+0x4f0>
 8011d22:	42ab      	cmp	r3, r5
 8011d24:	d07f      	beq.n	8011e26 <HAL_DMA_IRQHandler+0x4f6>
 8011d26:	488f      	ldr	r0, [pc, #572]	; (8011f64 <HAL_DMA_IRQHandler+0x634>)
 8011d28:	2204      	movs	r2, #4
 8011d2a:	4283      	cmp	r3, r0
 8011d2c:	d010      	beq.n	8011d50 <HAL_DMA_IRQHandler+0x420>
 8011d2e:	488e      	ldr	r0, [pc, #568]	; (8011f68 <HAL_DMA_IRQHandler+0x638>)
 8011d30:	323c      	adds	r2, #60	; 0x3c
 8011d32:	4283      	cmp	r3, r0
 8011d34:	d00c      	beq.n	8011d50 <HAL_DMA_IRQHandler+0x420>
 8011d36:	4a8d      	ldr	r2, [pc, #564]	; (8011f6c <HAL_DMA_IRQHandler+0x63c>)
 8011d38:	4293      	cmp	r3, r2
 8011d3a:	d077      	beq.n	8011e2c <HAL_DMA_IRQHandler+0x4fc>
 8011d3c:	4a8c      	ldr	r2, [pc, #560]	; (8011f70 <HAL_DMA_IRQHandler+0x640>)
 8011d3e:	189a      	adds	r2, r3, r2
 8011d40:	4250      	negs	r0, r2
 8011d42:	4142      	adcs	r2, r0
 8011d44:	488c      	ldr	r0, [pc, #560]	; (8011f78 <HAL_DMA_IRQHandler+0x648>)
 8011d46:	4252      	negs	r2, r2
 8011d48:	4002      	ands	r2, r0
 8011d4a:	2080      	movs	r0, #128	; 0x80
 8011d4c:	02c0      	lsls	r0, r0, #11
 8011d4e:	1812      	adds	r2, r2, r0
 8011d50:	420a      	tst	r2, r1
 8011d52:	d000      	beq.n	8011d56 <HAL_DMA_IRQHandler+0x426>
 8011d54:	e6a8      	b.n	8011aa8 <HAL_DMA_IRQHandler+0x178>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8011d56:	6822      	ldr	r2, [r4, #0]
 8011d58:	4b7c      	ldr	r3, [pc, #496]	; (8011f4c <HAL_DMA_IRQHandler+0x61c>)
 8011d5a:	e6ed      	b.n	8011b38 <HAL_DMA_IRQHandler+0x208>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8011d5c:	2280      	movs	r2, #128	; 0x80
 8011d5e:	0212      	lsls	r2, r2, #8
 8011d60:	e7c6      	b.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
 8011d62:	2280      	movs	r2, #128	; 0x80
 8011d64:	0312      	lsls	r2, r2, #12
 8011d66:	e7c3      	b.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
 8011d68:	2280      	movs	r2, #128	; 0x80
 8011d6a:	0412      	lsls	r2, r2, #16
 8011d6c:	e7c0      	b.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
 8011d6e:	2280      	movs	r2, #128	; 0x80
 8011d70:	0512      	lsls	r2, r2, #20
 8011d72:	e7bd      	b.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
 8011d74:	2280      	movs	r2, #128	; 0x80
 8011d76:	0112      	lsls	r2, r2, #4
 8011d78:	e7ba      	b.n	8011cf0 <HAL_DMA_IRQHandler+0x3c0>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8011d7a:	2380      	movs	r3, #128	; 0x80
 8011d7c:	041b      	lsls	r3, r3, #16
 8011d7e:	e649      	b.n	8011a14 <HAL_DMA_IRQHandler+0xe4>
 8011d80:	2380      	movs	r3, #128	; 0x80
 8011d82:	051b      	lsls	r3, r3, #20
 8011d84:	e646      	b.n	8011a14 <HAL_DMA_IRQHandler+0xe4>
 8011d86:	2380      	movs	r3, #128	; 0x80
 8011d88:	011b      	lsls	r3, r3, #4
 8011d8a:	e643      	b.n	8011a14 <HAL_DMA_IRQHandler+0xe4>
 8011d8c:	2380      	movs	r3, #128	; 0x80
 8011d8e:	031b      	lsls	r3, r3, #12
 8011d90:	e640      	b.n	8011a14 <HAL_DMA_IRQHandler+0xe4>
 8011d92:	42b1      	cmp	r1, r6
 8011d94:	d021      	beq.n	8011dda <HAL_DMA_IRQHandler+0x4aa>
 8011d96:	4a6e      	ldr	r2, [pc, #440]	; (8011f50 <HAL_DMA_IRQHandler+0x620>)
 8011d98:	2380      	movs	r3, #128	; 0x80
 8011d9a:	4291      	cmp	r1, r2
 8011d9c:	d01d      	beq.n	8011dda <HAL_DMA_IRQHandler+0x4aa>
 8011d9e:	4b6d      	ldr	r3, [pc, #436]	; (8011f54 <HAL_DMA_IRQHandler+0x624>)
 8011da0:	4299      	cmp	r1, r3
 8011da2:	d022      	beq.n	8011dea <HAL_DMA_IRQHandler+0x4ba>
 8011da4:	4b6c      	ldr	r3, [pc, #432]	; (8011f58 <HAL_DMA_IRQHandler+0x628>)
 8011da6:	4299      	cmp	r1, r3
 8011da8:	d015      	beq.n	8011dd6 <HAL_DMA_IRQHandler+0x4a6>
 8011daa:	4b6c      	ldr	r3, [pc, #432]	; (8011f5c <HAL_DMA_IRQHandler+0x62c>)
 8011dac:	4299      	cmp	r1, r3
 8011dae:	d01f      	beq.n	8011df0 <HAL_DMA_IRQHandler+0x4c0>
 8011db0:	4b6b      	ldr	r3, [pc, #428]	; (8011f60 <HAL_DMA_IRQHandler+0x630>)
 8011db2:	4299      	cmp	r1, r3
 8011db4:	d013      	beq.n	8011dde <HAL_DMA_IRQHandler+0x4ae>
 8011db6:	42a9      	cmp	r1, r5
 8011db8:	d014      	beq.n	8011de4 <HAL_DMA_IRQHandler+0x4b4>
 8011dba:	4a6a      	ldr	r2, [pc, #424]	; (8011f64 <HAL_DMA_IRQHandler+0x634>)
 8011dbc:	2308      	movs	r3, #8
 8011dbe:	4291      	cmp	r1, r2
 8011dc0:	d00b      	beq.n	8011dda <HAL_DMA_IRQHandler+0x4aa>
 8011dc2:	4a69      	ldr	r2, [pc, #420]	; (8011f68 <HAL_DMA_IRQHandler+0x638>)
 8011dc4:	3378      	adds	r3, #120	; 0x78
 8011dc6:	4291      	cmp	r1, r2
 8011dc8:	d007      	beq.n	8011dda <HAL_DMA_IRQHandler+0x4aa>
 8011dca:	4b68      	ldr	r3, [pc, #416]	; (8011f6c <HAL_DMA_IRQHandler+0x63c>)
 8011dcc:	4299      	cmp	r1, r3
 8011dce:	d00c      	beq.n	8011dea <HAL_DMA_IRQHandler+0x4ba>
 8011dd0:	4b6a      	ldr	r3, [pc, #424]	; (8011f7c <HAL_DMA_IRQHandler+0x64c>)
 8011dd2:	4299      	cmp	r1, r3
 8011dd4:	d10c      	bne.n	8011df0 <HAL_DMA_IRQHandler+0x4c0>
 8011dd6:	2380      	movs	r3, #128	; 0x80
 8011dd8:	021b      	lsls	r3, r3, #8
 8011dda:	4a5c      	ldr	r2, [pc, #368]	; (8011f4c <HAL_DMA_IRQHandler+0x61c>)
 8011ddc:	e61b      	b.n	8011a16 <HAL_DMA_IRQHandler+0xe6>
 8011dde:	2380      	movs	r3, #128	; 0x80
 8011de0:	041b      	lsls	r3, r3, #16
 8011de2:	e7fa      	b.n	8011dda <HAL_DMA_IRQHandler+0x4aa>
 8011de4:	2380      	movs	r3, #128	; 0x80
 8011de6:	051b      	lsls	r3, r3, #20
 8011de8:	e7f7      	b.n	8011dda <HAL_DMA_IRQHandler+0x4aa>
 8011dea:	2380      	movs	r3, #128	; 0x80
 8011dec:	011b      	lsls	r3, r3, #4
 8011dee:	e7f4      	b.n	8011dda <HAL_DMA_IRQHandler+0x4aa>
 8011df0:	2380      	movs	r3, #128	; 0x80
 8011df2:	031b      	lsls	r3, r3, #12
 8011df4:	e7f1      	b.n	8011dda <HAL_DMA_IRQHandler+0x4aa>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8011df6:	2280      	movs	r2, #128	; 0x80
 8011df8:	01d2      	lsls	r2, r2, #7
 8011dfa:	e652      	b.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011dfc:	2280      	movs	r2, #128	; 0x80
 8011dfe:	02d2      	lsls	r2, r2, #11
 8011e00:	e64f      	b.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011e02:	2280      	movs	r2, #128	; 0x80
 8011e04:	03d2      	lsls	r2, r2, #15
 8011e06:	e64c      	b.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011e08:	2280      	movs	r2, #128	; 0x80
 8011e0a:	04d2      	lsls	r2, r2, #19
 8011e0c:	e649      	b.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011e0e:	2280      	movs	r2, #128	; 0x80
 8011e10:	00d2      	lsls	r2, r2, #3
 8011e12:	e646      	b.n	8011aa2 <HAL_DMA_IRQHandler+0x172>
 8011e14:	2280      	movs	r2, #128	; 0x80
 8011e16:	01d2      	lsls	r2, r2, #7
 8011e18:	e79a      	b.n	8011d50 <HAL_DMA_IRQHandler+0x420>
 8011e1a:	2280      	movs	r2, #128	; 0x80
 8011e1c:	02d2      	lsls	r2, r2, #11
 8011e1e:	e797      	b.n	8011d50 <HAL_DMA_IRQHandler+0x420>
 8011e20:	2280      	movs	r2, #128	; 0x80
 8011e22:	03d2      	lsls	r2, r2, #15
 8011e24:	e794      	b.n	8011d50 <HAL_DMA_IRQHandler+0x420>
 8011e26:	2280      	movs	r2, #128	; 0x80
 8011e28:	04d2      	lsls	r2, r2, #19
 8011e2a:	e791      	b.n	8011d50 <HAL_DMA_IRQHandler+0x420>
 8011e2c:	2280      	movs	r2, #128	; 0x80
 8011e2e:	00d2      	lsls	r2, r2, #3
 8011e30:	e78e      	b.n	8011d50 <HAL_DMA_IRQHandler+0x420>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8011e32:	2280      	movs	r2, #128	; 0x80
 8011e34:	03d2      	lsls	r2, r2, #15
 8011e36:	e670      	b.n	8011b1a <HAL_DMA_IRQHandler+0x1ea>
 8011e38:	2280      	movs	r2, #128	; 0x80
 8011e3a:	04d2      	lsls	r2, r2, #19
 8011e3c:	e66d      	b.n	8011b1a <HAL_DMA_IRQHandler+0x1ea>
 8011e3e:	2280      	movs	r2, #128	; 0x80
 8011e40:	00d2      	lsls	r2, r2, #3
 8011e42:	e66a      	b.n	8011b1a <HAL_DMA_IRQHandler+0x1ea>
 8011e44:	2280      	movs	r2, #128	; 0x80
 8011e46:	02d2      	lsls	r2, r2, #11
 8011e48:	e667      	b.n	8011b1a <HAL_DMA_IRQHandler+0x1ea>
 8011e4a:	42b3      	cmp	r3, r6
 8011e4c:	d021      	beq.n	8011e92 <HAL_DMA_IRQHandler+0x562>
 8011e4e:	4940      	ldr	r1, [pc, #256]	; (8011f50 <HAL_DMA_IRQHandler+0x620>)
 8011e50:	323c      	adds	r2, #60	; 0x3c
 8011e52:	428b      	cmp	r3, r1
 8011e54:	d01d      	beq.n	8011e92 <HAL_DMA_IRQHandler+0x562>
 8011e56:	4a3f      	ldr	r2, [pc, #252]	; (8011f54 <HAL_DMA_IRQHandler+0x624>)
 8011e58:	4293      	cmp	r3, r2
 8011e5a:	d022      	beq.n	8011ea2 <HAL_DMA_IRQHandler+0x572>
 8011e5c:	4a3e      	ldr	r2, [pc, #248]	; (8011f58 <HAL_DMA_IRQHandler+0x628>)
 8011e5e:	4293      	cmp	r3, r2
 8011e60:	d015      	beq.n	8011e8e <HAL_DMA_IRQHandler+0x55e>
 8011e62:	4a3e      	ldr	r2, [pc, #248]	; (8011f5c <HAL_DMA_IRQHandler+0x62c>)
 8011e64:	4293      	cmp	r3, r2
 8011e66:	d01f      	beq.n	8011ea8 <HAL_DMA_IRQHandler+0x578>
 8011e68:	4a3d      	ldr	r2, [pc, #244]	; (8011f60 <HAL_DMA_IRQHandler+0x630>)
 8011e6a:	4293      	cmp	r3, r2
 8011e6c:	d013      	beq.n	8011e96 <HAL_DMA_IRQHandler+0x566>
 8011e6e:	42ab      	cmp	r3, r5
 8011e70:	d014      	beq.n	8011e9c <HAL_DMA_IRQHandler+0x56c>
 8011e72:	493c      	ldr	r1, [pc, #240]	; (8011f64 <HAL_DMA_IRQHandler+0x634>)
 8011e74:	2204      	movs	r2, #4
 8011e76:	428b      	cmp	r3, r1
 8011e78:	d00b      	beq.n	8011e92 <HAL_DMA_IRQHandler+0x562>
 8011e7a:	493b      	ldr	r1, [pc, #236]	; (8011f68 <HAL_DMA_IRQHandler+0x638>)
 8011e7c:	323c      	adds	r2, #60	; 0x3c
 8011e7e:	428b      	cmp	r3, r1
 8011e80:	d007      	beq.n	8011e92 <HAL_DMA_IRQHandler+0x562>
 8011e82:	4a3a      	ldr	r2, [pc, #232]	; (8011f6c <HAL_DMA_IRQHandler+0x63c>)
 8011e84:	4293      	cmp	r3, r2
 8011e86:	d00c      	beq.n	8011ea2 <HAL_DMA_IRQHandler+0x572>
 8011e88:	4a3c      	ldr	r2, [pc, #240]	; (8011f7c <HAL_DMA_IRQHandler+0x64c>)
 8011e8a:	4293      	cmp	r3, r2
 8011e8c:	d10c      	bne.n	8011ea8 <HAL_DMA_IRQHandler+0x578>
 8011e8e:	2280      	movs	r2, #128	; 0x80
 8011e90:	01d2      	lsls	r2, r2, #7
 8011e92:	4b2e      	ldr	r3, [pc, #184]	; (8011f4c <HAL_DMA_IRQHandler+0x61c>)
 8011e94:	e642      	b.n	8011b1c <HAL_DMA_IRQHandler+0x1ec>
 8011e96:	2280      	movs	r2, #128	; 0x80
 8011e98:	03d2      	lsls	r2, r2, #15
 8011e9a:	e7fa      	b.n	8011e92 <HAL_DMA_IRQHandler+0x562>
 8011e9c:	2280      	movs	r2, #128	; 0x80
 8011e9e:	04d2      	lsls	r2, r2, #19
 8011ea0:	e7f7      	b.n	8011e92 <HAL_DMA_IRQHandler+0x562>
 8011ea2:	2280      	movs	r2, #128	; 0x80
 8011ea4:	00d2      	lsls	r2, r2, #3
 8011ea6:	e7f4      	b.n	8011e92 <HAL_DMA_IRQHandler+0x562>
 8011ea8:	2280      	movs	r2, #128	; 0x80
 8011eaa:	02d2      	lsls	r2, r2, #11
 8011eac:	e7f1      	b.n	8011e92 <HAL_DMA_IRQHandler+0x562>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8011eae:	2380      	movs	r3, #128	; 0x80
 8011eb0:	019b      	lsls	r3, r3, #6
 8011eb2:	e672      	b.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
 8011eb4:	2380      	movs	r3, #128	; 0x80
 8011eb6:	029b      	lsls	r3, r3, #10
 8011eb8:	e66f      	b.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
 8011eba:	2380      	movs	r3, #128	; 0x80
 8011ebc:	039b      	lsls	r3, r3, #14
 8011ebe:	e66c      	b.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
 8011ec0:	2380      	movs	r3, #128	; 0x80
 8011ec2:	049b      	lsls	r3, r3, #18
 8011ec4:	e669      	b.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
 8011ec6:	2380      	movs	r3, #128	; 0x80
 8011ec8:	009b      	lsls	r3, r3, #2
 8011eca:	e666      	b.n	8011b9a <HAL_DMA_IRQHandler+0x26a>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8011ecc:	2280      	movs	r2, #128	; 0x80
 8011ece:	0392      	lsls	r2, r2, #14
 8011ed0:	e6a2      	b.n	8011c18 <HAL_DMA_IRQHandler+0x2e8>
 8011ed2:	2280      	movs	r2, #128	; 0x80
 8011ed4:	0492      	lsls	r2, r2, #18
 8011ed6:	e69f      	b.n	8011c18 <HAL_DMA_IRQHandler+0x2e8>
 8011ed8:	2280      	movs	r2, #128	; 0x80
 8011eda:	0092      	lsls	r2, r2, #2
 8011edc:	e69c      	b.n	8011c18 <HAL_DMA_IRQHandler+0x2e8>
 8011ede:	2280      	movs	r2, #128	; 0x80
 8011ee0:	0292      	lsls	r2, r2, #10
 8011ee2:	e699      	b.n	8011c18 <HAL_DMA_IRQHandler+0x2e8>
 8011ee4:	42b3      	cmp	r3, r6
 8011ee6:	d021      	beq.n	8011f2c <HAL_DMA_IRQHandler+0x5fc>
 8011ee8:	4919      	ldr	r1, [pc, #100]	; (8011f50 <HAL_DMA_IRQHandler+0x620>)
 8011eea:	321e      	adds	r2, #30
 8011eec:	428b      	cmp	r3, r1
 8011eee:	d01d      	beq.n	8011f2c <HAL_DMA_IRQHandler+0x5fc>
 8011ef0:	4a18      	ldr	r2, [pc, #96]	; (8011f54 <HAL_DMA_IRQHandler+0x624>)
 8011ef2:	4293      	cmp	r3, r2
 8011ef4:	d022      	beq.n	8011f3c <HAL_DMA_IRQHandler+0x60c>
 8011ef6:	4a18      	ldr	r2, [pc, #96]	; (8011f58 <HAL_DMA_IRQHandler+0x628>)
 8011ef8:	4293      	cmp	r3, r2
 8011efa:	d015      	beq.n	8011f28 <HAL_DMA_IRQHandler+0x5f8>
 8011efc:	4a17      	ldr	r2, [pc, #92]	; (8011f5c <HAL_DMA_IRQHandler+0x62c>)
 8011efe:	4293      	cmp	r3, r2
 8011f00:	d01f      	beq.n	8011f42 <HAL_DMA_IRQHandler+0x612>
 8011f02:	4a17      	ldr	r2, [pc, #92]	; (8011f60 <HAL_DMA_IRQHandler+0x630>)
 8011f04:	4293      	cmp	r3, r2
 8011f06:	d013      	beq.n	8011f30 <HAL_DMA_IRQHandler+0x600>
 8011f08:	42ab      	cmp	r3, r5
 8011f0a:	d014      	beq.n	8011f36 <HAL_DMA_IRQHandler+0x606>
 8011f0c:	4915      	ldr	r1, [pc, #84]	; (8011f64 <HAL_DMA_IRQHandler+0x634>)
 8011f0e:	2202      	movs	r2, #2
 8011f10:	428b      	cmp	r3, r1
 8011f12:	d00b      	beq.n	8011f2c <HAL_DMA_IRQHandler+0x5fc>
 8011f14:	4914      	ldr	r1, [pc, #80]	; (8011f68 <HAL_DMA_IRQHandler+0x638>)
 8011f16:	321e      	adds	r2, #30
 8011f18:	428b      	cmp	r3, r1
 8011f1a:	d007      	beq.n	8011f2c <HAL_DMA_IRQHandler+0x5fc>
 8011f1c:	4a13      	ldr	r2, [pc, #76]	; (8011f6c <HAL_DMA_IRQHandler+0x63c>)
 8011f1e:	4293      	cmp	r3, r2
 8011f20:	d00c      	beq.n	8011f3c <HAL_DMA_IRQHandler+0x60c>
 8011f22:	4a16      	ldr	r2, [pc, #88]	; (8011f7c <HAL_DMA_IRQHandler+0x64c>)
 8011f24:	4293      	cmp	r3, r2
 8011f26:	d10c      	bne.n	8011f42 <HAL_DMA_IRQHandler+0x612>
 8011f28:	2280      	movs	r2, #128	; 0x80
 8011f2a:	0192      	lsls	r2, r2, #6
 8011f2c:	4b07      	ldr	r3, [pc, #28]	; (8011f4c <HAL_DMA_IRQHandler+0x61c>)
 8011f2e:	e674      	b.n	8011c1a <HAL_DMA_IRQHandler+0x2ea>
 8011f30:	2280      	movs	r2, #128	; 0x80
 8011f32:	0392      	lsls	r2, r2, #14
 8011f34:	e7fa      	b.n	8011f2c <HAL_DMA_IRQHandler+0x5fc>
 8011f36:	2280      	movs	r2, #128	; 0x80
 8011f38:	0492      	lsls	r2, r2, #18
 8011f3a:	e7f7      	b.n	8011f2c <HAL_DMA_IRQHandler+0x5fc>
 8011f3c:	2280      	movs	r2, #128	; 0x80
 8011f3e:	0092      	lsls	r2, r2, #2
 8011f40:	e7f4      	b.n	8011f2c <HAL_DMA_IRQHandler+0x5fc>
 8011f42:	2280      	movs	r2, #128	; 0x80
 8011f44:	0292      	lsls	r2, r2, #10
 8011f46:	e7f1      	b.n	8011f2c <HAL_DMA_IRQHandler+0x5fc>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8011f48:	6822      	ldr	r2, [r4, #0]
 8011f4a:	e5f4      	b.n	8011b36 <HAL_DMA_IRQHandler+0x206>
 8011f4c:	40020000 	.word	0x40020000
 8011f50:	4002001c 	.word	0x4002001c
 8011f54:	40020030 	.word	0x40020030
 8011f58:	40020044 	.word	0x40020044
 8011f5c:	40020058 	.word	0x40020058
 8011f60:	4002006c 	.word	0x4002006c
 8011f64:	40020408 	.word	0x40020408
 8011f68:	4002041c 	.word	0x4002041c
 8011f6c:	40020430 	.word	0x40020430
 8011f70:	bffdfbbc 	.word	0xbffdfbbc
 8011f74:	fff88000 	.word	0xfff88000
 8011f78:	fffc4000 	.word	0xfffc4000
 8011f7c:	40020444 	.word	0x40020444

08011f80 <FLASH_SetErrorCode>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8011f80:	4b09      	ldr	r3, [pc, #36]	; (8011fa8 <FLASH_SetErrorCode+0x28>)
 8011f82:	68da      	ldr	r2, [r3, #12]
 8011f84:	06d2      	lsls	r2, r2, #27
 8011f86:	d504      	bpl.n	8011f92 <FLASH_SetErrorCode+0x12>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8011f88:	2202      	movs	r2, #2
 8011f8a:	4908      	ldr	r1, [pc, #32]	; (8011fac <FLASH_SetErrorCode+0x2c>)
 8011f8c:	69c8      	ldr	r0, [r1, #28]
 8011f8e:	4302      	orrs	r2, r0
 8011f90:	61ca      	str	r2, [r1, #28]
  }
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8011f92:	68da      	ldr	r2, [r3, #12]
 8011f94:	0752      	lsls	r2, r2, #29
 8011f96:	d504      	bpl.n	8011fa2 <FLASH_SetErrorCode+0x22>
  {
     pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8011f98:	2201      	movs	r2, #1
 8011f9a:	4904      	ldr	r1, [pc, #16]	; (8011fac <FLASH_SetErrorCode+0x2c>)
 8011f9c:	69c8      	ldr	r0, [r1, #28]
 8011f9e:	4302      	orrs	r2, r0
 8011fa0:	61ca      	str	r2, [r1, #28]
  }

  /* Clear FLASH error pending bits */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR | FLASH_FLAG_PGERR);
 8011fa2:	2214      	movs	r2, #20
 8011fa4:	60da      	str	r2, [r3, #12]
}  
 8011fa6:	4770      	bx	lr
 8011fa8:	40022000 	.word	0x40022000
 8011fac:	20007ab8 	.word	0x20007ab8

08011fb0 <HAL_FLASH_Unlock>:
  if (HAL_IS_BIT_SET(FLASH->CR, FLASH_CR_LOCK))
 8011fb0:	4b05      	ldr	r3, [pc, #20]	; (8011fc8 <HAL_FLASH_Unlock+0x18>)
    return HAL_ERROR;
 8011fb2:	2001      	movs	r0, #1
  if (HAL_IS_BIT_SET(FLASH->CR, FLASH_CR_LOCK))
 8011fb4:	691a      	ldr	r2, [r3, #16]
 8011fb6:	0612      	lsls	r2, r2, #24
 8011fb8:	d504      	bpl.n	8011fc4 <HAL_FLASH_Unlock+0x14>
  return HAL_OK; 
 8011fba:	2000      	movs	r0, #0
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8011fbc:	4a03      	ldr	r2, [pc, #12]	; (8011fcc <HAL_FLASH_Unlock+0x1c>)
 8011fbe:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8011fc0:	4a03      	ldr	r2, [pc, #12]	; (8011fd0 <HAL_FLASH_Unlock+0x20>)
 8011fc2:	605a      	str	r2, [r3, #4]
}
 8011fc4:	4770      	bx	lr
 8011fc6:	46c0      	nop			; (mov r8, r8)
 8011fc8:	40022000 	.word	0x40022000
 8011fcc:	45670123 	.word	0x45670123
 8011fd0:	cdef89ab 	.word	0xcdef89ab

08011fd4 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8011fd4:	2380      	movs	r3, #128	; 0x80
 8011fd6:	4a03      	ldr	r2, [pc, #12]	; (8011fe4 <HAL_FLASH_Lock+0x10>)
}
 8011fd8:	2000      	movs	r0, #0
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8011fda:	6911      	ldr	r1, [r2, #16]
 8011fdc:	430b      	orrs	r3, r1
 8011fde:	6113      	str	r3, [r2, #16]
}
 8011fe0:	4770      	bx	lr
 8011fe2:	46c0      	nop			; (mov r8, r8)
 8011fe4:	40022000 	.word	0x40022000

08011fe8 <FLASH_WaitForLastOperation>:
{
 8011fe8:	b570      	push	{r4, r5, r6, lr}
 8011fea:	0004      	movs	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8011fec:	f7ff fa88 	bl	8011500 <HAL_GetTick>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8011ff0:	2501      	movs	r5, #1
  uint32_t tickstart = HAL_GetTick();
 8011ff2:	0006      	movs	r6, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8011ff4:	4b10      	ldr	r3, [pc, #64]	; (8012038 <FLASH_WaitForLastOperation+0x50>)
 8011ff6:	001a      	movs	r2, r3
 8011ff8:	68d9      	ldr	r1, [r3, #12]
 8011ffa:	4229      	tst	r1, r5
 8011ffc:	d10f      	bne.n	801201e <FLASH_WaitForLastOperation+0x36>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8011ffe:	2120      	movs	r1, #32
 8012000:	68d8      	ldr	r0, [r3, #12]
 8012002:	4208      	tst	r0, r1
 8012004:	d000      	beq.n	8012008 <FLASH_WaitForLastOperation+0x20>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8012006:	60d9      	str	r1, [r3, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8012008:	2310      	movs	r3, #16
 801200a:	68d0      	ldr	r0, [r2, #12]
 801200c:	4018      	ands	r0, r3
 801200e:	d102      	bne.n	8012016 <FLASH_WaitForLastOperation+0x2e>
 8012010:	68d3      	ldr	r3, [r2, #12]
 8012012:	075b      	lsls	r3, r3, #29
 8012014:	d508      	bpl.n	8012028 <FLASH_WaitForLastOperation+0x40>
    FLASH_SetErrorCode();
 8012016:	f7ff ffb3 	bl	8011f80 <FLASH_SetErrorCode>
    return HAL_ERROR;
 801201a:	2001      	movs	r0, #1
 801201c:	e004      	b.n	8012028 <FLASH_WaitForLastOperation+0x40>
    if (Timeout != HAL_MAX_DELAY)
 801201e:	1c61      	adds	r1, r4, #1
 8012020:	d0ea      	beq.n	8011ff8 <FLASH_WaitForLastOperation+0x10>
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 8012022:	2c00      	cmp	r4, #0
 8012024:	d101      	bne.n	801202a <FLASH_WaitForLastOperation+0x42>
        return HAL_TIMEOUT;
 8012026:	2003      	movs	r0, #3
}
 8012028:	bd70      	pop	{r4, r5, r6, pc}
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 801202a:	f7ff fa69 	bl	8011500 <HAL_GetTick>
 801202e:	1b80      	subs	r0, r0, r6
 8012030:	42a0      	cmp	r0, r4
 8012032:	d9df      	bls.n	8011ff4 <FLASH_WaitForLastOperation+0xc>
 8012034:	e7f7      	b.n	8012026 <FLASH_WaitForLastOperation+0x3e>
 8012036:	46c0      	nop			; (mov r8, r8)
 8012038:	40022000 	.word	0x40022000

0801203c <HAL_FLASH_Program>:
{
 801203c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801203e:	b085      	sub	sp, #20
 8012040:	9202      	str	r2, [sp, #8]
 8012042:	9303      	str	r3, [sp, #12]
  __HAL_LOCK(&pFlash);
 8012044:	4b1b      	ldr	r3, [pc, #108]	; (80120b4 <HAL_FLASH_Program+0x78>)
{
 8012046:	9101      	str	r1, [sp, #4]
  __HAL_LOCK(&pFlash);
 8012048:	7e1a      	ldrb	r2, [r3, #24]
{
 801204a:	0004      	movs	r4, r0
  __HAL_LOCK(&pFlash);
 801204c:	2002      	movs	r0, #2
 801204e:	2a01      	cmp	r2, #1
 8012050:	d02e      	beq.n	80120b0 <HAL_FLASH_Program+0x74>
 8012052:	2201      	movs	r2, #1
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8012054:	4818      	ldr	r0, [pc, #96]	; (80120b8 <HAL_FLASH_Program+0x7c>)
  __HAL_LOCK(&pFlash);
 8012056:	761a      	strb	r2, [r3, #24]
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8012058:	f7ff ffc6 	bl	8011fe8 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 801205c:	2800      	cmp	r0, #0
 801205e:	d124      	bne.n	80120aa <HAL_FLASH_Program+0x6e>
      nbiterations = 1;
 8012060:	0026      	movs	r6, r4
    if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8012062:	2c01      	cmp	r4, #1
 8012064:	d002      	beq.n	801206c <HAL_FLASH_Program+0x30>
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 8012066:	2c02      	cmp	r4, #2
 8012068:	d000      	beq.n	801206c <HAL_FLASH_Program+0x30>
      nbiterations = 4;
 801206a:	2604      	movs	r6, #4
 801206c:	2400      	movs	r4, #0
      FLASH_Program_HalfWord((Address + (2*index)), (uint16_t)(Data >> (16*index)));
 801206e:	9802      	ldr	r0, [sp, #8]
 8012070:	9903      	ldr	r1, [sp, #12]
 8012072:	0122      	lsls	r2, r4, #4
 8012074:	f7ee f9f6 	bl	8000464 <__aeabi_llsr>
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8012078:	2200      	movs	r2, #0
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 801207a:	2701      	movs	r7, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 801207c:	4b0d      	ldr	r3, [pc, #52]	; (80120b4 <HAL_FLASH_Program+0x78>)
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 801207e:	4d0f      	ldr	r5, [pc, #60]	; (80120bc <HAL_FLASH_Program+0x80>)
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8012080:	61da      	str	r2, [r3, #28]
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8012082:	692b      	ldr	r3, [r5, #16]
      FLASH_Program_HalfWord((Address + (2*index)), (uint16_t)(Data >> (16*index)));
 8012084:	b280      	uxth	r0, r0
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8012086:	433b      	orrs	r3, r7
 8012088:	612b      	str	r3, [r5, #16]
 801208a:	9a01      	ldr	r2, [sp, #4]
 801208c:	0063      	lsls	r3, r4, #1
 801208e:	189b      	adds	r3, r3, r2
  *(__IO uint16_t*)Address = Data;
 8012090:	8018      	strh	r0, [r3, #0]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8012092:	4809      	ldr	r0, [pc, #36]	; (80120b8 <HAL_FLASH_Program+0x7c>)
 8012094:	f7ff ffa8 	bl	8011fe8 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8012098:	692b      	ldr	r3, [r5, #16]
 801209a:	43bb      	bics	r3, r7
 801209c:	612b      	str	r3, [r5, #16]
      if (status != HAL_OK)
 801209e:	2800      	cmp	r0, #0
 80120a0:	d103      	bne.n	80120aa <HAL_FLASH_Program+0x6e>
 80120a2:	19e4      	adds	r4, r4, r7
    for (index = 0; index < nbiterations; index++)
 80120a4:	b2e3      	uxtb	r3, r4
 80120a6:	429e      	cmp	r6, r3
 80120a8:	d8e1      	bhi.n	801206e <HAL_FLASH_Program+0x32>
  __HAL_UNLOCK(&pFlash);
 80120aa:	2200      	movs	r2, #0
 80120ac:	4b01      	ldr	r3, [pc, #4]	; (80120b4 <HAL_FLASH_Program+0x78>)
 80120ae:	761a      	strb	r2, [r3, #24]
}
 80120b0:	b005      	add	sp, #20
 80120b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80120b4:	20007ab8 	.word	0x20007ab8
 80120b8:	0000c350 	.word	0x0000c350
 80120bc:	40022000 	.word	0x40022000

080120c0 <FLASH_MassErase>:
  * @retval HAL Status
  */
static void FLASH_MassErase(void)
{
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80120c0:	2200      	movs	r2, #0
 80120c2:	4b06      	ldr	r3, [pc, #24]	; (80120dc <FLASH_MassErase+0x1c>)
 80120c4:	61da      	str	r2, [r3, #28]

    /* Only bank1 will be erased*/
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 80120c6:	4b06      	ldr	r3, [pc, #24]	; (80120e0 <FLASH_MassErase+0x20>)
 80120c8:	3204      	adds	r2, #4
 80120ca:	6919      	ldr	r1, [r3, #16]
 80120cc:	430a      	orrs	r2, r1
 80120ce:	611a      	str	r2, [r3, #16]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80120d0:	2240      	movs	r2, #64	; 0x40
 80120d2:	6919      	ldr	r1, [r3, #16]
 80120d4:	430a      	orrs	r2, r1
 80120d6:	611a      	str	r2, [r3, #16]
}
 80120d8:	4770      	bx	lr
 80120da:	46c0      	nop			; (mov r8, r8)
 80120dc:	20007ab8 	.word	0x20007ab8
 80120e0:	40022000 	.word	0x40022000

080120e4 <FLASH_PageErase>:
  * @retval None
  */
void FLASH_PageErase(uint32_t PageAddress)
{
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80120e4:	2200      	movs	r2, #0
 80120e6:	4b06      	ldr	r3, [pc, #24]	; (8012100 <FLASH_PageErase+0x1c>)
 80120e8:	61da      	str	r2, [r3, #28]

    /* Proceed to erase the page */
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 80120ea:	4b06      	ldr	r3, [pc, #24]	; (8012104 <FLASH_PageErase+0x20>)
 80120ec:	3202      	adds	r2, #2
 80120ee:	6919      	ldr	r1, [r3, #16]
 80120f0:	430a      	orrs	r2, r1
 80120f2:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->AR, PageAddress);
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80120f4:	2240      	movs	r2, #64	; 0x40
    WRITE_REG(FLASH->AR, PageAddress);
 80120f6:	6158      	str	r0, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80120f8:	6919      	ldr	r1, [r3, #16]
 80120fa:	430a      	orrs	r2, r1
 80120fc:	611a      	str	r2, [r3, #16]
}
 80120fe:	4770      	bx	lr
 8012100:	20007ab8 	.word	0x20007ab8
 8012104:	40022000 	.word	0x40022000

08012108 <HAL_FLASHEx_Erase>:
{
 8012108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 801210a:	4e21      	ldr	r6, [pc, #132]	; (8012190 <HAL_FLASHEx_Erase+0x88>)
{
 801210c:	0005      	movs	r5, r0
  __HAL_LOCK(&pFlash);
 801210e:	7e33      	ldrb	r3, [r6, #24]
{
 8012110:	000f      	movs	r7, r1
  __HAL_LOCK(&pFlash);
 8012112:	2002      	movs	r0, #2
 8012114:	2b01      	cmp	r3, #1
 8012116:	d00c      	beq.n	8012132 <HAL_FLASHEx_Erase+0x2a>
 8012118:	2301      	movs	r3, #1
 801211a:	7633      	strb	r3, [r6, #24]
  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 801211c:	682b      	ldr	r3, [r5, #0]
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 801211e:	481d      	ldr	r0, [pc, #116]	; (8012194 <HAL_FLASHEx_Erase+0x8c>)
  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8012120:	2b01      	cmp	r3, #1
 8012122:	d112      	bne.n	801214a <HAL_FLASHEx_Erase+0x42>
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 8012124:	f7ff ff60 	bl	8011fe8 <FLASH_WaitForLastOperation>
 8012128:	2800      	cmp	r0, #0
 801212a:	d003      	beq.n	8012134 <HAL_FLASHEx_Erase+0x2c>
  HAL_StatusTypeDef status = HAL_ERROR;
 801212c:	2001      	movs	r0, #1
  __HAL_UNLOCK(&pFlash);
 801212e:	2300      	movs	r3, #0
 8012130:	7633      	strb	r3, [r6, #24]
}
 8012132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        FLASH_MassErase();
 8012134:	f7ff ffc4 	bl	80120c0 <FLASH_MassErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8012138:	4816      	ldr	r0, [pc, #88]	; (8012194 <HAL_FLASHEx_Erase+0x8c>)
 801213a:	f7ff ff55 	bl	8011fe8 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
 801213e:	2104      	movs	r1, #4
 8012140:	4a15      	ldr	r2, [pc, #84]	; (8012198 <HAL_FLASHEx_Erase+0x90>)
 8012142:	6913      	ldr	r3, [r2, #16]
 8012144:	438b      	bics	r3, r1
 8012146:	6113      	str	r3, [r2, #16]
 8012148:	e7f1      	b.n	801212e <HAL_FLASHEx_Erase+0x26>
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 801214a:	f7ff ff4d 	bl	8011fe8 <FLASH_WaitForLastOperation>
 801214e:	2800      	cmp	r0, #0
 8012150:	d1ec      	bne.n	801212c <HAL_FLASHEx_Erase+0x24>
        *PageError = 0xFFFFFFFF;
 8012152:	2301      	movs	r3, #1
 8012154:	425b      	negs	r3, r3
 8012156:	603b      	str	r3, [r7, #0]
        for(address = pEraseInit->PageAddress;
 8012158:	686c      	ldr	r4, [r5, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
 801215a:	3001      	adds	r0, #1
            address < (pEraseInit->PageAddress + (pEraseInit->NbPages)*FLASH_PAGE_SIZE);
 801215c:	68ab      	ldr	r3, [r5, #8]
 801215e:	686a      	ldr	r2, [r5, #4]
 8012160:	02db      	lsls	r3, r3, #11
 8012162:	189b      	adds	r3, r3, r2
        for(address = pEraseInit->PageAddress;
 8012164:	42a3      	cmp	r3, r4
 8012166:	d9e2      	bls.n	801212e <HAL_FLASHEx_Erase+0x26>
          FLASH_PageErase(address);
 8012168:	0020      	movs	r0, r4
 801216a:	f7ff ffbb 	bl	80120e4 <FLASH_PageErase>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 801216e:	4809      	ldr	r0, [pc, #36]	; (8012194 <HAL_FLASHEx_Erase+0x8c>)
 8012170:	f7ff ff3a 	bl	8011fe8 <FLASH_WaitForLastOperation>
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8012174:	2102      	movs	r1, #2
 8012176:	4a08      	ldr	r2, [pc, #32]	; (8012198 <HAL_FLASHEx_Erase+0x90>)
 8012178:	6913      	ldr	r3, [r2, #16]
 801217a:	438b      	bics	r3, r1
 801217c:	6113      	str	r3, [r2, #16]
          if (status != HAL_OK)
 801217e:	2800      	cmp	r0, #0
 8012180:	d001      	beq.n	8012186 <HAL_FLASHEx_Erase+0x7e>
            *PageError = address;
 8012182:	603c      	str	r4, [r7, #0]
            break;
 8012184:	e7d3      	b.n	801212e <HAL_FLASHEx_Erase+0x26>
            address += FLASH_PAGE_SIZE)
 8012186:	2380      	movs	r3, #128	; 0x80
 8012188:	011b      	lsls	r3, r3, #4
 801218a:	18e4      	adds	r4, r4, r3
 801218c:	e7e6      	b.n	801215c <HAL_FLASHEx_Erase+0x54>
 801218e:	46c0      	nop			; (mov r8, r8)
 8012190:	20007ab8 	.word	0x20007ab8
 8012194:	0000c350 	.word	0x0000c350
 8012198:	40022000 	.word	0x40022000

0801219c <HAL_GPIO_Init>:
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 801219c:	4b56      	ldr	r3, [pc, #344]	; (80122f8 <HAL_GPIO_Init+0x15c>)
{ 
 801219e:	b5f0      	push	{r4, r5, r6, r7, lr}
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80121a0:	18c3      	adds	r3, r0, r3
 80121a2:	1e5c      	subs	r4, r3, #1
 80121a4:	41a3      	sbcs	r3, r4
  uint32_t position = 0x00;
 80121a6:	2200      	movs	r2, #0
{ 
 80121a8:	b087      	sub	sp, #28
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80121aa:	3304      	adds	r3, #4
 80121ac:	9303      	str	r3, [sp, #12]
  while ((GPIO_Init->Pin) >> position)
 80121ae:	680b      	ldr	r3, [r1, #0]
 80121b0:	001c      	movs	r4, r3
 80121b2:	40d4      	lsrs	r4, r2
 80121b4:	d101      	bne.n	80121ba <HAL_GPIO_Init+0x1e>
      }
    }
    
    position++;
  } 
}
 80121b6:	b007      	add	sp, #28
 80121b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1 << position);
 80121ba:	2401      	movs	r4, #1
 80121bc:	4094      	lsls	r4, r2
 80121be:	4023      	ands	r3, r4
 80121c0:	9301      	str	r3, [sp, #4]
    if(iocurrent)
 80121c2:	d100      	bne.n	80121c6 <HAL_GPIO_Init+0x2a>
 80121c4:	e096      	b.n	80122f4 <HAL_GPIO_Init+0x158>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 80121c6:	2410      	movs	r4, #16
 80121c8:	684d      	ldr	r5, [r1, #4]
 80121ca:	43a5      	bics	r5, r4
 80121cc:	2d02      	cmp	r5, #2
 80121ce:	d10e      	bne.n	80121ee <HAL_GPIO_Init+0x52>
        CLEAR_BIT(temp, (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;      
 80121d0:	2507      	movs	r5, #7
 80121d2:	270f      	movs	r7, #15
 80121d4:	4015      	ands	r5, r2
 80121d6:	00ad      	lsls	r5, r5, #2
 80121d8:	40af      	lsls	r7, r5
        temp = GPIOx->AFR[position >> 3];
 80121da:	08d4      	lsrs	r4, r2, #3
 80121dc:	00a4      	lsls	r4, r4, #2
 80121de:	1904      	adds	r4, r0, r4
 80121e0:	6a26      	ldr	r6, [r4, #32]
        CLEAR_BIT(temp, (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;      
 80121e2:	43be      	bics	r6, r7
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));       
 80121e4:	690f      	ldr	r7, [r1, #16]
 80121e6:	40af      	lsls	r7, r5
 80121e8:	003d      	movs	r5, r7
 80121ea:	4335      	orrs	r5, r6
        GPIOx->AFR[position >> 3] = temp;
 80121ec:	6225      	str	r5, [r4, #32]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
 80121ee:	2403      	movs	r4, #3
 80121f0:	0025      	movs	r5, r4
 80121f2:	0056      	lsls	r6, r2, #1
 80121f4:	40b5      	lsls	r5, r6
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80121f6:	684b      	ldr	r3, [r1, #4]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
 80121f8:	43ed      	mvns	r5, r5
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80121fa:	401c      	ands	r4, r3
 80121fc:	40b4      	lsls	r4, r6
      temp = GPIOx->MODER;
 80121fe:	6807      	ldr	r7, [r0, #0]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
 8012200:	402f      	ands	r7, r5
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8012202:	433c      	orrs	r4, r7
      GPIOx->MODER = temp;
 8012204:	6004      	str	r4, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8012206:	2410      	movs	r4, #16
 8012208:	684f      	ldr	r7, [r1, #4]
 801220a:	43a7      	bics	r7, r4
 801220c:	003c      	movs	r4, r7
 801220e:	3c01      	subs	r4, #1
 8012210:	2c01      	cmp	r4, #1
 8012212:	d812      	bhi.n	801223a <HAL_GPIO_Init+0x9e>
        SET_BIT(temp, GPIO_Init->Speed << (position * 2));
 8012214:	68cc      	ldr	r4, [r1, #12]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8012216:	2301      	movs	r3, #1
        SET_BIT(temp, GPIO_Init->Speed << (position * 2));
 8012218:	40b4      	lsls	r4, r6
        temp = GPIOx->OSPEEDR; 
 801221a:	6887      	ldr	r7, [r0, #8]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 801221c:	469c      	mov	ip, r3
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 801221e:	402f      	ands	r7, r5
        SET_BIT(temp, GPIO_Init->Speed << (position * 2));
 8012220:	433c      	orrs	r4, r7
        GPIOx->OSPEEDR = temp;
 8012222:	6084      	str	r4, [r0, #8]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8012224:	001c      	movs	r4, r3
 8012226:	4094      	lsls	r4, r2
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8012228:	684b      	ldr	r3, [r1, #4]
        temp = GPIOx->OTYPER;
 801222a:	6847      	ldr	r7, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 801222c:	43a7      	bics	r7, r4
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 801222e:	091c      	lsrs	r4, r3, #4
 8012230:	4663      	mov	r3, ip
 8012232:	401c      	ands	r4, r3
 8012234:	4094      	lsls	r4, r2
 8012236:	4327      	orrs	r7, r4
        GPIOx->OTYPER = temp;
 8012238:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 801223a:	68c4      	ldr	r4, [r0, #12]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2));
 801223c:	402c      	ands	r4, r5
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2));
 801223e:	688d      	ldr	r5, [r1, #8]
 8012240:	40b5      	lsls	r5, r6
 8012242:	4325      	orrs	r5, r4
      GPIOx->PUPDR = temp;
 8012244:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 8012246:	684b      	ldr	r3, [r1, #4]
 8012248:	00db      	lsls	r3, r3, #3
 801224a:	d553      	bpl.n	80122f4 <HAL_GPIO_Init+0x158>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 801224c:	2601      	movs	r6, #1
 801224e:	4c2b      	ldr	r4, [pc, #172]	; (80122fc <HAL_GPIO_Init+0x160>)
 8012250:	4b2b      	ldr	r3, [pc, #172]	; (8012300 <HAL_GPIO_Init+0x164>)
 8012252:	69a5      	ldr	r5, [r4, #24]
 8012254:	4335      	orrs	r5, r6
 8012256:	61a5      	str	r5, [r4, #24]
        temp = SYSCFG->EXTICR[position >> 2];
 8012258:	0895      	lsrs	r5, r2, #2
 801225a:	00ad      	lsls	r5, r5, #2
 801225c:	18ed      	adds	r5, r5, r3
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 801225e:	2303      	movs	r3, #3
 8012260:	001f      	movs	r7, r3
 8012262:	4017      	ands	r7, r2
 8012264:	469c      	mov	ip, r3
 8012266:	00bb      	lsls	r3, r7, #2
 8012268:	270f      	movs	r7, #15
 801226a:	409f      	lsls	r7, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 801226c:	69a4      	ldr	r4, [r4, #24]
 801226e:	4034      	ands	r4, r6
 8012270:	9405      	str	r4, [sp, #20]
 8012272:	9c05      	ldr	r4, [sp, #20]
        temp = SYSCFG->EXTICR[position >> 2];
 8012274:	68ac      	ldr	r4, [r5, #8]
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 8012276:	43bc      	bics	r4, r7
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8012278:	2790      	movs	r7, #144	; 0x90
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 801227a:	9402      	str	r4, [sp, #8]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 801227c:	05ff      	lsls	r7, r7, #23
 801227e:	2400      	movs	r4, #0
 8012280:	42b8      	cmp	r0, r7
 8012282:	d00c      	beq.n	801229e <HAL_GPIO_Init+0x102>
 8012284:	4f1f      	ldr	r7, [pc, #124]	; (8012304 <HAL_GPIO_Init+0x168>)
 8012286:	0034      	movs	r4, r6
 8012288:	42b8      	cmp	r0, r7
 801228a:	d008      	beq.n	801229e <HAL_GPIO_Init+0x102>
 801228c:	4e1e      	ldr	r6, [pc, #120]	; (8012308 <HAL_GPIO_Init+0x16c>)
 801228e:	1924      	adds	r4, r4, r4
 8012290:	42b0      	cmp	r0, r6
 8012292:	d004      	beq.n	801229e <HAL_GPIO_Init+0x102>
 8012294:	4e1d      	ldr	r6, [pc, #116]	; (801230c <HAL_GPIO_Init+0x170>)
 8012296:	4664      	mov	r4, ip
 8012298:	42b0      	cmp	r0, r6
 801229a:	d000      	beq.n	801229e <HAL_GPIO_Init+0x102>
 801229c:	9c03      	ldr	r4, [sp, #12]
 801229e:	409c      	lsls	r4, r3
 80122a0:	9b02      	ldr	r3, [sp, #8]
 80122a2:	431c      	orrs	r4, r3
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 80122a4:	9b01      	ldr	r3, [sp, #4]
        SYSCFG->EXTICR[position >> 2] = temp;
 80122a6:	60ac      	str	r4, [r5, #8]
          SET_BIT(temp, iocurrent); 
 80122a8:	001e      	movs	r6, r3
        temp = EXTI->IMR;
 80122aa:	4c19      	ldr	r4, [pc, #100]	; (8012310 <HAL_GPIO_Init+0x174>)
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 80122ac:	43dd      	mvns	r5, r3
        temp = EXTI->IMR;
 80122ae:	6827      	ldr	r7, [r4, #0]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80122b0:	684b      	ldr	r3, [r1, #4]
          SET_BIT(temp, iocurrent); 
 80122b2:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80122b4:	03db      	lsls	r3, r3, #15
 80122b6:	d401      	bmi.n	80122bc <HAL_GPIO_Init+0x120>
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 80122b8:	003e      	movs	r6, r7
 80122ba:	402e      	ands	r6, r5
        EXTI->IMR = temp;
 80122bc:	6026      	str	r6, [r4, #0]
        temp = EXTI->EMR;
 80122be:	6867      	ldr	r7, [r4, #4]
          SET_BIT(temp, iocurrent); 
 80122c0:	9e01      	ldr	r6, [sp, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80122c2:	684b      	ldr	r3, [r1, #4]
          SET_BIT(temp, iocurrent); 
 80122c4:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80122c6:	039b      	lsls	r3, r3, #14
 80122c8:	d401      	bmi.n	80122ce <HAL_GPIO_Init+0x132>
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 80122ca:	003e      	movs	r6, r7
 80122cc:	402e      	ands	r6, r5
        EXTI->EMR = temp;
 80122ce:	6066      	str	r6, [r4, #4]
        temp = EXTI->RTSR;
 80122d0:	68a7      	ldr	r7, [r4, #8]
          SET_BIT(temp, iocurrent); 
 80122d2:	9e01      	ldr	r6, [sp, #4]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80122d4:	684b      	ldr	r3, [r1, #4]
          SET_BIT(temp, iocurrent); 
 80122d6:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80122d8:	02db      	lsls	r3, r3, #11
 80122da:	d401      	bmi.n	80122e0 <HAL_GPIO_Init+0x144>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 80122dc:	003e      	movs	r6, r7
 80122de:	402e      	ands	r6, r5
        EXTI->RTSR = temp;
 80122e0:	60a6      	str	r6, [r4, #8]
        temp = EXTI->FTSR;
 80122e2:	68e6      	ldr	r6, [r4, #12]
          SET_BIT(temp, iocurrent); 
 80122e4:	9b01      	ldr	r3, [sp, #4]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80122e6:	684f      	ldr	r7, [r1, #4]
          SET_BIT(temp, iocurrent); 
 80122e8:	4333      	orrs	r3, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80122ea:	02bf      	lsls	r7, r7, #10
 80122ec:	d401      	bmi.n	80122f2 <HAL_GPIO_Init+0x156>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 80122ee:	0033      	movs	r3, r6
 80122f0:	402b      	ands	r3, r5
        EXTI->FTSR = temp;
 80122f2:	60e3      	str	r3, [r4, #12]
    position++;
 80122f4:	3201      	adds	r2, #1
 80122f6:	e75a      	b.n	80121ae <HAL_GPIO_Init+0x12>
 80122f8:	b7fff000 	.word	0xb7fff000
 80122fc:	40021000 	.word	0x40021000
 8012300:	40010000 	.word	0x40010000
 8012304:	48000400 	.word	0x48000400
 8012308:	48000800 	.word	0x48000800
 801230c:	48000c00 	.word	0x48000c00
 8012310:	40010400 	.word	0x40010400

08012314 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8012314:	6900      	ldr	r0, [r0, #16]
 8012316:	4008      	ands	r0, r1
 8012318:	1e41      	subs	r1, r0, #1
 801231a:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 801231c:	b2c0      	uxtb	r0, r0
  }
 801231e:	4770      	bx	lr

08012320 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8012320:	2a00      	cmp	r2, #0
 8012322:	d001      	beq.n	8012328 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8012324:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8012326:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8012328:	6281      	str	r1, [r0, #40]	; 0x28
}
 801232a:	e7fc      	b.n	8012326 <HAL_GPIO_WritePin+0x6>

0801232c <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 801232c:	6943      	ldr	r3, [r0, #20]
 801232e:	4059      	eors	r1, r3
 8012330:	6141      	str	r1, [r0, #20]
}
 8012332:	4770      	bx	lr

08012334 <HAL_MspInit>:
void HAL_MspInit(void)
{
  /* NOTE : This function is generated automatically by MicroXplorer and eventually  
            modified by the user
   */ 
}
 8012334:	4770      	bx	lr
	...

08012338 <HAL_PWR_EnableBkUpAccess>:
  *         Backup Domain Access should be kept enabled.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  PWR->CR |= (uint32_t)PWR_CR_DBP;
 8012338:	2380      	movs	r3, #128	; 0x80
 801233a:	4a03      	ldr	r2, [pc, #12]	; (8012348 <HAL_PWR_EnableBkUpAccess+0x10>)
 801233c:	005b      	lsls	r3, r3, #1
 801233e:	6811      	ldr	r1, [r2, #0]
 8012340:	430b      	orrs	r3, r1
 8012342:	6013      	str	r3, [r2, #0]
}
 8012344:	4770      	bx	lr
 8012346:	46c0      	nop			; (mov r8, r8)
 8012348:	40007000 	.word	0x40007000

0801234c <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 801234c:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 801234e:	6803      	ldr	r3, [r0, #0]
{
 8012350:	b085      	sub	sp, #20
 8012352:	0005      	movs	r5, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8012354:	07db      	lsls	r3, r3, #31
 8012356:	d43a      	bmi.n	80123ce <HAL_RCC_OscConfig+0x82>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8012358:	682b      	ldr	r3, [r5, #0]
 801235a:	079b      	lsls	r3, r3, #30
 801235c:	d500      	bpl.n	8012360 <HAL_RCC_OscConfig+0x14>
 801235e:	e0a2      	b.n	80124a6 <HAL_RCC_OscConfig+0x15a>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8012360:	682b      	ldr	r3, [r5, #0]
 8012362:	071b      	lsls	r3, r3, #28
 8012364:	d500      	bpl.n	8012368 <HAL_RCC_OscConfig+0x1c>
 8012366:	e0e3      	b.n	8012530 <HAL_RCC_OscConfig+0x1e4>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8012368:	682b      	ldr	r3, [r5, #0]
 801236a:	075b      	lsls	r3, r3, #29
 801236c:	d400      	bmi.n	8012370 <HAL_RCC_OscConfig+0x24>
 801236e:	e133      	b.n	80125d8 <HAL_RCC_OscConfig+0x28c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8012370:	2180      	movs	r1, #128	; 0x80
    
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR, PWR_CR_DBP);
 8012372:	2780      	movs	r7, #128	; 0x80
    __HAL_RCC_PWR_CLK_ENABLE();
 8012374:	4cbc      	ldr	r4, [pc, #752]	; (8012668 <HAL_RCC_OscConfig+0x31c>)
 8012376:	0549      	lsls	r1, r1, #21
 8012378:	69e2      	ldr	r2, [r4, #28]
    SET_BIT(PWR->CR, PWR_CR_DBP);
 801237a:	4ebc      	ldr	r6, [pc, #752]	; (801266c <HAL_RCC_OscConfig+0x320>)
    __HAL_RCC_PWR_CLK_ENABLE();
 801237c:	430a      	orrs	r2, r1
 801237e:	61e2      	str	r2, [r4, #28]
 8012380:	69e3      	ldr	r3, [r4, #28]
    SET_BIT(PWR->CR, PWR_CR_DBP);
 8012382:	007f      	lsls	r7, r7, #1
    __HAL_RCC_PWR_CLK_ENABLE();
 8012384:	400b      	ands	r3, r1
 8012386:	9303      	str	r3, [sp, #12]
 8012388:	9b03      	ldr	r3, [sp, #12]
    SET_BIT(PWR->CR, PWR_CR_DBP);
 801238a:	6833      	ldr	r3, [r6, #0]
 801238c:	433b      	orrs	r3, r7
 801238e:	6033      	str	r3, [r6, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8012390:	f7ff f8b6 	bl	8011500 <HAL_GetTick>
 8012394:	9001      	str	r0, [sp, #4]
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8012396:	6833      	ldr	r3, [r6, #0]
 8012398:	423b      	tst	r3, r7
 801239a:	d100      	bne.n	801239e <HAL_RCC_OscConfig+0x52>
 801239c:	e0ef      	b.n	801257e <HAL_RCC_OscConfig+0x232>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 801239e:	2201      	movs	r2, #1
 80123a0:	6a23      	ldr	r3, [r4, #32]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is disabled */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80123a2:	2602      	movs	r6, #2
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 80123a4:	4393      	bics	r3, r2
 80123a6:	6223      	str	r3, [r4, #32]
 80123a8:	6a23      	ldr	r3, [r4, #32]
 80123aa:	3203      	adds	r2, #3
 80123ac:	4393      	bics	r3, r2
 80123ae:	6223      	str	r3, [r4, #32]
    tickstart = HAL_GetTick();
 80123b0:	f7ff f8a6 	bl	8011500 <HAL_GetTick>
 80123b4:	0007      	movs	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80123b6:	6a23      	ldr	r3, [r4, #32]
 80123b8:	4233      	tst	r3, r6
 80123ba:	d000      	beq.n	80123be <HAL_RCC_OscConfig+0x72>
 80123bc:	e0e7      	b.n	801258e <HAL_RCC_OscConfig+0x242>
        return HAL_TIMEOUT;
      }
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80123be:	68ab      	ldr	r3, [r5, #8]
 80123c0:	2b01      	cmp	r3, #1
 80123c2:	d000      	beq.n	80123c6 <HAL_RCC_OscConfig+0x7a>
 80123c4:	e0eb      	b.n	801259e <HAL_RCC_OscConfig+0x252>
 80123c6:	6a22      	ldr	r2, [r4, #32]
 80123c8:	4313      	orrs	r3, r2
 80123ca:	6223      	str	r3, [r4, #32]
 80123cc:	e0fa      	b.n	80125c4 <HAL_RCC_OscConfig+0x278>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 80123ce:	210c      	movs	r1, #12
 80123d0:	4ca5      	ldr	r4, [pc, #660]	; (8012668 <HAL_RCC_OscConfig+0x31c>)
 80123d2:	6862      	ldr	r2, [r4, #4]
 80123d4:	400a      	ands	r2, r1
 80123d6:	2a04      	cmp	r2, #4
 80123d8:	d00b      	beq.n	80123f2 <HAL_RCC_OscConfig+0xa6>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80123da:	6863      	ldr	r3, [r4, #4]
 80123dc:	400b      	ands	r3, r1
 80123de:	2b08      	cmp	r3, #8
 80123e0:	d10f      	bne.n	8012402 <HAL_RCC_OscConfig+0xb6>
 80123e2:	22c0      	movs	r2, #192	; 0xc0
 80123e4:	6863      	ldr	r3, [r4, #4]
 80123e6:	0252      	lsls	r2, r2, #9
 80123e8:	4013      	ands	r3, r2
 80123ea:	2280      	movs	r2, #128	; 0x80
 80123ec:	0252      	lsls	r2, r2, #9
 80123ee:	4293      	cmp	r3, r2
 80123f0:	d107      	bne.n	8012402 <HAL_RCC_OscConfig+0xb6>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80123f2:	6823      	ldr	r3, [r4, #0]
 80123f4:	039b      	lsls	r3, r3, #14
 80123f6:	d5af      	bpl.n	8012358 <HAL_RCC_OscConfig+0xc>
 80123f8:	686b      	ldr	r3, [r5, #4]
 80123fa:	2b00      	cmp	r3, #0
 80123fc:	d1ac      	bne.n	8012358 <HAL_RCC_OscConfig+0xc>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI48)))
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET) && (RCC_OscInitStruct->HSI48State != RCC_HSI48_ON))
      {
        return HAL_ERROR;
 80123fe:	2001      	movs	r0, #1
 8012400:	e02f      	b.n	8012462 <HAL_RCC_OscConfig+0x116>
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8012402:	6823      	ldr	r3, [r4, #0]
 8012404:	4f9a      	ldr	r7, [pc, #616]	; (8012670 <HAL_RCC_OscConfig+0x324>)
 8012406:	4e9b      	ldr	r6, [pc, #620]	; (8012674 <HAL_RCC_OscConfig+0x328>)
 8012408:	403b      	ands	r3, r7
 801240a:	6023      	str	r3, [r4, #0]
 801240c:	6823      	ldr	r3, [r4, #0]
 801240e:	4033      	ands	r3, r6
 8012410:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 8012412:	f7ff f875 	bl	8011500 <HAL_GetTick>
 8012416:	9001      	str	r0, [sp, #4]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8012418:	2280      	movs	r2, #128	; 0x80
 801241a:	6823      	ldr	r3, [r4, #0]
 801241c:	0292      	lsls	r2, r2, #10
 801241e:	4213      	tst	r3, r2
 8012420:	d118      	bne.n	8012454 <HAL_RCC_OscConfig+0x108>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8012422:	686b      	ldr	r3, [r5, #4]
 8012424:	2b01      	cmp	r3, #1
 8012426:	d11e      	bne.n	8012466 <HAL_RCC_OscConfig+0x11a>
 8012428:	2380      	movs	r3, #128	; 0x80
 801242a:	6822      	ldr	r2, [r4, #0]
 801242c:	025b      	lsls	r3, r3, #9
 801242e:	4313      	orrs	r3, r2
 8012430:	6023      	str	r3, [r4, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8012432:	686b      	ldr	r3, [r5, #4]
 8012434:	2b00      	cmp	r3, #0
 8012436:	d027      	beq.n	8012488 <HAL_RCC_OscConfig+0x13c>
        tickstart = HAL_GetTick();
 8012438:	f7ff f862 	bl	8011500 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 801243c:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 801243e:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8012440:	02b6      	lsls	r6, r6, #10
 8012442:	6823      	ldr	r3, [r4, #0]
 8012444:	4233      	tst	r3, r6
 8012446:	d187      	bne.n	8012358 <HAL_RCC_OscConfig+0xc>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8012448:	f7ff f85a 	bl	8011500 <HAL_GetTick>
 801244c:	1bc0      	subs	r0, r0, r7
 801244e:	2864      	cmp	r0, #100	; 0x64
 8012450:	d9f7      	bls.n	8012442 <HAL_RCC_OscConfig+0xf6>
 8012452:	e005      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8012454:	f7ff f854 	bl	8011500 <HAL_GetTick>
 8012458:	9b01      	ldr	r3, [sp, #4]
 801245a:	1ac0      	subs	r0, r0, r3
 801245c:	2864      	cmp	r0, #100	; 0x64
 801245e:	d9db      	bls.n	8012418 <HAL_RCC_OscConfig+0xcc>
          return HAL_TIMEOUT;
 8012460:	2003      	movs	r0, #3
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
}
 8012462:	b005      	add	sp, #20
 8012464:	bdf0      	pop	{r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8012466:	2b00      	cmp	r3, #0
 8012468:	d106      	bne.n	8012478 <HAL_RCC_OscConfig+0x12c>
 801246a:	6823      	ldr	r3, [r4, #0]
 801246c:	401f      	ands	r7, r3
 801246e:	6027      	str	r7, [r4, #0]
 8012470:	6823      	ldr	r3, [r4, #0]
 8012472:	401e      	ands	r6, r3
 8012474:	6026      	str	r6, [r4, #0]
 8012476:	e7dc      	b.n	8012432 <HAL_RCC_OscConfig+0xe6>
 8012478:	2b05      	cmp	r3, #5
 801247a:	d1f6      	bne.n	801246a <HAL_RCC_OscConfig+0x11e>
 801247c:	2380      	movs	r3, #128	; 0x80
 801247e:	6822      	ldr	r2, [r4, #0]
 8012480:	02db      	lsls	r3, r3, #11
 8012482:	4313      	orrs	r3, r2
 8012484:	6023      	str	r3, [r4, #0]
 8012486:	e7cf      	b.n	8012428 <HAL_RCC_OscConfig+0xdc>
        tickstart = HAL_GetTick();
 8012488:	f7ff f83a 	bl	8011500 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 801248c:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 801248e:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8012490:	02b6      	lsls	r6, r6, #10
 8012492:	6823      	ldr	r3, [r4, #0]
 8012494:	4233      	tst	r3, r6
 8012496:	d100      	bne.n	801249a <HAL_RCC_OscConfig+0x14e>
 8012498:	e75e      	b.n	8012358 <HAL_RCC_OscConfig+0xc>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 801249a:	f7ff f831 	bl	8011500 <HAL_GetTick>
 801249e:	1bc0      	subs	r0, r0, r7
 80124a0:	2864      	cmp	r0, #100	; 0x64
 80124a2:	d9f6      	bls.n	8012492 <HAL_RCC_OscConfig+0x146>
 80124a4:	e7dc      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80124a6:	220c      	movs	r2, #12
 80124a8:	4c6f      	ldr	r4, [pc, #444]	; (8012668 <HAL_RCC_OscConfig+0x31c>)
 80124aa:	6863      	ldr	r3, [r4, #4]
 80124ac:	4213      	tst	r3, r2
 80124ae:	d00b      	beq.n	80124c8 <HAL_RCC_OscConfig+0x17c>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 80124b0:	6863      	ldr	r3, [r4, #4]
 80124b2:	4013      	ands	r3, r2
 80124b4:	2b08      	cmp	r3, #8
 80124b6:	d116      	bne.n	80124e6 <HAL_RCC_OscConfig+0x19a>
 80124b8:	22c0      	movs	r2, #192	; 0xc0
 80124ba:	6863      	ldr	r3, [r4, #4]
 80124bc:	0252      	lsls	r2, r2, #9
 80124be:	4013      	ands	r3, r2
 80124c0:	2280      	movs	r2, #128	; 0x80
 80124c2:	0212      	lsls	r2, r2, #8
 80124c4:	4293      	cmp	r3, r2
 80124c6:	d10e      	bne.n	80124e6 <HAL_RCC_OscConfig+0x19a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80124c8:	6823      	ldr	r3, [r4, #0]
 80124ca:	079b      	lsls	r3, r3, #30
 80124cc:	d503      	bpl.n	80124d6 <HAL_RCC_OscConfig+0x18a>
 80124ce:	68eb      	ldr	r3, [r5, #12]
 80124d0:	2b01      	cmp	r3, #1
 80124d2:	d000      	beq.n	80124d6 <HAL_RCC_OscConfig+0x18a>
 80124d4:	e793      	b.n	80123fe <HAL_RCC_OscConfig+0xb2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80124d6:	21f8      	movs	r1, #248	; 0xf8
 80124d8:	6822      	ldr	r2, [r4, #0]
 80124da:	692b      	ldr	r3, [r5, #16]
 80124dc:	438a      	bics	r2, r1
 80124de:	00db      	lsls	r3, r3, #3
 80124e0:	4313      	orrs	r3, r2
 80124e2:	6023      	str	r3, [r4, #0]
 80124e4:	e73c      	b.n	8012360 <HAL_RCC_OscConfig+0x14>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80124e6:	68ea      	ldr	r2, [r5, #12]
 80124e8:	2301      	movs	r3, #1
 80124ea:	2a00      	cmp	r2, #0
 80124ec:	d00f      	beq.n	801250e <HAL_RCC_OscConfig+0x1c2>
        __HAL_RCC_HSI_ENABLE();
 80124ee:	6822      	ldr	r2, [r4, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80124f0:	2602      	movs	r6, #2
        __HAL_RCC_HSI_ENABLE();
 80124f2:	4313      	orrs	r3, r2
 80124f4:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80124f6:	f7ff f803 	bl	8011500 <HAL_GetTick>
 80124fa:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80124fc:	6823      	ldr	r3, [r4, #0]
 80124fe:	4233      	tst	r3, r6
 8012500:	d1e9      	bne.n	80124d6 <HAL_RCC_OscConfig+0x18a>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8012502:	f7fe fffd 	bl	8011500 <HAL_GetTick>
 8012506:	1bc0      	subs	r0, r0, r7
 8012508:	2864      	cmp	r0, #100	; 0x64
 801250a:	d9f7      	bls.n	80124fc <HAL_RCC_OscConfig+0x1b0>
 801250c:	e7a8      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
        __HAL_RCC_HSI_DISABLE();
 801250e:	6822      	ldr	r2, [r4, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8012510:	2602      	movs	r6, #2
        __HAL_RCC_HSI_DISABLE();
 8012512:	439a      	bics	r2, r3
 8012514:	6022      	str	r2, [r4, #0]
        tickstart = HAL_GetTick();
 8012516:	f7fe fff3 	bl	8011500 <HAL_GetTick>
 801251a:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 801251c:	6823      	ldr	r3, [r4, #0]
 801251e:	4233      	tst	r3, r6
 8012520:	d100      	bne.n	8012524 <HAL_RCC_OscConfig+0x1d8>
 8012522:	e71d      	b.n	8012360 <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8012524:	f7fe ffec 	bl	8011500 <HAL_GetTick>
 8012528:	1bc0      	subs	r0, r0, r7
 801252a:	2864      	cmp	r0, #100	; 0x64
 801252c:	d9f6      	bls.n	801251c <HAL_RCC_OscConfig+0x1d0>
 801252e:	e797      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8012530:	6a2a      	ldr	r2, [r5, #32]
 8012532:	2301      	movs	r3, #1
 8012534:	4c4c      	ldr	r4, [pc, #304]	; (8012668 <HAL_RCC_OscConfig+0x31c>)
 8012536:	2a00      	cmp	r2, #0
 8012538:	d010      	beq.n	801255c <HAL_RCC_OscConfig+0x210>
      __HAL_RCC_LSI_ENABLE();
 801253a:	6a62      	ldr	r2, [r4, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 801253c:	2602      	movs	r6, #2
      __HAL_RCC_LSI_ENABLE();
 801253e:	4313      	orrs	r3, r2
 8012540:	6263      	str	r3, [r4, #36]	; 0x24
      tickstart = HAL_GetTick();
 8012542:	f7fe ffdd 	bl	8011500 <HAL_GetTick>
 8012546:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8012548:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801254a:	4233      	tst	r3, r6
 801254c:	d000      	beq.n	8012550 <HAL_RCC_OscConfig+0x204>
 801254e:	e70b      	b.n	8012368 <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8012550:	f7fe ffd6 	bl	8011500 <HAL_GetTick>
 8012554:	1bc0      	subs	r0, r0, r7
 8012556:	2864      	cmp	r0, #100	; 0x64
 8012558:	d9f6      	bls.n	8012548 <HAL_RCC_OscConfig+0x1fc>
 801255a:	e781      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
      __HAL_RCC_LSI_DISABLE();
 801255c:	6a62      	ldr	r2, [r4, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 801255e:	2602      	movs	r6, #2
      __HAL_RCC_LSI_DISABLE();
 8012560:	439a      	bics	r2, r3
 8012562:	6262      	str	r2, [r4, #36]	; 0x24
      tickstart = HAL_GetTick();
 8012564:	f7fe ffcc 	bl	8011500 <HAL_GetTick>
 8012568:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 801256a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801256c:	4233      	tst	r3, r6
 801256e:	d100      	bne.n	8012572 <HAL_RCC_OscConfig+0x226>
 8012570:	e6fa      	b.n	8012368 <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8012572:	f7fe ffc5 	bl	8011500 <HAL_GetTick>
 8012576:	1bc0      	subs	r0, r0, r7
 8012578:	2864      	cmp	r0, #100	; 0x64
 801257a:	d9f6      	bls.n	801256a <HAL_RCC_OscConfig+0x21e>
 801257c:	e770      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 801257e:	f7fe ffbf 	bl	8011500 <HAL_GetTick>
 8012582:	9b01      	ldr	r3, [sp, #4]
 8012584:	1ac0      	subs	r0, r0, r3
 8012586:	2864      	cmp	r0, #100	; 0x64
 8012588:	d800      	bhi.n	801258c <HAL_RCC_OscConfig+0x240>
 801258a:	e704      	b.n	8012396 <HAL_RCC_OscConfig+0x4a>
 801258c:	e768      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 801258e:	f7fe ffb7 	bl	8011500 <HAL_GetTick>
 8012592:	4b39      	ldr	r3, [pc, #228]	; (8012678 <HAL_RCC_OscConfig+0x32c>)
 8012594:	1bc0      	subs	r0, r0, r7
 8012596:	4298      	cmp	r0, r3
 8012598:	d800      	bhi.n	801259c <HAL_RCC_OscConfig+0x250>
 801259a:	e70c      	b.n	80123b6 <HAL_RCC_OscConfig+0x6a>
 801259c:	e760      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
 801259e:	2201      	movs	r2, #1
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80125a0:	2b00      	cmp	r3, #0
 80125a2:	d106      	bne.n	80125b2 <HAL_RCC_OscConfig+0x266>
 80125a4:	6a23      	ldr	r3, [r4, #32]
 80125a6:	4393      	bics	r3, r2
 80125a8:	2204      	movs	r2, #4
 80125aa:	6223      	str	r3, [r4, #32]
 80125ac:	6a23      	ldr	r3, [r4, #32]
 80125ae:	4393      	bics	r3, r2
 80125b0:	e70b      	b.n	80123ca <HAL_RCC_OscConfig+0x7e>
 80125b2:	2b05      	cmp	r3, #5
 80125b4:	d1f6      	bne.n	80125a4 <HAL_RCC_OscConfig+0x258>
 80125b6:	6a21      	ldr	r1, [r4, #32]
 80125b8:	3b01      	subs	r3, #1
 80125ba:	430b      	orrs	r3, r1
 80125bc:	6223      	str	r3, [r4, #32]
 80125be:	6a23      	ldr	r3, [r4, #32]
 80125c0:	431a      	orrs	r2, r3
 80125c2:	6222      	str	r2, [r4, #32]
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80125c4:	68ab      	ldr	r3, [r5, #8]
 80125c6:	2b00      	cmp	r3, #0
 80125c8:	d019      	beq.n	80125fe <HAL_RCC_OscConfig+0x2b2>
      tickstart = HAL_GetTick();
 80125ca:	f7fe ff99 	bl	8011500 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80125ce:	2602      	movs	r6, #2
      tickstart = HAL_GetTick();
 80125d0:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80125d2:	6a23      	ldr	r3, [r4, #32]
 80125d4:	4233      	tst	r3, r6
 80125d6:	d00b      	beq.n	80125f0 <HAL_RCC_OscConfig+0x2a4>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 80125d8:	682b      	ldr	r3, [r5, #0]
 80125da:	06db      	lsls	r3, r3, #27
 80125dc:	d41d      	bmi.n	801261a <HAL_RCC_OscConfig+0x2ce>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80125de:	682b      	ldr	r3, [r5, #0]
 80125e0:	069b      	lsls	r3, r3, #26
 80125e2:	d45f      	bmi.n	80126a4 <HAL_RCC_OscConfig+0x358>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80125e4:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80125e6:	2900      	cmp	r1, #0
 80125e8:	d000      	beq.n	80125ec <HAL_RCC_OscConfig+0x2a0>
 80125ea:	e09b      	b.n	8012724 <HAL_RCC_OscConfig+0x3d8>
  return HAL_OK;
 80125ec:	2000      	movs	r0, #0
 80125ee:	e738      	b.n	8012462 <HAL_RCC_OscConfig+0x116>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80125f0:	f7fe ff86 	bl	8011500 <HAL_GetTick>
 80125f4:	4b20      	ldr	r3, [pc, #128]	; (8012678 <HAL_RCC_OscConfig+0x32c>)
 80125f6:	1bc0      	subs	r0, r0, r7
 80125f8:	4298      	cmp	r0, r3
 80125fa:	d9ea      	bls.n	80125d2 <HAL_RCC_OscConfig+0x286>
 80125fc:	e730      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
      tickstart = HAL_GetTick();
 80125fe:	f7fe ff7f 	bl	8011500 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8012602:	2602      	movs	r6, #2
      tickstart = HAL_GetTick();
 8012604:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8012606:	6a23      	ldr	r3, [r4, #32]
 8012608:	4233      	tst	r3, r6
 801260a:	d0e5      	beq.n	80125d8 <HAL_RCC_OscConfig+0x28c>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 801260c:	f7fe ff78 	bl	8011500 <HAL_GetTick>
 8012610:	4b19      	ldr	r3, [pc, #100]	; (8012678 <HAL_RCC_OscConfig+0x32c>)
 8012612:	1bc0      	subs	r0, r0, r7
 8012614:	4298      	cmp	r0, r3
 8012616:	d9f6      	bls.n	8012606 <HAL_RCC_OscConfig+0x2ba>
 8012618:	e722      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
    if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 801261a:	696a      	ldr	r2, [r5, #20]
 801261c:	4c12      	ldr	r4, [pc, #72]	; (8012668 <HAL_RCC_OscConfig+0x31c>)
 801261e:	2304      	movs	r3, #4
 8012620:	2a01      	cmp	r2, #1
 8012622:	d11a      	bne.n	801265a <HAL_RCC_OscConfig+0x30e>
      __HAL_RCC_HSI14ADC_DISABLE();
 8012624:	6b61      	ldr	r1, [r4, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 8012626:	2602      	movs	r6, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 8012628:	430b      	orrs	r3, r1
 801262a:	6363      	str	r3, [r4, #52]	; 0x34
      __HAL_RCC_HSI14_ENABLE();
 801262c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 801262e:	431a      	orrs	r2, r3
 8012630:	6362      	str	r2, [r4, #52]	; 0x34
      tickstart = HAL_GetTick();
 8012632:	f7fe ff65 	bl	8011500 <HAL_GetTick>
 8012636:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 8012638:	6b63      	ldr	r3, [r4, #52]	; 0x34
 801263a:	4233      	tst	r3, r6
 801263c:	d007      	beq.n	801264e <HAL_RCC_OscConfig+0x302>
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 801263e:	21f8      	movs	r1, #248	; 0xf8
 8012640:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8012642:	69ab      	ldr	r3, [r5, #24]
 8012644:	438a      	bics	r2, r1
 8012646:	00db      	lsls	r3, r3, #3
 8012648:	4313      	orrs	r3, r2
 801264a:	6363      	str	r3, [r4, #52]	; 0x34
 801264c:	e7c7      	b.n	80125de <HAL_RCC_OscConfig+0x292>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 801264e:	f7fe ff57 	bl	8011500 <HAL_GetTick>
 8012652:	1bc0      	subs	r0, r0, r7
 8012654:	2864      	cmp	r0, #100	; 0x64
 8012656:	d9ef      	bls.n	8012638 <HAL_RCC_OscConfig+0x2ec>
 8012658:	e702      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
    else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 801265a:	3205      	adds	r2, #5
 801265c:	d10e      	bne.n	801267c <HAL_RCC_OscConfig+0x330>
      __HAL_RCC_HSI14ADC_ENABLE();
 801265e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8012660:	439a      	bics	r2, r3
 8012662:	6362      	str	r2, [r4, #52]	; 0x34
 8012664:	e7eb      	b.n	801263e <HAL_RCC_OscConfig+0x2f2>
 8012666:	46c0      	nop			; (mov r8, r8)
 8012668:	40021000 	.word	0x40021000
 801266c:	40007000 	.word	0x40007000
 8012670:	fffeffff 	.word	0xfffeffff
 8012674:	fffbffff 	.word	0xfffbffff
 8012678:	00001388 	.word	0x00001388
      __HAL_RCC_HSI14ADC_DISABLE();
 801267c:	6b62      	ldr	r2, [r4, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 801267e:	2602      	movs	r6, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 8012680:	4313      	orrs	r3, r2
      __HAL_RCC_HSI14_DISABLE();
 8012682:	2201      	movs	r2, #1
      __HAL_RCC_HSI14ADC_DISABLE();
 8012684:	6363      	str	r3, [r4, #52]	; 0x34
      __HAL_RCC_HSI14_DISABLE();
 8012686:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8012688:	4393      	bics	r3, r2
 801268a:	6363      	str	r3, [r4, #52]	; 0x34
      tickstart = HAL_GetTick();
 801268c:	f7fe ff38 	bl	8011500 <HAL_GetTick>
 8012690:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8012692:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8012694:	4233      	tst	r3, r6
 8012696:	d0a2      	beq.n	80125de <HAL_RCC_OscConfig+0x292>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 8012698:	f7fe ff32 	bl	8011500 <HAL_GetTick>
 801269c:	1bc0      	subs	r0, r0, r7
 801269e:	2864      	cmp	r0, #100	; 0x64
 80126a0:	d9f7      	bls.n	8012692 <HAL_RCC_OscConfig+0x346>
 80126a2:	e6dd      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
 80126a4:	210c      	movs	r1, #12
 80126a6:	4c45      	ldr	r4, [pc, #276]	; (80127bc <HAL_RCC_OscConfig+0x470>)
 80126a8:	6862      	ldr	r2, [r4, #4]
 80126aa:	400a      	ands	r2, r1
 80126ac:	428a      	cmp	r2, r1
 80126ae:	d009      	beq.n	80126c4 <HAL_RCC_OscConfig+0x378>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI48)))
 80126b0:	6863      	ldr	r3, [r4, #4]
 80126b2:	400b      	ands	r3, r1
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
 80126b4:	2b08      	cmp	r3, #8
 80126b6:	d10d      	bne.n	80126d4 <HAL_RCC_OscConfig+0x388>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI48)))
 80126b8:	22c0      	movs	r2, #192	; 0xc0
 80126ba:	6863      	ldr	r3, [r4, #4]
 80126bc:	0252      	lsls	r2, r2, #9
 80126be:	4013      	ands	r3, r2
 80126c0:	4293      	cmp	r3, r2
 80126c2:	d107      	bne.n	80126d4 <HAL_RCC_OscConfig+0x388>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET) && (RCC_OscInitStruct->HSI48State != RCC_HSI48_ON))
 80126c4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80126c6:	03db      	lsls	r3, r3, #15
 80126c8:	d58c      	bpl.n	80125e4 <HAL_RCC_OscConfig+0x298>
 80126ca:	69eb      	ldr	r3, [r5, #28]
 80126cc:	2b01      	cmp	r3, #1
 80126ce:	d000      	beq.n	80126d2 <HAL_RCC_OscConfig+0x386>
 80126d0:	e695      	b.n	80123fe <HAL_RCC_OscConfig+0xb2>
 80126d2:	e787      	b.n	80125e4 <HAL_RCC_OscConfig+0x298>
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80126d4:	69eb      	ldr	r3, [r5, #28]
 80126d6:	2b00      	cmp	r3, #0
 80126d8:	d011      	beq.n	80126fe <HAL_RCC_OscConfig+0x3b2>
        __HAL_RCC_HSI48_ENABLE();
 80126da:	2680      	movs	r6, #128	; 0x80
 80126dc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80126de:	0276      	lsls	r6, r6, #9
 80126e0:	4333      	orrs	r3, r6
 80126e2:	6363      	str	r3, [r4, #52]	; 0x34
        tickstart = HAL_GetTick();
 80126e4:	f7fe ff0c 	bl	8011500 <HAL_GetTick>
 80126e8:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 80126ea:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80126ec:	4233      	tst	r3, r6
 80126ee:	d000      	beq.n	80126f2 <HAL_RCC_OscConfig+0x3a6>
 80126f0:	e778      	b.n	80125e4 <HAL_RCC_OscConfig+0x298>
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80126f2:	f7fe ff05 	bl	8011500 <HAL_GetTick>
 80126f6:	1bc0      	subs	r0, r0, r7
 80126f8:	2864      	cmp	r0, #100	; 0x64
 80126fa:	d9f6      	bls.n	80126ea <HAL_RCC_OscConfig+0x39e>
 80126fc:	e6b0      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
        __HAL_RCC_HSI48_DISABLE();
 80126fe:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8012700:	4a2f      	ldr	r2, [pc, #188]	; (80127c0 <HAL_RCC_OscConfig+0x474>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 8012702:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_HSI48_DISABLE();
 8012704:	4013      	ands	r3, r2
 8012706:	6363      	str	r3, [r4, #52]	; 0x34
        tickstart = HAL_GetTick();
 8012708:	f7fe fefa 	bl	8011500 <HAL_GetTick>
 801270c:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 801270e:	0276      	lsls	r6, r6, #9
 8012710:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8012712:	4233      	tst	r3, r6
 8012714:	d100      	bne.n	8012718 <HAL_RCC_OscConfig+0x3cc>
 8012716:	e765      	b.n	80125e4 <HAL_RCC_OscConfig+0x298>
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8012718:	f7fe fef2 	bl	8011500 <HAL_GetTick>
 801271c:	1bc0      	subs	r0, r0, r7
 801271e:	2864      	cmp	r0, #100	; 0x64
 8012720:	d9f6      	bls.n	8012710 <HAL_RCC_OscConfig+0x3c4>
 8012722:	e69d      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8012724:	220c      	movs	r2, #12
 8012726:	4c25      	ldr	r4, [pc, #148]	; (80127bc <HAL_RCC_OscConfig+0x470>)
 8012728:	6863      	ldr	r3, [r4, #4]
 801272a:	4013      	ands	r3, r2
 801272c:	2b08      	cmp	r3, #8
 801272e:	d100      	bne.n	8012732 <HAL_RCC_OscConfig+0x3e6>
 8012730:	e665      	b.n	80123fe <HAL_RCC_OscConfig+0xb2>
        __HAL_RCC_PLL_DISABLE();
 8012732:	6823      	ldr	r3, [r4, #0]
 8012734:	4a23      	ldr	r2, [pc, #140]	; (80127c4 <HAL_RCC_OscConfig+0x478>)
 8012736:	4013      	ands	r3, r2
 8012738:	6023      	str	r3, [r4, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 801273a:	2902      	cmp	r1, #2
 801273c:	d12f      	bne.n	801279e <HAL_RCC_OscConfig+0x452>
        tickstart = HAL_GetTick();
 801273e:	f7fe fedf 	bl	8011500 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8012742:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 8012744:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8012746:	04b6      	lsls	r6, r6, #18
 8012748:	6823      	ldr	r3, [r4, #0]
 801274a:	4233      	tst	r3, r6
 801274c:	d121      	bne.n	8012792 <HAL_RCC_OscConfig+0x446>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 801274e:	220f      	movs	r2, #15
 8012750:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8012752:	4393      	bics	r3, r2
 8012754:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8012756:	4313      	orrs	r3, r2
 8012758:	62e3      	str	r3, [r4, #44]	; 0x2c
 801275a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 801275c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 801275e:	6862      	ldr	r2, [r4, #4]
 8012760:	430b      	orrs	r3, r1
 8012762:	4919      	ldr	r1, [pc, #100]	; (80127c8 <HAL_RCC_OscConfig+0x47c>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8012764:	2580      	movs	r5, #128	; 0x80
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8012766:	400a      	ands	r2, r1
 8012768:	4313      	orrs	r3, r2
 801276a:	6063      	str	r3, [r4, #4]
        __HAL_RCC_PLL_ENABLE();
 801276c:	2380      	movs	r3, #128	; 0x80
 801276e:	6822      	ldr	r2, [r4, #0]
 8012770:	045b      	lsls	r3, r3, #17
 8012772:	4313      	orrs	r3, r2
 8012774:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8012776:	f7fe fec3 	bl	8011500 <HAL_GetTick>
 801277a:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 801277c:	04ad      	lsls	r5, r5, #18
 801277e:	6823      	ldr	r3, [r4, #0]
 8012780:	422b      	tst	r3, r5
 8012782:	d000      	beq.n	8012786 <HAL_RCC_OscConfig+0x43a>
 8012784:	e732      	b.n	80125ec <HAL_RCC_OscConfig+0x2a0>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8012786:	f7fe febb 	bl	8011500 <HAL_GetTick>
 801278a:	1b80      	subs	r0, r0, r6
 801278c:	2864      	cmp	r0, #100	; 0x64
 801278e:	d9f6      	bls.n	801277e <HAL_RCC_OscConfig+0x432>
 8012790:	e666      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8012792:	f7fe feb5 	bl	8011500 <HAL_GetTick>
 8012796:	1bc0      	subs	r0, r0, r7
 8012798:	2864      	cmp	r0, #100	; 0x64
 801279a:	d9d5      	bls.n	8012748 <HAL_RCC_OscConfig+0x3fc>
 801279c:	e660      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
        tickstart = HAL_GetTick();
 801279e:	f7fe feaf 	bl	8011500 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80127a2:	2580      	movs	r5, #128	; 0x80
        tickstart = HAL_GetTick();
 80127a4:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80127a6:	04ad      	lsls	r5, r5, #18
 80127a8:	6823      	ldr	r3, [r4, #0]
 80127aa:	422b      	tst	r3, r5
 80127ac:	d100      	bne.n	80127b0 <HAL_RCC_OscConfig+0x464>
 80127ae:	e71d      	b.n	80125ec <HAL_RCC_OscConfig+0x2a0>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80127b0:	f7fe fea6 	bl	8011500 <HAL_GetTick>
 80127b4:	1b80      	subs	r0, r0, r6
 80127b6:	2864      	cmp	r0, #100	; 0x64
 80127b8:	d9f6      	bls.n	80127a8 <HAL_RCC_OscConfig+0x45c>
 80127ba:	e651      	b.n	8012460 <HAL_RCC_OscConfig+0x114>
 80127bc:	40021000 	.word	0x40021000
 80127c0:	fffeffff 	.word	0xfffeffff
 80127c4:	feffffff 	.word	0xfeffffff
 80127c8:	ffc27fff 	.word	0xffc27fff

080127cc <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80127cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80127ce:	000e      	movs	r6, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80127d0:	2101      	movs	r1, #1
 80127d2:	4b7b      	ldr	r3, [pc, #492]	; (80129c0 <HAL_RCC_ClockConfig+0x1f4>)
{
 80127d4:	0004      	movs	r4, r0
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80127d6:	681a      	ldr	r2, [r3, #0]
 80127d8:	001f      	movs	r7, r3
 80127da:	400a      	ands	r2, r1
 80127dc:	42b2      	cmp	r2, r6
 80127de:	d300      	bcc.n	80127e2 <HAL_RCC_ClockConfig+0x16>
 80127e0:	e072      	b.n	80128c8 <HAL_RCC_ClockConfig+0xfc>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80127e2:	681a      	ldr	r2, [r3, #0]
 80127e4:	438a      	bics	r2, r1
 80127e6:	4332      	orrs	r2, r6
 80127e8:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80127ea:	681b      	ldr	r3, [r3, #0]
 80127ec:	400b      	ands	r3, r1
 80127ee:	42b3      	cmp	r3, r6
 80127f0:	d001      	beq.n	80127f6 <HAL_RCC_ClockConfig+0x2a>
    {
      return HAL_ERROR;
 80127f2:	2001      	movs	r0, #1
  
  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
  
  return HAL_OK;
}
 80127f4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80127f6:	6803      	ldr	r3, [r0, #0]
 80127f8:	079b      	lsls	r3, r3, #30
 80127fa:	d506      	bpl.n	801280a <HAL_RCC_ClockConfig+0x3e>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80127fc:	21f0      	movs	r1, #240	; 0xf0
 80127fe:	4a71      	ldr	r2, [pc, #452]	; (80129c4 <HAL_RCC_ClockConfig+0x1f8>)
 8012800:	6853      	ldr	r3, [r2, #4]
 8012802:	438b      	bics	r3, r1
 8012804:	6881      	ldr	r1, [r0, #8]
 8012806:	430b      	orrs	r3, r1
 8012808:	6053      	str	r3, [r2, #4]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 801280a:	6823      	ldr	r3, [r4, #0]
 801280c:	07db      	lsls	r3, r3, #31
 801280e:	d408      	bmi.n	8012822 <HAL_RCC_ClockConfig+0x56>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8012810:	6823      	ldr	r3, [r4, #0]
 8012812:	075b      	lsls	r3, r3, #29
 8012814:	d500      	bpl.n	8012818 <HAL_RCC_ClockConfig+0x4c>
 8012816:	e0ca      	b.n	80129ae <HAL_RCC_ClockConfig+0x1e2>
  HAL_InitTick (TICK_INT_PRIORITY);
 8012818:	2000      	movs	r0, #0
 801281a:	f7fe fe47 	bl	80114ac <HAL_InitTick>
  return HAL_OK;
 801281e:	2000      	movs	r0, #0
 8012820:	e7e8      	b.n	80127f4 <HAL_RCC_ClockConfig+0x28>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8012822:	6862      	ldr	r2, [r4, #4]
 8012824:	4d67      	ldr	r5, [pc, #412]	; (80129c4 <HAL_RCC_ClockConfig+0x1f8>)
 8012826:	2a01      	cmp	r2, #1
 8012828:	d11a      	bne.n	8012860 <HAL_RCC_ClockConfig+0x94>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 801282a:	682b      	ldr	r3, [r5, #0]
 801282c:	039b      	lsls	r3, r3, #14
 801282e:	d5e0      	bpl.n	80127f2 <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8012830:	2103      	movs	r1, #3
 8012832:	686b      	ldr	r3, [r5, #4]
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8012834:	270c      	movs	r7, #12
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8012836:	438b      	bics	r3, r1
 8012838:	4313      	orrs	r3, r2
 801283a:	606b      	str	r3, [r5, #4]
      tickstart = HAL_GetTick();
 801283c:	f7fe fe60 	bl	8011500 <HAL_GetTick>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8012840:	6863      	ldr	r3, [r4, #4]
      tickstart = HAL_GetTick();
 8012842:	0006      	movs	r6, r0
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8012844:	2b01      	cmp	r3, #1
 8012846:	d11b      	bne.n	8012880 <HAL_RCC_ClockConfig+0xb4>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8012848:	686b      	ldr	r3, [r5, #4]
 801284a:	403b      	ands	r3, r7
 801284c:	2b04      	cmp	r3, #4
 801284e:	d0df      	beq.n	8012810 <HAL_RCC_ClockConfig+0x44>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012850:	f7fe fe56 	bl	8011500 <HAL_GetTick>
 8012854:	4b5c      	ldr	r3, [pc, #368]	; (80129c8 <HAL_RCC_ClockConfig+0x1fc>)
 8012856:	1b80      	subs	r0, r0, r6
 8012858:	4298      	cmp	r0, r3
 801285a:	d9f5      	bls.n	8012848 <HAL_RCC_ClockConfig+0x7c>
            return HAL_TIMEOUT;
 801285c:	2003      	movs	r0, #3
 801285e:	e7c9      	b.n	80127f4 <HAL_RCC_ClockConfig+0x28>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012860:	2a02      	cmp	r2, #2
 8012862:	d103      	bne.n	801286c <HAL_RCC_ClockConfig+0xa0>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8012864:	682b      	ldr	r3, [r5, #0]
 8012866:	019b      	lsls	r3, r3, #6
 8012868:	d4e2      	bmi.n	8012830 <HAL_RCC_ClockConfig+0x64>
 801286a:	e7c2      	b.n	80127f2 <HAL_RCC_ClockConfig+0x26>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 801286c:	2a03      	cmp	r2, #3
 801286e:	d103      	bne.n	8012878 <HAL_RCC_ClockConfig+0xac>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 8012870:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8012872:	03db      	lsls	r3, r3, #15
 8012874:	d4dc      	bmi.n	8012830 <HAL_RCC_ClockConfig+0x64>
 8012876:	e7bc      	b.n	80127f2 <HAL_RCC_ClockConfig+0x26>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8012878:	682b      	ldr	r3, [r5, #0]
 801287a:	079b      	lsls	r3, r3, #30
 801287c:	d4d8      	bmi.n	8012830 <HAL_RCC_ClockConfig+0x64>
 801287e:	e7b8      	b.n	80127f2 <HAL_RCC_ClockConfig+0x26>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012880:	2b02      	cmp	r3, #2
 8012882:	d10a      	bne.n	801289a <HAL_RCC_ClockConfig+0xce>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8012884:	686b      	ldr	r3, [r5, #4]
 8012886:	403b      	ands	r3, r7
 8012888:	2b08      	cmp	r3, #8
 801288a:	d0c1      	beq.n	8012810 <HAL_RCC_ClockConfig+0x44>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 801288c:	f7fe fe38 	bl	8011500 <HAL_GetTick>
 8012890:	4b4d      	ldr	r3, [pc, #308]	; (80129c8 <HAL_RCC_ClockConfig+0x1fc>)
 8012892:	1b80      	subs	r0, r0, r6
 8012894:	4298      	cmp	r0, r3
 8012896:	d9f5      	bls.n	8012884 <HAL_RCC_ClockConfig+0xb8>
 8012898:	e7e0      	b.n	801285c <HAL_RCC_ClockConfig+0x90>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 801289a:	2b03      	cmp	r3, #3
 801289c:	d110      	bne.n	80128c0 <HAL_RCC_ClockConfig+0xf4>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI48)
 801289e:	686b      	ldr	r3, [r5, #4]
 80128a0:	403b      	ands	r3, r7
 80128a2:	2b0c      	cmp	r3, #12
 80128a4:	d0b4      	beq.n	8012810 <HAL_RCC_ClockConfig+0x44>
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80128a6:	f7fe fe2b 	bl	8011500 <HAL_GetTick>
 80128aa:	4b47      	ldr	r3, [pc, #284]	; (80129c8 <HAL_RCC_ClockConfig+0x1fc>)
 80128ac:	1b80      	subs	r0, r0, r6
 80128ae:	4298      	cmp	r0, r3
 80128b0:	d9f5      	bls.n	801289e <HAL_RCC_ClockConfig+0xd2>
 80128b2:	e7d3      	b.n	801285c <HAL_RCC_ClockConfig+0x90>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80128b4:	f7fe fe24 	bl	8011500 <HAL_GetTick>
 80128b8:	4b43      	ldr	r3, [pc, #268]	; (80129c8 <HAL_RCC_ClockConfig+0x1fc>)
 80128ba:	1b80      	subs	r0, r0, r6
 80128bc:	4298      	cmp	r0, r3
 80128be:	d8cd      	bhi.n	801285c <HAL_RCC_ClockConfig+0x90>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80128c0:	686b      	ldr	r3, [r5, #4]
 80128c2:	423b      	tst	r3, r7
 80128c4:	d1f6      	bne.n	80128b4 <HAL_RCC_ClockConfig+0xe8>
 80128c6:	e7a3      	b.n	8012810 <HAL_RCC_ClockConfig+0x44>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80128c8:	6803      	ldr	r3, [r0, #0]
 80128ca:	079b      	lsls	r3, r3, #30
 80128cc:	d506      	bpl.n	80128dc <HAL_RCC_ClockConfig+0x110>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80128ce:	21f0      	movs	r1, #240	; 0xf0
 80128d0:	4a3c      	ldr	r2, [pc, #240]	; (80129c4 <HAL_RCC_ClockConfig+0x1f8>)
 80128d2:	6853      	ldr	r3, [r2, #4]
 80128d4:	438b      	bics	r3, r1
 80128d6:	6881      	ldr	r1, [r0, #8]
 80128d8:	430b      	orrs	r3, r1
 80128da:	6053      	str	r3, [r2, #4]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80128dc:	6823      	ldr	r3, [r4, #0]
 80128de:	07db      	lsls	r3, r3, #31
 80128e0:	d40a      	bmi.n	80128f8 <HAL_RCC_ClockConfig+0x12c>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80128e2:	2201      	movs	r2, #1
 80128e4:	683b      	ldr	r3, [r7, #0]
 80128e6:	4393      	bics	r3, r2
 80128e8:	4333      	orrs	r3, r6
 80128ea:	603b      	str	r3, [r7, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80128ec:	683b      	ldr	r3, [r7, #0]
 80128ee:	4013      	ands	r3, r2
 80128f0:	42b3      	cmp	r3, r6
 80128f2:	d000      	beq.n	80128f6 <HAL_RCC_ClockConfig+0x12a>
 80128f4:	e77d      	b.n	80127f2 <HAL_RCC_ClockConfig+0x26>
 80128f6:	e78b      	b.n	8012810 <HAL_RCC_ClockConfig+0x44>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80128f8:	6862      	ldr	r2, [r4, #4]
 80128fa:	4d32      	ldr	r5, [pc, #200]	; (80129c4 <HAL_RCC_ClockConfig+0x1f8>)
 80128fc:	2a01      	cmp	r2, #1
 80128fe:	d11b      	bne.n	8012938 <HAL_RCC_ClockConfig+0x16c>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8012900:	682b      	ldr	r3, [r5, #0]
 8012902:	039b      	lsls	r3, r3, #14
 8012904:	d400      	bmi.n	8012908 <HAL_RCC_ClockConfig+0x13c>
 8012906:	e774      	b.n	80127f2 <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8012908:	2103      	movs	r1, #3
 801290a:	686b      	ldr	r3, [r5, #4]
 801290c:	438b      	bics	r3, r1
 801290e:	4313      	orrs	r3, r2
 8012910:	606b      	str	r3, [r5, #4]
      tickstart = HAL_GetTick();
 8012912:	f7fe fdf5 	bl	8011500 <HAL_GetTick>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8012916:	6863      	ldr	r3, [r4, #4]
      tickstart = HAL_GetTick();
 8012918:	9001      	str	r0, [sp, #4]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 801291a:	2b01      	cmp	r3, #1
 801291c:	d11c      	bne.n	8012958 <HAL_RCC_ClockConfig+0x18c>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 801291e:	220c      	movs	r2, #12
 8012920:	686b      	ldr	r3, [r5, #4]
 8012922:	4013      	ands	r3, r2
 8012924:	2b04      	cmp	r3, #4
 8012926:	d0dc      	beq.n	80128e2 <HAL_RCC_ClockConfig+0x116>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012928:	f7fe fdea 	bl	8011500 <HAL_GetTick>
 801292c:	9b01      	ldr	r3, [sp, #4]
 801292e:	1ac0      	subs	r0, r0, r3
 8012930:	4b25      	ldr	r3, [pc, #148]	; (80129c8 <HAL_RCC_ClockConfig+0x1fc>)
 8012932:	4298      	cmp	r0, r3
 8012934:	d9f3      	bls.n	801291e <HAL_RCC_ClockConfig+0x152>
 8012936:	e791      	b.n	801285c <HAL_RCC_ClockConfig+0x90>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012938:	2a02      	cmp	r2, #2
 801293a:	d103      	bne.n	8012944 <HAL_RCC_ClockConfig+0x178>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 801293c:	682b      	ldr	r3, [r5, #0]
 801293e:	019b      	lsls	r3, r3, #6
 8012940:	d4e2      	bmi.n	8012908 <HAL_RCC_ClockConfig+0x13c>
 8012942:	e756      	b.n	80127f2 <HAL_RCC_ClockConfig+0x26>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 8012944:	2a03      	cmp	r2, #3
 8012946:	d103      	bne.n	8012950 <HAL_RCC_ClockConfig+0x184>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 8012948:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 801294a:	03db      	lsls	r3, r3, #15
 801294c:	d4dc      	bmi.n	8012908 <HAL_RCC_ClockConfig+0x13c>
 801294e:	e750      	b.n	80127f2 <HAL_RCC_ClockConfig+0x26>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8012950:	682b      	ldr	r3, [r5, #0]
 8012952:	079b      	lsls	r3, r3, #30
 8012954:	d4d8      	bmi.n	8012908 <HAL_RCC_ClockConfig+0x13c>
 8012956:	e74c      	b.n	80127f2 <HAL_RCC_ClockConfig+0x26>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012958:	2b02      	cmp	r3, #2
 801295a:	d10c      	bne.n	8012976 <HAL_RCC_ClockConfig+0x1aa>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 801295c:	220c      	movs	r2, #12
 801295e:	686b      	ldr	r3, [r5, #4]
 8012960:	4013      	ands	r3, r2
 8012962:	2b08      	cmp	r3, #8
 8012964:	d0bd      	beq.n	80128e2 <HAL_RCC_ClockConfig+0x116>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012966:	f7fe fdcb 	bl	8011500 <HAL_GetTick>
 801296a:	9b01      	ldr	r3, [sp, #4]
 801296c:	1ac0      	subs	r0, r0, r3
 801296e:	4b16      	ldr	r3, [pc, #88]	; (80129c8 <HAL_RCC_ClockConfig+0x1fc>)
 8012970:	4298      	cmp	r0, r3
 8012972:	d9f3      	bls.n	801295c <HAL_RCC_ClockConfig+0x190>
 8012974:	e772      	b.n	801285c <HAL_RCC_ClockConfig+0x90>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 8012976:	2b03      	cmp	r3, #3
 8012978:	d013      	beq.n	80129a2 <HAL_RCC_ClockConfig+0x1d6>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 801297a:	220c      	movs	r2, #12
 801297c:	686b      	ldr	r3, [r5, #4]
 801297e:	4213      	tst	r3, r2
 8012980:	d0af      	beq.n	80128e2 <HAL_RCC_ClockConfig+0x116>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012982:	f7fe fdbd 	bl	8011500 <HAL_GetTick>
 8012986:	9b01      	ldr	r3, [sp, #4]
 8012988:	1ac0      	subs	r0, r0, r3
 801298a:	4b0f      	ldr	r3, [pc, #60]	; (80129c8 <HAL_RCC_ClockConfig+0x1fc>)
 801298c:	4298      	cmp	r0, r3
 801298e:	d9f4      	bls.n	801297a <HAL_RCC_ClockConfig+0x1ae>
 8012990:	e764      	b.n	801285c <HAL_RCC_ClockConfig+0x90>
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012992:	f7fe fdb5 	bl	8011500 <HAL_GetTick>
 8012996:	9b01      	ldr	r3, [sp, #4]
 8012998:	1ac0      	subs	r0, r0, r3
 801299a:	4b0b      	ldr	r3, [pc, #44]	; (80129c8 <HAL_RCC_ClockConfig+0x1fc>)
 801299c:	4298      	cmp	r0, r3
 801299e:	d900      	bls.n	80129a2 <HAL_RCC_ClockConfig+0x1d6>
 80129a0:	e75c      	b.n	801285c <HAL_RCC_ClockConfig+0x90>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI48)
 80129a2:	220c      	movs	r2, #12
 80129a4:	686b      	ldr	r3, [r5, #4]
 80129a6:	4013      	ands	r3, r2
 80129a8:	4293      	cmp	r3, r2
 80129aa:	d1f2      	bne.n	8012992 <HAL_RCC_ClockConfig+0x1c6>
 80129ac:	e799      	b.n	80128e2 <HAL_RCC_ClockConfig+0x116>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 80129ae:	4a05      	ldr	r2, [pc, #20]	; (80129c4 <HAL_RCC_ClockConfig+0x1f8>)
 80129b0:	4906      	ldr	r1, [pc, #24]	; (80129cc <HAL_RCC_ClockConfig+0x200>)
 80129b2:	6853      	ldr	r3, [r2, #4]
 80129b4:	400b      	ands	r3, r1
 80129b6:	68e1      	ldr	r1, [r4, #12]
 80129b8:	430b      	orrs	r3, r1
 80129ba:	6053      	str	r3, [r2, #4]
 80129bc:	e72c      	b.n	8012818 <HAL_RCC_ClockConfig+0x4c>
 80129be:	46c0      	nop			; (mov r8, r8)
 80129c0:	40022000 	.word	0x40022000
 80129c4:	40021000 	.word	0x40021000
 80129c8:	00001388 	.word	0x00001388
 80129cc:	fffff8ff 	.word	0xfffff8ff

080129d0 <HAL_RCC_GetSysClockFreq>:
  *         
  *               
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80129d0:	b530      	push	{r4, r5, lr}
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9,
 80129d2:	4c1b      	ldr	r4, [pc, #108]	; (8012a40 <HAL_RCC_GetSysClockFreq+0x70>)
{
 80129d4:	b089      	sub	sp, #36	; 0x24
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9,
 80129d6:	2210      	movs	r2, #16
 80129d8:	0021      	movs	r1, r4
 80129da:	4668      	mov	r0, sp
 80129dc:	f001 fe3a 	bl	8014654 <memcpy>
                                         10, 11, 12, 13, 14, 15, 16, 16};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8,
 80129e0:	0021      	movs	r1, r4
 80129e2:	ad04      	add	r5, sp, #16
 80129e4:	2210      	movs	r2, #16
 80129e6:	3110      	adds	r1, #16
 80129e8:	0028      	movs	r0, r5
 80129ea:	f001 fe33 	bl	8014654 <memcpy>
  uint32_t sysclockfreq = 0;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 80129ee:	200c      	movs	r0, #12
  tmpreg = RCC->CFGR;
 80129f0:	4a14      	ldr	r2, [pc, #80]	; (8012a44 <HAL_RCC_GetSysClockFreq+0x74>)
 80129f2:	6853      	ldr	r3, [r2, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 80129f4:	4018      	ands	r0, r3
 80129f6:	2808      	cmp	r0, #8
 80129f8:	d009      	beq.n	8012a0e <HAL_RCC_GetSysClockFreq+0x3e>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 80129fa:	380c      	subs	r0, #12
 80129fc:	4243      	negs	r3, r0
 80129fe:	4158      	adcs	r0, r3
 8012a00:	4b11      	ldr	r3, [pc, #68]	; (8012a48 <HAL_RCC_GetSysClockFreq+0x78>)
 8012a02:	4240      	negs	r0, r0
 8012a04:	4018      	ands	r0, r3
 8012a06:	4b11      	ldr	r3, [pc, #68]	; (8012a4c <HAL_RCC_GetSysClockFreq+0x7c>)
 8012a08:	18c0      	adds	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8012a0a:	b009      	add	sp, #36	; 0x24
 8012a0c:	bd30      	pop	{r4, r5, pc}
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8012a0e:	200f      	movs	r0, #15
 8012a10:	466c      	mov	r4, sp
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8012a12:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8012a14:	0c99      	lsrs	r1, r3, #18
 8012a16:	4001      	ands	r1, r0
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8012a18:	4002      	ands	r2, r0
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8012a1a:	5c64      	ldrb	r4, [r4, r1]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8012a1c:	5ca9      	ldrb	r1, [r5, r2]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8012a1e:	22c0      	movs	r2, #192	; 0xc0
 8012a20:	2080      	movs	r0, #128	; 0x80
 8012a22:	0252      	lsls	r2, r2, #9
 8012a24:	4013      	ands	r3, r2
 8012a26:	0240      	lsls	r0, r0, #9
 8012a28:	4283      	cmp	r3, r0
 8012a2a:	d101      	bne.n	8012a30 <HAL_RCC_GetSysClockFreq+0x60>
        pllclk = (HSI_VALUE/prediv) * pllmul;
 8012a2c:	4807      	ldr	r0, [pc, #28]	; (8012a4c <HAL_RCC_GetSysClockFreq+0x7c>)
 8012a2e:	e002      	b.n	8012a36 <HAL_RCC_GetSysClockFreq+0x66>
      else if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSI48)
 8012a30:	4293      	cmp	r3, r2
 8012a32:	d1fb      	bne.n	8012a2c <HAL_RCC_GetSysClockFreq+0x5c>
        pllclk = (HSI48_VALUE/prediv) * pllmul;
 8012a34:	4806      	ldr	r0, [pc, #24]	; (8012a50 <HAL_RCC_GetSysClockFreq+0x80>)
        pllclk = (HSI_VALUE/prediv) * pllmul;
 8012a36:	f7ed fb9f 	bl	8000178 <__udivsi3>
 8012a3a:	4360      	muls	r0, r4
 8012a3c:	e7e5      	b.n	8012a0a <HAL_RCC_GetSysClockFreq+0x3a>
 8012a3e:	46c0      	nop			; (mov r8, r8)
 8012a40:	08018f98 	.word	0x08018f98
 8012a44:	40021000 	.word	0x40021000
 8012a48:	02625a00 	.word	0x02625a00
 8012a4c:	007a1200 	.word	0x007a1200
 8012a50:	02dc6c00 	.word	0x02dc6c00

08012a54 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8012a54:	b510      	push	{r4, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8012a56:	f7ff ffbb 	bl	80129d0 <HAL_RCC_GetSysClockFreq>
 8012a5a:	4b05      	ldr	r3, [pc, #20]	; (8012a70 <HAL_RCC_GetHCLKFreq+0x1c>)
 8012a5c:	4a05      	ldr	r2, [pc, #20]	; (8012a74 <HAL_RCC_GetHCLKFreq+0x20>)
 8012a5e:	685b      	ldr	r3, [r3, #4]
 8012a60:	061b      	lsls	r3, r3, #24
 8012a62:	0f1b      	lsrs	r3, r3, #28
 8012a64:	5cd3      	ldrb	r3, [r2, r3]
 8012a66:	40d8      	lsrs	r0, r3
 8012a68:	4b03      	ldr	r3, [pc, #12]	; (8012a78 <HAL_RCC_GetHCLKFreq+0x24>)
 8012a6a:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 8012a6c:	bd10      	pop	{r4, pc}
 8012a6e:	46c0      	nop			; (mov r8, r8)
 8012a70:	40021000 	.word	0x40021000
 8012a74:	0801c565 	.word	0x0801c565
 8012a78:	200000a0 	.word	0x200000a0

08012a7c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8012a7c:	b510      	push	{r4, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE)>> RCC_CFGR_PPRE_BITNUMBER]);
 8012a7e:	f7ff ffe9 	bl	8012a54 <HAL_RCC_GetHCLKFreq>
 8012a82:	4b04      	ldr	r3, [pc, #16]	; (8012a94 <HAL_RCC_GetPCLK1Freq+0x18>)
 8012a84:	4a04      	ldr	r2, [pc, #16]	; (8012a98 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8012a86:	685b      	ldr	r3, [r3, #4]
 8012a88:	055b      	lsls	r3, r3, #21
 8012a8a:	0f5b      	lsrs	r3, r3, #29
 8012a8c:	5cd3      	ldrb	r3, [r2, r3]
 8012a8e:	40d8      	lsrs	r0, r3
}    
 8012a90:	bd10      	pop	{r4, pc}
 8012a92:	46c0      	nop			; (mov r8, r8)
 8012a94:	40021000 	.word	0x40021000
 8012a98:	0801c565 	.word	0x0801c565

08012a9c <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval None
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8012a9c:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8012a9e:	6803      	ldr	r3, [r0, #0]
{
 8012aa0:	b085      	sub	sp, #20
 8012aa2:	0005      	movs	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8012aa4:	03db      	lsls	r3, r3, #15
 8012aa6:	d534      	bpl.n	8012b12 <HAL_RCCEx_PeriphCLKConfig+0x76>
  {
    /* Reset the Backup domain only if the RTC Clock source selction is modified */ 
    if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8012aa8:	4c3f      	ldr	r4, [pc, #252]	; (8012ba8 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8012aaa:	6842      	ldr	r2, [r0, #4]
 8012aac:	6a23      	ldr	r3, [r4, #32]
 8012aae:	4053      	eors	r3, r2
 8012ab0:	22c0      	movs	r2, #192	; 0xc0
 8012ab2:	0092      	lsls	r2, r2, #2
 8012ab4:	4213      	tst	r3, r2
 8012ab6:	d02c      	beq.n	8012b12 <HAL_RCCEx_PeriphCLKConfig+0x76>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 8012ab8:	2180      	movs	r1, #128	; 0x80
      
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8012aba:	2780      	movs	r7, #128	; 0x80
      __HAL_RCC_PWR_CLK_ENABLE();
 8012abc:	69e2      	ldr	r2, [r4, #28]
 8012abe:	0549      	lsls	r1, r1, #21
 8012ac0:	430a      	orrs	r2, r1
 8012ac2:	61e2      	str	r2, [r4, #28]
 8012ac4:	69e3      	ldr	r3, [r4, #28]
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8012ac6:	4e39      	ldr	r6, [pc, #228]	; (8012bac <HAL_RCCEx_PeriphCLKConfig+0x110>)
      __HAL_RCC_PWR_CLK_ENABLE();
 8012ac8:	400b      	ands	r3, r1
 8012aca:	9303      	str	r3, [sp, #12]
 8012acc:	9b03      	ldr	r3, [sp, #12]
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8012ace:	6833      	ldr	r3, [r6, #0]
 8012ad0:	007f      	lsls	r7, r7, #1
 8012ad2:	433b      	orrs	r3, r7
 8012ad4:	6033      	str	r3, [r6, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8012ad6:	f7fe fd13 	bl	8011500 <HAL_GetTick>
 8012ada:	9001      	str	r0, [sp, #4]
      
      while((PWR->CR & PWR_CR_DBP) == RESET)
 8012adc:	6833      	ldr	r3, [r6, #0]
 8012ade:	423b      	tst	r3, r7
 8012ae0:	d04b      	beq.n	8012b7a <HAL_RCCEx_PeriphCLKConfig+0xde>
      }
      
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8012ae2:	2380      	movs	r3, #128	; 0x80
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8012ae4:	6a22      	ldr	r2, [r4, #32]
      __HAL_RCC_BACKUPRESET_FORCE();
 8012ae6:	6a26      	ldr	r6, [r4, #32]
 8012ae8:	025b      	lsls	r3, r3, #9
 8012aea:	4333      	orrs	r3, r6
 8012aec:	6223      	str	r3, [r4, #32]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8012aee:	6a23      	ldr	r3, [r4, #32]
 8012af0:	4e2f      	ldr	r6, [pc, #188]	; (8012bb0 <HAL_RCCEx_PeriphCLKConfig+0x114>)
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8012af2:	0010      	movs	r0, r2
      __HAL_RCC_BACKUPRESET_RELEASE();
 8012af4:	4033      	ands	r3, r6
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY))
 8012af6:	2602      	movs	r6, #2
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8012af8:	492e      	ldr	r1, [pc, #184]	; (8012bb4 <HAL_RCCEx_PeriphCLKConfig+0x118>)
      __HAL_RCC_BACKUPRESET_RELEASE();
 8012afa:	6223      	str	r3, [r4, #32]
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8012afc:	4008      	ands	r0, r1
      RCC->BDCR = temp_reg;
 8012afe:	6220      	str	r0, [r4, #32]
 8012b00:	9101      	str	r1, [sp, #4]
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY))
 8012b02:	4232      	tst	r2, r6
 8012b04:	d142      	bne.n	8012b8c <HAL_RCCEx_PeriphCLKConfig+0xf0>
          {
            return HAL_TIMEOUT;
          }      
        }  
      }
      __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 8012b06:	9a01      	ldr	r2, [sp, #4]
 8012b08:	6a23      	ldr	r3, [r4, #32]
 8012b0a:	4013      	ands	r3, r2
 8012b0c:	686a      	ldr	r2, [r5, #4]
 8012b0e:	4313      	orrs	r3, r2
 8012b10:	6223      	str	r3, [r4, #32]
    }
  }
  
  /*------------------------------- USART1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8012b12:	682b      	ldr	r3, [r5, #0]
 8012b14:	07db      	lsls	r3, r3, #31
 8012b16:	d506      	bpl.n	8012b26 <HAL_RCCEx_PeriphCLKConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8012b18:	2103      	movs	r1, #3
 8012b1a:	4a23      	ldr	r2, [pc, #140]	; (8012ba8 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8012b1c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8012b1e:	438b      	bics	r3, r1
 8012b20:	68a9      	ldr	r1, [r5, #8]
 8012b22:	430b      	orrs	r3, r1
 8012b24:	6313      	str	r3, [r2, #48]	; 0x30
  }
  
#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 || defined(STM32F091xC) || defined(STM32F098xx)
  /*----------------------------- USART2 Configuration --------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8012b26:	682b      	ldr	r3, [r5, #0]
 8012b28:	079b      	lsls	r3, r3, #30
 8012b2a:	d506      	bpl.n	8012b3a <HAL_RCCEx_PeriphCLKConfig+0x9e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8012b2c:	4a1e      	ldr	r2, [pc, #120]	; (8012ba8 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8012b2e:	4922      	ldr	r1, [pc, #136]	; (8012bb8 <HAL_RCCEx_PeriphCLKConfig+0x11c>)
 8012b30:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8012b32:	400b      	ands	r3, r1
 8012b34:	68e9      	ldr	r1, [r5, #12]
 8012b36:	430b      	orrs	r3, r1
 8012b38:	6313      	str	r3, [r2, #48]	; 0x30
#endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
       /* STM32F091xC || STM32F098xx */

#if defined(STM32F091xC) || defined(STM32F098xx)
  /*----------------------------- USART3 Configuration --------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8012b3a:	682b      	ldr	r3, [r5, #0]
 8012b3c:	035b      	lsls	r3, r3, #13
 8012b3e:	d506      	bpl.n	8012b4e <HAL_RCCEx_PeriphCLKConfig+0xb2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    
    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8012b40:	4a19      	ldr	r2, [pc, #100]	; (8012ba8 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8012b42:	491e      	ldr	r1, [pc, #120]	; (8012bbc <HAL_RCCEx_PeriphCLKConfig+0x120>)
 8012b44:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8012b46:	400b      	ands	r3, r1
 8012b48:	6929      	ldr	r1, [r5, #16]
 8012b4a:	430b      	orrs	r3, r1
 8012b4c:	6313      	str	r3, [r2, #48]	; 0x30
  }
#endif /* STM32F091xC || STM32F098xx */  

  /*------------------------------ I2C1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8012b4e:	682b      	ldr	r3, [r5, #0]
 8012b50:	069b      	lsls	r3, r3, #26
 8012b52:	d506      	bpl.n	8012b62 <HAL_RCCEx_PeriphCLKConfig+0xc6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8012b54:	2110      	movs	r1, #16
 8012b56:	4a14      	ldr	r2, [pc, #80]	; (8012ba8 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8012b58:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8012b5a:	438b      	bics	r3, r1
 8012b5c:	6969      	ldr	r1, [r5, #20]
 8012b5e:	430b      	orrs	r3, r1
 8012b60:	6313      	str	r3, [r2, #48]	; 0x30
#if defined(STM32F042x6) || defined(STM32F048xx)\
 || defined(STM32F051x8) || defined(STM32F058xx)\
 || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 || defined(STM32F091xC) || defined(STM32F098xx)
  /*------------------------------ CEC clock Configuration -------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8012b62:	682b      	ldr	r3, [r5, #0]
#endif /* STM32F042x6 || STM32F048xx ||                */
       /* STM32F051x8 || STM32F058xx ||                */
       /* STM32F071xB || STM32F072xB || STM32F078xx || */
       /* STM32F091xC || STM32F098xx */
  
  return HAL_OK;
 8012b64:	2000      	movs	r0, #0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8012b66:	055b      	lsls	r3, r3, #21
 8012b68:	d50e      	bpl.n	8012b88 <HAL_RCCEx_PeriphCLKConfig+0xec>
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8012b6a:	2140      	movs	r1, #64	; 0x40
 8012b6c:	4a0e      	ldr	r2, [pc, #56]	; (8012ba8 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8012b6e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8012b70:	438b      	bics	r3, r1
 8012b72:	69a9      	ldr	r1, [r5, #24]
 8012b74:	430b      	orrs	r3, r1
 8012b76:	6313      	str	r3, [r2, #48]	; 0x30
 8012b78:	e006      	b.n	8012b88 <HAL_RCCEx_PeriphCLKConfig+0xec>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8012b7a:	f7fe fcc1 	bl	8011500 <HAL_GetTick>
 8012b7e:	9b01      	ldr	r3, [sp, #4]
 8012b80:	1ac0      	subs	r0, r0, r3
 8012b82:	2864      	cmp	r0, #100	; 0x64
 8012b84:	d9aa      	bls.n	8012adc <HAL_RCCEx_PeriphCLKConfig+0x40>
          return HAL_TIMEOUT;
 8012b86:	2003      	movs	r0, #3
}
 8012b88:	b005      	add	sp, #20
 8012b8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tickstart = HAL_GetTick();
 8012b8c:	f7fe fcb8 	bl	8011500 <HAL_GetTick>
 8012b90:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8012b92:	6a23      	ldr	r3, [r4, #32]
 8012b94:	4233      	tst	r3, r6
 8012b96:	d1b6      	bne.n	8012b06 <HAL_RCCEx_PeriphCLKConfig+0x6a>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012b98:	f7fe fcb2 	bl	8011500 <HAL_GetTick>
 8012b9c:	4b08      	ldr	r3, [pc, #32]	; (8012bc0 <HAL_RCCEx_PeriphCLKConfig+0x124>)
 8012b9e:	1bc0      	subs	r0, r0, r7
 8012ba0:	4298      	cmp	r0, r3
 8012ba2:	d9f6      	bls.n	8012b92 <HAL_RCCEx_PeriphCLKConfig+0xf6>
 8012ba4:	e7ef      	b.n	8012b86 <HAL_RCCEx_PeriphCLKConfig+0xea>
 8012ba6:	46c0      	nop			; (mov r8, r8)
 8012ba8:	40021000 	.word	0x40021000
 8012bac:	40007000 	.word	0x40007000
 8012bb0:	fffeffff 	.word	0xfffeffff
 8012bb4:	fffffcff 	.word	0xfffffcff
 8012bb8:	fffcffff 	.word	0xfffcffff
 8012bbc:	fff3ffff 	.word	0xfff3ffff
 8012bc0:	00001388 	.word	0x00001388

08012bc4 <HAL_RTC_MspInit>:
__weak void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_RTC_MspInit could be implemented in the user file
   */ 
}
 8012bc4:	4770      	bx	lr

08012bc6 <HAL_RTC_WaitForSynchro>:
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
  uint32_t tickstart = 0;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8012bc6:	21a0      	movs	r1, #160	; 0xa0
{
 8012bc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8012bca:	6802      	ldr	r2, [r0, #0]
{
 8012bcc:	0004      	movs	r4, r0
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8012bce:	68d3      	ldr	r3, [r2, #12]
  tickstart = HAL_GetTick();

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
  {
    if((HAL_GetTick()-tickstart) > RTC_TIMEOUT_VALUE)
 8012bd0:	27fa      	movs	r7, #250	; 0xfa
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8012bd2:	438b      	bics	r3, r1
 8012bd4:	60d3      	str	r3, [r2, #12]
  tickstart = HAL_GetTick();
 8012bd6:	f7fe fc93 	bl	8011500 <HAL_GetTick>
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8012bda:	2520      	movs	r5, #32
  tickstart = HAL_GetTick();
 8012bdc:	0006      	movs	r6, r0
    if((HAL_GetTick()-tickstart) > RTC_TIMEOUT_VALUE)
 8012bde:	00bf      	lsls	r7, r7, #2
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8012be0:	6823      	ldr	r3, [r4, #0]
 8012be2:	68db      	ldr	r3, [r3, #12]
 8012be4:	422b      	tst	r3, r5
 8012be6:	d001      	beq.n	8012bec <HAL_RTC_WaitForSynchro+0x26>
    {       
      return HAL_TIMEOUT;
    } 
  }

  return HAL_OK;
 8012be8:	2000      	movs	r0, #0
}
 8012bea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((HAL_GetTick()-tickstart) > RTC_TIMEOUT_VALUE)
 8012bec:	f7fe fc88 	bl	8011500 <HAL_GetTick>
 8012bf0:	1b80      	subs	r0, r0, r6
 8012bf2:	42b8      	cmp	r0, r7
 8012bf4:	d9f4      	bls.n	8012be0 <HAL_RTC_WaitForSynchro+0x1a>
      return HAL_TIMEOUT;
 8012bf6:	2003      	movs	r0, #3
 8012bf8:	e7f7      	b.n	8012bea <HAL_RTC_WaitForSynchro+0x24>

08012bfa <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8012bfa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart = 0;
  
  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8012bfc:	2440      	movs	r4, #64	; 0x40
 8012bfe:	6803      	ldr	r3, [r0, #0]
{
 8012c00:	0005      	movs	r5, r0
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8012c02:	68da      	ldr	r2, [r3, #12]
 8012c04:	4222      	tst	r2, r4
 8012c06:	d001      	beq.n	8012c0c <RTC_EnterInitMode+0x12>
        return HAL_TIMEOUT;
      } 
    }
  }
  
  return HAL_OK;  
 8012c08:	2000      	movs	r0, #0
}
 8012c0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8012c0c:	2201      	movs	r2, #1
 8012c0e:	4252      	negs	r2, r2
 8012c10:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8012c12:	f7fe fc75 	bl	8011500 <HAL_GetTick>
      if((HAL_GetTick()-tickstart) > RTC_TIMEOUT_VALUE)
 8012c16:	27fa      	movs	r7, #250	; 0xfa
    tickstart = HAL_GetTick();
 8012c18:	0006      	movs	r6, r0
      if((HAL_GetTick()-tickstart) > RTC_TIMEOUT_VALUE)
 8012c1a:	00bf      	lsls	r7, r7, #2
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8012c1c:	682b      	ldr	r3, [r5, #0]
 8012c1e:	68db      	ldr	r3, [r3, #12]
 8012c20:	4223      	tst	r3, r4
 8012c22:	d1f1      	bne.n	8012c08 <RTC_EnterInitMode+0xe>
      if((HAL_GetTick()-tickstart) > RTC_TIMEOUT_VALUE)
 8012c24:	f7fe fc6c 	bl	8011500 <HAL_GetTick>
 8012c28:	1b80      	subs	r0, r0, r6
 8012c2a:	42b8      	cmp	r0, r7
 8012c2c:	d9f6      	bls.n	8012c1c <RTC_EnterInitMode+0x22>
        return HAL_TIMEOUT;
 8012c2e:	2003      	movs	r0, #3
 8012c30:	e7eb      	b.n	8012c0a <RTC_EnterInitMode+0x10>
	...

08012c34 <HAL_RTC_Init>:
{
 8012c34:	b570      	push	{r4, r5, r6, lr}
 8012c36:	0004      	movs	r4, r0
     return HAL_ERROR;
 8012c38:	2001      	movs	r0, #1
  if(hrtc == NULL)
 8012c3a:	2c00      	cmp	r4, #0
 8012c3c:	d01a      	beq.n	8012c74 <HAL_RTC_Init+0x40>
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8012c3e:	7f63      	ldrb	r3, [r4, #29]
 8012c40:	b2db      	uxtb	r3, r3
 8012c42:	2b00      	cmp	r3, #0
 8012c44:	d103      	bne.n	8012c4e <HAL_RTC_Init+0x1a>
    hrtc->Lock = HAL_UNLOCKED;
 8012c46:	7723      	strb	r3, [r4, #28]
    HAL_RTC_MspInit(hrtc);
 8012c48:	0020      	movs	r0, r4
 8012c4a:	f7ff ffbb 	bl	8012bc4 <HAL_RTC_MspInit>
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8012c4e:	2302      	movs	r3, #2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012c50:	22ca      	movs	r2, #202	; 0xca
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8012c52:	7763      	strb	r3, [r4, #29]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012c54:	6823      	ldr	r3, [r4, #0]
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012c56:	0020      	movs	r0, r4
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012c58:	625a      	str	r2, [r3, #36]	; 0x24
 8012c5a:	6823      	ldr	r3, [r4, #0]
 8012c5c:	3a77      	subs	r2, #119	; 0x77
 8012c5e:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012c60:	f7ff ffcb 	bl	8012bfa <RTC_EnterInitMode>
 8012c64:	6823      	ldr	r3, [r4, #0]
 8012c66:	2800      	cmp	r0, #0
 8012c68:	d005      	beq.n	8012c76 <HAL_RTC_Init+0x42>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8012c6a:	22ff      	movs	r2, #255	; 0xff
 8012c6c:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8012c6e:	2304      	movs	r3, #4
    return HAL_ERROR;
 8012c70:	2001      	movs	r0, #1
    hrtc->State = HAL_RTC_STATE_ERROR;
 8012c72:	7763      	strb	r3, [r4, #29]
}
 8012c74:	bd70      	pop	{r4, r5, r6, pc}
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8012c76:	689a      	ldr	r2, [r3, #8]
 8012c78:	4914      	ldr	r1, [pc, #80]	; (8012ccc <HAL_RTC_Init+0x98>)
 8012c7a:	400a      	ands	r2, r1
 8012c7c:	609a      	str	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8012c7e:	6925      	ldr	r5, [r4, #16]
 8012c80:	6863      	ldr	r3, [r4, #4]
 8012c82:	6822      	ldr	r2, [r4, #0]
 8012c84:	432b      	orrs	r3, r5
 8012c86:	6965      	ldr	r5, [r4, #20]
 8012c88:	6891      	ldr	r1, [r2, #8]
 8012c8a:	432b      	orrs	r3, r5
 8012c8c:	430b      	orrs	r3, r1
 8012c8e:	6093      	str	r3, [r2, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8012c90:	6823      	ldr	r3, [r4, #0]
 8012c92:	68e2      	ldr	r2, [r4, #12]
 8012c94:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16);
 8012c96:	6822      	ldr	r2, [r4, #0]
 8012c98:	68a3      	ldr	r3, [r4, #8]
 8012c9a:	6911      	ldr	r1, [r2, #16]
 8012c9c:	041b      	lsls	r3, r3, #16
 8012c9e:	430b      	orrs	r3, r1
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
 8012ca0:	2180      	movs	r1, #128	; 0x80
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16);
 8012ca2:	6113      	str	r3, [r2, #16]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
 8012ca4:	6822      	ldr	r2, [r4, #0]
 8012ca6:	68d3      	ldr	r3, [r2, #12]
 8012ca8:	438b      	bics	r3, r1
 8012caa:	60d3      	str	r3, [r2, #12]
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8012cac:	6822      	ldr	r2, [r4, #0]
 8012cae:	4908      	ldr	r1, [pc, #32]	; (8012cd0 <HAL_RTC_Init+0x9c>)
 8012cb0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8012cb2:	400b      	ands	r3, r1
 8012cb4:	6413      	str	r3, [r2, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
 8012cb6:	6822      	ldr	r2, [r4, #0]
 8012cb8:	69a1      	ldr	r1, [r4, #24]
 8012cba:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8012cbc:	430b      	orrs	r3, r1
 8012cbe:	6413      	str	r3, [r2, #64]	; 0x40
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8012cc0:	22ff      	movs	r2, #255	; 0xff
 8012cc2:	6823      	ldr	r3, [r4, #0]
 8012cc4:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8012cc6:	2301      	movs	r3, #1
 8012cc8:	7763      	strb	r3, [r4, #29]
    return HAL_OK;
 8012cca:	e7d3      	b.n	8012c74 <HAL_RTC_Init+0x40>
 8012ccc:	ff8fffbf 	.word	0xff8fffbf
 8012cd0:	fffbffff 	.word	0xfffbffff

08012cd4 <RTC_ByteToBcd2>:
  * @param  Value: Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;
 8012cd4:	2300      	movs	r3, #0
  
  while(Value >= 10)
 8012cd6:	2809      	cmp	r0, #9
 8012cd8:	d803      	bhi.n	8012ce2 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
    Value -= 10;
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
 8012cda:	011b      	lsls	r3, r3, #4
 8012cdc:	4318      	orrs	r0, r3
 8012cde:	b2c0      	uxtb	r0, r0
}
 8012ce0:	4770      	bx	lr
    Value -= 10;
 8012ce2:	380a      	subs	r0, #10
    bcdhigh++;
 8012ce4:	3301      	adds	r3, #1
    Value -= 10;
 8012ce6:	b2c0      	uxtb	r0, r0
 8012ce8:	e7f5      	b.n	8012cd6 <RTC_ByteToBcd2+0x2>
	...

08012cec <HAL_RTC_SetTime>:
{
 8012cec:	2302      	movs	r3, #2
 8012cee:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8012cf0:	000d      	movs	r5, r1
  __HAL_LOCK(hrtc);
 8012cf2:	7f01      	ldrb	r1, [r0, #28]
{
 8012cf4:	0004      	movs	r4, r0
  __HAL_LOCK(hrtc);
 8012cf6:	001f      	movs	r7, r3
 8012cf8:	2901      	cmp	r1, #1
 8012cfa:	d033      	beq.n	8012d64 <HAL_RTC_SetTime+0x78>
 8012cfc:	2101      	movs	r1, #1
  hrtc->State = HAL_RTC_STATE_BUSY;
 8012cfe:	7743      	strb	r3, [r0, #29]
 8012d00:	6803      	ldr	r3, [r0, #0]
  __HAL_LOCK(hrtc);
 8012d02:	7701      	strb	r1, [r0, #28]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8012d04:	689b      	ldr	r3, [r3, #8]
 8012d06:	313f      	adds	r1, #63	; 0x3f
 8012d08:	7828      	ldrb	r0, [r5, #0]
 8012d0a:	786e      	ldrb	r6, [r5, #1]
 8012d0c:	78af      	ldrb	r7, [r5, #2]
 8012d0e:	400b      	ands	r3, r1
  if(Format == RTC_FORMAT_BIN)
 8012d10:	2a00      	cmp	r2, #0
 8012d12:	d129      	bne.n	8012d68 <HAL_RTC_SetTime+0x7c>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8012d14:	2b00      	cmp	r3, #0
 8012d16:	d100      	bne.n	8012d1a <HAL_RTC_SetTime+0x2e>
      sTime->TimeFormat = 0x00;
 8012d18:	722b      	strb	r3, [r5, #8]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8012d1a:	f7ff ffdb 	bl	8012cd4 <RTC_ByteToBcd2>
 8012d1e:	9001      	str	r0, [sp, #4]
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 8012d20:	0030      	movs	r0, r6
 8012d22:	f7ff ffd7 	bl	8012cd4 <RTC_ByteToBcd2>
 8012d26:	0006      	movs	r6, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8012d28:	0038      	movs	r0, r7
 8012d2a:	f7ff ffd3 	bl	8012cd4 <RTC_ByteToBcd2>
                        (((uint32_t)sTime->TimeFormat) << 16));  
 8012d2e:	7a2f      	ldrb	r7, [r5, #8]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8012d30:	9b01      	ldr	r3, [sp, #4]
                        (((uint32_t)sTime->TimeFormat) << 16));  
 8012d32:	043f      	lsls	r7, r7, #16
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8012d34:	4307      	orrs	r7, r0
 8012d36:	0418      	lsls	r0, r3, #16
 8012d38:	4307      	orrs	r7, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 8012d3a:	0236      	lsls	r6, r6, #8
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012d3c:	22ca      	movs	r2, #202	; 0xca
 8012d3e:	6823      	ldr	r3, [r4, #0]
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012d40:	0020      	movs	r0, r4
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012d42:	625a      	str	r2, [r3, #36]	; 0x24
 8012d44:	6823      	ldr	r3, [r4, #0]
 8012d46:	3a77      	subs	r2, #119	; 0x77
 8012d48:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012d4a:	f7ff ff56 	bl	8012bfa <RTC_EnterInitMode>
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 8012d4e:	433e      	orrs	r6, r7
 8012d50:	6823      	ldr	r3, [r4, #0]
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012d52:	1e07      	subs	r7, r0, #0
 8012d54:	d012      	beq.n	8012d7c <HAL_RTC_SetTime+0x90>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8012d56:	22ff      	movs	r2, #255	; 0xff
 8012d58:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8012d5a:	2304      	movs	r3, #4
 8012d5c:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8012d5e:	2300      	movs	r3, #0
 8012d60:	7723      	strb	r3, [r4, #28]
        return HAL_ERROR;
 8012d62:	2701      	movs	r7, #1
}
 8012d64:	0038      	movs	r0, r7
 8012d66:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8012d68:	2b00      	cmp	r3, #0
 8012d6a:	d100      	bne.n	8012d6e <HAL_RTC_SetTime+0x82>
      sTime->TimeFormat = 0x00;
 8012d6c:	722b      	strb	r3, [r5, #8]
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 8012d6e:	0400      	lsls	r0, r0, #16
              ((uint32_t)(sTime->Minutes) << 8) | \
 8012d70:	0236      	lsls	r6, r6, #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 8012d72:	4306      	orrs	r6, r0
              ((uint32_t)(sTime->Minutes) << 8) | \
 8012d74:	4337      	orrs	r7, r6
              ((uint32_t)(sTime->TimeFormat) << 16));   
 8012d76:	7a2e      	ldrb	r6, [r5, #8]
 8012d78:	0436      	lsls	r6, r6, #16
 8012d7a:	e7df      	b.n	8012d3c <HAL_RTC_SetTime+0x50>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8012d7c:	4815      	ldr	r0, [pc, #84]	; (8012dd4 <HAL_RTC_SetTime+0xe8>)
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BCK);
 8012d7e:	4916      	ldr	r1, [pc, #88]	; (8012dd8 <HAL_RTC_SetTime+0xec>)
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8012d80:	4006      	ands	r6, r0
 8012d82:	601e      	str	r6, [r3, #0]
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BCK);
 8012d84:	6822      	ldr	r2, [r4, #0]
 8012d86:	6893      	ldr	r3, [r2, #8]
 8012d88:	400b      	ands	r3, r1
 8012d8a:	6093      	str	r3, [r2, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8012d8c:	6822      	ldr	r2, [r4, #0]
 8012d8e:	68eb      	ldr	r3, [r5, #12]
 8012d90:	6928      	ldr	r0, [r5, #16]
 8012d92:	6891      	ldr	r1, [r2, #8]
 8012d94:	4303      	orrs	r3, r0
 8012d96:	430b      	orrs	r3, r1
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8012d98:	2180      	movs	r1, #128	; 0x80
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8012d9a:	6093      	str	r3, [r2, #8]
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8012d9c:	6822      	ldr	r2, [r4, #0]
 8012d9e:	68d3      	ldr	r3, [r2, #12]
 8012da0:	438b      	bics	r3, r1
 8012da2:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8012da4:	6823      	ldr	r3, [r4, #0]
 8012da6:	689b      	ldr	r3, [r3, #8]
 8012da8:	069b      	lsls	r3, r3, #26
 8012daa:	d40b      	bmi.n	8012dc4 <HAL_RTC_SetTime+0xd8>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8012dac:	0020      	movs	r0, r4
 8012dae:	f7ff ff0a 	bl	8012bc6 <HAL_RTC_WaitForSynchro>
 8012db2:	2800      	cmp	r0, #0
 8012db4:	d006      	beq.n	8012dc4 <HAL_RTC_SetTime+0xd8>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8012db6:	22ff      	movs	r2, #255	; 0xff
 8012db8:	6823      	ldr	r3, [r4, #0]
 8012dba:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8012dbc:	2304      	movs	r3, #4
        __HAL_UNLOCK(hrtc);
 8012dbe:	7727      	strb	r7, [r4, #28]
        hrtc->State = HAL_RTC_STATE_ERROR;
 8012dc0:	7763      	strb	r3, [r4, #29]
 8012dc2:	e7ce      	b.n	8012d62 <HAL_RTC_SetTime+0x76>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8012dc4:	22ff      	movs	r2, #255	; 0xff
 8012dc6:	6823      	ldr	r3, [r4, #0]
 8012dc8:	625a      	str	r2, [r3, #36]	; 0x24
   hrtc->State = HAL_RTC_STATE_READY;
 8012dca:	2301      	movs	r3, #1
 8012dcc:	7763      	strb	r3, [r4, #29]
   __HAL_UNLOCK(hrtc); 
 8012dce:	2300      	movs	r3, #0
 8012dd0:	7723      	strb	r3, [r4, #28]
   return HAL_OK;
 8012dd2:	e7c7      	b.n	8012d64 <HAL_RTC_SetTime+0x78>
 8012dd4:	007f7f7f 	.word	0x007f7f7f
 8012dd8:	fffbffff 	.word	0xfffbffff

08012ddc <HAL_RTC_SetDate>:
{
 8012ddc:	2302      	movs	r3, #2
 8012dde:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8012de0:	000d      	movs	r5, r1
 __HAL_LOCK(hrtc);
 8012de2:	7f01      	ldrb	r1, [r0, #28]
{
 8012de4:	0004      	movs	r4, r0
 __HAL_LOCK(hrtc);
 8012de6:	001e      	movs	r6, r3
 8012de8:	2901      	cmp	r1, #1
 8012dea:	d032      	beq.n	8012e52 <HAL_RTC_SetDate+0x76>
 8012dec:	2101      	movs	r1, #1
  hrtc->State = HAL_RTC_STATE_BUSY; 
 8012dee:	7743      	strb	r3, [r0, #29]
 __HAL_LOCK(hrtc);
 8012df0:	7701      	strb	r1, [r0, #28]
 8012df2:	786b      	ldrb	r3, [r5, #1]
 8012df4:	78e8      	ldrb	r0, [r5, #3]
 8012df6:	78af      	ldrb	r7, [r5, #2]
 8012df8:	782e      	ldrb	r6, [r5, #0]
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10) == 0x10))
 8012dfa:	2a00      	cmp	r2, #0
 8012dfc:	d14b      	bne.n	8012e96 <HAL_RTC_SetDate+0xba>
 8012dfe:	3210      	adds	r2, #16
 8012e00:	4213      	tst	r3, r2
 8012e02:	d002      	beq.n	8012e0a <HAL_RTC_SetDate+0x2e>
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10)) + (uint8_t)0x0A);
 8012e04:	4393      	bics	r3, r2
 8012e06:	330a      	adds	r3, #10
 8012e08:	706b      	strb	r3, [r5, #1]
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8012e0a:	f7ff ff63 	bl	8012cd4 <RTC_ByteToBcd2>
 8012e0e:	9001      	str	r0, [sp, #4]
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 8012e10:	7868      	ldrb	r0, [r5, #1]
 8012e12:	f7ff ff5f 	bl	8012cd4 <RTC_ByteToBcd2>
 8012e16:	0005      	movs	r5, r0
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8012e18:	0038      	movs	r0, r7
 8012e1a:	f7ff ff5b 	bl	8012cd4 <RTC_ByteToBcd2>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8012e1e:	9b01      	ldr	r3, [sp, #4]
                 ((uint32_t)sDate->WeekDay << 13));   
 8012e20:	0376      	lsls	r6, r6, #13
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8012e22:	4330      	orrs	r0, r6
 8012e24:	041e      	lsls	r6, r3, #16
 8012e26:	4306      	orrs	r6, r0
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 8012e28:	022d      	lsls	r5, r5, #8
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8012e2a:	4335      	orrs	r5, r6
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012e2c:	22ca      	movs	r2, #202	; 0xca
 8012e2e:	6823      	ldr	r3, [r4, #0]
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012e30:	0020      	movs	r0, r4
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8012e32:	625a      	str	r2, [r3, #36]	; 0x24
 8012e34:	6823      	ldr	r3, [r4, #0]
 8012e36:	3a77      	subs	r2, #119	; 0x77
 8012e38:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8012e3a:	f7ff fede 	bl	8012bfa <RTC_EnterInitMode>
 8012e3e:	6823      	ldr	r3, [r4, #0]
 8012e40:	1e06      	subs	r6, r0, #0
 8012e42:	d008      	beq.n	8012e56 <HAL_RTC_SetDate+0x7a>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8012e44:	22ff      	movs	r2, #255	; 0xff
 8012e46:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8012e48:	2304      	movs	r3, #4
 8012e4a:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8012e4c:	2300      	movs	r3, #0
 8012e4e:	7723      	strb	r3, [r4, #28]
        return HAL_ERROR;
 8012e50:	2601      	movs	r6, #1
}
 8012e52:	0030      	movs	r0, r6
 8012e54:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8012e56:	2180      	movs	r1, #128	; 0x80
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8012e58:	4f12      	ldr	r7, [pc, #72]	; (8012ea4 <HAL_RTC_SetDate+0xc8>)
 8012e5a:	403d      	ands	r5, r7
 8012e5c:	605d      	str	r5, [r3, #4]
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8012e5e:	6822      	ldr	r2, [r4, #0]
 8012e60:	68d3      	ldr	r3, [r2, #12]
 8012e62:	438b      	bics	r3, r1
 8012e64:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8012e66:	6823      	ldr	r3, [r4, #0]
 8012e68:	689b      	ldr	r3, [r3, #8]
 8012e6a:	069b      	lsls	r3, r3, #26
 8012e6c:	d40b      	bmi.n	8012e86 <HAL_RTC_SetDate+0xaa>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8012e6e:	0020      	movs	r0, r4
 8012e70:	f7ff fea9 	bl	8012bc6 <HAL_RTC_WaitForSynchro>
 8012e74:	2800      	cmp	r0, #0
 8012e76:	d006      	beq.n	8012e86 <HAL_RTC_SetDate+0xaa>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8012e78:	22ff      	movs	r2, #255	; 0xff
 8012e7a:	6823      	ldr	r3, [r4, #0]
 8012e7c:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8012e7e:	2304      	movs	r3, #4
        __HAL_UNLOCK(hrtc);
 8012e80:	7726      	strb	r6, [r4, #28]
        hrtc->State = HAL_RTC_STATE_ERROR;
 8012e82:	7763      	strb	r3, [r4, #29]
 8012e84:	e7e4      	b.n	8012e50 <HAL_RTC_SetDate+0x74>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8012e86:	22ff      	movs	r2, #255	; 0xff
 8012e88:	6823      	ldr	r3, [r4, #0]
 8012e8a:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY ;
 8012e8c:	2301      	movs	r3, #1
 8012e8e:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8012e90:	2300      	movs	r3, #0
 8012e92:	7723      	strb	r3, [r4, #28]
    return HAL_OK;    
 8012e94:	e7dd      	b.n	8012e52 <HAL_RTC_SetDate+0x76>
    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 8012e96:	0400      	lsls	r0, r0, #16
                  (((uint32_t)sDate->Month) << 8) | \
 8012e98:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 8012e9a:	4303      	orrs	r3, r0
                  (((uint32_t)sDate->Month) << 8) | \
 8012e9c:	431f      	orrs	r7, r3
                  (((uint32_t)sDate->WeekDay) << 13));  
 8012e9e:	0375      	lsls	r5, r6, #13
    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 8012ea0:	433d      	orrs	r5, r7
 8012ea2:	e7c3      	b.n	8012e2c <HAL_RTC_SetDate+0x50>
 8012ea4:	00ffff3f 	.word	0x00ffff3f

08012ea8 <RTC_Bcd2ToByte>:
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8012ea8:	230a      	movs	r3, #10
 8012eaa:	0902      	lsrs	r2, r0, #4
 8012eac:	4353      	muls	r3, r2
  return (tmp + (Value & (uint8_t)0x0F));
 8012eae:	220f      	movs	r2, #15
 8012eb0:	4010      	ands	r0, r2
 8012eb2:	1818      	adds	r0, r3, r0
 8012eb4:	b2c0      	uxtb	r0, r0
}
 8012eb6:	4770      	bx	lr

08012eb8 <HAL_RTC_GetTime>:
{
 8012eb8:	b570      	push	{r4, r5, r6, lr}
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8012eba:	6803      	ldr	r3, [r0, #0]
{
 8012ebc:	000c      	movs	r4, r1
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8012ebe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012ec0:	604b      	str	r3, [r1, #4]
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK); 
 8012ec2:	6803      	ldr	r3, [r0, #0]
 8012ec4:	490e      	ldr	r1, [pc, #56]	; (8012f00 <HAL_RTC_GetTime+0x48>)
 8012ec6:	681b      	ldr	r3, [r3, #0]
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8012ec8:	203f      	movs	r0, #63	; 0x3f
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK); 
 8012eca:	400b      	ands	r3, r1
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8012ecc:	0c19      	lsrs	r1, r3, #16
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8012ece:	0a1e      	lsrs	r6, r3, #8
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8012ed0:	b2dd      	uxtb	r5, r3
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16); 
 8012ed2:	2340      	movs	r3, #64	; 0x40
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8012ed4:	4008      	ands	r0, r1
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8012ed6:	b2f6      	uxtb	r6, r6
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16); 
 8012ed8:	4019      	ands	r1, r3
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8012eda:	7020      	strb	r0, [r4, #0]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8012edc:	7066      	strb	r6, [r4, #1]
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8012ede:	70a5      	strb	r5, [r4, #2]
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16); 
 8012ee0:	7221      	strb	r1, [r4, #8]
  if(Format == RTC_FORMAT_BIN)
 8012ee2:	2a00      	cmp	r2, #0
 8012ee4:	d10a      	bne.n	8012efc <HAL_RTC_GetTime+0x44>
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8012ee6:	f7ff ffdf 	bl	8012ea8 <RTC_Bcd2ToByte>
 8012eea:	7020      	strb	r0, [r4, #0]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8012eec:	0030      	movs	r0, r6
 8012eee:	f7ff ffdb 	bl	8012ea8 <RTC_Bcd2ToByte>
 8012ef2:	7060      	strb	r0, [r4, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);  
 8012ef4:	0028      	movs	r0, r5
 8012ef6:	f7ff ffd7 	bl	8012ea8 <RTC_Bcd2ToByte>
 8012efa:	70a0      	strb	r0, [r4, #2]
}
 8012efc:	2000      	movs	r0, #0
 8012efe:	bd70      	pop	{r4, r5, r6, pc}
 8012f00:	007f7f7f 	.word	0x007f7f7f

08012f04 <HAL_RTC_GetDate>:
{
 8012f04:	b570      	push	{r4, r5, r6, lr}
 8012f06:	000c      	movs	r4, r1
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK); 
 8012f08:	6803      	ldr	r3, [r0, #0]
 8012f0a:	490e      	ldr	r1, [pc, #56]	; (8012f44 <HAL_RTC_GetDate+0x40>)
 8012f0c:	685b      	ldr	r3, [r3, #4]
 8012f0e:	400b      	ands	r3, r1
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8012f10:	0c18      	lsrs	r0, r3, #16
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8012f12:	04dd      	lsls	r5, r3, #19
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8012f14:	b2de      	uxtb	r6, r3
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8012f16:	041b      	lsls	r3, r3, #16
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8012f18:	0eed      	lsrs	r5, r5, #27
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8012f1a:	0f5b      	lsrs	r3, r3, #29
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8012f1c:	70e0      	strb	r0, [r4, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8012f1e:	7065      	strb	r5, [r4, #1]
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8012f20:	70a6      	strb	r6, [r4, #2]
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8012f22:	7023      	strb	r3, [r4, #0]
  if(Format == RTC_FORMAT_BIN)
 8012f24:	2a00      	cmp	r2, #0
 8012f26:	d10a      	bne.n	8012f3e <HAL_RTC_GetDate+0x3a>
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 8012f28:	f7ff ffbe 	bl	8012ea8 <RTC_Bcd2ToByte>
 8012f2c:	70e0      	strb	r0, [r4, #3]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 8012f2e:	0028      	movs	r0, r5
 8012f30:	f7ff ffba 	bl	8012ea8 <RTC_Bcd2ToByte>
 8012f34:	7060      	strb	r0, [r4, #1]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);  
 8012f36:	0030      	movs	r0, r6
 8012f38:	f7ff ffb6 	bl	8012ea8 <RTC_Bcd2ToByte>
 8012f3c:	70a0      	strb	r0, [r4, #2]
}
 8012f3e:	2000      	movs	r0, #0
 8012f40:	bd70      	pop	{r4, r5, r6, pc}
 8012f42:	46c0      	nop			; (mov r8, r8)
 8012f44:	00ffff3f 	.word	0x00ffff3f

08012f48 <HAL_RTCEx_BKUPWrite>:
  uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t)&(hrtc->Instance->BKP0R);
 8012f48:	6803      	ldr	r3, [r0, #0]
  tmp += (BackupRegister * 4);
 8012f4a:	0089      	lsls	r1, r1, #2
  tmp = (uint32_t)&(hrtc->Instance->BKP0R);
 8012f4c:	3350      	adds	r3, #80	; 0x50
  tmp += (BackupRegister * 4);
 8012f4e:	18c9      	adds	r1, r1, r3

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8012f50:	600a      	str	r2, [r1, #0]
}
 8012f52:	4770      	bx	lr

08012f54 <HAL_RTCEx_BKUPRead>:
  uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t)&(hrtc->Instance->BKP0R);
 8012f54:	6803      	ldr	r3, [r0, #0]
  tmp += (BackupRegister * 4);
 8012f56:	0089      	lsls	r1, r1, #2
  tmp = (uint32_t)&(hrtc->Instance->BKP0R);
 8012f58:	3350      	adds	r3, #80	; 0x50
  tmp += (BackupRegister * 4);
 8012f5a:	18c9      	adds	r1, r1, r3
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8012f5c:	6808      	ldr	r0, [r1, #0]
}
 8012f5e:	4770      	bx	lr

08012f60 <SPI_WaitFifoStateUntilTimeout.part.0>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
                  on both master and slave sides in order to resynchronize the master
                 and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8012f60:	21e0      	movs	r1, #224	; 0xe0
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout)
 8012f62:	b510      	push	{r4, lr}
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8012f64:	6802      	ldr	r2, [r0, #0]
 8012f66:	6853      	ldr	r3, [r2, #4]
 8012f68:	438b      	bics	r3, r1
 8012f6a:	6053      	str	r3, [r2, #4]

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8012f6c:	2382      	movs	r3, #130	; 0x82
 8012f6e:	6842      	ldr	r2, [r0, #4]
 8012f70:	005b      	lsls	r3, r3, #1
 8012f72:	429a      	cmp	r2, r3
 8012f74:	d10d      	bne.n	8012f92 <SPI_WaitFifoStateUntilTimeout.part.0+0x32>
 8012f76:	2280      	movs	r2, #128	; 0x80
 8012f78:	6883      	ldr	r3, [r0, #8]
 8012f7a:	0212      	lsls	r2, r2, #8
 8012f7c:	4293      	cmp	r3, r2
 8012f7e:	d003      	beq.n	8012f88 <SPI_WaitFifoStateUntilTimeout.part.0+0x28>
 8012f80:	2280      	movs	r2, #128	; 0x80
 8012f82:	00d2      	lsls	r2, r2, #3
 8012f84:	4293      	cmp	r3, r2
 8012f86:	d104      	bne.n	8012f92 <SPI_WaitFifoStateUntilTimeout.part.0+0x32>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8012f88:	2140      	movs	r1, #64	; 0x40
 8012f8a:	6802      	ldr	r2, [r0, #0]
 8012f8c:	6813      	ldr	r3, [r2, #0]
 8012f8e:	438b      	bics	r3, r1
 8012f90:	6013      	str	r3, [r2, #0]
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8012f92:	2280      	movs	r2, #128	; 0x80
 8012f94:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8012f96:	0192      	lsls	r2, r2, #6
 8012f98:	4293      	cmp	r3, r2
 8012f9a:	d108      	bne.n	8012fae <SPI_WaitFifoStateUntilTimeout.part.0+0x4e>
        {
          SPI_RESET_CRC(hspi);
 8012f9c:	6801      	ldr	r1, [r0, #0]
 8012f9e:	4c08      	ldr	r4, [pc, #32]	; (8012fc0 <SPI_WaitFifoStateUntilTimeout.part.0+0x60>)
 8012fa0:	680a      	ldr	r2, [r1, #0]
 8012fa2:	4022      	ands	r2, r4
 8012fa4:	600a      	str	r2, [r1, #0]
 8012fa6:	6802      	ldr	r2, [r0, #0]
 8012fa8:	6811      	ldr	r1, [r2, #0]
 8012faa:	430b      	orrs	r3, r1
 8012fac:	6013      	str	r3, [r2, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8012fae:	0003      	movs	r3, r0
 8012fb0:	2201      	movs	r2, #1
 8012fb2:	335d      	adds	r3, #93	; 0x5d
 8012fb4:	701a      	strb	r2, [r3, #0]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8012fb6:	2300      	movs	r3, #0
 8012fb8:	305c      	adds	r0, #92	; 0x5c
 8012fba:	7003      	strb	r3, [r0, #0]
      }
    }
  }

  return HAL_OK;
}
 8012fbc:	2003      	movs	r0, #3
 8012fbe:	bd10      	pop	{r4, pc}
 8012fc0:	0000dfff 	.word	0x0000dfff

08012fc4 <SPI_WaitFifoStateUntilTimeout>:
{
 8012fc4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012fc6:	b085      	sub	sp, #20
 8012fc8:	0006      	movs	r6, r0
 8012fca:	000d      	movs	r5, r1
 8012fcc:	0017      	movs	r7, r2
 8012fce:	001c      	movs	r4, r3
  uint32_t tickstart = HAL_GetTick();
 8012fd0:	f7fe fa96 	bl	8011500 <HAL_GetTick>
 8012fd4:	9001      	str	r0, [sp, #4]
      tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
 8012fd6:	ab02      	add	r3, sp, #8
  while((hspi->Instance->SR & Fifo) != State)
 8012fd8:	6831      	ldr	r1, [r6, #0]
      tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
 8012fda:	1dda      	adds	r2, r3, #7
  while((hspi->Instance->SR & Fifo) != State)
 8012fdc:	688b      	ldr	r3, [r1, #8]
 8012fde:	402b      	ands	r3, r5
 8012fe0:	42bb      	cmp	r3, r7
 8012fe2:	d101      	bne.n	8012fe8 <SPI_WaitFifoStateUntilTimeout+0x24>
  return HAL_OK;
 8012fe4:	2000      	movs	r0, #0
 8012fe6:	e010      	b.n	801300a <SPI_WaitFifoStateUntilTimeout+0x46>
    if((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8012fe8:	23c0      	movs	r3, #192	; 0xc0
 8012fea:	00db      	lsls	r3, r3, #3
 8012fec:	429d      	cmp	r5, r3
 8012fee:	d105      	bne.n	8012ffc <SPI_WaitFifoStateUntilTimeout+0x38>
 8012ff0:	2f00      	cmp	r7, #0
 8012ff2:	d103      	bne.n	8012ffc <SPI_WaitFifoStateUntilTimeout+0x38>
      tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
 8012ff4:	7b0b      	ldrb	r3, [r1, #12]
 8012ff6:	b2db      	uxtb	r3, r3
 8012ff8:	7013      	strb	r3, [r2, #0]
      UNUSED(tmpreg);
 8012ffa:	7813      	ldrb	r3, [r2, #0]
    if(Timeout != HAL_MAX_DELAY)
 8012ffc:	1c63      	adds	r3, r4, #1
 8012ffe:	d0ed      	beq.n	8012fdc <SPI_WaitFifoStateUntilTimeout+0x18>
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
 8013000:	2c00      	cmp	r4, #0
 8013002:	d104      	bne.n	801300e <SPI_WaitFifoStateUntilTimeout+0x4a>
 8013004:	0030      	movs	r0, r6
 8013006:	f7ff ffab 	bl	8012f60 <SPI_WaitFifoStateUntilTimeout.part.0>
}
 801300a:	b005      	add	sp, #20
 801300c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
 801300e:	f7fe fa77 	bl	8011500 <HAL_GetTick>
 8013012:	9b01      	ldr	r3, [sp, #4]
 8013014:	1ac0      	subs	r0, r0, r3
 8013016:	42a0      	cmp	r0, r4
 8013018:	d3dd      	bcc.n	8012fd6 <SPI_WaitFifoStateUntilTimeout+0x12>
 801301a:	e7f3      	b.n	8013004 <SPI_WaitFifoStateUntilTimeout+0x40>

0801301c <SPI_WaitFlagStateUntilTimeout>:
{
 801301c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801301e:	0005      	movs	r5, r0
 8013020:	000e      	movs	r6, r1
 8013022:	9201      	str	r2, [sp, #4]
 8013024:	001c      	movs	r4, r3
  uint32_t tickstart = HAL_GetTick();
 8013026:	f7fe fa6b 	bl	8011500 <HAL_GetTick>
 801302a:	0007      	movs	r7, r0
  while((hspi->Instance->SR & Flag) != State)
 801302c:	682a      	ldr	r2, [r5, #0]
 801302e:	6893      	ldr	r3, [r2, #8]
 8013030:	9901      	ldr	r1, [sp, #4]
 8013032:	4033      	ands	r3, r6
 8013034:	428b      	cmp	r3, r1
 8013036:	d101      	bne.n	801303c <SPI_WaitFlagStateUntilTimeout+0x20>
  return HAL_OK;
 8013038:	2000      	movs	r0, #0
 801303a:	e006      	b.n	801304a <SPI_WaitFlagStateUntilTimeout+0x2e>
    if(Timeout != HAL_MAX_DELAY)
 801303c:	1c63      	adds	r3, r4, #1
 801303e:	d0f6      	beq.n	801302e <SPI_WaitFlagStateUntilTimeout+0x12>
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
 8013040:	2c00      	cmp	r4, #0
 8013042:	d103      	bne.n	801304c <SPI_WaitFlagStateUntilTimeout+0x30>
 8013044:	0028      	movs	r0, r5
 8013046:	f7ff ff8b 	bl	8012f60 <SPI_WaitFifoStateUntilTimeout.part.0>
}
 801304a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
 801304c:	f7fe fa58 	bl	8011500 <HAL_GetTick>
 8013050:	1bc0      	subs	r0, r0, r7
 8013052:	42a0      	cmp	r0, r4
 8013054:	d3ea      	bcc.n	801302c <SPI_WaitFlagStateUntilTimeout+0x10>
 8013056:	e7f5      	b.n	8013044 <SPI_WaitFlagStateUntilTimeout+0x28>

08013058 <SPI_EndRxTxTransaction>:
  * @brief Handle the check of the RXTX or TX transaction complete.
  * @param hspi: SPI handle
  * @param Timeout : Timeout duration
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
{
 8013058:	b570      	push	{r4, r5, r6, lr}
  /* Control if the TX fifo is empty */
  if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
 801305a:	000b      	movs	r3, r1
{
 801305c:	000d      	movs	r5, r1
  if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
 801305e:	21c0      	movs	r1, #192	; 0xc0
 8013060:	2200      	movs	r2, #0
 8013062:	0149      	lsls	r1, r1, #5
{
 8013064:	0004      	movs	r4, r0
  if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
 8013066:	f7ff ffad 	bl	8012fc4 <SPI_WaitFifoStateUntilTimeout>
 801306a:	1e02      	subs	r2, r0, #0
 801306c:	d005      	beq.n	801307a <SPI_EndRxTxTransaction+0x22>
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 801306e:	2320      	movs	r3, #32
 8013070:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 8013072:	2003      	movs	r0, #3
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 8013074:	4313      	orrs	r3, r2
 8013076:	6623      	str	r3, [r4, #96]	; 0x60
 8013078:	e006      	b.n	8013088 <SPI_EndRxTxTransaction+0x30>
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
 801307a:	002b      	movs	r3, r5
 801307c:	2180      	movs	r1, #128	; 0x80
 801307e:	0020      	movs	r0, r4
 8013080:	f7ff ffcc 	bl	801301c <SPI_WaitFlagStateUntilTimeout>
 8013084:	2800      	cmp	r0, #0
 8013086:	d1f2      	bne.n	801306e <SPI_EndRxTxTransaction+0x16>
  }
  return HAL_OK;
}
 8013088:	bd70      	pop	{r4, r5, r6, pc}

0801308a <HAL_SPI_MspInit>:
}
 801308a:	4770      	bx	lr

0801308c <HAL_SPI_Init>:
{
 801308c:	b570      	push	{r4, r5, r6, lr}
 801308e:	0004      	movs	r4, r0
    return HAL_ERROR;
 8013090:	2001      	movs	r0, #1
  if(hspi == NULL)
 8013092:	2c00      	cmp	r4, #0
 8013094:	d05c      	beq.n	8013150 <HAL_SPI_Init+0xc4>
  if(hspi->State == HAL_SPI_STATE_RESET)
 8013096:	0025      	movs	r5, r4
 8013098:	355d      	adds	r5, #93	; 0x5d
 801309a:	782b      	ldrb	r3, [r5, #0]
 801309c:	b2db      	uxtb	r3, r3
 801309e:	2b00      	cmp	r3, #0
 80130a0:	d105      	bne.n	80130ae <HAL_SPI_Init+0x22>
    hspi->Lock = HAL_UNLOCKED;
 80130a2:	0022      	movs	r2, r4
 80130a4:	325c      	adds	r2, #92	; 0x5c
 80130a6:	7013      	strb	r3, [r2, #0]
    HAL_SPI_MspInit(hspi);
 80130a8:	0020      	movs	r0, r4
 80130aa:	f7ff ffee 	bl	801308a <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 80130ae:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 80130b0:	2140      	movs	r1, #64	; 0x40
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80130b2:	20e0      	movs	r0, #224	; 0xe0
  hspi->State = HAL_SPI_STATE_BUSY;
 80130b4:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 80130b6:	6822      	ldr	r2, [r4, #0]
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80130b8:	00c0      	lsls	r0, r0, #3
  __HAL_SPI_DISABLE(hspi);
 80130ba:	6813      	ldr	r3, [r2, #0]
 80130bc:	438b      	bics	r3, r1
 80130be:	6013      	str	r3, [r2, #0]
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80130c0:	68e3      	ldr	r3, [r4, #12]
 80130c2:	2200      	movs	r2, #0
 80130c4:	4283      	cmp	r3, r0
 80130c6:	d846      	bhi.n	8013156 <HAL_SPI_Init+0xca>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80130c8:	2180      	movs	r1, #128	; 0x80
 80130ca:	0149      	lsls	r1, r1, #5
  if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
 80130cc:	4283      	cmp	r3, r0
 80130ce:	d101      	bne.n	80130d4 <HAL_SPI_Init+0x48>
 80130d0:	e001      	b.n	80130d6 <HAL_SPI_Init+0x4a>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80130d2:	0011      	movs	r1, r2
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80130d4:	62a2      	str	r2, [r4, #40]	; 0x28
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80130d6:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80130d8:	2a00      	cmp	r2, #0
 80130da:	d103      	bne.n	80130e4 <HAL_SPI_Init+0x58>
    if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80130dc:	4283      	cmp	r3, r0
 80130de:	d938      	bls.n	8013152 <HAL_SPI_Init+0xc6>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 80130e0:	2302      	movs	r3, #2
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 80130e2:	6323      	str	r3, [r4, #48]	; 0x30
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 80130e4:	68a0      	ldr	r0, [r4, #8]
 80130e6:	6863      	ldr	r3, [r4, #4]
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 80130e8:	69a6      	ldr	r6, [r4, #24]
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 80130ea:	4303      	orrs	r3, r0
 80130ec:	6920      	ldr	r0, [r4, #16]
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
 80130ee:	6822      	ldr	r2, [r4, #0]
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 80130f0:	4303      	orrs	r3, r0
 80130f2:	6960      	ldr	r0, [r4, #20]
 80130f4:	4303      	orrs	r3, r0
 80130f6:	69e0      	ldr	r0, [r4, #28]
 80130f8:	4303      	orrs	r3, r0
 80130fa:	6a20      	ldr	r0, [r4, #32]
 80130fc:	4303      	orrs	r3, r0
 80130fe:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8013100:	4303      	orrs	r3, r0
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 8013102:	2080      	movs	r0, #128	; 0x80
 8013104:	0080      	lsls	r0, r0, #2
 8013106:	4030      	ands	r0, r6
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8013108:	4303      	orrs	r3, r0
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
 801310a:	6013      	str	r3, [r2, #0]
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 801310c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801310e:	2b02      	cmp	r3, #2
 8013110:	d105      	bne.n	801311e <HAL_SPI_Init+0x92>
    hspi->Instance->CR1|= SPI_CR1_CRCL;
 8013112:	2380      	movs	r3, #128	; 0x80
 8013114:	6822      	ldr	r2, [r4, #0]
 8013116:	011b      	lsls	r3, r3, #4
 8013118:	6810      	ldr	r0, [r2, #0]
 801311a:	4303      	orrs	r3, r0
 801311c:	6013      	str	r3, [r2, #0]
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
 801311e:	2604      	movs	r6, #4
 8013120:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8013122:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8013124:	6822      	ldr	r2, [r4, #0]
 8013126:	4303      	orrs	r3, r0
 8013128:	68e0      	ldr	r0, [r4, #12]
 801312a:	4303      	orrs	r3, r0
 801312c:	69a0      	ldr	r0, [r4, #24]
 801312e:	0c00      	lsrs	r0, r0, #16
 8013130:	4030      	ands	r0, r6
 8013132:	4303      	orrs	r3, r0
                         hspi->Init.DataSize ) | frxth;
 8013134:	4319      	orrs	r1, r3
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
 8013136:	6051      	str	r1, [r2, #4]
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 8013138:	6823      	ldr	r3, [r4, #0]
 801313a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  hspi->Instance->I2SCFGR &= (uint16_t)(~SPI_I2SCFGR_I2SMOD);
 801313c:	4909      	ldr	r1, [pc, #36]	; (8013164 <HAL_SPI_Init+0xd8>)
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 801313e:	611a      	str	r2, [r3, #16]
  hspi->Instance->I2SCFGR &= (uint16_t)(~SPI_I2SCFGR_I2SMOD);
 8013140:	6822      	ldr	r2, [r4, #0]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8013142:	2000      	movs	r0, #0
  hspi->Instance->I2SCFGR &= (uint16_t)(~SPI_I2SCFGR_I2SMOD);
 8013144:	69d3      	ldr	r3, [r2, #28]
 8013146:	400b      	ands	r3, r1
 8013148:	61d3      	str	r3, [r2, #28]
  hspi->State= HAL_SPI_STATE_READY;
 801314a:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 801314c:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State= HAL_SPI_STATE_READY;
 801314e:	702b      	strb	r3, [r5, #0]
}
 8013150:	bd70      	pop	{r4, r5, r6, pc}
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8013152:	2301      	movs	r3, #1
 8013154:	e7c5      	b.n	80130e2 <HAL_SPI_Init+0x56>
  if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
 8013156:	21f0      	movs	r1, #240	; 0xf0
 8013158:	0109      	lsls	r1, r1, #4
 801315a:	428b      	cmp	r3, r1
 801315c:	d1b9      	bne.n	80130d2 <HAL_SPI_Init+0x46>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 801315e:	0011      	movs	r1, r2
 8013160:	e7b9      	b.n	80130d6 <HAL_SPI_Init+0x4a>
 8013162:	46c0      	nop			; (mov r8, r8)
 8013164:	0000f7ff 	.word	0x0000f7ff

08013168 <HAL_SPI_MspDeInit>:
 8013168:	4770      	bx	lr

0801316a <HAL_SPI_DeInit>:
{
 801316a:	b570      	push	{r4, r5, r6, lr}
 801316c:	0004      	movs	r4, r0
    return HAL_ERROR;
 801316e:	2001      	movs	r0, #1
  if(hspi == NULL)
 8013170:	2c00      	cmp	r4, #0
 8013172:	d010      	beq.n	8013196 <HAL_SPI_DeInit+0x2c>
  hspi->State = HAL_SPI_STATE_BUSY;
 8013174:	0025      	movs	r5, r4
 8013176:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8013178:	2140      	movs	r1, #64	; 0x40
  hspi->State = HAL_SPI_STATE_BUSY;
 801317a:	355d      	adds	r5, #93	; 0x5d
 801317c:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 801317e:	6822      	ldr	r2, [r4, #0]
  HAL_SPI_MspDeInit(hspi);
 8013180:	0020      	movs	r0, r4
  __HAL_SPI_DISABLE(hspi);
 8013182:	6813      	ldr	r3, [r2, #0]
  __HAL_UNLOCK(hspi);
 8013184:	345c      	adds	r4, #92	; 0x5c
  __HAL_SPI_DISABLE(hspi);
 8013186:	438b      	bics	r3, r1
 8013188:	6013      	str	r3, [r2, #0]
  HAL_SPI_MspDeInit(hspi);
 801318a:	f7ff ffed 	bl	8013168 <HAL_SPI_MspDeInit>
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 801318e:	2000      	movs	r0, #0
 8013190:	6060      	str	r0, [r4, #4]
  hspi->State = HAL_SPI_STATE_RESET;
 8013192:	7028      	strb	r0, [r5, #0]
  __HAL_UNLOCK(hspi);
 8013194:	7020      	strb	r0, [r4, #0]
}
 8013196:	bd70      	pop	{r4, r5, r6, pc}

08013198 <HAL_SPI_TransmitReceive>:
{
 8013198:	b5f0      	push	{r4, r5, r6, r7, lr}
 801319a:	0004      	movs	r4, r0
 801319c:	b087      	sub	sp, #28
 801319e:	001e      	movs	r6, r3
 80131a0:	9103      	str	r1, [sp, #12]
 80131a2:	0017      	movs	r7, r2
  uint32_t tickstart = HAL_GetTick();
 80131a4:	f7fe f9ac 	bl	8011500 <HAL_GetTick>
  __HAL_LOCK(hspi);
 80131a8:	0023      	movs	r3, r4
 80131aa:	335c      	adds	r3, #92	; 0x5c
  uint32_t tickstart = HAL_GetTick();
 80131ac:	9002      	str	r0, [sp, #8]
  __HAL_LOCK(hspi);
 80131ae:	9301      	str	r3, [sp, #4]
 80131b0:	781b      	ldrb	r3, [r3, #0]
 80131b2:	2502      	movs	r5, #2
 80131b4:	2b01      	cmp	r3, #1
 80131b6:	d100      	bne.n	80131ba <HAL_SPI_TransmitReceive+0x22>
 80131b8:	e0b2      	b.n	8013320 <HAL_SPI_TransmitReceive+0x188>
 80131ba:	2301      	movs	r3, #1
 80131bc:	9a01      	ldr	r2, [sp, #4]
 80131be:	7013      	strb	r3, [r2, #0]
  if(hspi->State != HAL_SPI_STATE_READY)
 80131c0:	0023      	movs	r3, r4
 80131c2:	335d      	adds	r3, #93	; 0x5d
 80131c4:	781a      	ldrb	r2, [r3, #0]
 80131c6:	2a01      	cmp	r2, #1
 80131c8:	d000      	beq.n	80131cc <HAL_SPI_TransmitReceive+0x34>
 80131ca:	e0a3      	b.n	8013314 <HAL_SPI_TransmitReceive+0x17c>
  if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
 80131cc:	9a03      	ldr	r2, [sp, #12]
 80131ce:	2a00      	cmp	r2, #0
 80131d0:	d100      	bne.n	80131d4 <HAL_SPI_TransmitReceive+0x3c>
 80131d2:	e11c      	b.n	801340e <HAL_SPI_TransmitReceive+0x276>
 80131d4:	2f00      	cmp	r7, #0
 80131d6:	d100      	bne.n	80131da <HAL_SPI_TransmitReceive+0x42>
 80131d8:	e119      	b.n	801340e <HAL_SPI_TransmitReceive+0x276>
 80131da:	2e00      	cmp	r6, #0
 80131dc:	d100      	bne.n	80131e0 <HAL_SPI_TransmitReceive+0x48>
 80131de:	e116      	b.n	801340e <HAL_SPI_TransmitReceive+0x276>
  hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
 80131e0:	2205      	movs	r2, #5
  hspi->RxXferCount = Size;
 80131e2:	0025      	movs	r5, r4
  hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
 80131e4:	701a      	strb	r2, [r3, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80131e6:	2300      	movs	r3, #0
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80131e8:	2280      	movs	r2, #128	; 0x80
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80131ea:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->RxXferCount = Size;
 80131ec:	3508      	adds	r5, #8
  hspi->RxXferSize  = Size;
 80131ee:	1da3      	adds	r3, r4, #6
  hspi->pRxBuffPtr  = pRxData;
 80131f0:	6427      	str	r7, [r4, #64]	; 0x40
  hspi->RxXferCount = Size;
 80131f2:	87ee      	strh	r6, [r5, #62]	; 0x3e
  hspi->RxXferSize  = Size;
 80131f4:	87de      	strh	r6, [r3, #62]	; 0x3e
  hspi->pTxBuffPtr  = pTxData;
 80131f6:	9b03      	ldr	r3, [sp, #12]
  hspi->TxXferCount = Size;
 80131f8:	87e6      	strh	r6, [r4, #62]	; 0x3e
  hspi->pTxBuffPtr  = pTxData;
 80131fa:	63a3      	str	r3, [r4, #56]	; 0x38
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80131fc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  hspi->TxXferSize  = Size;
 80131fe:	87a6      	strh	r6, [r4, #60]	; 0x3c
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8013200:	0192      	lsls	r2, r2, #6
 8013202:	4293      	cmp	r3, r2
 8013204:	d108      	bne.n	8013218 <HAL_SPI_TransmitReceive+0x80>
 8013206:	6821      	ldr	r1, [r4, #0]
    SPI_RESET_CRC(hspi);
 8013208:	488c      	ldr	r0, [pc, #560]	; (801343c <HAL_SPI_TransmitReceive+0x2a4>)
 801320a:	680a      	ldr	r2, [r1, #0]
 801320c:	4002      	ands	r2, r0
 801320e:	600a      	str	r2, [r1, #0]
 8013210:	6822      	ldr	r2, [r4, #0]
 8013212:	6811      	ldr	r1, [r2, #0]
 8013214:	430b      	orrs	r3, r1
 8013216:	6013      	str	r3, [r2, #0]
  if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
 8013218:	22e0      	movs	r2, #224	; 0xe0
 801321a:	68e1      	ldr	r1, [r4, #12]
 801321c:	6823      	ldr	r3, [r4, #0]
 801321e:	00d2      	lsls	r2, r2, #3
 8013220:	4291      	cmp	r1, r2
 8013222:	d802      	bhi.n	801322a <HAL_SPI_TransmitReceive+0x92>
 8013224:	8fea      	ldrh	r2, [r5, #62]	; 0x3e
 8013226:	2a01      	cmp	r2, #1
 8013228:	d930      	bls.n	801328c <HAL_SPI_TransmitReceive+0xf4>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801322a:	685a      	ldr	r2, [r3, #4]
 801322c:	4984      	ldr	r1, [pc, #528]	; (8013440 <HAL_SPI_TransmitReceive+0x2a8>)
 801322e:	400a      	ands	r2, r1
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8013230:	605a      	str	r2, [r3, #4]
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 8013232:	2340      	movs	r3, #64	; 0x40
 8013234:	6822      	ldr	r2, [r4, #0]
 8013236:	6811      	ldr	r1, [r2, #0]
 8013238:	4219      	tst	r1, r3
 801323a:	d102      	bne.n	8013242 <HAL_SPI_TransmitReceive+0xaa>
    __HAL_SPI_ENABLE(hspi);
 801323c:	6811      	ldr	r1, [r2, #0]
 801323e:	430b      	orrs	r3, r1
 8013240:	6013      	str	r3, [r2, #0]
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8013242:	23e0      	movs	r3, #224	; 0xe0
 8013244:	68e2      	ldr	r2, [r4, #12]
 8013246:	00db      	lsls	r3, r3, #3
 8013248:	429a      	cmp	r2, r3
 801324a:	d924      	bls.n	8013296 <HAL_SPI_TransmitReceive+0xfe>
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
 801324c:	2601      	movs	r6, #1
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
 801324e:	2702      	movs	r7, #2
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8013250:	2280      	movs	r2, #128	; 0x80
          hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
 8013252:	2180      	movs	r1, #128	; 0x80
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8013254:	0192      	lsls	r2, r2, #6
          hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
 8013256:	0149      	lsls	r1, r1, #5
    while ((hspi->TxXferCount > 0 ) || (hspi->RxXferCount > 0))
 8013258:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801325a:	2b00      	cmp	r3, #0
 801325c:	d128      	bne.n	80132b0 <HAL_SPI_TransmitReceive+0x118>
 801325e:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 8013260:	2b00      	cmp	r3, #0
 8013262:	d13f      	bne.n	80132e4 <HAL_SPI_TransmitReceive+0x14c>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8013264:	2380      	movs	r3, #128	; 0x80
 8013266:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8013268:	019b      	lsls	r3, r3, #6
 801326a:	429a      	cmp	r2, r3
 801326c:	d000      	beq.n	8013270 <HAL_SPI_TransmitReceive+0xd8>
 801326e:	e0b6      	b.n	80133de <HAL_SPI_TransmitReceive+0x246>
    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 8013270:	2201      	movs	r2, #1
 8013272:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013274:	0011      	movs	r1, r2
 8013276:	0020      	movs	r0, r4
 8013278:	f7ff fed0 	bl	801301c <SPI_WaitFlagStateUntilTimeout>
 801327c:	2800      	cmp	r0, #0
 801327e:	d100      	bne.n	8013282 <HAL_SPI_TransmitReceive+0xea>
 8013280:	e0a1      	b.n	80133c6 <HAL_SPI_TransmitReceive+0x22e>
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 8013282:	2302      	movs	r3, #2
 8013284:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8013286:	4313      	orrs	r3, r2
 8013288:	6623      	str	r3, [r4, #96]	; 0x60
 801328a:	e042      	b.n	8013312 <HAL_SPI_TransmitReceive+0x17a>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801328c:	2280      	movs	r2, #128	; 0x80
 801328e:	6859      	ldr	r1, [r3, #4]
 8013290:	0152      	lsls	r2, r2, #5
 8013292:	430a      	orrs	r2, r1
 8013294:	e7cc      	b.n	8013230 <HAL_SPI_TransmitReceive+0x98>
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8013296:	2680      	movs	r6, #128	; 0x80
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
 8013298:	2701      	movs	r7, #1
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801329a:	0176      	lsls	r6, r6, #5
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 801329c:	2180      	movs	r1, #128	; 0x80
 801329e:	0189      	lsls	r1, r1, #6
    while((hspi->TxXferCount > 0) || (hspi->RxXferCount > 0))
 80132a0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80132a2:	469c      	mov	ip, r3
 80132a4:	2b00      	cmp	r3, #0
 80132a6:	d13e      	bne.n	8013326 <HAL_SPI_TransmitReceive+0x18e>
 80132a8:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 80132aa:	2b00      	cmp	r3, #0
 80132ac:	d159      	bne.n	8013362 <HAL_SPI_TransmitReceive+0x1ca>
 80132ae:	e7d9      	b.n	8013264 <HAL_SPI_TransmitReceive+0xcc>
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
 80132b0:	6823      	ldr	r3, [r4, #0]
 80132b2:	6898      	ldr	r0, [r3, #8]
 80132b4:	4238      	tst	r0, r7
 80132b6:	d012      	beq.n	80132de <HAL_SPI_TransmitReceive+0x146>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80132b8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80132ba:	8800      	ldrh	r0, [r0, #0]
 80132bc:	60d8      	str	r0, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 80132be:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80132c0:	3302      	adds	r3, #2
 80132c2:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 80132c4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80132c6:	3b01      	subs	r3, #1
 80132c8:	b29b      	uxth	r3, r3
 80132ca:	87e3      	strh	r3, [r4, #62]	; 0x3e
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 80132cc:	2b00      	cmp	r3, #0
 80132ce:	d106      	bne.n	80132de <HAL_SPI_TransmitReceive+0x146>
 80132d0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80132d2:	4293      	cmp	r3, r2
 80132d4:	d103      	bne.n	80132de <HAL_SPI_TransmitReceive+0x146>
          hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
 80132d6:	6820      	ldr	r0, [r4, #0]
 80132d8:	6803      	ldr	r3, [r0, #0]
 80132da:	430b      	orrs	r3, r1
 80132dc:	6003      	str	r3, [r0, #0]
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
 80132de:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 80132e0:	2b00      	cmp	r3, #0
 80132e2:	d00c      	beq.n	80132fe <HAL_SPI_TransmitReceive+0x166>
 80132e4:	6823      	ldr	r3, [r4, #0]
 80132e6:	6898      	ldr	r0, [r3, #8]
 80132e8:	4230      	tst	r0, r6
 80132ea:	d008      	beq.n	80132fe <HAL_SPI_TransmitReceive+0x166>
        *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 80132ec:	68db      	ldr	r3, [r3, #12]
 80132ee:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80132f0:	8003      	strh	r3, [r0, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 80132f2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80132f4:	3302      	adds	r3, #2
 80132f6:	6423      	str	r3, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 80132f8:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 80132fa:	3b01      	subs	r3, #1
 80132fc:	87eb      	strh	r3, [r5, #62]	; 0x3e
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 80132fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013300:	3301      	adds	r3, #1
 8013302:	d0a9      	beq.n	8013258 <HAL_SPI_TransmitReceive+0xc0>
 8013304:	f7fe f8fc 	bl	8011500 <HAL_GetTick>
 8013308:	9b02      	ldr	r3, [sp, #8]
 801330a:	1ac0      	subs	r0, r0, r3
 801330c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801330e:	4298      	cmp	r0, r3
 8013310:	d39e      	bcc.n	8013250 <HAL_SPI_TransmitReceive+0xb8>
          errorcode = HAL_TIMEOUT;
 8013312:	2503      	movs	r5, #3
  hspi->State = HAL_SPI_STATE_READY;
 8013314:	2301      	movs	r3, #1
 8013316:	345d      	adds	r4, #93	; 0x5d
 8013318:	7023      	strb	r3, [r4, #0]
  __HAL_UNLOCK(hspi);
 801331a:	2300      	movs	r3, #0
 801331c:	9a01      	ldr	r2, [sp, #4]
 801331e:	7013      	strb	r3, [r2, #0]
}
 8013320:	0028      	movs	r0, r5
 8013322:	b007      	add	sp, #28
 8013324:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
 8013326:	2202      	movs	r2, #2
 8013328:	6823      	ldr	r3, [r4, #0]
 801332a:	6898      	ldr	r0, [r3, #8]
 801332c:	4210      	tst	r0, r2
 801332e:	d015      	beq.n	801335c <HAL_SPI_TransmitReceive+0x1c4>
        if(hspi->TxXferCount > 1)
 8013330:	4662      	mov	r2, ip
 8013332:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8013334:	2a01      	cmp	r2, #1
 8013336:	d937      	bls.n	80133a8 <HAL_SPI_TransmitReceive+0x210>
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 8013338:	8800      	ldrh	r0, [r0, #0]
 801333a:	60d8      	str	r0, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 801333c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801333e:	3302      	adds	r3, #2
 8013340:	63a3      	str	r3, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2;
 8013342:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8013344:	3b02      	subs	r3, #2
          hspi->TxXferCount--;
 8013346:	87e3      	strh	r3, [r4, #62]	; 0x3e
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8013348:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 801334a:	2b00      	cmp	r3, #0
 801334c:	d106      	bne.n	801335c <HAL_SPI_TransmitReceive+0x1c4>
 801334e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8013350:	428b      	cmp	r3, r1
 8013352:	d103      	bne.n	801335c <HAL_SPI_TransmitReceive+0x1c4>
          hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8013354:	6820      	ldr	r0, [r4, #0]
 8013356:	6803      	ldr	r3, [r0, #0]
 8013358:	4333      	orrs	r3, r6
 801335a:	6003      	str	r3, [r0, #0]
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
 801335c:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 801335e:	2b00      	cmp	r3, #0
 8013360:	d015      	beq.n	801338e <HAL_SPI_TransmitReceive+0x1f6>
 8013362:	6822      	ldr	r2, [r4, #0]
 8013364:	6890      	ldr	r0, [r2, #8]
 8013366:	4238      	tst	r0, r7
 8013368:	d011      	beq.n	801338e <HAL_SPI_TransmitReceive+0x1f6>
 801336a:	6c20      	ldr	r0, [r4, #64]	; 0x40
        if(hspi->RxXferCount > 1)
 801336c:	2b01      	cmp	r3, #1
 801336e:	d922      	bls.n	80133b6 <HAL_SPI_TransmitReceive+0x21e>
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8013370:	68d3      	ldr	r3, [r2, #12]
 8013372:	8003      	strh	r3, [r0, #0]
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8013374:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8013376:	3302      	adds	r3, #2
 8013378:	6423      	str	r3, [r4, #64]	; 0x40
          hspi->RxXferCount -= 2;
 801337a:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 801337c:	3b02      	subs	r3, #2
 801337e:	b29b      	uxth	r3, r3
 8013380:	87eb      	strh	r3, [r5, #62]	; 0x3e
          if(hspi->RxXferCount <= 1)
 8013382:	2b01      	cmp	r3, #1
 8013384:	d803      	bhi.n	801338e <HAL_SPI_TransmitReceive+0x1f6>
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8013386:	6820      	ldr	r0, [r4, #0]
 8013388:	6843      	ldr	r3, [r0, #4]
 801338a:	4333      	orrs	r3, r6
 801338c:	6043      	str	r3, [r0, #4]
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 801338e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013390:	3301      	adds	r3, #1
 8013392:	d100      	bne.n	8013396 <HAL_SPI_TransmitReceive+0x1fe>
 8013394:	e784      	b.n	80132a0 <HAL_SPI_TransmitReceive+0x108>
 8013396:	f7fe f8b3 	bl	8011500 <HAL_GetTick>
 801339a:	9b02      	ldr	r3, [sp, #8]
 801339c:	1ac0      	subs	r0, r0, r3
 801339e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80133a0:	4298      	cmp	r0, r3
 80133a2:	d200      	bcs.n	80133a6 <HAL_SPI_TransmitReceive+0x20e>
 80133a4:	e77a      	b.n	801329c <HAL_SPI_TransmitReceive+0x104>
 80133a6:	e7b4      	b.n	8013312 <HAL_SPI_TransmitReceive+0x17a>
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 80133a8:	1c42      	adds	r2, r0, #1
 80133aa:	63a2      	str	r2, [r4, #56]	; 0x38
 80133ac:	7800      	ldrb	r0, [r0, #0]
 80133ae:	7318      	strb	r0, [r3, #12]
          hspi->TxXferCount--;
 80133b0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80133b2:	3b01      	subs	r3, #1
 80133b4:	e7c7      	b.n	8013346 <HAL_SPI_TransmitReceive+0x1ae>
          (*hspi->pRxBuffPtr++) =  *(__IO uint8_t *)&hspi->Instance->DR;
 80133b6:	1c43      	adds	r3, r0, #1
 80133b8:	6423      	str	r3, [r4, #64]	; 0x40
 80133ba:	7b13      	ldrb	r3, [r2, #12]
 80133bc:	7003      	strb	r3, [r0, #0]
          hspi->RxXferCount--;
 80133be:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 80133c0:	3b01      	subs	r3, #1
 80133c2:	87eb      	strh	r3, [r5, #62]	; 0x3e
 80133c4:	e7e3      	b.n	801338e <HAL_SPI_TransmitReceive+0x1f6>
    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 80133c6:	22f0      	movs	r2, #240	; 0xf0
 80133c8:	a904      	add	r1, sp, #16
 80133ca:	1d8d      	adds	r5, r1, #6
 80133cc:	68e1      	ldr	r1, [r4, #12]
 80133ce:	6823      	ldr	r3, [r4, #0]
 80133d0:	0112      	lsls	r2, r2, #4
 80133d2:	4291      	cmp	r1, r2
 80133d4:	d11d      	bne.n	8013412 <HAL_SPI_TransmitReceive+0x27a>
      tmpreg = hspi->Instance->DR;
 80133d6:	68db      	ldr	r3, [r3, #12]
 80133d8:	b29b      	uxth	r3, r3
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 80133da:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 80133dc:	882b      	ldrh	r3, [r5, #0]
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 80133de:	6822      	ldr	r2, [r4, #0]
  HAL_StatusTypeDef errorcode = HAL_OK;
 80133e0:	2500      	movs	r5, #0
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 80133e2:	6893      	ldr	r3, [r2, #8]
 80133e4:	06db      	lsls	r3, r3, #27
 80133e6:	d506      	bpl.n	80133f6 <HAL_SPI_TransmitReceive+0x25e>
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 80133e8:	2302      	movs	r3, #2
 80133ea:	6e21      	ldr	r1, [r4, #96]	; 0x60
    errorcode = HAL_ERROR;
 80133ec:	3501      	adds	r5, #1
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 80133ee:	430b      	orrs	r3, r1
 80133f0:	6623      	str	r3, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 80133f2:	4b14      	ldr	r3, [pc, #80]	; (8013444 <HAL_SPI_TransmitReceive+0x2ac>)
 80133f4:	6093      	str	r3, [r2, #8]
  if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
 80133f6:	990c      	ldr	r1, [sp, #48]	; 0x30
 80133f8:	0020      	movs	r0, r4
 80133fa:	f7ff fe2d 	bl	8013058 <SPI_EndRxTxTransaction>
 80133fe:	2800      	cmp	r0, #0
 8013400:	d001      	beq.n	8013406 <HAL_SPI_TransmitReceive+0x26e>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8013402:	2320      	movs	r3, #32
 8013404:	6623      	str	r3, [r4, #96]	; 0x60
  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8013406:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8013408:	2b00      	cmp	r3, #0
 801340a:	d100      	bne.n	801340e <HAL_SPI_TransmitReceive+0x276>
 801340c:	e782      	b.n	8013314 <HAL_SPI_TransmitReceive+0x17c>
    errorcode = HAL_ERROR;
 801340e:	2501      	movs	r5, #1
 8013410:	e780      	b.n	8013314 <HAL_SPI_TransmitReceive+0x17c>
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8013412:	7b1b      	ldrb	r3, [r3, #12]
      if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8013414:	6b26      	ldr	r6, [r4, #48]	; 0x30
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8013416:	802b      	strh	r3, [r5, #0]
      UNUSED(tmpreg);
 8013418:	882b      	ldrh	r3, [r5, #0]
      if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 801341a:	2e02      	cmp	r6, #2
 801341c:	d1df      	bne.n	80133de <HAL_SPI_TransmitReceive+0x246>
        if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 801341e:	2201      	movs	r2, #1
 8013420:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013422:	0011      	movs	r1, r2
 8013424:	0020      	movs	r0, r4
 8013426:	f7ff fdf9 	bl	801301c <SPI_WaitFlagStateUntilTimeout>
 801342a:	2800      	cmp	r0, #0
 801342c:	d003      	beq.n	8013436 <HAL_SPI_TransmitReceive+0x29e>
          hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 801342e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8013430:	431e      	orrs	r6, r3
 8013432:	6626      	str	r6, [r4, #96]	; 0x60
 8013434:	e76d      	b.n	8013312 <HAL_SPI_TransmitReceive+0x17a>
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8013436:	6823      	ldr	r3, [r4, #0]
 8013438:	7b1b      	ldrb	r3, [r3, #12]
 801343a:	e7ce      	b.n	80133da <HAL_SPI_TransmitReceive+0x242>
 801343c:	0000dfff 	.word	0x0000dfff
 8013440:	ffffefff 	.word	0xffffefff
 8013444:	0000ffef 	.word	0x0000ffef

08013448 <HAL_TIM_Base_MspInit>:
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8013448:	4770      	bx	lr

0801344a <HAL_TIM_Base_Start>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 801344a:	0002      	movs	r2, r0
 801344c:	2302      	movs	r3, #2

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 801344e:	2101      	movs	r1, #1
  htim->State= HAL_TIM_STATE_BUSY;
 8013450:	3239      	adds	r2, #57	; 0x39
 8013452:	7013      	strb	r3, [r2, #0]
  __HAL_TIM_ENABLE(htim);
 8013454:	6800      	ldr	r0, [r0, #0]
 8013456:	6803      	ldr	r3, [r0, #0]
 8013458:	430b      	orrs	r3, r1
 801345a:	6003      	str	r3, [r0, #0]
  /* Change the TIM state*/
  htim->State= HAL_TIM_STATE_READY;

  /* Return function status */
  return HAL_OK;
}
 801345c:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 801345e:	7011      	strb	r1, [r2, #0]
}
 8013460:	4770      	bx	lr
	...

08013464 <HAL_TIM_Base_Stop>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 8013464:	0001      	movs	r1, r0
 8013466:	2302      	movs	r3, #2
 8013468:	3139      	adds	r1, #57	; 0x39
 801346a:	700b      	strb	r3, [r1, #0]

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 801346c:	6803      	ldr	r3, [r0, #0]
 801346e:	4a08      	ldr	r2, [pc, #32]	; (8013490 <HAL_TIM_Base_Stop+0x2c>)
 8013470:	6a18      	ldr	r0, [r3, #32]
 8013472:	4210      	tst	r0, r2
 8013474:	d107      	bne.n	8013486 <HAL_TIM_Base_Stop+0x22>
 8013476:	6a18      	ldr	r0, [r3, #32]
 8013478:	4a06      	ldr	r2, [pc, #24]	; (8013494 <HAL_TIM_Base_Stop+0x30>)
 801347a:	4210      	tst	r0, r2
 801347c:	d103      	bne.n	8013486 <HAL_TIM_Base_Stop+0x22>
 801347e:	2001      	movs	r0, #1
 8013480:	681a      	ldr	r2, [r3, #0]
 8013482:	4382      	bics	r2, r0
 8013484:	601a      	str	r2, [r3, #0]

  /* Change the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 8013486:	2301      	movs	r3, #1

  /* Return function status */
  return HAL_OK;
}
 8013488:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 801348a:	700b      	strb	r3, [r1, #0]
}
 801348c:	4770      	bx	lr
 801348e:	46c0      	nop			; (mov r8, r8)
 8013490:	00001111 	.word	0x00001111
 8013494:	00000444 	.word	0x00000444

08013498 <HAL_TIM_Base_Start_IT>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

   /* Enable the TIM Update interrupt */
   __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8013498:	2301      	movs	r3, #1
 801349a:	6801      	ldr	r1, [r0, #0]
 801349c:	68ca      	ldr	r2, [r1, #12]
 801349e:	431a      	orrs	r2, r3
 80134a0:	60ca      	str	r2, [r1, #12]

   /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 80134a2:	6802      	ldr	r2, [r0, #0]

  /* Return function status */
  return HAL_OK;
}
 80134a4:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
 80134a6:	6811      	ldr	r1, [r2, #0]
 80134a8:	430b      	orrs	r3, r1
 80134aa:	6013      	str	r3, [r2, #0]
}
 80134ac:	4770      	bx	lr

080134ae <HAL_TIM_PeriodElapsedCallback>:
 80134ae:	4770      	bx	lr

080134b0 <HAL_TIM_OC_DelayElapsedCallback>:
 80134b0:	4770      	bx	lr

080134b2 <HAL_TIM_IC_CaptureCallback>:
 80134b2:	4770      	bx	lr

080134b4 <HAL_TIM_PWM_PulseFinishedCallback>:
 80134b4:	4770      	bx	lr

080134b6 <HAL_TIM_TriggerCallback>:
 80134b6:	4770      	bx	lr

080134b8 <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80134b8:	2202      	movs	r2, #2
{
 80134ba:	b510      	push	{r4, lr}
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80134bc:	6803      	ldr	r3, [r0, #0]
{
 80134be:	0004      	movs	r4, r0
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80134c0:	6919      	ldr	r1, [r3, #16]
 80134c2:	4211      	tst	r1, r2
 80134c4:	d00f      	beq.n	80134e6 <HAL_TIM_IRQHandler+0x2e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 80134c6:	68d9      	ldr	r1, [r3, #12]
 80134c8:	4211      	tst	r1, r2
 80134ca:	d00c      	beq.n	80134e6 <HAL_TIM_IRQHandler+0x2e>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 80134cc:	3a05      	subs	r2, #5
 80134ce:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80134d0:	2301      	movs	r3, #1
 80134d2:	7603      	strb	r3, [r0, #24]

        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 80134d4:	6803      	ldr	r3, [r0, #0]
 80134d6:	699b      	ldr	r3, [r3, #24]
 80134d8:	079b      	lsls	r3, r3, #30
 80134da:	d100      	bne.n	80134de <HAL_TIM_IRQHandler+0x26>
 80134dc:	e07d      	b.n	80135da <HAL_TIM_IRQHandler+0x122>
        {
          HAL_TIM_IC_CaptureCallback(htim);
 80134de:	f7ff ffe8 	bl	80134b2 <HAL_TIM_IC_CaptureCallback>
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80134e2:	2300      	movs	r3, #0
 80134e4:	7623      	strb	r3, [r4, #24]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 80134e6:	2204      	movs	r2, #4
 80134e8:	6823      	ldr	r3, [r4, #0]
 80134ea:	6919      	ldr	r1, [r3, #16]
 80134ec:	4211      	tst	r1, r2
 80134ee:	d012      	beq.n	8013516 <HAL_TIM_IRQHandler+0x5e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 80134f0:	68d9      	ldr	r1, [r3, #12]
 80134f2:	4211      	tst	r1, r2
 80134f4:	d00f      	beq.n	8013516 <HAL_TIM_IRQHandler+0x5e>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 80134f6:	3a09      	subs	r2, #9
 80134f8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80134fa:	2302      	movs	r3, #2
 80134fc:	7623      	strb	r3, [r4, #24]
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 80134fe:	6823      	ldr	r3, [r4, #0]
      {
        HAL_TIM_IC_CaptureCallback(htim);
 8013500:	0020      	movs	r0, r4
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 8013502:	699a      	ldr	r2, [r3, #24]
 8013504:	23c0      	movs	r3, #192	; 0xc0
 8013506:	009b      	lsls	r3, r3, #2
 8013508:	421a      	tst	r2, r3
 801350a:	d100      	bne.n	801350e <HAL_TIM_IRQHandler+0x56>
 801350c:	e06b      	b.n	80135e6 <HAL_TIM_IRQHandler+0x12e>
        HAL_TIM_IC_CaptureCallback(htim);
 801350e:	f7ff ffd0 	bl	80134b2 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8013512:	2300      	movs	r3, #0
 8013514:	7623      	strb	r3, [r4, #24]
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8013516:	2208      	movs	r2, #8
 8013518:	6823      	ldr	r3, [r4, #0]
 801351a:	6919      	ldr	r1, [r3, #16]
 801351c:	4211      	tst	r1, r2
 801351e:	d00f      	beq.n	8013540 <HAL_TIM_IRQHandler+0x88>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 8013520:	68d9      	ldr	r1, [r3, #12]
 8013522:	4211      	tst	r1, r2
 8013524:	d00c      	beq.n	8013540 <HAL_TIM_IRQHandler+0x88>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8013526:	3a11      	subs	r2, #17
 8013528:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 801352a:	2304      	movs	r3, #4
 801352c:	7623      	strb	r3, [r4, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 801352e:	6823      	ldr	r3, [r4, #0]
      {
        HAL_TIM_IC_CaptureCallback(htim);
 8013530:	0020      	movs	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 8013532:	69db      	ldr	r3, [r3, #28]
 8013534:	079b      	lsls	r3, r3, #30
 8013536:	d05c      	beq.n	80135f2 <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_IC_CaptureCallback(htim);
 8013538:	f7ff ffbb 	bl	80134b2 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801353c:	2300      	movs	r3, #0
 801353e:	7623      	strb	r3, [r4, #24]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8013540:	2210      	movs	r2, #16
 8013542:	6823      	ldr	r3, [r4, #0]
 8013544:	6919      	ldr	r1, [r3, #16]
 8013546:	4211      	tst	r1, r2
 8013548:	d011      	beq.n	801356e <HAL_TIM_IRQHandler+0xb6>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 801354a:	68d9      	ldr	r1, [r3, #12]
 801354c:	4211      	tst	r1, r2
 801354e:	d00e      	beq.n	801356e <HAL_TIM_IRQHandler+0xb6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8013550:	3a21      	subs	r2, #33	; 0x21
 8013552:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8013554:	2308      	movs	r3, #8
 8013556:	7623      	strb	r3, [r4, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 8013558:	6823      	ldr	r3, [r4, #0]
      {
        HAL_TIM_IC_CaptureCallback(htim);
 801355a:	0020      	movs	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 801355c:	69da      	ldr	r2, [r3, #28]
 801355e:	23c0      	movs	r3, #192	; 0xc0
 8013560:	009b      	lsls	r3, r3, #2
 8013562:	421a      	tst	r2, r3
 8013564:	d04b      	beq.n	80135fe <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8013566:	f7ff ffa4 	bl	80134b2 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801356a:	2300      	movs	r3, #0
 801356c:	7623      	strb	r3, [r4, #24]
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 801356e:	2201      	movs	r2, #1
 8013570:	6823      	ldr	r3, [r4, #0]
 8013572:	6919      	ldr	r1, [r3, #16]
 8013574:	4211      	tst	r1, r2
 8013576:	d007      	beq.n	8013588 <HAL_TIM_IRQHandler+0xd0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 8013578:	68d9      	ldr	r1, [r3, #12]
 801357a:	4211      	tst	r1, r2
 801357c:	d004      	beq.n	8013588 <HAL_TIM_IRQHandler+0xd0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 801357e:	3a03      	subs	r2, #3
 8013580:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8013582:	0020      	movs	r0, r4
 8013584:	f7ff ff93 	bl	80134ae <HAL_TIM_PeriodElapsedCallback>
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8013588:	2280      	movs	r2, #128	; 0x80
 801358a:	6823      	ldr	r3, [r4, #0]
 801358c:	6919      	ldr	r1, [r3, #16]
 801358e:	4211      	tst	r1, r2
 8013590:	d008      	beq.n	80135a4 <HAL_TIM_IRQHandler+0xec>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8013592:	68d9      	ldr	r1, [r3, #12]
 8013594:	4211      	tst	r1, r2
 8013596:	d005      	beq.n	80135a4 <HAL_TIM_IRQHandler+0xec>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8013598:	3a02      	subs	r2, #2
 801359a:	3aff      	subs	r2, #255	; 0xff
 801359c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 801359e:	0020      	movs	r0, r4
 80135a0:	f000 f8c2 	bl	8013728 <HAL_TIMEx_BreakCallback>
    }
  }
  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80135a4:	2240      	movs	r2, #64	; 0x40
 80135a6:	6823      	ldr	r3, [r4, #0]
 80135a8:	6919      	ldr	r1, [r3, #16]
 80135aa:	4211      	tst	r1, r2
 80135ac:	d007      	beq.n	80135be <HAL_TIM_IRQHandler+0x106>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 80135ae:	68d9      	ldr	r1, [r3, #12]
 80135b0:	4211      	tst	r1, r2
 80135b2:	d004      	beq.n	80135be <HAL_TIM_IRQHandler+0x106>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80135b4:	3a81      	subs	r2, #129	; 0x81
 80135b6:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80135b8:	0020      	movs	r0, r4
 80135ba:	f7ff ff7c 	bl	80134b6 <HAL_TIM_TriggerCallback>
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80135be:	2220      	movs	r2, #32
 80135c0:	6823      	ldr	r3, [r4, #0]
 80135c2:	6919      	ldr	r1, [r3, #16]
 80135c4:	4211      	tst	r1, r2
 80135c6:	d007      	beq.n	80135d8 <HAL_TIM_IRQHandler+0x120>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 80135c8:	68d9      	ldr	r1, [r3, #12]
 80135ca:	4211      	tst	r1, r2
 80135cc:	d004      	beq.n	80135d8 <HAL_TIM_IRQHandler+0x120>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80135ce:	3a41      	subs	r2, #65	; 0x41
 80135d0:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutationCallback(htim);
 80135d2:	0020      	movs	r0, r4
 80135d4:	f000 f8a7 	bl	8013726 <HAL_TIMEx_CommutationCallback>
    }
  }
}
 80135d8:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80135da:	f7ff ff69 	bl	80134b0 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80135de:	0020      	movs	r0, r4
 80135e0:	f7ff ff68 	bl	80134b4 <HAL_TIM_PWM_PulseFinishedCallback>
 80135e4:	e77d      	b.n	80134e2 <HAL_TIM_IRQHandler+0x2a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80135e6:	f7ff ff63 	bl	80134b0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80135ea:	0020      	movs	r0, r4
 80135ec:	f7ff ff62 	bl	80134b4 <HAL_TIM_PWM_PulseFinishedCallback>
 80135f0:	e78f      	b.n	8013512 <HAL_TIM_IRQHandler+0x5a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80135f2:	f7ff ff5d 	bl	80134b0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80135f6:	0020      	movs	r0, r4
 80135f8:	f7ff ff5c 	bl	80134b4 <HAL_TIM_PWM_PulseFinishedCallback>
 80135fc:	e79e      	b.n	801353c <HAL_TIM_IRQHandler+0x84>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80135fe:	f7ff ff57 	bl	80134b0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8013602:	0020      	movs	r0, r4
 8013604:	f7ff ff56 	bl	80134b4 <HAL_TIM_PWM_PulseFinishedCallback>
 8013608:	e7af      	b.n	801356a <HAL_TIM_IRQHandler+0xb2>
	...

0801360c <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 801360c:	4a1e      	ldr	r2, [pc, #120]	; (8013688 <TIM_Base_SetConfig+0x7c>)
{
 801360e:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8013610:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8013612:	4290      	cmp	r0, r2
 8013614:	d006      	beq.n	8013624 <TIM_Base_SetConfig+0x18>
 8013616:	2480      	movs	r4, #128	; 0x80
 8013618:	05e4      	lsls	r4, r4, #23
 801361a:	42a0      	cmp	r0, r4
 801361c:	d002      	beq.n	8013624 <TIM_Base_SetConfig+0x18>
 801361e:	4c1b      	ldr	r4, [pc, #108]	; (801368c <TIM_Base_SetConfig+0x80>)
 8013620:	42a0      	cmp	r0, r4
 8013622:	d10c      	bne.n	801363e <TIM_Base_SetConfig+0x32>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8013624:	2470      	movs	r4, #112	; 0x70
 8013626:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 8013628:	684c      	ldr	r4, [r1, #4]
 801362a:	4323      	orrs	r3, r4
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 801362c:	4290      	cmp	r0, r2
 801362e:	d012      	beq.n	8013656 <TIM_Base_SetConfig+0x4a>
 8013630:	2480      	movs	r4, #128	; 0x80
 8013632:	05e4      	lsls	r4, r4, #23
 8013634:	42a0      	cmp	r0, r4
 8013636:	d00e      	beq.n	8013656 <TIM_Base_SetConfig+0x4a>
 8013638:	4c14      	ldr	r4, [pc, #80]	; (801368c <TIM_Base_SetConfig+0x80>)
 801363a:	42a0      	cmp	r0, r4
 801363c:	d00b      	beq.n	8013656 <TIM_Base_SetConfig+0x4a>
 801363e:	4c14      	ldr	r4, [pc, #80]	; (8013690 <TIM_Base_SetConfig+0x84>)
 8013640:	42a0      	cmp	r0, r4
 8013642:	d008      	beq.n	8013656 <TIM_Base_SetConfig+0x4a>
 8013644:	4c13      	ldr	r4, [pc, #76]	; (8013694 <TIM_Base_SetConfig+0x88>)
 8013646:	42a0      	cmp	r0, r4
 8013648:	d005      	beq.n	8013656 <TIM_Base_SetConfig+0x4a>
 801364a:	4c13      	ldr	r4, [pc, #76]	; (8013698 <TIM_Base_SetConfig+0x8c>)
 801364c:	42a0      	cmp	r0, r4
 801364e:	d002      	beq.n	8013656 <TIM_Base_SetConfig+0x4a>
 8013650:	4c12      	ldr	r4, [pc, #72]	; (801369c <TIM_Base_SetConfig+0x90>)
 8013652:	42a0      	cmp	r0, r4
 8013654:	d103      	bne.n	801365e <TIM_Base_SetConfig+0x52>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8013656:	4c12      	ldr	r4, [pc, #72]	; (80136a0 <TIM_Base_SetConfig+0x94>)
 8013658:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 801365a:	68cc      	ldr	r4, [r1, #12]
 801365c:	4323      	orrs	r3, r4
  }

  TIMx->CR1 = tmpcr1;
 801365e:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8013660:	688b      	ldr	r3, [r1, #8]
 8013662:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8013664:	680b      	ldr	r3, [r1, #0]
 8013666:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8013668:	4290      	cmp	r0, r2
 801366a:	d008      	beq.n	801367e <TIM_Base_SetConfig+0x72>
 801366c:	4b09      	ldr	r3, [pc, #36]	; (8013694 <TIM_Base_SetConfig+0x88>)
 801366e:	4298      	cmp	r0, r3
 8013670:	d005      	beq.n	801367e <TIM_Base_SetConfig+0x72>
 8013672:	4b09      	ldr	r3, [pc, #36]	; (8013698 <TIM_Base_SetConfig+0x8c>)
 8013674:	4298      	cmp	r0, r3
 8013676:	d002      	beq.n	801367e <TIM_Base_SetConfig+0x72>
 8013678:	4b08      	ldr	r3, [pc, #32]	; (801369c <TIM_Base_SetConfig+0x90>)
 801367a:	4298      	cmp	r0, r3
 801367c:	d101      	bne.n	8013682 <TIM_Base_SetConfig+0x76>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 801367e:	690b      	ldr	r3, [r1, #16]
 8013680:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 8013682:	2301      	movs	r3, #1
 8013684:	6143      	str	r3, [r0, #20]
}
 8013686:	bd10      	pop	{r4, pc}
 8013688:	40012c00 	.word	0x40012c00
 801368c:	40000400 	.word	0x40000400
 8013690:	40002000 	.word	0x40002000
 8013694:	40014000 	.word	0x40014000
 8013698:	40014400 	.word	0x40014400
 801369c:	40014800 	.word	0x40014800
 80136a0:	fffffcff 	.word	0xfffffcff

080136a4 <HAL_TIM_Base_Init>:
{
 80136a4:	b570      	push	{r4, r5, r6, lr}
 80136a6:	0004      	movs	r4, r0
    return HAL_ERROR;
 80136a8:	2001      	movs	r0, #1
  if(htim == NULL)
 80136aa:	2c00      	cmp	r4, #0
 80136ac:	d014      	beq.n	80136d8 <HAL_TIM_Base_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 80136ae:	0025      	movs	r5, r4
 80136b0:	3539      	adds	r5, #57	; 0x39
 80136b2:	782b      	ldrb	r3, [r5, #0]
 80136b4:	b2db      	uxtb	r3, r3
 80136b6:	2b00      	cmp	r3, #0
 80136b8:	d105      	bne.n	80136c6 <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 80136ba:	0022      	movs	r2, r4
 80136bc:	3238      	adds	r2, #56	; 0x38
 80136be:	7013      	strb	r3, [r2, #0]
    HAL_TIM_Base_MspInit(htim);
 80136c0:	0020      	movs	r0, r4
 80136c2:	f7ff fec1 	bl	8013448 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 80136c6:	2302      	movs	r3, #2
 80136c8:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80136ca:	6820      	ldr	r0, [r4, #0]
 80136cc:	1d21      	adds	r1, r4, #4
 80136ce:	f7ff ff9d 	bl	801360c <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 80136d2:	2301      	movs	r3, #1
  return HAL_OK;
 80136d4:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 80136d6:	702b      	strb	r3, [r5, #0]
}
 80136d8:	bd70      	pop	{r4, r5, r6, pc}

080136da <HAL_TIMEx_MasterConfigSynchronization>:
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);
 80136da:	0002      	movs	r2, r0
{
 80136dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80136de:	2602      	movs	r6, #2
  __HAL_LOCK(htim);
 80136e0:	3238      	adds	r2, #56	; 0x38
 80136e2:	7814      	ldrb	r4, [r2, #0]
{
 80136e4:	0003      	movs	r3, r0
  __HAL_LOCK(htim);
 80136e6:	0030      	movs	r0, r6
 80136e8:	2c01      	cmp	r4, #1
 80136ea:	d01b      	beq.n	8013724 <HAL_TIMEx_MasterConfigSynchronization+0x4a>

  htim->State = HAL_TIM_STATE_BUSY;
 80136ec:	001c      	movs	r4, r3
  __HAL_LOCK(htim);
 80136ee:	2501      	movs	r5, #1

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 80136f0:	2770      	movs	r7, #112	; 0x70
  htim->State = HAL_TIM_STATE_BUSY;
 80136f2:	3439      	adds	r4, #57	; 0x39
  __HAL_LOCK(htim);
 80136f4:	7015      	strb	r5, [r2, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80136f6:	7026      	strb	r6, [r4, #0]
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 80136f8:	681e      	ldr	r6, [r3, #0]
 80136fa:	6870      	ldr	r0, [r6, #4]
 80136fc:	43b8      	bics	r0, r7
 80136fe:	6070      	str	r0, [r6, #4]
  /* Select the TRGO source */
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 8013700:	681e      	ldr	r6, [r3, #0]
 8013702:	680f      	ldr	r7, [r1, #0]
 8013704:	6870      	ldr	r0, [r6, #4]
 8013706:	4338      	orrs	r0, r7

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 8013708:	2780      	movs	r7, #128	; 0x80
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 801370a:	6070      	str	r0, [r6, #4]
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 801370c:	681e      	ldr	r6, [r3, #0]
 801370e:	68b0      	ldr	r0, [r6, #8]
 8013710:	43b8      	bics	r0, r7
 8013712:	60b0      	str	r0, [r6, #8]
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8013714:	6818      	ldr	r0, [r3, #0]
 8013716:	6849      	ldr	r1, [r1, #4]
 8013718:	6883      	ldr	r3, [r0, #8]
 801371a:	430b      	orrs	r3, r1
 801371c:	6083      	str	r3, [r0, #8]

  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 801371e:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8013720:	7025      	strb	r5, [r4, #0]
  __HAL_UNLOCK(htim);
 8013722:	7010      	strb	r0, [r2, #0]

  return HAL_OK;
}
 8013724:	bdf0      	pop	{r4, r5, r6, r7, pc}

08013726 <HAL_TIMEx_CommutationCallback>:
 8013726:	4770      	bx	lr

08013728 <HAL_TIMEx_BreakCallback>:
 8013728:	4770      	bx	lr

0801372a <HAL_UART_MspDeInit>:
 801372a:	4770      	bx	lr

0801372c <HAL_UART_DeInit>:
  * @brief DeInitialize the UART peripheral.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
 801372c:	b570      	push	{r4, r5, r6, lr}
 801372e:	0005      	movs	r5, r0
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 8013730:	2001      	movs	r0, #1
  if(huart == NULL)
 8013732:	2d00      	cmp	r5, #0
 8013734:	d016      	beq.n	8013764 <HAL_UART_DeInit+0x38>
  }

  /* Check the parameters */
  assert_param(IS_UART_INSTANCE(huart->Instance));

  huart->State = HAL_UART_STATE_BUSY;
 8013736:	002e      	movs	r6, r5
 8013738:	2302      	movs	r3, #2

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);

  huart->Instance->CR1 = 0x0;
 801373a:	2400      	movs	r4, #0
  huart->State = HAL_UART_STATE_BUSY;
 801373c:	3669      	adds	r6, #105	; 0x69
 801373e:	7033      	strb	r3, [r6, #0]
  __HAL_UART_DISABLE(huart);
 8013740:	682a      	ldr	r2, [r5, #0]
 8013742:	6813      	ldr	r3, [r2, #0]
 8013744:	4383      	bics	r3, r0
 8013746:	6013      	str	r3, [r2, #0]
  huart->Instance->CR1 = 0x0;
 8013748:	682b      	ldr	r3, [r5, #0]
  huart->Instance->CR2 = 0x0;
  huart->Instance->CR3 = 0x0;

  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);
 801374a:	0028      	movs	r0, r5
  huart->Instance->CR1 = 0x0;
 801374c:	601c      	str	r4, [r3, #0]
  huart->Instance->CR2 = 0x0;
 801374e:	682b      	ldr	r3, [r5, #0]
 8013750:	605c      	str	r4, [r3, #4]
  huart->Instance->CR3 = 0x0;
 8013752:	682b      	ldr	r3, [r5, #0]

  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->State = HAL_UART_STATE_RESET;

  /* Process Unlock */
  __HAL_UNLOCK(huart);
 8013754:	3568      	adds	r5, #104	; 0x68
  huart->Instance->CR3 = 0x0;
 8013756:	609c      	str	r4, [r3, #8]
  HAL_UART_MspDeInit(huart);
 8013758:	f7ff ffe7 	bl	801372a <HAL_UART_MspDeInit>

  return HAL_OK;
 801375c:	0020      	movs	r0, r4
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 801375e:	606c      	str	r4, [r5, #4]
  huart->State = HAL_UART_STATE_RESET;
 8013760:	7034      	strb	r4, [r6, #0]
  __HAL_UNLOCK(huart);
 8013762:	702c      	strb	r4, [r5, #0]
}
 8013764:	bd70      	pop	{r4, r5, r6, pc}

08013766 <HAL_UART_Transmit_IT>:
  * @param Size: amount of data to be sent.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013766:	0003      	movs	r3, r0
{
 8013768:	b570      	push	{r4, r5, r6, lr}
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 801376a:	3369      	adds	r3, #105	; 0x69
{
 801376c:	0004      	movs	r4, r0
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 801376e:	7818      	ldrb	r0, [r3, #0]
 8013770:	2801      	cmp	r0, #1
 8013772:	d003      	beq.n	801377c <HAL_UART_Transmit_IT+0x16>
 8013774:	781d      	ldrb	r5, [r3, #0]

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8013776:	2002      	movs	r0, #2
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013778:	2d22      	cmp	r5, #34	; 0x22
 801377a:	d123      	bne.n	80137c4 <HAL_UART_Transmit_IT+0x5e>
      return HAL_ERROR;
 801377c:	2001      	movs	r0, #1
    if((pData == NULL ) || (Size == 0))
 801377e:	2900      	cmp	r1, #0
 8013780:	d020      	beq.n	80137c4 <HAL_UART_Transmit_IT+0x5e>
 8013782:	2a00      	cmp	r2, #0
 8013784:	d01e      	beq.n	80137c4 <HAL_UART_Transmit_IT+0x5e>
    __HAL_LOCK(huart);
 8013786:	0025      	movs	r5, r4
 8013788:	3568      	adds	r5, #104	; 0x68
 801378a:	782e      	ldrb	r6, [r5, #0]
 801378c:	4286      	cmp	r6, r0
 801378e:	d01c      	beq.n	80137ca <HAL_UART_Transmit_IT+0x64>
 8013790:	7028      	strb	r0, [r5, #0]
    huart->pTxBuffPtr = pData;
 8013792:	64e1      	str	r1, [r4, #76]	; 0x4c
    huart->TxXferSize = Size;
 8013794:	0021      	movs	r1, r4
 8013796:	3150      	adds	r1, #80	; 0x50
 8013798:	800a      	strh	r2, [r1, #0]
    huart->TxXferCount = Size;
 801379a:	804a      	strh	r2, [r1, #2]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 801379c:	2200      	movs	r2, #0
 801379e:	66e2      	str	r2, [r4, #108]	; 0x6c
    if(huart->State == HAL_UART_STATE_BUSY_RX)
 80137a0:	781a      	ldrb	r2, [r3, #0]
 80137a2:	2a22      	cmp	r2, #34	; 0x22
 80137a4:	d10f      	bne.n	80137c6 <HAL_UART_Transmit_IT+0x60>
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 80137a6:	3210      	adds	r2, #16
      huart->State = HAL_UART_STATE_BUSY_TX;
 80137a8:	701a      	strb	r2, [r3, #0]
    __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
 80137aa:	2301      	movs	r3, #1
 80137ac:	6822      	ldr	r2, [r4, #0]
 80137ae:	6891      	ldr	r1, [r2, #8]
 80137b0:	430b      	orrs	r3, r1
 80137b2:	6093      	str	r3, [r2, #8]
    __HAL_UNLOCK(huart);
 80137b4:	2300      	movs	r3, #0
    __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
 80137b6:	2280      	movs	r2, #128	; 0x80
    __HAL_UNLOCK(huart);
 80137b8:	702b      	strb	r3, [r5, #0]
    __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
 80137ba:	6821      	ldr	r1, [r4, #0]
 80137bc:	6808      	ldr	r0, [r1, #0]
 80137be:	4302      	orrs	r2, r0
    return HAL_OK;
 80137c0:	0018      	movs	r0, r3
    __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
 80137c2:	600a      	str	r2, [r1, #0]
  }
}
 80137c4:	bd70      	pop	{r4, r5, r6, pc}
      huart->State = HAL_UART_STATE_BUSY_TX;
 80137c6:	2212      	movs	r2, #18
 80137c8:	e7ee      	b.n	80137a8 <HAL_UART_Transmit_IT+0x42>
    return HAL_BUSY;
 80137ca:	2002      	movs	r0, #2
 80137cc:	e7fa      	b.n	80137c4 <HAL_UART_Transmit_IT+0x5e>
	...

080137d0 <HAL_UART_Receive_IT>:
  * @param pData: pointer to data buffer.
  * @param Size: amount of data to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80137d0:	b570      	push	{r4, r5, r6, lr}
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 80137d2:	0004      	movs	r4, r0
 80137d4:	3469      	adds	r4, #105	; 0x69
{
 80137d6:	0003      	movs	r3, r0
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 80137d8:	7820      	ldrb	r0, [r4, #0]
 80137da:	2801      	cmp	r0, #1
 80137dc:	d003      	beq.n	80137e6 <HAL_UART_Receive_IT+0x16>
 80137de:	7825      	ldrb	r5, [r4, #0]

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 80137e0:	2002      	movs	r0, #2
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 80137e2:	2d12      	cmp	r5, #18
 80137e4:	d134      	bne.n	8013850 <HAL_UART_Receive_IT+0x80>
      return HAL_ERROR;
 80137e6:	2001      	movs	r0, #1
    if((pData == NULL ) || (Size == 0))
 80137e8:	2900      	cmp	r1, #0
 80137ea:	d031      	beq.n	8013850 <HAL_UART_Receive_IT+0x80>
 80137ec:	2a00      	cmp	r2, #0
 80137ee:	d02f      	beq.n	8013850 <HAL_UART_Receive_IT+0x80>
    __HAL_LOCK(huart);
 80137f0:	001d      	movs	r5, r3
 80137f2:	3568      	adds	r5, #104	; 0x68
 80137f4:	782e      	ldrb	r6, [r5, #0]
 80137f6:	4286      	cmp	r6, r0
 80137f8:	d03f      	beq.n	801387a <HAL_UART_Receive_IT+0xaa>
 80137fa:	7028      	strb	r0, [r5, #0]
    huart->pRxBuffPtr = pData;
 80137fc:	6559      	str	r1, [r3, #84]	; 0x54
    huart->RxXferSize = Size;
 80137fe:	0019      	movs	r1, r3
 8013800:	3158      	adds	r1, #88	; 0x58
 8013802:	800a      	strh	r2, [r1, #0]
    huart->RxXferCount = Size;
 8013804:	804a      	strh	r2, [r1, #2]
    UART_MASK_COMPUTATION(huart);
 8013806:	2180      	movs	r1, #128	; 0x80
 8013808:	689a      	ldr	r2, [r3, #8]
 801380a:	0149      	lsls	r1, r1, #5
 801380c:	428a      	cmp	r2, r1
 801380e:	d122      	bne.n	8013856 <HAL_UART_Receive_IT+0x86>
 8013810:	691a      	ldr	r2, [r3, #16]
 8013812:	2a00      	cmp	r2, #0
 8013814:	d11d      	bne.n	8013852 <HAL_UART_Receive_IT+0x82>
 8013816:	491a      	ldr	r1, [pc, #104]	; (8013880 <HAL_UART_Receive_IT+0xb0>)
 8013818:	001a      	movs	r2, r3
 801381a:	325c      	adds	r2, #92	; 0x5c
 801381c:	8011      	strh	r1, [r2, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 801381e:	2200      	movs	r2, #0
 8013820:	66da      	str	r2, [r3, #108]	; 0x6c
    if(huart->State == HAL_UART_STATE_BUSY_TX)
 8013822:	7822      	ldrb	r2, [r4, #0]
 8013824:	2a12      	cmp	r2, #18
 8013826:	d126      	bne.n	8013876 <HAL_UART_Receive_IT+0xa6>
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 8013828:	3220      	adds	r2, #32
      huart->State = HAL_UART_STATE_BUSY_RX;
 801382a:	7022      	strb	r2, [r4, #0]
    __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
 801382c:	2280      	movs	r2, #128	; 0x80
 801382e:	6819      	ldr	r1, [r3, #0]
 8013830:	0052      	lsls	r2, r2, #1
 8013832:	6808      	ldr	r0, [r1, #0]
 8013834:	4302      	orrs	r2, r0
 8013836:	600a      	str	r2, [r1, #0]
    __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
 8013838:	2201      	movs	r2, #1
 801383a:	6819      	ldr	r1, [r3, #0]
 801383c:	6888      	ldr	r0, [r1, #8]
 801383e:	4302      	orrs	r2, r0
    __HAL_UNLOCK(huart);
 8013840:	2000      	movs	r0, #0
    __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
 8013842:	608a      	str	r2, [r1, #8]
    __HAL_UNLOCK(huart);
 8013844:	7028      	strb	r0, [r5, #0]
    __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
 8013846:	681a      	ldr	r2, [r3, #0]
 8013848:	2320      	movs	r3, #32
 801384a:	6811      	ldr	r1, [r2, #0]
 801384c:	430b      	orrs	r3, r1
 801384e:	6013      	str	r3, [r2, #0]
  }
}
 8013850:	bd70      	pop	{r4, r5, r6, pc}
    UART_MASK_COMPUTATION(huart);
 8013852:	21ff      	movs	r1, #255	; 0xff
 8013854:	e7e0      	b.n	8013818 <HAL_UART_Receive_IT+0x48>
 8013856:	2a00      	cmp	r2, #0
 8013858:	d104      	bne.n	8013864 <HAL_UART_Receive_IT+0x94>
 801385a:	691a      	ldr	r2, [r3, #16]
 801385c:	2a00      	cmp	r2, #0
 801385e:	d0f8      	beq.n	8013852 <HAL_UART_Receive_IT+0x82>
 8013860:	217f      	movs	r1, #127	; 0x7f
 8013862:	e7d9      	b.n	8013818 <HAL_UART_Receive_IT+0x48>
 8013864:	2180      	movs	r1, #128	; 0x80
 8013866:	0549      	lsls	r1, r1, #21
 8013868:	428a      	cmp	r2, r1
 801386a:	d1d8      	bne.n	801381e <HAL_UART_Receive_IT+0x4e>
 801386c:	691a      	ldr	r2, [r3, #16]
 801386e:	2a00      	cmp	r2, #0
 8013870:	d0f6      	beq.n	8013860 <HAL_UART_Receive_IT+0x90>
 8013872:	213f      	movs	r1, #63	; 0x3f
 8013874:	e7d0      	b.n	8013818 <HAL_UART_Receive_IT+0x48>
      huart->State = HAL_UART_STATE_BUSY_RX;
 8013876:	2222      	movs	r2, #34	; 0x22
 8013878:	e7d7      	b.n	801382a <HAL_UART_Receive_IT+0x5a>
    return HAL_BUSY;
 801387a:	2002      	movs	r0, #2
 801387c:	e7e8      	b.n	8013850 <HAL_UART_Receive_IT+0x80>
 801387e:	46c0      	nop			; (mov r8, r8)
 8013880:	000001ff 	.word	0x000001ff

08013884 <HAL_UART_Transmit_DMA>:
  * @param pData: pointer to data buffer.
  * @param Size: amount of data to be sent.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8013884:	b570      	push	{r4, r5, r6, lr}
  uint32_t *tmp;

  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013886:	0006      	movs	r6, r0
 8013888:	3669      	adds	r6, #105	; 0x69
{
 801388a:	0013      	movs	r3, r2
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 801388c:	7832      	ldrb	r2, [r6, #0]
{
 801388e:	0004      	movs	r4, r0
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013890:	2a01      	cmp	r2, #1
 8013892:	d003      	beq.n	801389c <HAL_UART_Transmit_DMA+0x18>
 8013894:	7832      	ldrb	r2, [r6, #0]

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8013896:	2002      	movs	r0, #2
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013898:	2a22      	cmp	r2, #34	; 0x22
 801389a:	d12e      	bne.n	80138fa <HAL_UART_Transmit_DMA+0x76>
      return HAL_ERROR;
 801389c:	2001      	movs	r0, #1
    if((pData == NULL ) || (Size == 0))
 801389e:	2900      	cmp	r1, #0
 80138a0:	d02b      	beq.n	80138fa <HAL_UART_Transmit_DMA+0x76>
 80138a2:	2b00      	cmp	r3, #0
 80138a4:	d029      	beq.n	80138fa <HAL_UART_Transmit_DMA+0x76>
    __HAL_LOCK(huart);
 80138a6:	0025      	movs	r5, r4
 80138a8:	3568      	adds	r5, #104	; 0x68
 80138aa:	782a      	ldrb	r2, [r5, #0]
 80138ac:	4282      	cmp	r2, r0
 80138ae:	d027      	beq.n	8013900 <HAL_UART_Transmit_DMA+0x7c>
    huart->TxXferSize = Size;
 80138b0:	0022      	movs	r2, r4
 80138b2:	3250      	adds	r2, #80	; 0x50
    __HAL_LOCK(huart);
 80138b4:	7028      	strb	r0, [r5, #0]
    huart->pTxBuffPtr = pData;
 80138b6:	64e1      	str	r1, [r4, #76]	; 0x4c
    huart->TxXferSize = Size;
 80138b8:	8013      	strh	r3, [r2, #0]
    huart->TxXferCount = Size;
 80138ba:	8053      	strh	r3, [r2, #2]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80138bc:	2200      	movs	r2, #0
 80138be:	66e2      	str	r2, [r4, #108]	; 0x6c
    if(huart->State == HAL_UART_STATE_BUSY_RX)
 80138c0:	7832      	ldrb	r2, [r6, #0]
 80138c2:	2a22      	cmp	r2, #34	; 0x22
 80138c4:	d11a      	bne.n	80138fc <HAL_UART_Transmit_DMA+0x78>
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 80138c6:	3210      	adds	r2, #16
      huart->State = HAL_UART_STATE_BUSY_TX;
 80138c8:	7032      	strb	r2, [r6, #0]
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 80138ca:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80138cc:	480d      	ldr	r0, [pc, #52]	; (8013904 <HAL_UART_Transmit_DMA+0x80>)
 80138ce:	6290      	str	r0, [r2, #40]	; 0x28
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 80138d0:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80138d2:	480d      	ldr	r0, [pc, #52]	; (8013908 <HAL_UART_Transmit_DMA+0x84>)
 80138d4:	62d0      	str	r0, [r2, #44]	; 0x2c
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 80138d6:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80138d8:	480c      	ldr	r0, [pc, #48]	; (801390c <HAL_UART_Transmit_DMA+0x88>)
 80138da:	6310      	str	r0, [r2, #48]	; 0x30
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
 80138dc:	6822      	ldr	r2, [r4, #0]
 80138de:	6e20      	ldr	r0, [r4, #96]	; 0x60
 80138e0:	3228      	adds	r2, #40	; 0x28
 80138e2:	f7fd ffcd 	bl	8011880 <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 80138e6:	2240      	movs	r2, #64	; 0x40
 80138e8:	6823      	ldr	r3, [r4, #0]
    __HAL_UNLOCK(huart);
 80138ea:	2000      	movs	r0, #0
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 80138ec:	621a      	str	r2, [r3, #32]
    huart->Instance->CR3 |= USART_CR3_DMAT;
 80138ee:	2380      	movs	r3, #128	; 0x80
 80138f0:	6822      	ldr	r2, [r4, #0]
 80138f2:	6891      	ldr	r1, [r2, #8]
 80138f4:	430b      	orrs	r3, r1
 80138f6:	6093      	str	r3, [r2, #8]
    __HAL_UNLOCK(huart);
 80138f8:	7028      	strb	r0, [r5, #0]
  }
}
 80138fa:	bd70      	pop	{r4, r5, r6, pc}
      huart->State = HAL_UART_STATE_BUSY_TX;
 80138fc:	2212      	movs	r2, #18
 80138fe:	e7e3      	b.n	80138c8 <HAL_UART_Transmit_DMA+0x44>
    return HAL_BUSY;
 8013900:	2002      	movs	r0, #2
 8013902:	e7fa      	b.n	80138fa <HAL_UART_Transmit_DMA+0x76>
 8013904:	08013999 	.word	0x08013999
 8013908:	080139cd 	.word	0x080139cd
 801390c:	08013a1b 	.word	0x08013a1b

08013910 <HAL_UART_Receive_DMA>:
  * @note   When the UART parity is enabled (PCE = 1), the received data contain
  *         the parity bit (MSB position).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8013910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t *tmp;

  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 8013912:	0006      	movs	r6, r0
 8013914:	3669      	adds	r6, #105	; 0x69
{
 8013916:	0013      	movs	r3, r2
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 8013918:	7832      	ldrb	r2, [r6, #0]
{
 801391a:	0004      	movs	r4, r0
 801391c:	000f      	movs	r7, r1
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 801391e:	2a01      	cmp	r2, #1
 8013920:	d003      	beq.n	801392a <HAL_UART_Receive_DMA+0x1a>
 8013922:	7832      	ldrb	r2, [r6, #0]

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8013924:	2002      	movs	r0, #2
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 8013926:	2a12      	cmp	r2, #18
 8013928:	d12b      	bne.n	8013982 <HAL_UART_Receive_DMA+0x72>
      return HAL_ERROR;
 801392a:	2001      	movs	r0, #1
    if((pData == NULL ) || (Size == 0))
 801392c:	2f00      	cmp	r7, #0
 801392e:	d028      	beq.n	8013982 <HAL_UART_Receive_DMA+0x72>
 8013930:	2b00      	cmp	r3, #0
 8013932:	d026      	beq.n	8013982 <HAL_UART_Receive_DMA+0x72>
    __HAL_LOCK(huart);
 8013934:	0025      	movs	r5, r4
 8013936:	3568      	adds	r5, #104	; 0x68
 8013938:	782a      	ldrb	r2, [r5, #0]
 801393a:	4282      	cmp	r2, r0
 801393c:	d024      	beq.n	8013988 <HAL_UART_Receive_DMA+0x78>
    huart->RxXferSize = Size;
 801393e:	0022      	movs	r2, r4
 8013940:	3258      	adds	r2, #88	; 0x58
    __HAL_LOCK(huart);
 8013942:	7028      	strb	r0, [r5, #0]
    huart->pRxBuffPtr = pData;
 8013944:	6567      	str	r7, [r4, #84]	; 0x54
    huart->RxXferSize = Size;
 8013946:	8013      	strh	r3, [r2, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8013948:	2200      	movs	r2, #0
 801394a:	66e2      	str	r2, [r4, #108]	; 0x6c
    if(huart->State == HAL_UART_STATE_BUSY_TX)
 801394c:	7832      	ldrb	r2, [r6, #0]
 801394e:	2a12      	cmp	r2, #18
 8013950:	d118      	bne.n	8013984 <HAL_UART_Receive_DMA+0x74>
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 8013952:	3220      	adds	r2, #32
      huart->State = HAL_UART_STATE_BUSY_RX;
 8013954:	7032      	strb	r2, [r6, #0]
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8013956:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8013958:	490c      	ldr	r1, [pc, #48]	; (801398c <HAL_UART_Receive_DMA+0x7c>)
 801395a:	6291      	str	r1, [r2, #40]	; 0x28
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 801395c:	6e62      	ldr	r2, [r4, #100]	; 0x64
 801395e:	490c      	ldr	r1, [pc, #48]	; (8013990 <HAL_UART_Receive_DMA+0x80>)
 8013960:	62d1      	str	r1, [r2, #44]	; 0x2c
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 8013962:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8013964:	490b      	ldr	r1, [pc, #44]	; (8013994 <HAL_UART_Receive_DMA+0x84>)
 8013966:	6311      	str	r1, [r2, #48]	; 0x30
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
 8013968:	6821      	ldr	r1, [r4, #0]
 801396a:	003a      	movs	r2, r7
 801396c:	3124      	adds	r1, #36	; 0x24
 801396e:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8013970:	f7fd ff86 	bl	8011880 <HAL_DMA_Start_IT>
     huart->Instance->CR3 |= USART_CR3_DMAR;
 8013974:	2340      	movs	r3, #64	; 0x40
     __HAL_UNLOCK(huart);
 8013976:	2000      	movs	r0, #0
     huart->Instance->CR3 |= USART_CR3_DMAR;
 8013978:	6822      	ldr	r2, [r4, #0]
 801397a:	6891      	ldr	r1, [r2, #8]
 801397c:	430b      	orrs	r3, r1
 801397e:	6093      	str	r3, [r2, #8]
     __HAL_UNLOCK(huart);
 8013980:	7028      	strb	r0, [r5, #0]
  }
}
 8013982:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      huart->State = HAL_UART_STATE_BUSY_RX;
 8013984:	2222      	movs	r2, #34	; 0x22
 8013986:	e7e5      	b.n	8013954 <HAL_UART_Receive_DMA+0x44>
    return HAL_BUSY;
 8013988:	2002      	movs	r0, #2
 801398a:	e7fa      	b.n	8013982 <HAL_UART_Receive_DMA+0x72>
 801398c:	080139d7 	.word	0x080139d7
 8013990:	08013a11 	.word	0x08013a11
 8013994:	08013a1b 	.word	0x08013a1b

08013998 <UART_DMATransmitCplt>:
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* DMA Normal mode */
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 8013998:	2120      	movs	r1, #32
{
 801399a:	b510      	push	{r4, lr}
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 801399c:	6802      	ldr	r2, [r0, #0]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 801399e:	6a43      	ldr	r3, [r0, #36]	; 0x24
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80139a0:	6812      	ldr	r2, [r2, #0]
 80139a2:	400a      	ands	r2, r1
 80139a4:	d10d      	bne.n	80139c2 <UART_DMATransmitCplt+0x2a>
  {  
    huart->TxXferCount = 0;
 80139a6:	0019      	movs	r1, r3
  
    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
    in the UART CR3 register */
    huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAT);
 80139a8:	2080      	movs	r0, #128	; 0x80
    huart->TxXferCount = 0;
 80139aa:	3152      	adds	r1, #82	; 0x52
 80139ac:	800a      	strh	r2, [r1, #0]
    huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAT);
 80139ae:	6819      	ldr	r1, [r3, #0]
 80139b0:	688a      	ldr	r2, [r1, #8]
 80139b2:	4382      	bics	r2, r0
 80139b4:	608a      	str	r2, [r1, #8]

    /* Enable the UART Transmit Complete Interrupt */
    __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 80139b6:	681a      	ldr	r2, [r3, #0]
 80139b8:	2340      	movs	r3, #64	; 0x40
 80139ba:	6811      	ldr	r1, [r2, #0]
 80139bc:	430b      	orrs	r3, r1
 80139be:	6013      	str	r3, [r2, #0]
  else
  {
    HAL_UART_TxCpltCallback(huart);
  }

}
 80139c0:	bd10      	pop	{r4, pc}
    HAL_UART_TxCpltCallback(huart);
 80139c2:	0018      	movs	r0, r3
 80139c4:	f7f8 fc76 	bl	800c2b4 <HAL_UART_TxCpltCallback>
}
 80139c8:	e7fa      	b.n	80139c0 <UART_DMATransmitCplt+0x28>

080139ca <HAL_UART_TxHalfCpltCallback>:
 80139ca:	4770      	bx	lr

080139cc <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma : DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 80139cc:	b510      	push	{r4, lr}
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_UART_TxHalfCpltCallback(huart);
 80139ce:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80139d0:	f7ff fffb 	bl	80139ca <HAL_UART_TxHalfCpltCallback>
}
 80139d4:	bd10      	pop	{r4, pc}

080139d6 <UART_DMAReceiveCplt>:
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* DMA Normal mode */
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80139d6:	2120      	movs	r1, #32
{
 80139d8:	b510      	push	{r4, lr}
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80139da:	6802      	ldr	r2, [r0, #0]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80139dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
  if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
 80139de:	6812      	ldr	r2, [r2, #0]
 80139e0:	400a      	ands	r2, r1
 80139e2:	d10e      	bne.n	8013a02 <UART_DMAReceiveCplt+0x2c>
  {
    huart->RxXferCount = 0;
 80139e4:	0019      	movs	r1, r3

    /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
       in the UART CR3 register */
    huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
 80139e6:	2040      	movs	r0, #64	; 0x40
    huart->RxXferCount = 0;
 80139e8:	315a      	adds	r1, #90	; 0x5a
 80139ea:	800a      	strh	r2, [r1, #0]
    huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
 80139ec:	6819      	ldr	r1, [r3, #0]
 80139ee:	688a      	ldr	r2, [r1, #8]
 80139f0:	4382      	bics	r2, r0
 80139f2:	608a      	str	r2, [r1, #8]

    /* Check if a transmit Process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
 80139f4:	001a      	movs	r2, r3
 80139f6:	3269      	adds	r2, #105	; 0x69
 80139f8:	7811      	ldrb	r1, [r2, #0]
 80139fa:	2932      	cmp	r1, #50	; 0x32
 80139fc:	d105      	bne.n	8013a0a <UART_DMAReceiveCplt+0x34>
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
 80139fe:	3920      	subs	r1, #32
    }
    else
    {
      huart->State = HAL_UART_STATE_READY;
 8013a00:	7011      	strb	r1, [r2, #0]
    }
  }
  
  HAL_UART_RxCpltCallback(huart);
 8013a02:	0018      	movs	r0, r3
 8013a04:	f7f8 fc92 	bl	800c32c <HAL_UART_RxCpltCallback>
}
 8013a08:	bd10      	pop	{r4, pc}
      huart->State = HAL_UART_STATE_READY;
 8013a0a:	2101      	movs	r1, #1
 8013a0c:	e7f8      	b.n	8013a00 <UART_DMAReceiveCplt+0x2a>

08013a0e <HAL_UART_RxHalfCpltCallback>:
 8013a0e:	4770      	bx	lr

08013a10 <UART_DMARxHalfCplt>:
  * @brief DMA UART receive process half complete callback.
  * @param hdma : DMA handle.
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8013a10:	b510      	push	{r4, lr}
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_UART_RxHalfCpltCallback(huart);
 8013a12:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8013a14:	f7ff fffb 	bl	8013a0e <HAL_UART_RxHalfCpltCallback>
}
 8013a18:	bd10      	pop	{r4, pc}

08013a1a <UART_DMAError>:
  * @brief DMA UART communication error callback.
  * @param hdma: DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 8013a1a:	b510      	push	{r4, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8013a1c:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->RxXferCount = 0;
 8013a1e:	2300      	movs	r3, #0
 8013a20:	0002      	movs	r2, r0
 8013a22:	325a      	adds	r2, #90	; 0x5a
 8013a24:	8013      	strh	r3, [r2, #0]
  huart->TxXferCount = 0;
 8013a26:	3a08      	subs	r2, #8
 8013a28:	8013      	strh	r3, [r2, #0]
  huart->State= HAL_UART_STATE_READY;
 8013a2a:	0003      	movs	r3, r0
 8013a2c:	2201      	movs	r2, #1
 8013a2e:	3369      	adds	r3, #105	; 0x69
 8013a30:	701a      	strb	r2, [r3, #0]
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8013a32:	2310      	movs	r3, #16
 8013a34:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8013a36:	4313      	orrs	r3, r2
 8013a38:	66c3      	str	r3, [r0, #108]	; 0x6c
  HAL_UART_ErrorCallback(huart);
 8013a3a:	f7f8 fc51 	bl	800c2e0 <HAL_UART_ErrorCallback>
}
 8013a3e:	bd10      	pop	{r4, pc}

08013a40 <UART_SetConfig>:
{
 8013a40:	b570      	push	{r4, r5, r6, lr}
 8013a42:	0004      	movs	r4, r0
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8013a44:	6801      	ldr	r1, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8013a46:	6883      	ldr	r3, [r0, #8]
 8013a48:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8013a4a:	680a      	ldr	r2, [r1, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8013a4c:	4303      	orrs	r3, r0
 8013a4e:	6960      	ldr	r0, [r4, #20]
 8013a50:	4303      	orrs	r3, r0
 8013a52:	69e0      	ldr	r0, [r4, #28]
 8013a54:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8013a56:	4856      	ldr	r0, [pc, #344]	; (8013bb0 <UART_SetConfig+0x170>)
 8013a58:	4002      	ands	r2, r0
 8013a5a:	4313      	orrs	r3, r2
 8013a5c:	600b      	str	r3, [r1, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8013a5e:	6822      	ldr	r2, [r4, #0]
 8013a60:	4954      	ldr	r1, [pc, #336]	; (8013bb4 <UART_SetConfig+0x174>)
 8013a62:	6853      	ldr	r3, [r2, #4]
 8013a64:	400b      	ands	r3, r1
 8013a66:	68e1      	ldr	r1, [r4, #12]
 8013a68:	430b      	orrs	r3, r1
 8013a6a:	6053      	str	r3, [r2, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8013a6c:	6a20      	ldr	r0, [r4, #32]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8013a6e:	6821      	ldr	r1, [r4, #0]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8013a70:	69a3      	ldr	r3, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8013a72:	688a      	ldr	r2, [r1, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8013a74:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8013a76:	4850      	ldr	r0, [pc, #320]	; (8013bb8 <UART_SetConfig+0x178>)
 8013a78:	4002      	ands	r2, r0
 8013a7a:	4313      	orrs	r3, r2
 8013a7c:	608b      	str	r3, [r1, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 8013a7e:	6825      	ldr	r5, [r4, #0]
 8013a80:	4b4e      	ldr	r3, [pc, #312]	; (8013bbc <UART_SetConfig+0x17c>)
 8013a82:	429d      	cmp	r5, r3
 8013a84:	d114      	bne.n	8013ab0 <UART_SetConfig+0x70>
 8013a86:	2203      	movs	r2, #3
 8013a88:	4b4d      	ldr	r3, [pc, #308]	; (8013bc0 <UART_SetConfig+0x180>)
 8013a8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013a8c:	4013      	ands	r3, r2
 8013a8e:	4a4d      	ldr	r2, [pc, #308]	; (8013bc4 <UART_SetConfig+0x184>)
 8013a90:	5cd0      	ldrb	r0, [r2, r3]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8013a92:	2380      	movs	r3, #128	; 0x80
 8013a94:	69e2      	ldr	r2, [r4, #28]
 8013a96:	021b      	lsls	r3, r3, #8
 8013a98:	429a      	cmp	r2, r3
 8013a9a:	d000      	beq.n	8013a9e <UART_SetConfig+0x5e>
 8013a9c:	e067      	b.n	8013b6e <UART_SetConfig+0x12e>
    switch (clocksource)
 8013a9e:	2808      	cmp	r0, #8
 8013aa0:	d862      	bhi.n	8013b68 <UART_SetConfig+0x128>
 8013aa2:	f7ec fb4b 	bl	800013c <__gnu_thumb1_case_uqi>
 8013aa6:	6145      	.short	0x6145
 8013aa8:	615a614a 	.word	0x615a614a
 8013aac:	6161      	.short	0x6161
 8013aae:	5d          	.byte	0x5d
 8013aaf:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8013ab0:	4b45      	ldr	r3, [pc, #276]	; (8013bc8 <UART_SetConfig+0x188>)
 8013ab2:	429d      	cmp	r5, r3
 8013ab4:	d118      	bne.n	8013ae8 <UART_SetConfig+0xa8>
 8013ab6:	22c0      	movs	r2, #192	; 0xc0
 8013ab8:	2180      	movs	r1, #128	; 0x80
 8013aba:	4b41      	ldr	r3, [pc, #260]	; (8013bc0 <UART_SetConfig+0x180>)
 8013abc:	0292      	lsls	r2, r2, #10
 8013abe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013ac0:	0249      	lsls	r1, r1, #9
 8013ac2:	4013      	ands	r3, r2
 8013ac4:	2004      	movs	r0, #4
 8013ac6:	428b      	cmp	r3, r1
 8013ac8:	d0e3      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013aca:	d804      	bhi.n	8013ad6 <UART_SetConfig+0x96>
 8013acc:	2000      	movs	r0, #0
 8013ace:	4283      	cmp	r3, r0
 8013ad0:	d0df      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013ad2:	2010      	movs	r0, #16
 8013ad4:	e7dd      	b.n	8013a92 <UART_SetConfig+0x52>
 8013ad6:	2180      	movs	r1, #128	; 0x80
 8013ad8:	0289      	lsls	r1, r1, #10
 8013ada:	2008      	movs	r0, #8
 8013adc:	428b      	cmp	r3, r1
 8013ade:	d0d8      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013ae0:	3806      	subs	r0, #6
 8013ae2:	4293      	cmp	r3, r2
 8013ae4:	d0d5      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013ae6:	e7f4      	b.n	8013ad2 <UART_SetConfig+0x92>
 8013ae8:	4b38      	ldr	r3, [pc, #224]	; (8013bcc <UART_SetConfig+0x18c>)
 8013aea:	429d      	cmp	r5, r3
 8013aec:	d10d      	bne.n	8013b0a <UART_SetConfig+0xca>
 8013aee:	22c0      	movs	r2, #192	; 0xc0
 8013af0:	2180      	movs	r1, #128	; 0x80
 8013af2:	4b33      	ldr	r3, [pc, #204]	; (8013bc0 <UART_SetConfig+0x180>)
 8013af4:	0312      	lsls	r2, r2, #12
 8013af6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013af8:	02c9      	lsls	r1, r1, #11
 8013afa:	4013      	ands	r3, r2
 8013afc:	2004      	movs	r0, #4
 8013afe:	428b      	cmp	r3, r1
 8013b00:	d0c7      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013b02:	d9e3      	bls.n	8013acc <UART_SetConfig+0x8c>
 8013b04:	2180      	movs	r1, #128	; 0x80
 8013b06:	0309      	lsls	r1, r1, #12
 8013b08:	e7e7      	b.n	8013ada <UART_SetConfig+0x9a>
 8013b0a:	4b31      	ldr	r3, [pc, #196]	; (8013bd0 <UART_SetConfig+0x190>)
 8013b0c:	2000      	movs	r0, #0
 8013b0e:	429d      	cmp	r5, r3
 8013b10:	d0bf      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013b12:	4b30      	ldr	r3, [pc, #192]	; (8013bd4 <UART_SetConfig+0x194>)
 8013b14:	429d      	cmp	r5, r3
 8013b16:	d0bc      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013b18:	4b2f      	ldr	r3, [pc, #188]	; (8013bd8 <UART_SetConfig+0x198>)
 8013b1a:	429d      	cmp	r5, r3
 8013b1c:	d0b9      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013b1e:	4b2f      	ldr	r3, [pc, #188]	; (8013bdc <UART_SetConfig+0x19c>)
 8013b20:	429d      	cmp	r5, r3
 8013b22:	d0b6      	beq.n	8013a92 <UART_SetConfig+0x52>
 8013b24:	4b2e      	ldr	r3, [pc, #184]	; (8013be0 <UART_SetConfig+0x1a0>)
 8013b26:	18e8      	adds	r0, r5, r3
 8013b28:	1e43      	subs	r3, r0, #1
 8013b2a:	4198      	sbcs	r0, r3
 8013b2c:	0100      	lsls	r0, r0, #4
 8013b2e:	e7b0      	b.n	8013a92 <UART_SetConfig+0x52>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8013b30:	f7fe ffa4 	bl	8012a7c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8013b34:	0040      	lsls	r0, r0, #1
 8013b36:	6861      	ldr	r1, [r4, #4]
 8013b38:	e001      	b.n	8013b3e <UART_SetConfig+0xfe>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8013b3a:	6861      	ldr	r1, [r4, #4]
 8013b3c:	4829      	ldr	r0, [pc, #164]	; (8013be4 <UART_SetConfig+0x1a4>)
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8013b3e:	f7ec fb1b 	bl	8000178 <__udivsi3>
 8013b42:	b283      	uxth	r3, r0
  HAL_StatusTypeDef ret               = HAL_OK;
 8013b44:	2000      	movs	r0, #0
    brrtemp = usartdiv & 0xFFF0;
 8013b46:	220f      	movs	r2, #15
 8013b48:	0019      	movs	r1, r3
 8013b4a:	4391      	bics	r1, r2
 8013b4c:	000a      	movs	r2, r1
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 8013b4e:	071b      	lsls	r3, r3, #28
    huart->Instance->BRR = brrtemp;
 8013b50:	6821      	ldr	r1, [r4, #0]
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 8013b52:	0f5b      	lsrs	r3, r3, #29
    huart->Instance->BRR = brrtemp;
 8013b54:	4313      	orrs	r3, r2
 8013b56:	60cb      	str	r3, [r1, #12]
}
 8013b58:	bd70      	pop	{r4, r5, r6, pc}
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8013b5a:	f7fe ff39 	bl	80129d0 <HAL_RCC_GetSysClockFreq>
 8013b5e:	e7e9      	b.n	8013b34 <UART_SetConfig+0xf4>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8013b60:	2080      	movs	r0, #128	; 0x80
 8013b62:	6861      	ldr	r1, [r4, #4]
 8013b64:	0240      	lsls	r0, r0, #9
 8013b66:	e7ea      	b.n	8013b3e <UART_SetConfig+0xfe>
        ret = HAL_ERROR;
 8013b68:	2001      	movs	r0, #1
  uint16_t usartdiv                   = 0x0000;
 8013b6a:	2300      	movs	r3, #0
 8013b6c:	e7eb      	b.n	8013b46 <UART_SetConfig+0x106>
    switch (clocksource)
 8013b6e:	2808      	cmp	r0, #8
 8013b70:	d81c      	bhi.n	8013bac <UART_SetConfig+0x16c>
 8013b72:	f7ec fae3 	bl	800013c <__gnu_thumb1_case_uqi>
 8013b76:	1b05      	.short	0x1b05
 8013b78:	1b121b0a 	.word	0x1b121b0a
 8013b7c:	1b1b      	.short	0x1b1b
 8013b7e:	15          	.byte	0x15
 8013b7f:	00          	.byte	0x00
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8013b80:	f7fe ff7c 	bl	8012a7c <HAL_RCC_GetPCLK1Freq>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8013b84:	6825      	ldr	r5, [r4, #0]
 8013b86:	6861      	ldr	r1, [r4, #4]
 8013b88:	e001      	b.n	8013b8e <UART_SetConfig+0x14e>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate)); 
 8013b8a:	6861      	ldr	r1, [r4, #4]
 8013b8c:	4816      	ldr	r0, [pc, #88]	; (8013be8 <UART_SetConfig+0x1a8>)
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8013b8e:	f7ec faf3 	bl	8000178 <__udivsi3>
 8013b92:	b280      	uxth	r0, r0
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate)); 
 8013b94:	60e8      	str	r0, [r5, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
 8013b96:	2000      	movs	r0, #0
        break;
 8013b98:	e7de      	b.n	8013b58 <UART_SetConfig+0x118>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8013b9a:	f7fe ff19 	bl	80129d0 <HAL_RCC_GetSysClockFreq>
 8013b9e:	e7f1      	b.n	8013b84 <UART_SetConfig+0x144>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate)); 
 8013ba0:	2080      	movs	r0, #128	; 0x80
 8013ba2:	6861      	ldr	r1, [r4, #4]
 8013ba4:	0200      	lsls	r0, r0, #8
 8013ba6:	f7ec fae7 	bl	8000178 <__udivsi3>
 8013baa:	e7f3      	b.n	8013b94 <UART_SetConfig+0x154>
        ret = HAL_ERROR;
 8013bac:	2001      	movs	r0, #1
 8013bae:	e7d3      	b.n	8013b58 <UART_SetConfig+0x118>
 8013bb0:	efff69f3 	.word	0xefff69f3
 8013bb4:	ffffcfff 	.word	0xffffcfff
 8013bb8:	fffff4ff 	.word	0xfffff4ff
 8013bbc:	40013800 	.word	0x40013800
 8013bc0:	40021000 	.word	0x40021000
 8013bc4:	0801c575 	.word	0x0801c575
 8013bc8:	40004400 	.word	0x40004400
 8013bcc:	40004800 	.word	0x40004800
 8013bd0:	40004c00 	.word	0x40004c00
 8013bd4:	40005000 	.word	0x40005000
 8013bd8:	40011400 	.word	0x40011400
 8013bdc:	40011800 	.word	0x40011800
 8013be0:	bffee400 	.word	0xbffee400
 8013be4:	00f42400 	.word	0x00f42400
 8013be8:	007a1200 	.word	0x007a1200

08013bec <UART_AdvFeatureConfig>:
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8013bec:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8013bee:	07db      	lsls	r3, r3, #31
 8013bf0:	d506      	bpl.n	8013c00 <UART_AdvFeatureConfig+0x14>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8013bf2:	6802      	ldr	r2, [r0, #0]
 8013bf4:	492c      	ldr	r1, [pc, #176]	; (8013ca8 <UART_AdvFeatureConfig+0xbc>)
 8013bf6:	6853      	ldr	r3, [r2, #4]
 8013bf8:	400b      	ands	r3, r1
 8013bfa:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8013bfc:	430b      	orrs	r3, r1
 8013bfe:	6053      	str	r3, [r2, #4]
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8013c00:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8013c02:	079b      	lsls	r3, r3, #30
 8013c04:	d506      	bpl.n	8013c14 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8013c06:	6802      	ldr	r2, [r0, #0]
 8013c08:	4928      	ldr	r1, [pc, #160]	; (8013cac <UART_AdvFeatureConfig+0xc0>)
 8013c0a:	6853      	ldr	r3, [r2, #4]
 8013c0c:	400b      	ands	r3, r1
 8013c0e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8013c10:	430b      	orrs	r3, r1
 8013c12:	6053      	str	r3, [r2, #4]
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8013c14:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8013c16:	075b      	lsls	r3, r3, #29
 8013c18:	d506      	bpl.n	8013c28 <UART_AdvFeatureConfig+0x3c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8013c1a:	6802      	ldr	r2, [r0, #0]
 8013c1c:	4924      	ldr	r1, [pc, #144]	; (8013cb0 <UART_AdvFeatureConfig+0xc4>)
 8013c1e:	6853      	ldr	r3, [r2, #4]
 8013c20:	400b      	ands	r3, r1
 8013c22:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8013c24:	430b      	orrs	r3, r1
 8013c26:	6053      	str	r3, [r2, #4]
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8013c28:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8013c2a:	071b      	lsls	r3, r3, #28
 8013c2c:	d506      	bpl.n	8013c3c <UART_AdvFeatureConfig+0x50>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8013c2e:	6802      	ldr	r2, [r0, #0]
 8013c30:	4920      	ldr	r1, [pc, #128]	; (8013cb4 <UART_AdvFeatureConfig+0xc8>)
 8013c32:	6853      	ldr	r3, [r2, #4]
 8013c34:	400b      	ands	r3, r1
 8013c36:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8013c38:	430b      	orrs	r3, r1
 8013c3a:	6053      	str	r3, [r2, #4]
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8013c3c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8013c3e:	06db      	lsls	r3, r3, #27
 8013c40:	d506      	bpl.n	8013c50 <UART_AdvFeatureConfig+0x64>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8013c42:	6802      	ldr	r2, [r0, #0]
 8013c44:	491c      	ldr	r1, [pc, #112]	; (8013cb8 <UART_AdvFeatureConfig+0xcc>)
 8013c46:	6893      	ldr	r3, [r2, #8]
 8013c48:	400b      	ands	r3, r1
 8013c4a:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8013c4c:	430b      	orrs	r3, r1
 8013c4e:	6093      	str	r3, [r2, #8]
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8013c50:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8013c52:	069b      	lsls	r3, r3, #26
 8013c54:	d506      	bpl.n	8013c64 <UART_AdvFeatureConfig+0x78>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8013c56:	6802      	ldr	r2, [r0, #0]
 8013c58:	4918      	ldr	r1, [pc, #96]	; (8013cbc <UART_AdvFeatureConfig+0xd0>)
 8013c5a:	6893      	ldr	r3, [r2, #8]
 8013c5c:	400b      	ands	r3, r1
 8013c5e:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8013c60:	430b      	orrs	r3, r1
 8013c62:	6093      	str	r3, [r2, #8]
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8013c64:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8013c66:	065b      	lsls	r3, r3, #25
 8013c68:	d512      	bpl.n	8013c90 <UART_AdvFeatureConfig+0xa4>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8013c6a:	6802      	ldr	r2, [r0, #0]
 8013c6c:	4914      	ldr	r1, [pc, #80]	; (8013cc0 <UART_AdvFeatureConfig+0xd4>)
 8013c6e:	6853      	ldr	r3, [r2, #4]
 8013c70:	400b      	ands	r3, r1
 8013c72:	6c01      	ldr	r1, [r0, #64]	; 0x40
 8013c74:	430b      	orrs	r3, r1
 8013c76:	6053      	str	r3, [r2, #4]
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8013c78:	2380      	movs	r3, #128	; 0x80
 8013c7a:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8013c7c:	035b      	lsls	r3, r3, #13
 8013c7e:	429a      	cmp	r2, r3
 8013c80:	d106      	bne.n	8013c90 <UART_AdvFeatureConfig+0xa4>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8013c82:	6802      	ldr	r2, [r0, #0]
 8013c84:	490f      	ldr	r1, [pc, #60]	; (8013cc4 <UART_AdvFeatureConfig+0xd8>)
 8013c86:	6853      	ldr	r3, [r2, #4]
 8013c88:	400b      	ands	r3, r1
 8013c8a:	6c41      	ldr	r1, [r0, #68]	; 0x44
 8013c8c:	430b      	orrs	r3, r1
 8013c8e:	6053      	str	r3, [r2, #4]
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8013c90:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8013c92:	061b      	lsls	r3, r3, #24
 8013c94:	d506      	bpl.n	8013ca4 <UART_AdvFeatureConfig+0xb8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8013c96:	6802      	ldr	r2, [r0, #0]
 8013c98:	490b      	ldr	r1, [pc, #44]	; (8013cc8 <UART_AdvFeatureConfig+0xdc>)
 8013c9a:	6853      	ldr	r3, [r2, #4]
 8013c9c:	400b      	ands	r3, r1
 8013c9e:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8013ca0:	430b      	orrs	r3, r1
 8013ca2:	6053      	str	r3, [r2, #4]
}
 8013ca4:	4770      	bx	lr
 8013ca6:	46c0      	nop			; (mov r8, r8)
 8013ca8:	fffdffff 	.word	0xfffdffff
 8013cac:	fffeffff 	.word	0xfffeffff
 8013cb0:	fffbffff 	.word	0xfffbffff
 8013cb4:	ffff7fff 	.word	0xffff7fff
 8013cb8:	ffffefff 	.word	0xffffefff
 8013cbc:	ffffdfff 	.word	0xffffdfff
 8013cc0:	ffefffff 	.word	0xffefffff
 8013cc4:	ff9fffff 	.word	0xff9fffff
 8013cc8:	fff7ffff 	.word	0xfff7ffff

08013ccc <UART_WaitOnFlagUntilTimeout>:
{
 8013ccc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8013cce:	001d      	movs	r5, r3
 8013cd0:	0004      	movs	r4, r0
 8013cd2:	000e      	movs	r6, r1
 8013cd4:	9201      	str	r2, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8013cd6:	f7fd fc13 	bl	8011500 <HAL_GetTick>
  if(Status == RESET)
 8013cda:	9b01      	ldr	r3, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8013cdc:	0007      	movs	r7, r0
  if(Status == RESET)
 8013cde:	2b00      	cmp	r3, #0
 8013ce0:	d033      	beq.n	8013d4a <UART_WaitOnFlagUntilTimeout+0x7e>
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
 8013ce2:	6822      	ldr	r2, [r4, #0]
 8013ce4:	69d3      	ldr	r3, [r2, #28]
 8013ce6:	4033      	ands	r3, r6
 8013ce8:	42b3      	cmp	r3, r6
 8013cea:	d133      	bne.n	8013d54 <UART_WaitOnFlagUntilTimeout+0x88>
      if(Timeout != HAL_MAX_DELAY)
 8013cec:	1c6b      	adds	r3, r5, #1
 8013cee:	d0f9      	beq.n	8013ce4 <UART_WaitOnFlagUntilTimeout+0x18>
        if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 8013cf0:	2d00      	cmp	r5, #0
 8013cf2:	d00e      	beq.n	8013d12 <UART_WaitOnFlagUntilTimeout+0x46>
 8013cf4:	f7fd fc04 	bl	8011500 <HAL_GetTick>
 8013cf8:	1bc0      	subs	r0, r0, r7
 8013cfa:	42a8      	cmp	r0, r5
 8013cfc:	d9f1      	bls.n	8013ce2 <UART_WaitOnFlagUntilTimeout+0x16>
 8013cfe:	e008      	b.n	8013d12 <UART_WaitOnFlagUntilTimeout+0x46>
      if(Timeout != HAL_MAX_DELAY)
 8013d00:	1c6b      	adds	r3, r5, #1
 8013d02:	d023      	beq.n	8013d4c <UART_WaitOnFlagUntilTimeout+0x80>
        if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 8013d04:	2d00      	cmp	r5, #0
 8013d06:	d004      	beq.n	8013d12 <UART_WaitOnFlagUntilTimeout+0x46>
 8013d08:	f7fd fbfa 	bl	8011500 <HAL_GetTick>
 8013d0c:	1bc0      	subs	r0, r0, r7
 8013d0e:	42a8      	cmp	r0, r5
 8013d10:	d91b      	bls.n	8013d4a <UART_WaitOnFlagUntilTimeout+0x7e>
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8013d12:	2180      	movs	r1, #128	; 0x80
 8013d14:	6822      	ldr	r2, [r4, #0]
          return HAL_TIMEOUT;
 8013d16:	2003      	movs	r0, #3
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8013d18:	6813      	ldr	r3, [r2, #0]
 8013d1a:	438b      	bics	r3, r1
 8013d1c:	6013      	str	r3, [r2, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8013d1e:	6822      	ldr	r2, [r4, #0]
 8013d20:	3960      	subs	r1, #96	; 0x60
 8013d22:	6813      	ldr	r3, [r2, #0]
 8013d24:	438b      	bics	r3, r1
 8013d26:	6013      	str	r3, [r2, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8013d28:	6822      	ldr	r2, [r4, #0]
 8013d2a:	490b      	ldr	r1, [pc, #44]	; (8013d58 <UART_WaitOnFlagUntilTimeout+0x8c>)
 8013d2c:	6813      	ldr	r3, [r2, #0]
 8013d2e:	400b      	ands	r3, r1
 8013d30:	6013      	str	r3, [r2, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8013d32:	2201      	movs	r2, #1
 8013d34:	6821      	ldr	r1, [r4, #0]
 8013d36:	688b      	ldr	r3, [r1, #8]
 8013d38:	4393      	bics	r3, r2
 8013d3a:	608b      	str	r3, [r1, #8]
          huart->State = HAL_UART_STATE_READY;
 8013d3c:	0023      	movs	r3, r4
 8013d3e:	3369      	adds	r3, #105	; 0x69
 8013d40:	701a      	strb	r2, [r3, #0]
          __HAL_UNLOCK(huart);
 8013d42:	2300      	movs	r3, #0
 8013d44:	3468      	adds	r4, #104	; 0x68
 8013d46:	7023      	strb	r3, [r4, #0]
          return HAL_TIMEOUT;
 8013d48:	e005      	b.n	8013d56 <UART_WaitOnFlagUntilTimeout+0x8a>
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
 8013d4a:	6822      	ldr	r2, [r4, #0]
 8013d4c:	69d3      	ldr	r3, [r2, #28]
 8013d4e:	4033      	ands	r3, r6
 8013d50:	42b3      	cmp	r3, r6
 8013d52:	d1d5      	bne.n	8013d00 <UART_WaitOnFlagUntilTimeout+0x34>
  return HAL_OK;
 8013d54:	2000      	movs	r0, #0
}
 8013d56:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8013d58:	fffffeff 	.word	0xfffffeff

08013d5c <HAL_UART_Transmit>:
{
 8013d5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013d5e:	0005      	movs	r5, r0
{
 8013d60:	9301      	str	r3, [sp, #4]
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013d62:	3569      	adds	r5, #105	; 0x69
 8013d64:	782b      	ldrb	r3, [r5, #0]
{
 8013d66:	0004      	movs	r4, r0
 8013d68:	000e      	movs	r6, r1
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013d6a:	2b01      	cmp	r3, #1
 8013d6c:	d003      	beq.n	8013d76 <HAL_UART_Transmit+0x1a>
 8013d6e:	782b      	ldrb	r3, [r5, #0]
    return HAL_BUSY;
 8013d70:	2002      	movs	r0, #2
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
 8013d72:	2b22      	cmp	r3, #34	; 0x22
 8013d74:	d136      	bne.n	8013de4 <HAL_UART_Transmit+0x88>
      return  HAL_ERROR;
 8013d76:	2001      	movs	r0, #1
    if((pData == NULL ) || (Size == 0))
 8013d78:	2e00      	cmp	r6, #0
 8013d7a:	d033      	beq.n	8013de4 <HAL_UART_Transmit+0x88>
 8013d7c:	2a00      	cmp	r2, #0
 8013d7e:	d031      	beq.n	8013de4 <HAL_UART_Transmit+0x88>
    __HAL_LOCK(huart);
 8013d80:	0027      	movs	r7, r4
 8013d82:	3768      	adds	r7, #104	; 0x68
 8013d84:	783b      	ldrb	r3, [r7, #0]
 8013d86:	4283      	cmp	r3, r0
 8013d88:	d043      	beq.n	8013e12 <HAL_UART_Transmit+0xb6>
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8013d8a:	2300      	movs	r3, #0
    __HAL_LOCK(huart);
 8013d8c:	7038      	strb	r0, [r7, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8013d8e:	66e3      	str	r3, [r4, #108]	; 0x6c
    if(huart->State == HAL_UART_STATE_BUSY_RX)
 8013d90:	782b      	ldrb	r3, [r5, #0]
 8013d92:	2b22      	cmp	r3, #34	; 0x22
 8013d94:	d119      	bne.n	8013dca <HAL_UART_Transmit+0x6e>
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 8013d96:	3310      	adds	r3, #16
      huart->State = HAL_UART_STATE_BUSY_TX;
 8013d98:	702b      	strb	r3, [r5, #0]
    huart->TxXferSize = Size;
 8013d9a:	0023      	movs	r3, r4
 8013d9c:	3350      	adds	r3, #80	; 0x50
 8013d9e:	801a      	strh	r2, [r3, #0]
    huart->TxXferCount = Size;
 8013da0:	805a      	strh	r2, [r3, #2]
    while(huart->TxXferCount > 0)
 8013da2:	0023      	movs	r3, r4
 8013da4:	3352      	adds	r3, #82	; 0x52
 8013da6:	881a      	ldrh	r2, [r3, #0]
 8013da8:	2a00      	cmp	r2, #0
 8013daa:	d110      	bne.n	8013dce <HAL_UART_Transmit+0x72>
    if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
 8013dac:	9b01      	ldr	r3, [sp, #4]
 8013dae:	2140      	movs	r1, #64	; 0x40
 8013db0:	0020      	movs	r0, r4
 8013db2:	f7ff ff8b 	bl	8013ccc <UART_WaitOnFlagUntilTimeout>
 8013db6:	2800      	cmp	r0, #0
 8013db8:	d113      	bne.n	8013de2 <HAL_UART_Transmit+0x86>
    if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
 8013dba:	782b      	ldrb	r3, [r5, #0]
 8013dbc:	2b32      	cmp	r3, #50	; 0x32
 8013dbe:	d126      	bne.n	8013e0e <HAL_UART_Transmit+0xb2>
      huart->State = HAL_UART_STATE_BUSY_RX;
 8013dc0:	3b10      	subs	r3, #16
      huart->State = HAL_UART_STATE_READY;
 8013dc2:	702b      	strb	r3, [r5, #0]
    __HAL_UNLOCK(huart);
 8013dc4:	2300      	movs	r3, #0
 8013dc6:	703b      	strb	r3, [r7, #0]
    return HAL_OK;
 8013dc8:	e00c      	b.n	8013de4 <HAL_UART_Transmit+0x88>
      huart->State = HAL_UART_STATE_BUSY_TX;
 8013dca:	2312      	movs	r3, #18
 8013dcc:	e7e4      	b.n	8013d98 <HAL_UART_Transmit+0x3c>
      huart->TxXferCount--;
 8013dce:	3a01      	subs	r2, #1
 8013dd0:	801a      	strh	r2, [r3, #0]
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8013dd2:	2180      	movs	r1, #128	; 0x80
 8013dd4:	9b01      	ldr	r3, [sp, #4]
 8013dd6:	2200      	movs	r2, #0
 8013dd8:	0020      	movs	r0, r4
 8013dda:	f7ff ff77 	bl	8013ccc <UART_WaitOnFlagUntilTimeout>
 8013dde:	2800      	cmp	r0, #0
 8013de0:	d001      	beq.n	8013de6 <HAL_UART_Transmit+0x8a>
        return HAL_TIMEOUT;
 8013de2:	2003      	movs	r0, #3
}
 8013de4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8013de6:	68a3      	ldr	r3, [r4, #8]
 8013de8:	6822      	ldr	r2, [r4, #0]
 8013dea:	0019      	movs	r1, r3
 8013dec:	2380      	movs	r3, #128	; 0x80
 8013dee:	015b      	lsls	r3, r3, #5
 8013df0:	4299      	cmp	r1, r3
 8013df2:	d108      	bne.n	8013e06 <HAL_UART_Transmit+0xaa>
 8013df4:	6923      	ldr	r3, [r4, #16]
 8013df6:	2b00      	cmp	r3, #0
 8013df8:	d105      	bne.n	8013e06 <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
 8013dfa:	8833      	ldrh	r3, [r6, #0]
        pData += 2;
 8013dfc:	3602      	adds	r6, #2
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
 8013dfe:	05db      	lsls	r3, r3, #23
 8013e00:	0ddb      	lsrs	r3, r3, #23
 8013e02:	8513      	strh	r3, [r2, #40]	; 0x28
        pData += 2;
 8013e04:	e7cd      	b.n	8013da2 <HAL_UART_Transmit+0x46>
        huart->Instance->TDR = (*pData++ & (uint8_t)0xFF);
 8013e06:	7833      	ldrb	r3, [r6, #0]
 8013e08:	3601      	adds	r6, #1
 8013e0a:	8513      	strh	r3, [r2, #40]	; 0x28
 8013e0c:	e7c9      	b.n	8013da2 <HAL_UART_Transmit+0x46>
      huart->State = HAL_UART_STATE_READY;
 8013e0e:	2301      	movs	r3, #1
 8013e10:	e7d7      	b.n	8013dc2 <HAL_UART_Transmit+0x66>
    return HAL_BUSY;
 8013e12:	2002      	movs	r0, #2
 8013e14:	e7e6      	b.n	8013de4 <HAL_UART_Transmit+0x88>
	...

08013e18 <UART_CheckIdleState>:
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8013e18:	2300      	movs	r3, #0
{
 8013e1a:	b510      	push	{r4, lr}
  if (IS_UART_WAKEUP_INSTANCE(huart->Instance))
 8013e1c:	4a18      	ldr	r2, [pc, #96]	; (8013e80 <UART_CheckIdleState+0x68>)
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8013e1e:	66c3      	str	r3, [r0, #108]	; 0x6c
  if (IS_UART_WAKEUP_INSTANCE(huart->Instance))
 8013e20:	6803      	ldr	r3, [r0, #0]
{
 8013e22:	0004      	movs	r4, r0
  if (IS_UART_WAKEUP_INSTANCE(huart->Instance))
 8013e24:	4293      	cmp	r3, r2
 8013e26:	d00d      	beq.n	8013e44 <UART_CheckIdleState+0x2c>
 8013e28:	4a16      	ldr	r2, [pc, #88]	; (8013e84 <UART_CheckIdleState+0x6c>)
 8013e2a:	4293      	cmp	r3, r2
 8013e2c:	d00a      	beq.n	8013e44 <UART_CheckIdleState+0x2c>
 8013e2e:	4a16      	ldr	r2, [pc, #88]	; (8013e88 <UART_CheckIdleState+0x70>)
 8013e30:	4293      	cmp	r3, r2
 8013e32:	d007      	beq.n	8013e44 <UART_CheckIdleState+0x2c>
  huart->State= HAL_UART_STATE_READY;
 8013e34:	0023      	movs	r3, r4
 8013e36:	2201      	movs	r2, #1
  __HAL_UNLOCK(huart);
 8013e38:	2000      	movs	r0, #0
  huart->State= HAL_UART_STATE_READY;
 8013e3a:	3369      	adds	r3, #105	; 0x69
  __HAL_UNLOCK(huart);
 8013e3c:	3468      	adds	r4, #104	; 0x68
  huart->State= HAL_UART_STATE_READY;
 8013e3e:	701a      	strb	r2, [r3, #0]
  __HAL_UNLOCK(huart);
 8013e40:	7020      	strb	r0, [r4, #0]
}
 8013e42:	bd10      	pop	{r4, pc}
    if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8013e44:	681b      	ldr	r3, [r3, #0]
 8013e46:	071b      	lsls	r3, r3, #28
 8013e48:	d40e      	bmi.n	8013e68 <UART_CheckIdleState+0x50>
    if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8013e4a:	6823      	ldr	r3, [r4, #0]
 8013e4c:	681b      	ldr	r3, [r3, #0]
 8013e4e:	075b      	lsls	r3, r3, #29
 8013e50:	d5f0      	bpl.n	8013e34 <UART_CheckIdleState+0x1c>
      if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET,  UART_TEACK_REACK_TIMEOUT) != HAL_OK)
 8013e52:	23fa      	movs	r3, #250	; 0xfa
 8013e54:	2180      	movs	r1, #128	; 0x80
 8013e56:	009b      	lsls	r3, r3, #2
 8013e58:	2200      	movs	r2, #0
 8013e5a:	03c9      	lsls	r1, r1, #15
 8013e5c:	0020      	movs	r0, r4
 8013e5e:	f7ff ff35 	bl	8013ccc <UART_WaitOnFlagUntilTimeout>
 8013e62:	2800      	cmp	r0, #0
 8013e64:	d0e6      	beq.n	8013e34 <UART_CheckIdleState+0x1c>
 8013e66:	e009      	b.n	8013e7c <UART_CheckIdleState+0x64>
      if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, UART_TEACK_REACK_TIMEOUT) != HAL_OK)
 8013e68:	23fa      	movs	r3, #250	; 0xfa
 8013e6a:	2180      	movs	r1, #128	; 0x80
 8013e6c:	009b      	lsls	r3, r3, #2
 8013e6e:	2200      	movs	r2, #0
 8013e70:	0389      	lsls	r1, r1, #14
 8013e72:	0020      	movs	r0, r4
 8013e74:	f7ff ff2a 	bl	8013ccc <UART_WaitOnFlagUntilTimeout>
 8013e78:	2800      	cmp	r0, #0
 8013e7a:	d0e6      	beq.n	8013e4a <UART_CheckIdleState+0x32>
        return HAL_TIMEOUT;
 8013e7c:	2003      	movs	r0, #3
 8013e7e:	e7e0      	b.n	8013e42 <UART_CheckIdleState+0x2a>
 8013e80:	40013800 	.word	0x40013800
 8013e84:	40004400 	.word	0x40004400
 8013e88:	40004800 	.word	0x40004800

08013e8c <HAL_UART_Init>:
{
 8013e8c:	b570      	push	{r4, r5, r6, lr}
 8013e8e:	1e04      	subs	r4, r0, #0
  if(huart == NULL)
 8013e90:	d101      	bne.n	8013e96 <HAL_UART_Init+0xa>
    return HAL_ERROR;
 8013e92:	2001      	movs	r0, #1
}
 8013e94:	bd70      	pop	{r4, r5, r6, pc}
  if(huart->State == HAL_UART_STATE_RESET)
 8013e96:	0005      	movs	r5, r0
 8013e98:	3569      	adds	r5, #105	; 0x69
 8013e9a:	782b      	ldrb	r3, [r5, #0]
 8013e9c:	b2db      	uxtb	r3, r3
 8013e9e:	2b00      	cmp	r3, #0
 8013ea0:	d104      	bne.n	8013eac <HAL_UART_Init+0x20>
    huart->Lock = HAL_UNLOCKED;
 8013ea2:	0002      	movs	r2, r0
 8013ea4:	3268      	adds	r2, #104	; 0x68
 8013ea6:	7013      	strb	r3, [r2, #0]
    HAL_UART_MspInit(huart);
 8013ea8:	f7f9 f9ca 	bl	800d240 <HAL_UART_MspInit>
  huart->State = HAL_UART_STATE_BUSY;
 8013eac:	2302      	movs	r3, #2
  __HAL_UART_DISABLE(huart);
 8013eae:	2101      	movs	r1, #1
  huart->State = HAL_UART_STATE_BUSY;
 8013eb0:	702b      	strb	r3, [r5, #0]
  __HAL_UART_DISABLE(huart);
 8013eb2:	6822      	ldr	r2, [r4, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8013eb4:	0020      	movs	r0, r4
  __HAL_UART_DISABLE(huart);
 8013eb6:	6813      	ldr	r3, [r2, #0]
 8013eb8:	438b      	bics	r3, r1
 8013eba:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8013ebc:	f7ff fdc0 	bl	8013a40 <UART_SetConfig>
 8013ec0:	2801      	cmp	r0, #1
 8013ec2:	d0e6      	beq.n	8013e92 <HAL_UART_Init+0x6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8013ec4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8013ec6:	2b00      	cmp	r3, #0
 8013ec8:	d002      	beq.n	8013ed0 <HAL_UART_Init+0x44>
    UART_AdvFeatureConfig(huart);
 8013eca:	0020      	movs	r0, r4
 8013ecc:	f7ff fe8e 	bl	8013bec <UART_AdvFeatureConfig>
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
 8013ed0:	6822      	ldr	r2, [r4, #0]
 8013ed2:	4909      	ldr	r1, [pc, #36]	; (8013ef8 <HAL_UART_Init+0x6c>)
 8013ed4:	6853      	ldr	r3, [r2, #4]
  return (UART_CheckIdleState(huart));
 8013ed6:	0020      	movs	r0, r4
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
 8013ed8:	400b      	ands	r3, r1
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 8013eda:	212a      	movs	r1, #42	; 0x2a
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
 8013edc:	6053      	str	r3, [r2, #4]
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 8013ede:	6822      	ldr	r2, [r4, #0]
 8013ee0:	6893      	ldr	r3, [r2, #8]
 8013ee2:	438b      	bics	r3, r1
 8013ee4:	6093      	str	r3, [r2, #8]
  __HAL_UART_ENABLE(huart);
 8013ee6:	2301      	movs	r3, #1
 8013ee8:	6822      	ldr	r2, [r4, #0]
 8013eea:	6811      	ldr	r1, [r2, #0]
 8013eec:	430b      	orrs	r3, r1
 8013eee:	6013      	str	r3, [r2, #0]
  return (UART_CheckIdleState(huart));
 8013ef0:	f7ff ff92 	bl	8013e18 <UART_CheckIdleState>
 8013ef4:	e7ce      	b.n	8013e94 <HAL_UART_Init+0x8>
 8013ef6:	46c0      	nop			; (mov r8, r8)
 8013ef8:	ffffb7ff 	.word	0xffffb7ff

08013efc <UART_Transmit_IT>:
  */
HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;

  if ((huart->State == HAL_UART_STATE_BUSY_TX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
 8013efc:	0002      	movs	r2, r0
{
 8013efe:	b530      	push	{r4, r5, lr}
  if ((huart->State == HAL_UART_STATE_BUSY_TX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
 8013f00:	3269      	adds	r2, #105	; 0x69
 8013f02:	7811      	ldrb	r1, [r2, #0]
{
 8013f04:	0003      	movs	r3, r0
  if ((huart->State == HAL_UART_STATE_BUSY_TX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
 8013f06:	2912      	cmp	r1, #18
 8013f08:	d003      	beq.n	8013f12 <UART_Transmit_IT+0x16>
 8013f0a:	7812      	ldrb	r2, [r2, #0]
      return HAL_OK;
    }
  }
  else
  {
    return HAL_BUSY;
 8013f0c:	2002      	movs	r0, #2
  if ((huart->State == HAL_UART_STATE_BUSY_TX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
 8013f0e:	2a32      	cmp	r2, #50	; 0x32
 8013f10:	d10e      	bne.n	8013f30 <UART_Transmit_IT+0x34>
    if(huart->TxXferCount == 0)
 8013f12:	001c      	movs	r4, r3
 8013f14:	3452      	adds	r4, #82	; 0x52
 8013f16:	8820      	ldrh	r0, [r4, #0]
 8013f18:	6819      	ldr	r1, [r3, #0]
 8013f1a:	2800      	cmp	r0, #0
 8013f1c:	d109      	bne.n	8013f32 <UART_Transmit_IT+0x36>
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8013f1e:	2480      	movs	r4, #128	; 0x80
 8013f20:	680a      	ldr	r2, [r1, #0]
 8013f22:	43a2      	bics	r2, r4
 8013f24:	600a      	str	r2, [r1, #0]
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8013f26:	681a      	ldr	r2, [r3, #0]
 8013f28:	2340      	movs	r3, #64	; 0x40
 8013f2a:	6811      	ldr	r1, [r2, #0]
 8013f2c:	430b      	orrs	r3, r1
 8013f2e:	6013      	str	r3, [r2, #0]
  }
}
 8013f30:	bd30      	pop	{r4, r5, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8013f32:	2080      	movs	r0, #128	; 0x80
 8013f34:	689d      	ldr	r5, [r3, #8]
 8013f36:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8013f38:	0140      	lsls	r0, r0, #5
 8013f3a:	4285      	cmp	r5, r0
 8013f3c:	d10e      	bne.n	8013f5c <UART_Transmit_IT+0x60>
 8013f3e:	6918      	ldr	r0, [r3, #16]
 8013f40:	2800      	cmp	r0, #0
 8013f42:	d10b      	bne.n	8013f5c <UART_Transmit_IT+0x60>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
 8013f44:	8812      	ldrh	r2, [r2, #0]
 8013f46:	05d2      	lsls	r2, r2, #23
 8013f48:	0dd2      	lsrs	r2, r2, #23
 8013f4a:	850a      	strh	r2, [r1, #40]	; 0x28
        huart->pTxBuffPtr += 2;
 8013f4c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8013f4e:	3202      	adds	r2, #2
 8013f50:	64da      	str	r2, [r3, #76]	; 0x4c
      huart->TxXferCount--;
 8013f52:	8823      	ldrh	r3, [r4, #0]
      return HAL_OK;
 8013f54:	2000      	movs	r0, #0
      huart->TxXferCount--;
 8013f56:	3b01      	subs	r3, #1
 8013f58:	8023      	strh	r3, [r4, #0]
      return HAL_OK;
 8013f5a:	e7e9      	b.n	8013f30 <UART_Transmit_IT+0x34>
        huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFF);
 8013f5c:	1c50      	adds	r0, r2, #1
 8013f5e:	64d8      	str	r0, [r3, #76]	; 0x4c
 8013f60:	7813      	ldrb	r3, [r2, #0]
 8013f62:	850b      	strh	r3, [r1, #40]	; 0x28
 8013f64:	e7f5      	b.n	8013f52 <UART_Transmit_IT+0x56>

08013f66 <UART_EndTransmit_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8013f66:	2140      	movs	r1, #64	; 0x40
{
 8013f68:	b510      	push	{r4, lr}
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8013f6a:	6802      	ldr	r2, [r0, #0]
 8013f6c:	6813      	ldr	r3, [r2, #0]
 8013f6e:	438b      	bics	r3, r1
 8013f70:	6013      	str	r3, [r2, #0]

  /* Check if a receive process is ongoing or not */
  if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
 8013f72:	0003      	movs	r3, r0
 8013f74:	3369      	adds	r3, #105	; 0x69
 8013f76:	781a      	ldrb	r2, [r3, #0]
 8013f78:	2a32      	cmp	r2, #50	; 0x32
 8013f7a:	d105      	bne.n	8013f88 <UART_EndTransmit_IT+0x22>
  {
    huart->State = HAL_UART_STATE_BUSY_RX;
 8013f7c:	3a10      	subs	r2, #16
 8013f7e:	701a      	strb	r2, [r3, #0]
    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);

    huart->State = HAL_UART_STATE_READY;
  }

  HAL_UART_TxCpltCallback(huart);
 8013f80:	f7f8 f998 	bl	800c2b4 <HAL_UART_TxCpltCallback>

  return HAL_OK;
}
 8013f84:	2000      	movs	r0, #0
 8013f86:	bd10      	pop	{r4, pc}
    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8013f88:	2101      	movs	r1, #1
 8013f8a:	6804      	ldr	r4, [r0, #0]
 8013f8c:	68a2      	ldr	r2, [r4, #8]
 8013f8e:	438a      	bics	r2, r1
 8013f90:	60a2      	str	r2, [r4, #8]
    huart->State = HAL_UART_STATE_READY;
 8013f92:	7019      	strb	r1, [r3, #0]
 8013f94:	e7f4      	b.n	8013f80 <UART_EndTransmit_IT+0x1a>
	...

08013f98 <UART_Receive_IT>:
HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  uint16_t uhMask = huart->Mask;

  if((huart->State == HAL_UART_STATE_BUSY_RX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
 8013f98:	0002      	movs	r2, r0
{
 8013f9a:	b570      	push	{r4, r5, r6, lr}
  if((huart->State == HAL_UART_STATE_BUSY_RX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
 8013f9c:	3269      	adds	r2, #105	; 0x69
 8013f9e:	7813      	ldrb	r3, [r2, #0]
 8013fa0:	2b22      	cmp	r3, #34	; 0x22
 8013fa2:	d003      	beq.n	8013fac <UART_Receive_IT+0x14>
 8013fa4:	7813      	ldrb	r3, [r2, #0]

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8013fa6:	2102      	movs	r1, #2
  if((huart->State == HAL_UART_STATE_BUSY_RX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
 8013fa8:	2b32      	cmp	r3, #50	; 0x32
 8013faa:	d128      	bne.n	8013ffe <UART_Receive_IT+0x66>
  uint16_t uhMask = huart->Mask;
 8013fac:	0003      	movs	r3, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8013fae:	2580      	movs	r5, #128	; 0x80
 8013fb0:	6886      	ldr	r6, [r0, #8]
  uint16_t uhMask = huart->Mask;
 8013fb2:	335c      	adds	r3, #92	; 0x5c
 8013fb4:	881b      	ldrh	r3, [r3, #0]
 8013fb6:	6804      	ldr	r4, [r0, #0]
 8013fb8:	6d41      	ldr	r1, [r0, #84]	; 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8013fba:	016d      	lsls	r5, r5, #5
 8013fbc:	42ae      	cmp	r6, r5
 8013fbe:	d120      	bne.n	8014002 <UART_Receive_IT+0x6a>
 8013fc0:	6905      	ldr	r5, [r0, #16]
 8013fc2:	2d00      	cmp	r5, #0
 8013fc4:	d11d      	bne.n	8014002 <UART_Receive_IT+0x6a>
      *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
 8013fc6:	8ca4      	ldrh	r4, [r4, #36]	; 0x24
 8013fc8:	4023      	ands	r3, r4
 8013fca:	800b      	strh	r3, [r1, #0]
      huart->pRxBuffPtr +=2;
 8013fcc:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8013fce:	3302      	adds	r3, #2
 8013fd0:	6543      	str	r3, [r0, #84]	; 0x54
    if(--huart->RxXferCount == 0)
 8013fd2:	0001      	movs	r1, r0
 8013fd4:	315a      	adds	r1, #90	; 0x5a
 8013fd6:	880b      	ldrh	r3, [r1, #0]
 8013fd8:	3b01      	subs	r3, #1
 8013fda:	b29b      	uxth	r3, r3
 8013fdc:	800b      	strh	r3, [r1, #0]
    return HAL_OK;
 8013fde:	2100      	movs	r1, #0
    if(--huart->RxXferCount == 0)
 8013fe0:	428b      	cmp	r3, r1
 8013fe2:	d10c      	bne.n	8013ffe <UART_Receive_IT+0x66>
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8013fe4:	2420      	movs	r4, #32
 8013fe6:	6801      	ldr	r1, [r0, #0]
 8013fe8:	680b      	ldr	r3, [r1, #0]
 8013fea:	43a3      	bics	r3, r4
 8013fec:	600b      	str	r3, [r1, #0]
      if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
 8013fee:	7813      	ldrb	r3, [r2, #0]
 8013ff0:	2b32      	cmp	r3, #50	; 0x32
 8013ff2:	d10c      	bne.n	801400e <UART_Receive_IT+0x76>
        huart->State = HAL_UART_STATE_BUSY_TX;
 8013ff4:	3b20      	subs	r3, #32
 8013ff6:	7013      	strb	r3, [r2, #0]
      HAL_UART_RxCpltCallback(huart);
 8013ff8:	f7f8 f998 	bl	800c32c <HAL_UART_RxCpltCallback>
      return HAL_OK;
 8013ffc:	2100      	movs	r1, #0
  }
}
 8013ffe:	0008      	movs	r0, r1
 8014000:	bd70      	pop	{r4, r5, r6, pc}
      *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 8014002:	8ca4      	ldrh	r4, [r4, #36]	; 0x24
 8014004:	1c4d      	adds	r5, r1, #1
 8014006:	4023      	ands	r3, r4
 8014008:	6545      	str	r5, [r0, #84]	; 0x54
 801400a:	700b      	strb	r3, [r1, #0]
 801400c:	e7e1      	b.n	8013fd2 <UART_Receive_IT+0x3a>
        __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 801400e:	6801      	ldr	r1, [r0, #0]
 8014010:	4c05      	ldr	r4, [pc, #20]	; (8014028 <UART_Receive_IT+0x90>)
 8014012:	680b      	ldr	r3, [r1, #0]
 8014014:	4023      	ands	r3, r4
 8014016:	600b      	str	r3, [r1, #0]
        __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8014018:	2101      	movs	r1, #1
 801401a:	6804      	ldr	r4, [r0, #0]
 801401c:	68a3      	ldr	r3, [r4, #8]
 801401e:	438b      	bics	r3, r1
 8014020:	60a3      	str	r3, [r4, #8]
        huart->State = HAL_UART_STATE_READY;
 8014022:	7011      	strb	r1, [r2, #0]
 8014024:	e7e8      	b.n	8013ff8 <UART_Receive_IT+0x60>
 8014026:	46c0      	nop			; (mov r8, r8)
 8014028:	fffffeff 	.word	0xfffffeff

0801402c <HAL_UARTEx_WakeupCallback>:
 __weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file
   */ 
}
 801402c:	4770      	bx	lr

0801402e <HAL_UART_IRQHandler>:
  if((__HAL_UART_GET_IT(huart, UART_IT_PE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE) != RESET))
 801402e:	2301      	movs	r3, #1
{
 8014030:	b510      	push	{r4, lr}
  if((__HAL_UART_GET_IT(huart, UART_IT_PE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE) != RESET))
 8014032:	6802      	ldr	r2, [r0, #0]
{
 8014034:	0004      	movs	r4, r0
  if((__HAL_UART_GET_IT(huart, UART_IT_PE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE) != RESET))
 8014036:	69d1      	ldr	r1, [r2, #28]
 8014038:	4219      	tst	r1, r3
 801403a:	d009      	beq.n	8014050 <HAL_UART_IRQHandler+0x22>
 801403c:	6811      	ldr	r1, [r2, #0]
 801403e:	05c9      	lsls	r1, r1, #23
 8014040:	d506      	bpl.n	8014050 <HAL_UART_IRQHandler+0x22>
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
 8014042:	6213      	str	r3, [r2, #32]
    huart->ErrorCode |= HAL_UART_ERROR_PE;
 8014044:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8014046:	431a      	orrs	r2, r3
 8014048:	66c2      	str	r2, [r0, #108]	; 0x6c
    huart->State = HAL_UART_STATE_READY;
 801404a:	0002      	movs	r2, r0
 801404c:	3269      	adds	r2, #105	; 0x69
 801404e:	7013      	strb	r3, [r2, #0]
  if((__HAL_UART_GET_IT(huart, UART_IT_FE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
 8014050:	2102      	movs	r1, #2
 8014052:	6823      	ldr	r3, [r4, #0]
 8014054:	69da      	ldr	r2, [r3, #28]
 8014056:	420a      	tst	r2, r1
 8014058:	d00b      	beq.n	8014072 <HAL_UART_IRQHandler+0x44>
 801405a:	2201      	movs	r2, #1
 801405c:	6898      	ldr	r0, [r3, #8]
 801405e:	4210      	tst	r0, r2
 8014060:	d007      	beq.n	8014072 <HAL_UART_IRQHandler+0x44>
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
 8014062:	6219      	str	r1, [r3, #32]
    huart->ErrorCode |= HAL_UART_ERROR_FE;
 8014064:	2304      	movs	r3, #4
 8014066:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8014068:	430b      	orrs	r3, r1
 801406a:	66e3      	str	r3, [r4, #108]	; 0x6c
    huart->State = HAL_UART_STATE_READY;
 801406c:	0023      	movs	r3, r4
 801406e:	3369      	adds	r3, #105	; 0x69
 8014070:	701a      	strb	r2, [r3, #0]
  if((__HAL_UART_GET_IT(huart, UART_IT_NE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
 8014072:	2104      	movs	r1, #4
 8014074:	6823      	ldr	r3, [r4, #0]
 8014076:	69da      	ldr	r2, [r3, #28]
 8014078:	420a      	tst	r2, r1
 801407a:	d00b      	beq.n	8014094 <HAL_UART_IRQHandler+0x66>
 801407c:	2201      	movs	r2, #1
 801407e:	6898      	ldr	r0, [r3, #8]
 8014080:	4210      	tst	r0, r2
 8014082:	d007      	beq.n	8014094 <HAL_UART_IRQHandler+0x66>
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
 8014084:	6219      	str	r1, [r3, #32]
    huart->ErrorCode |= HAL_UART_ERROR_NE;
 8014086:	2302      	movs	r3, #2
 8014088:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 801408a:	430b      	orrs	r3, r1
 801408c:	66e3      	str	r3, [r4, #108]	; 0x6c
    huart->State = HAL_UART_STATE_READY;
 801408e:	0023      	movs	r3, r4
 8014090:	3369      	adds	r3, #105	; 0x69
 8014092:	701a      	strb	r2, [r3, #0]
  if((__HAL_UART_GET_IT(huart, UART_IT_ORE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
 8014094:	2308      	movs	r3, #8
 8014096:	6822      	ldr	r2, [r4, #0]
 8014098:	69d1      	ldr	r1, [r2, #28]
 801409a:	4219      	tst	r1, r3
 801409c:	d00a      	beq.n	80140b4 <HAL_UART_IRQHandler+0x86>
 801409e:	2101      	movs	r1, #1
 80140a0:	6890      	ldr	r0, [r2, #8]
 80140a2:	4208      	tst	r0, r1
 80140a4:	d006      	beq.n	80140b4 <HAL_UART_IRQHandler+0x86>
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
 80140a6:	6213      	str	r3, [r2, #32]
    huart->ErrorCode |= HAL_UART_ERROR_ORE;
 80140a8:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80140aa:	4313      	orrs	r3, r2
 80140ac:	66e3      	str	r3, [r4, #108]	; 0x6c
    huart->State = HAL_UART_STATE_READY;
 80140ae:	0023      	movs	r3, r4
 80140b0:	3369      	adds	r3, #105	; 0x69
 80140b2:	7019      	strb	r1, [r3, #0]
  if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 80140b4:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80140b6:	2b00      	cmp	r3, #0
 80140b8:	d002      	beq.n	80140c0 <HAL_UART_IRQHandler+0x92>
    HAL_UART_ErrorCallback(huart);
 80140ba:	0020      	movs	r0, r4
 80140bc:	f7f8 f910 	bl	800c2e0 <HAL_UART_ErrorCallback>
  if((__HAL_UART_GET_IT(huart, UART_IT_WUF) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_WUF) != RESET))
 80140c0:	2280      	movs	r2, #128	; 0x80
 80140c2:	6823      	ldr	r3, [r4, #0]
 80140c4:	0352      	lsls	r2, r2, #13
 80140c6:	69d9      	ldr	r1, [r3, #28]
 80140c8:	4211      	tst	r1, r2
 80140ca:	d00a      	beq.n	80140e2 <HAL_UART_IRQHandler+0xb4>
 80140cc:	6899      	ldr	r1, [r3, #8]
 80140ce:	0249      	lsls	r1, r1, #9
 80140d0:	d507      	bpl.n	80140e2 <HAL_UART_IRQHandler+0xb4>
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_WUF);
 80140d2:	621a      	str	r2, [r3, #32]
    huart->State = HAL_UART_STATE_READY;
 80140d4:	0023      	movs	r3, r4
 80140d6:	2201      	movs	r2, #1
 80140d8:	3369      	adds	r3, #105	; 0x69
 80140da:	701a      	strb	r2, [r3, #0]
    HAL_UARTEx_WakeupCallback(huart);
 80140dc:	0020      	movs	r0, r4
 80140de:	f7ff ffa5 	bl	801402c <HAL_UARTEx_WakeupCallback>
  if((__HAL_UART_GET_IT(huart, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE) != RESET))
 80140e2:	2320      	movs	r3, #32
 80140e4:	6822      	ldr	r2, [r4, #0]
 80140e6:	69d1      	ldr	r1, [r2, #28]
 80140e8:	4219      	tst	r1, r3
 80140ea:	d00a      	beq.n	8014102 <HAL_UART_IRQHandler+0xd4>
 80140ec:	6812      	ldr	r2, [r2, #0]
 80140ee:	421a      	tst	r2, r3
 80140f0:	d007      	beq.n	8014102 <HAL_UART_IRQHandler+0xd4>
    UART_Receive_IT(huart);
 80140f2:	0020      	movs	r0, r4
 80140f4:	f7ff ff50 	bl	8013f98 <UART_Receive_IT>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80140f8:	2308      	movs	r3, #8
 80140fa:	6822      	ldr	r2, [r4, #0]
 80140fc:	6991      	ldr	r1, [r2, #24]
 80140fe:	430b      	orrs	r3, r1
 8014100:	6193      	str	r3, [r2, #24]
 if((__HAL_UART_GET_IT(huart, UART_IT_TXE) != RESET) &&(__HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE) != RESET))
 8014102:	2380      	movs	r3, #128	; 0x80
 8014104:	6822      	ldr	r2, [r4, #0]
 8014106:	69d1      	ldr	r1, [r2, #28]
 8014108:	4219      	tst	r1, r3
 801410a:	d005      	beq.n	8014118 <HAL_UART_IRQHandler+0xea>
 801410c:	6812      	ldr	r2, [r2, #0]
 801410e:	421a      	tst	r2, r3
 8014110:	d002      	beq.n	8014118 <HAL_UART_IRQHandler+0xea>
    UART_Transmit_IT(huart);
 8014112:	0020      	movs	r0, r4
 8014114:	f7ff fef2 	bl	8013efc <UART_Transmit_IT>
 if((__HAL_UART_GET_IT(huart, UART_IT_TC) != RESET) &&(__HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC) != RESET))
 8014118:	2340      	movs	r3, #64	; 0x40
 801411a:	6822      	ldr	r2, [r4, #0]
 801411c:	69d1      	ldr	r1, [r2, #28]
 801411e:	4219      	tst	r1, r3
 8014120:	d005      	beq.n	801412e <HAL_UART_IRQHandler+0x100>
 8014122:	6812      	ldr	r2, [r2, #0]
 8014124:	421a      	tst	r2, r3
 8014126:	d002      	beq.n	801412e <HAL_UART_IRQHandler+0x100>
    UART_EndTransmit_IT(huart);
 8014128:	0020      	movs	r0, r4
 801412a:	f7ff ff1c 	bl	8013f66 <UART_EndTransmit_IT>
}
 801412e:	bd10      	pop	{r4, pc}

08014130 <main>:

/* Private function prototypes -----------------------------------------------*/
uint32_t MYDATA=15;
/* Main functions ------------------------------------------------------------*/

int main(void) {
 8014130:	b510      	push	{r4, lr}

	/* MCU Configuration----------------------------------------------------------*/

	/* Reset all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
 8014132:	f7fd f9cd 	bl	80114d0 <HAL_Init>

	/* Configure the system clock */
	SystemClock_Config();
 8014136:	f7f5 faa1 	bl	800967c <SystemClock_Config>

	/* Initialize all user peripherals */

	/* Initialize BitzOS */
	BOS_Init();
 801413a:	f7ef ff6f 	bl	800401c <BOS_Init>

	/* Call init function for freertos objects (in freertos.c) */
	MX_FREERTOS_Init();
 801413e:	f7f2 febd 	bl	8006ebc <MX_FREERTOS_Init>

	/* Start scheduler */
	osKernelStart();
 8014142:	f7fb fb09 	bl	800f758 <osKernelStart>
 8014146:	e7fe      	b.n	8014146 <main+0x16>

08014148 <UserTask>:
}

/*-----------------------------------------------------------*/

/* User Task */
void UserTask(void *argument) {
 8014148:	e7fe      	b.n	8014148 <UserTask>

0801414a <atof>:
 801414a:	b510      	push	{r4, lr}
 801414c:	2100      	movs	r1, #0
 801414e:	f001 fb2f 	bl	80157b0 <strtod>
 8014152:	bd10      	pop	{r4, pc}

08014154 <atoi>:
 8014154:	b510      	push	{r4, lr}
 8014156:	220a      	movs	r2, #10
 8014158:	2100      	movs	r1, #0
 801415a:	f001 fbf5 	bl	8015948 <strtol>
 801415e:	bd10      	pop	{r4, pc}

08014160 <atol>:
 8014160:	b510      	push	{r4, lr}
 8014162:	220a      	movs	r2, #10
 8014164:	2100      	movs	r1, #0
 8014166:	f001 fbef 	bl	8015948 <strtol>
 801416a:	bd10      	pop	{r4, pc}

0801416c <__libc_init_array>:
 801416c:	b570      	push	{r4, r5, r6, lr}
 801416e:	2600      	movs	r6, #0
 8014170:	4d0c      	ldr	r5, [pc, #48]	; (80141a4 <__libc_init_array+0x38>)
 8014172:	4c0d      	ldr	r4, [pc, #52]	; (80141a8 <__libc_init_array+0x3c>)
 8014174:	1b64      	subs	r4, r4, r5
 8014176:	10a4      	asrs	r4, r4, #2
 8014178:	42a6      	cmp	r6, r4
 801417a:	d109      	bne.n	8014190 <__libc_init_array+0x24>
 801417c:	2600      	movs	r6, #0
 801417e:	f004 fef7 	bl	8018f70 <_init>
 8014182:	4d0a      	ldr	r5, [pc, #40]	; (80141ac <__libc_init_array+0x40>)
 8014184:	4c0a      	ldr	r4, [pc, #40]	; (80141b0 <__libc_init_array+0x44>)
 8014186:	1b64      	subs	r4, r4, r5
 8014188:	10a4      	asrs	r4, r4, #2
 801418a:	42a6      	cmp	r6, r4
 801418c:	d105      	bne.n	801419a <__libc_init_array+0x2e>
 801418e:	bd70      	pop	{r4, r5, r6, pc}
 8014190:	00b3      	lsls	r3, r6, #2
 8014192:	58eb      	ldr	r3, [r5, r3]
 8014194:	4798      	blx	r3
 8014196:	3601      	adds	r6, #1
 8014198:	e7ee      	b.n	8014178 <__libc_init_array+0xc>
 801419a:	00b3      	lsls	r3, r6, #2
 801419c:	58eb      	ldr	r3, [r5, r3]
 801419e:	4798      	blx	r3
 80141a0:	3601      	adds	r6, #1
 80141a2:	e7f2      	b.n	801418a <__libc_init_array+0x1e>
 80141a4:	0801c83c 	.word	0x0801c83c
 80141a8:	0801c83c 	.word	0x0801c83c
 80141ac:	0801c83c 	.word	0x0801c83c
 80141b0:	0801c844 	.word	0x0801c844

080141b4 <__locale_ctype_ptr_l>:
 80141b4:	30ec      	adds	r0, #236	; 0xec
 80141b6:	6800      	ldr	r0, [r0, #0]
 80141b8:	4770      	bx	lr
	...

080141bc <__locale_ctype_ptr>:
 80141bc:	4b04      	ldr	r3, [pc, #16]	; (80141d0 <__locale_ctype_ptr+0x14>)
 80141be:	681b      	ldr	r3, [r3, #0]
 80141c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80141c2:	2b00      	cmp	r3, #0
 80141c4:	d100      	bne.n	80141c8 <__locale_ctype_ptr+0xc>
 80141c6:	4b03      	ldr	r3, [pc, #12]	; (80141d4 <__locale_ctype_ptr+0x18>)
 80141c8:	33ec      	adds	r3, #236	; 0xec
 80141ca:	6818      	ldr	r0, [r3, #0]
 80141cc:	4770      	bx	lr
 80141ce:	46c0      	nop			; (mov r8, r8)
 80141d0:	200000d0 	.word	0x200000d0
 80141d4:	20000500 	.word	0x20000500

080141d8 <malloc>:
 80141d8:	b510      	push	{r4, lr}
 80141da:	4b03      	ldr	r3, [pc, #12]	; (80141e8 <malloc+0x10>)
 80141dc:	0001      	movs	r1, r0
 80141de:	6818      	ldr	r0, [r3, #0]
 80141e0:	f000 f80e 	bl	8014200 <_malloc_r>
 80141e4:	bd10      	pop	{r4, pc}
 80141e6:	46c0      	nop			; (mov r8, r8)
 80141e8:	200000d0 	.word	0x200000d0

080141ec <free>:
 80141ec:	b510      	push	{r4, lr}
 80141ee:	4b03      	ldr	r3, [pc, #12]	; (80141fc <free+0x10>)
 80141f0:	0001      	movs	r1, r0
 80141f2:	6818      	ldr	r0, [r3, #0]
 80141f4:	f003 fd9a 	bl	8017d2c <_free_r>
 80141f8:	bd10      	pop	{r4, pc}
 80141fa:	46c0      	nop			; (mov r8, r8)
 80141fc:	200000d0 	.word	0x200000d0

08014200 <_malloc_r>:
 8014200:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014202:	000d      	movs	r5, r1
 8014204:	b085      	sub	sp, #20
 8014206:	350b      	adds	r5, #11
 8014208:	9001      	str	r0, [sp, #4]
 801420a:	2d16      	cmp	r5, #22
 801420c:	d908      	bls.n	8014220 <_malloc_r+0x20>
 801420e:	2307      	movs	r3, #7
 8014210:	439d      	bics	r5, r3
 8014212:	d506      	bpl.n	8014222 <_malloc_r+0x22>
 8014214:	230c      	movs	r3, #12
 8014216:	9a01      	ldr	r2, [sp, #4]
 8014218:	6013      	str	r3, [r2, #0]
 801421a:	2000      	movs	r0, #0
 801421c:	b005      	add	sp, #20
 801421e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8014220:	2510      	movs	r5, #16
 8014222:	428d      	cmp	r5, r1
 8014224:	d3f6      	bcc.n	8014214 <_malloc_r+0x14>
 8014226:	9801      	ldr	r0, [sp, #4]
 8014228:	f000 fa26 	bl	8014678 <__malloc_lock>
 801422c:	23f8      	movs	r3, #248	; 0xf8
 801422e:	33ff      	adds	r3, #255	; 0xff
 8014230:	4ac4      	ldr	r2, [pc, #784]	; (8014544 <_malloc_r+0x344>)
 8014232:	429d      	cmp	r5, r3
 8014234:	d820      	bhi.n	8014278 <_malloc_r+0x78>
 8014236:	0029      	movs	r1, r5
 8014238:	3108      	adds	r1, #8
 801423a:	1851      	adds	r1, r2, r1
 801423c:	0008      	movs	r0, r1
 801423e:	684c      	ldr	r4, [r1, #4]
 8014240:	3808      	subs	r0, #8
 8014242:	08eb      	lsrs	r3, r5, #3
 8014244:	4284      	cmp	r4, r0
 8014246:	d104      	bne.n	8014252 <_malloc_r+0x52>
 8014248:	68cc      	ldr	r4, [r1, #12]
 801424a:	3302      	adds	r3, #2
 801424c:	469c      	mov	ip, r3
 801424e:	42a1      	cmp	r1, r4
 8014250:	d02a      	beq.n	80142a8 <_malloc_r+0xa8>
 8014252:	2303      	movs	r3, #3
 8014254:	6862      	ldr	r2, [r4, #4]
 8014256:	68a1      	ldr	r1, [r4, #8]
 8014258:	439a      	bics	r2, r3
 801425a:	0013      	movs	r3, r2
 801425c:	68e2      	ldr	r2, [r4, #12]
 801425e:	18e3      	adds	r3, r4, r3
 8014260:	60ca      	str	r2, [r1, #12]
 8014262:	6091      	str	r1, [r2, #8]
 8014264:	2201      	movs	r2, #1
 8014266:	6859      	ldr	r1, [r3, #4]
 8014268:	430a      	orrs	r2, r1
 801426a:	605a      	str	r2, [r3, #4]
 801426c:	9801      	ldr	r0, [sp, #4]
 801426e:	f000 fa0b 	bl	8014688 <__malloc_unlock>
 8014272:	0020      	movs	r0, r4
 8014274:	3008      	adds	r0, #8
 8014276:	e7d1      	b.n	801421c <_malloc_r+0x1c>
 8014278:	0a69      	lsrs	r1, r5, #9
 801427a:	233f      	movs	r3, #63	; 0x3f
 801427c:	2900      	cmp	r1, #0
 801427e:	d003      	beq.n	8014288 <_malloc_r+0x88>
 8014280:	2904      	cmp	r1, #4
 8014282:	d828      	bhi.n	80142d6 <_malloc_r+0xd6>
 8014284:	09ab      	lsrs	r3, r5, #6
 8014286:	3338      	adds	r3, #56	; 0x38
 8014288:	2103      	movs	r1, #3
 801428a:	468c      	mov	ip, r1
 801428c:	00d8      	lsls	r0, r3, #3
 801428e:	1880      	adds	r0, r0, r2
 8014290:	68c4      	ldr	r4, [r0, #12]
 8014292:	4284      	cmp	r4, r0
 8014294:	d006      	beq.n	80142a4 <_malloc_r+0xa4>
 8014296:	4666      	mov	r6, ip
 8014298:	6861      	ldr	r1, [r4, #4]
 801429a:	43b1      	bics	r1, r6
 801429c:	1b4f      	subs	r7, r1, r5
 801429e:	2f0f      	cmp	r7, #15
 80142a0:	dd31      	ble.n	8014306 <_malloc_r+0x106>
 80142a2:	3b01      	subs	r3, #1
 80142a4:	3301      	adds	r3, #1
 80142a6:	469c      	mov	ip, r3
 80142a8:	6914      	ldr	r4, [r2, #16]
 80142aa:	49a7      	ldr	r1, [pc, #668]	; (8014548 <_malloc_r+0x348>)
 80142ac:	428c      	cmp	r4, r1
 80142ae:	d055      	beq.n	801435c <_malloc_r+0x15c>
 80142b0:	2303      	movs	r3, #3
 80142b2:	6860      	ldr	r0, [r4, #4]
 80142b4:	4398      	bics	r0, r3
 80142b6:	0003      	movs	r3, r0
 80142b8:	1b46      	subs	r6, r0, r5
 80142ba:	2e0f      	cmp	r6, #15
 80142bc:	dd31      	ble.n	8014322 <_malloc_r+0x122>
 80142be:	2701      	movs	r7, #1
 80142c0:	1960      	adds	r0, r4, r5
 80142c2:	433d      	orrs	r5, r7
 80142c4:	4337      	orrs	r7, r6
 80142c6:	6065      	str	r5, [r4, #4]
 80142c8:	6150      	str	r0, [r2, #20]
 80142ca:	6110      	str	r0, [r2, #16]
 80142cc:	60c1      	str	r1, [r0, #12]
 80142ce:	6081      	str	r1, [r0, #8]
 80142d0:	6047      	str	r7, [r0, #4]
 80142d2:	50e6      	str	r6, [r4, r3]
 80142d4:	e7ca      	b.n	801426c <_malloc_r+0x6c>
 80142d6:	2914      	cmp	r1, #20
 80142d8:	d802      	bhi.n	80142e0 <_malloc_r+0xe0>
 80142da:	000b      	movs	r3, r1
 80142dc:	335b      	adds	r3, #91	; 0x5b
 80142de:	e7d3      	b.n	8014288 <_malloc_r+0x88>
 80142e0:	2954      	cmp	r1, #84	; 0x54
 80142e2:	d802      	bhi.n	80142ea <_malloc_r+0xea>
 80142e4:	0b2b      	lsrs	r3, r5, #12
 80142e6:	336e      	adds	r3, #110	; 0x6e
 80142e8:	e7ce      	b.n	8014288 <_malloc_r+0x88>
 80142ea:	23aa      	movs	r3, #170	; 0xaa
 80142ec:	005b      	lsls	r3, r3, #1
 80142ee:	4299      	cmp	r1, r3
 80142f0:	d802      	bhi.n	80142f8 <_malloc_r+0xf8>
 80142f2:	0beb      	lsrs	r3, r5, #15
 80142f4:	3377      	adds	r3, #119	; 0x77
 80142f6:	e7c7      	b.n	8014288 <_malloc_r+0x88>
 80142f8:	4894      	ldr	r0, [pc, #592]	; (801454c <_malloc_r+0x34c>)
 80142fa:	237e      	movs	r3, #126	; 0x7e
 80142fc:	4281      	cmp	r1, r0
 80142fe:	d8c3      	bhi.n	8014288 <_malloc_r+0x88>
 8014300:	0cab      	lsrs	r3, r5, #18
 8014302:	337c      	adds	r3, #124	; 0x7c
 8014304:	e7c0      	b.n	8014288 <_malloc_r+0x88>
 8014306:	68e6      	ldr	r6, [r4, #12]
 8014308:	2f00      	cmp	r7, #0
 801430a:	db08      	blt.n	801431e <_malloc_r+0x11e>
 801430c:	68a3      	ldr	r3, [r4, #8]
 801430e:	1861      	adds	r1, r4, r1
 8014310:	60de      	str	r6, [r3, #12]
 8014312:	60b3      	str	r3, [r6, #8]
 8014314:	2301      	movs	r3, #1
 8014316:	684a      	ldr	r2, [r1, #4]
 8014318:	4313      	orrs	r3, r2
 801431a:	604b      	str	r3, [r1, #4]
 801431c:	e7a6      	b.n	801426c <_malloc_r+0x6c>
 801431e:	0034      	movs	r4, r6
 8014320:	e7b7      	b.n	8014292 <_malloc_r+0x92>
 8014322:	6151      	str	r1, [r2, #20]
 8014324:	6111      	str	r1, [r2, #16]
 8014326:	2e00      	cmp	r6, #0
 8014328:	db05      	blt.n	8014336 <_malloc_r+0x136>
 801432a:	2101      	movs	r1, #1
 801432c:	1823      	adds	r3, r4, r0
 801432e:	685a      	ldr	r2, [r3, #4]
 8014330:	4311      	orrs	r1, r2
 8014332:	6059      	str	r1, [r3, #4]
 8014334:	e79a      	b.n	801426c <_malloc_r+0x6c>
 8014336:	4986      	ldr	r1, [pc, #536]	; (8014550 <_malloc_r+0x350>)
 8014338:	6857      	ldr	r7, [r2, #4]
 801433a:	4288      	cmp	r0, r1
 801433c:	d900      	bls.n	8014340 <_malloc_r+0x140>
 801433e:	e090      	b.n	8014462 <_malloc_r+0x262>
 8014340:	08c3      	lsrs	r3, r0, #3
 8014342:	39ff      	subs	r1, #255	; 0xff
 8014344:	1098      	asrs	r0, r3, #2
 8014346:	39ff      	subs	r1, #255	; 0xff
 8014348:	4081      	lsls	r1, r0
 801434a:	00db      	lsls	r3, r3, #3
 801434c:	4339      	orrs	r1, r7
 801434e:	6051      	str	r1, [r2, #4]
 8014350:	189a      	adds	r2, r3, r2
 8014352:	6893      	ldr	r3, [r2, #8]
 8014354:	60e2      	str	r2, [r4, #12]
 8014356:	60a3      	str	r3, [r4, #8]
 8014358:	6094      	str	r4, [r2, #8]
 801435a:	60dc      	str	r4, [r3, #12]
 801435c:	4663      	mov	r3, ip
 801435e:	2201      	movs	r2, #1
 8014360:	4978      	ldr	r1, [pc, #480]	; (8014544 <_malloc_r+0x344>)
 8014362:	109b      	asrs	r3, r3, #2
 8014364:	6848      	ldr	r0, [r1, #4]
 8014366:	409a      	lsls	r2, r3
 8014368:	4290      	cmp	r0, r2
 801436a:	d32d      	bcc.n	80143c8 <_malloc_r+0x1c8>
 801436c:	4202      	tst	r2, r0
 801436e:	d109      	bne.n	8014384 <_malloc_r+0x184>
 8014370:	2303      	movs	r3, #3
 8014372:	4664      	mov	r4, ip
 8014374:	439c      	bics	r4, r3
 8014376:	0023      	movs	r3, r4
 8014378:	3304      	adds	r3, #4
 801437a:	469c      	mov	ip, r3
 801437c:	0052      	lsls	r2, r2, #1
 801437e:	4202      	tst	r2, r0
 8014380:	d100      	bne.n	8014384 <_malloc_r+0x184>
 8014382:	e0a4      	b.n	80144ce <_malloc_r+0x2ce>
 8014384:	4663      	mov	r3, ip
 8014386:	00db      	lsls	r3, r3, #3
 8014388:	18cb      	adds	r3, r1, r3
 801438a:	9303      	str	r3, [sp, #12]
 801438c:	001f      	movs	r7, r3
 801438e:	4663      	mov	r3, ip
 8014390:	9302      	str	r3, [sp, #8]
 8014392:	68fc      	ldr	r4, [r7, #12]
 8014394:	42bc      	cmp	r4, r7
 8014396:	d000      	beq.n	801439a <_malloc_r+0x19a>
 8014398:	e09c      	b.n	80144d4 <_malloc_r+0x2d4>
 801439a:	2003      	movs	r0, #3
 801439c:	9b02      	ldr	r3, [sp, #8]
 801439e:	3708      	adds	r7, #8
 80143a0:	3301      	adds	r3, #1
 80143a2:	9302      	str	r3, [sp, #8]
 80143a4:	4203      	tst	r3, r0
 80143a6:	d1f4      	bne.n	8014392 <_malloc_r+0x192>
 80143a8:	4663      	mov	r3, ip
 80143aa:	2003      	movs	r0, #3
 80143ac:	4203      	tst	r3, r0
 80143ae:	d000      	beq.n	80143b2 <_malloc_r+0x1b2>
 80143b0:	e0b3      	b.n	801451a <_malloc_r+0x31a>
 80143b2:	684b      	ldr	r3, [r1, #4]
 80143b4:	4393      	bics	r3, r2
 80143b6:	604b      	str	r3, [r1, #4]
 80143b8:	4b62      	ldr	r3, [pc, #392]	; (8014544 <_malloc_r+0x344>)
 80143ba:	0052      	lsls	r2, r2, #1
 80143bc:	685b      	ldr	r3, [r3, #4]
 80143be:	4293      	cmp	r3, r2
 80143c0:	d302      	bcc.n	80143c8 <_malloc_r+0x1c8>
 80143c2:	2a00      	cmp	r2, #0
 80143c4:	d000      	beq.n	80143c8 <_malloc_r+0x1c8>
 80143c6:	e0b9      	b.n	801453c <_malloc_r+0x33c>
 80143c8:	2303      	movs	r3, #3
 80143ca:	688f      	ldr	r7, [r1, #8]
 80143cc:	687a      	ldr	r2, [r7, #4]
 80143ce:	439a      	bics	r2, r3
 80143d0:	9202      	str	r2, [sp, #8]
 80143d2:	42aa      	cmp	r2, r5
 80143d4:	d303      	bcc.n	80143de <_malloc_r+0x1de>
 80143d6:	1b52      	subs	r2, r2, r5
 80143d8:	2a0f      	cmp	r2, #15
 80143da:	dd00      	ble.n	80143de <_malloc_r+0x1de>
 80143dc:	e116      	b.n	801460c <_malloc_r+0x40c>
 80143de:	4b5d      	ldr	r3, [pc, #372]	; (8014554 <_malloc_r+0x354>)
 80143e0:	2008      	movs	r0, #8
 80143e2:	681e      	ldr	r6, [r3, #0]
 80143e4:	f002 fdb0 	bl	8016f48 <sysconf>
 80143e8:	4b5b      	ldr	r3, [pc, #364]	; (8014558 <_malloc_r+0x358>)
 80143ea:	3610      	adds	r6, #16
 80143ec:	681b      	ldr	r3, [r3, #0]
 80143ee:	1976      	adds	r6, r6, r5
 80143f0:	9003      	str	r0, [sp, #12]
 80143f2:	3301      	adds	r3, #1
 80143f4:	d003      	beq.n	80143fe <_malloc_r+0x1fe>
 80143f6:	3e01      	subs	r6, #1
 80143f8:	1836      	adds	r6, r6, r0
 80143fa:	4243      	negs	r3, r0
 80143fc:	401e      	ands	r6, r3
 80143fe:	0031      	movs	r1, r6
 8014400:	9801      	ldr	r0, [sp, #4]
 8014402:	f000 fb19 	bl	8014a38 <_sbrk_r>
 8014406:	0004      	movs	r4, r0
 8014408:	1c43      	adds	r3, r0, #1
 801440a:	d100      	bne.n	801440e <_malloc_r+0x20e>
 801440c:	e0d6      	b.n	80145bc <_malloc_r+0x3bc>
 801440e:	9b02      	ldr	r3, [sp, #8]
 8014410:	18fb      	adds	r3, r7, r3
 8014412:	4283      	cmp	r3, r0
 8014414:	d903      	bls.n	801441e <_malloc_r+0x21e>
 8014416:	4a4b      	ldr	r2, [pc, #300]	; (8014544 <_malloc_r+0x344>)
 8014418:	4297      	cmp	r7, r2
 801441a:	d000      	beq.n	801441e <_malloc_r+0x21e>
 801441c:	e0ce      	b.n	80145bc <_malloc_r+0x3bc>
 801441e:	494f      	ldr	r1, [pc, #316]	; (801455c <_malloc_r+0x35c>)
 8014420:	680a      	ldr	r2, [r1, #0]
 8014422:	18b2      	adds	r2, r6, r2
 8014424:	600a      	str	r2, [r1, #0]
 8014426:	9903      	ldr	r1, [sp, #12]
 8014428:	4694      	mov	ip, r2
 801442a:	1e48      	subs	r0, r1, #1
 801442c:	42a3      	cmp	r3, r4
 801442e:	d000      	beq.n	8014432 <_malloc_r+0x232>
 8014430:	e09a      	b.n	8014568 <_malloc_r+0x368>
 8014432:	4203      	tst	r3, r0
 8014434:	d000      	beq.n	8014438 <_malloc_r+0x238>
 8014436:	e097      	b.n	8014568 <_malloc_r+0x368>
 8014438:	9a02      	ldr	r2, [sp, #8]
 801443a:	4b42      	ldr	r3, [pc, #264]	; (8014544 <_malloc_r+0x344>)
 801443c:	1992      	adds	r2, r2, r6
 801443e:	2601      	movs	r6, #1
 8014440:	689b      	ldr	r3, [r3, #8]
 8014442:	4316      	orrs	r6, r2
 8014444:	605e      	str	r6, [r3, #4]
 8014446:	4b45      	ldr	r3, [pc, #276]	; (801455c <_malloc_r+0x35c>)
 8014448:	4a45      	ldr	r2, [pc, #276]	; (8014560 <_malloc_r+0x360>)
 801444a:	681b      	ldr	r3, [r3, #0]
 801444c:	6811      	ldr	r1, [r2, #0]
 801444e:	428b      	cmp	r3, r1
 8014450:	d900      	bls.n	8014454 <_malloc_r+0x254>
 8014452:	6013      	str	r3, [r2, #0]
 8014454:	4a43      	ldr	r2, [pc, #268]	; (8014564 <_malloc_r+0x364>)
 8014456:	6811      	ldr	r1, [r2, #0]
 8014458:	428b      	cmp	r3, r1
 801445a:	d800      	bhi.n	801445e <_malloc_r+0x25e>
 801445c:	e0ae      	b.n	80145bc <_malloc_r+0x3bc>
 801445e:	6013      	str	r3, [r2, #0]
 8014460:	e0ac      	b.n	80145bc <_malloc_r+0x3bc>
 8014462:	0a40      	lsrs	r0, r0, #9
 8014464:	2804      	cmp	r0, #4
 8014466:	d810      	bhi.n	801448a <_malloc_r+0x28a>
 8014468:	0999      	lsrs	r1, r3, #6
 801446a:	3138      	adds	r1, #56	; 0x38
 801446c:	00ce      	lsls	r6, r1, #3
 801446e:	18b6      	adds	r6, r6, r2
 8014470:	68b0      	ldr	r0, [r6, #8]
 8014472:	4286      	cmp	r6, r0
 8014474:	d124      	bne.n	80144c0 <_malloc_r+0x2c0>
 8014476:	2301      	movs	r3, #1
 8014478:	1089      	asrs	r1, r1, #2
 801447a:	408b      	lsls	r3, r1
 801447c:	433b      	orrs	r3, r7
 801447e:	6053      	str	r3, [r2, #4]
 8014480:	60e6      	str	r6, [r4, #12]
 8014482:	60a0      	str	r0, [r4, #8]
 8014484:	60b4      	str	r4, [r6, #8]
 8014486:	60c4      	str	r4, [r0, #12]
 8014488:	e768      	b.n	801435c <_malloc_r+0x15c>
 801448a:	2814      	cmp	r0, #20
 801448c:	d802      	bhi.n	8014494 <_malloc_r+0x294>
 801448e:	0001      	movs	r1, r0
 8014490:	315b      	adds	r1, #91	; 0x5b
 8014492:	e7eb      	b.n	801446c <_malloc_r+0x26c>
 8014494:	2854      	cmp	r0, #84	; 0x54
 8014496:	d802      	bhi.n	801449e <_malloc_r+0x29e>
 8014498:	0b19      	lsrs	r1, r3, #12
 801449a:	316e      	adds	r1, #110	; 0x6e
 801449c:	e7e6      	b.n	801446c <_malloc_r+0x26c>
 801449e:	21aa      	movs	r1, #170	; 0xaa
 80144a0:	0049      	lsls	r1, r1, #1
 80144a2:	4288      	cmp	r0, r1
 80144a4:	d802      	bhi.n	80144ac <_malloc_r+0x2ac>
 80144a6:	0bd9      	lsrs	r1, r3, #15
 80144a8:	3177      	adds	r1, #119	; 0x77
 80144aa:	e7df      	b.n	801446c <_malloc_r+0x26c>
 80144ac:	4e27      	ldr	r6, [pc, #156]	; (801454c <_malloc_r+0x34c>)
 80144ae:	217e      	movs	r1, #126	; 0x7e
 80144b0:	42b0      	cmp	r0, r6
 80144b2:	d8db      	bhi.n	801446c <_malloc_r+0x26c>
 80144b4:	0c99      	lsrs	r1, r3, #18
 80144b6:	317c      	adds	r1, #124	; 0x7c
 80144b8:	e7d8      	b.n	801446c <_malloc_r+0x26c>
 80144ba:	6880      	ldr	r0, [r0, #8]
 80144bc:	4286      	cmp	r6, r0
 80144be:	d004      	beq.n	80144ca <_malloc_r+0x2ca>
 80144c0:	2103      	movs	r1, #3
 80144c2:	6842      	ldr	r2, [r0, #4]
 80144c4:	438a      	bics	r2, r1
 80144c6:	429a      	cmp	r2, r3
 80144c8:	d8f7      	bhi.n	80144ba <_malloc_r+0x2ba>
 80144ca:	68c6      	ldr	r6, [r0, #12]
 80144cc:	e7d8      	b.n	8014480 <_malloc_r+0x280>
 80144ce:	2304      	movs	r3, #4
 80144d0:	449c      	add	ip, r3
 80144d2:	e753      	b.n	801437c <_malloc_r+0x17c>
 80144d4:	2003      	movs	r0, #3
 80144d6:	6863      	ldr	r3, [r4, #4]
 80144d8:	4383      	bics	r3, r0
 80144da:	1b5e      	subs	r6, r3, r5
 80144dc:	68e0      	ldr	r0, [r4, #12]
 80144de:	2e0f      	cmp	r6, #15
 80144e0:	dd0e      	ble.n	8014500 <_malloc_r+0x300>
 80144e2:	2701      	movs	r7, #1
 80144e4:	1962      	adds	r2, r4, r5
 80144e6:	433d      	orrs	r5, r7
 80144e8:	6065      	str	r5, [r4, #4]
 80144ea:	68a5      	ldr	r5, [r4, #8]
 80144ec:	4337      	orrs	r7, r6
 80144ee:	60e8      	str	r0, [r5, #12]
 80144f0:	6085      	str	r5, [r0, #8]
 80144f2:	614a      	str	r2, [r1, #20]
 80144f4:	610a      	str	r2, [r1, #16]
 80144f6:	4914      	ldr	r1, [pc, #80]	; (8014548 <_malloc_r+0x348>)
 80144f8:	6057      	str	r7, [r2, #4]
 80144fa:	60d1      	str	r1, [r2, #12]
 80144fc:	6091      	str	r1, [r2, #8]
 80144fe:	e6e8      	b.n	80142d2 <_malloc_r+0xd2>
 8014500:	2e00      	cmp	r6, #0
 8014502:	db08      	blt.n	8014516 <_malloc_r+0x316>
 8014504:	2201      	movs	r2, #1
 8014506:	18e3      	adds	r3, r4, r3
 8014508:	6859      	ldr	r1, [r3, #4]
 801450a:	430a      	orrs	r2, r1
 801450c:	605a      	str	r2, [r3, #4]
 801450e:	68a3      	ldr	r3, [r4, #8]
 8014510:	60d8      	str	r0, [r3, #12]
 8014512:	6083      	str	r3, [r0, #8]
 8014514:	e6aa      	b.n	801426c <_malloc_r+0x6c>
 8014516:	0004      	movs	r4, r0
 8014518:	e73c      	b.n	8014394 <_malloc_r+0x194>
 801451a:	2301      	movs	r3, #1
 801451c:	425b      	negs	r3, r3
 801451e:	449c      	add	ip, r3
 8014520:	9b03      	ldr	r3, [sp, #12]
 8014522:	6818      	ldr	r0, [r3, #0]
 8014524:	3b08      	subs	r3, #8
 8014526:	9003      	str	r0, [sp, #12]
 8014528:	4298      	cmp	r0, r3
 801452a:	d100      	bne.n	801452e <_malloc_r+0x32e>
 801452c:	e73c      	b.n	80143a8 <_malloc_r+0x1a8>
 801452e:	e743      	b.n	80143b8 <_malloc_r+0x1b8>
 8014530:	2004      	movs	r0, #4
 8014532:	0052      	lsls	r2, r2, #1
 8014534:	4484      	add	ip, r0
 8014536:	421a      	tst	r2, r3
 8014538:	d0fa      	beq.n	8014530 <_malloc_r+0x330>
 801453a:	e723      	b.n	8014384 <_malloc_r+0x184>
 801453c:	9802      	ldr	r0, [sp, #8]
 801453e:	4684      	mov	ip, r0
 8014540:	e7f9      	b.n	8014536 <_malloc_r+0x336>
 8014542:	46c0      	nop			; (mov r8, r8)
 8014544:	2000066c 	.word	0x2000066c
 8014548:	20000674 	.word	0x20000674
 801454c:	00000554 	.word	0x00000554
 8014550:	000001ff 	.word	0x000001ff
 8014554:	20006eec 	.word	0x20006eec
 8014558:	20000a74 	.word	0x20000a74
 801455c:	20006ebc 	.word	0x20006ebc
 8014560:	20006ee4 	.word	0x20006ee4
 8014564:	20006ee8 	.word	0x20006ee8
 8014568:	492e      	ldr	r1, [pc, #184]	; (8014624 <_malloc_r+0x424>)
 801456a:	680a      	ldr	r2, [r1, #0]
 801456c:	3201      	adds	r2, #1
 801456e:	d133      	bne.n	80145d8 <_malloc_r+0x3d8>
 8014570:	600c      	str	r4, [r1, #0]
 8014572:	2307      	movs	r3, #7
 8014574:	4023      	ands	r3, r4
 8014576:	d002      	beq.n	801457e <_malloc_r+0x37e>
 8014578:	2208      	movs	r2, #8
 801457a:	1ad3      	subs	r3, r2, r3
 801457c:	18e4      	adds	r4, r4, r3
 801457e:	9a03      	ldr	r2, [sp, #12]
 8014580:	19a6      	adds	r6, r4, r6
 8014582:	18d3      	adds	r3, r2, r3
 8014584:	4006      	ands	r6, r0
 8014586:	1b9e      	subs	r6, r3, r6
 8014588:	0031      	movs	r1, r6
 801458a:	9801      	ldr	r0, [sp, #4]
 801458c:	f000 fa54 	bl	8014a38 <_sbrk_r>
 8014590:	1c43      	adds	r3, r0, #1
 8014592:	d101      	bne.n	8014598 <_malloc_r+0x398>
 8014594:	0020      	movs	r0, r4
 8014596:	2600      	movs	r6, #0
 8014598:	4a23      	ldr	r2, [pc, #140]	; (8014628 <_malloc_r+0x428>)
 801459a:	1b00      	subs	r0, r0, r4
 801459c:	6813      	ldr	r3, [r2, #0]
 801459e:	199b      	adds	r3, r3, r6
 80145a0:	6013      	str	r3, [r2, #0]
 80145a2:	2301      	movs	r3, #1
 80145a4:	4a21      	ldr	r2, [pc, #132]	; (801462c <_malloc_r+0x42c>)
 80145a6:	1986      	adds	r6, r0, r6
 80145a8:	431e      	orrs	r6, r3
 80145aa:	6094      	str	r4, [r2, #8]
 80145ac:	6066      	str	r6, [r4, #4]
 80145ae:	4297      	cmp	r7, r2
 80145b0:	d100      	bne.n	80145b4 <_malloc_r+0x3b4>
 80145b2:	e748      	b.n	8014446 <_malloc_r+0x246>
 80145b4:	9a02      	ldr	r2, [sp, #8]
 80145b6:	2a0f      	cmp	r2, #15
 80145b8:	d813      	bhi.n	80145e2 <_malloc_r+0x3e2>
 80145ba:	6063      	str	r3, [r4, #4]
 80145bc:	2203      	movs	r2, #3
 80145be:	4b1b      	ldr	r3, [pc, #108]	; (801462c <_malloc_r+0x42c>)
 80145c0:	689b      	ldr	r3, [r3, #8]
 80145c2:	685b      	ldr	r3, [r3, #4]
 80145c4:	4393      	bics	r3, r2
 80145c6:	1b5a      	subs	r2, r3, r5
 80145c8:	42ab      	cmp	r3, r5
 80145ca:	d301      	bcc.n	80145d0 <_malloc_r+0x3d0>
 80145cc:	2a0f      	cmp	r2, #15
 80145ce:	dc1d      	bgt.n	801460c <_malloc_r+0x40c>
 80145d0:	9801      	ldr	r0, [sp, #4]
 80145d2:	f000 f859 	bl	8014688 <__malloc_unlock>
 80145d6:	e620      	b.n	801421a <_malloc_r+0x1a>
 80145d8:	1ae3      	subs	r3, r4, r3
 80145da:	4a13      	ldr	r2, [pc, #76]	; (8014628 <_malloc_r+0x428>)
 80145dc:	4463      	add	r3, ip
 80145de:	6013      	str	r3, [r2, #0]
 80145e0:	e7c7      	b.n	8014572 <_malloc_r+0x372>
 80145e2:	2207      	movs	r2, #7
 80145e4:	9e02      	ldr	r6, [sp, #8]
 80145e6:	3e0c      	subs	r6, #12
 80145e8:	4396      	bics	r6, r2
 80145ea:	687a      	ldr	r2, [r7, #4]
 80145ec:	4013      	ands	r3, r2
 80145ee:	2205      	movs	r2, #5
 80145f0:	4333      	orrs	r3, r6
 80145f2:	607b      	str	r3, [r7, #4]
 80145f4:	19bb      	adds	r3, r7, r6
 80145f6:	605a      	str	r2, [r3, #4]
 80145f8:	609a      	str	r2, [r3, #8]
 80145fa:	2e0f      	cmp	r6, #15
 80145fc:	d800      	bhi.n	8014600 <_malloc_r+0x400>
 80145fe:	e722      	b.n	8014446 <_malloc_r+0x246>
 8014600:	0039      	movs	r1, r7
 8014602:	9801      	ldr	r0, [sp, #4]
 8014604:	3108      	adds	r1, #8
 8014606:	f003 fb91 	bl	8017d2c <_free_r>
 801460a:	e71c      	b.n	8014446 <_malloc_r+0x246>
 801460c:	2301      	movs	r3, #1
 801460e:	0018      	movs	r0, r3
 8014610:	4906      	ldr	r1, [pc, #24]	; (801462c <_malloc_r+0x42c>)
 8014612:	4328      	orrs	r0, r5
 8014614:	688c      	ldr	r4, [r1, #8]
 8014616:	4313      	orrs	r3, r2
 8014618:	1965      	adds	r5, r4, r5
 801461a:	6060      	str	r0, [r4, #4]
 801461c:	608d      	str	r5, [r1, #8]
 801461e:	606b      	str	r3, [r5, #4]
 8014620:	e624      	b.n	801426c <_malloc_r+0x6c>
 8014622:	46c0      	nop			; (mov r8, r8)
 8014624:	20000a74 	.word	0x20000a74
 8014628:	20006ebc 	.word	0x20006ebc
 801462c:	2000066c 	.word	0x2000066c

08014630 <__ascii_mbtowc>:
 8014630:	b082      	sub	sp, #8
 8014632:	2900      	cmp	r1, #0
 8014634:	d100      	bne.n	8014638 <__ascii_mbtowc+0x8>
 8014636:	a901      	add	r1, sp, #4
 8014638:	1e10      	subs	r0, r2, #0
 801463a:	d006      	beq.n	801464a <__ascii_mbtowc+0x1a>
 801463c:	2b00      	cmp	r3, #0
 801463e:	d006      	beq.n	801464e <__ascii_mbtowc+0x1e>
 8014640:	7813      	ldrb	r3, [r2, #0]
 8014642:	600b      	str	r3, [r1, #0]
 8014644:	7810      	ldrb	r0, [r2, #0]
 8014646:	1e43      	subs	r3, r0, #1
 8014648:	4198      	sbcs	r0, r3
 801464a:	b002      	add	sp, #8
 801464c:	4770      	bx	lr
 801464e:	2002      	movs	r0, #2
 8014650:	4240      	negs	r0, r0
 8014652:	e7fa      	b.n	801464a <__ascii_mbtowc+0x1a>

08014654 <memcpy>:
 8014654:	2300      	movs	r3, #0
 8014656:	b510      	push	{r4, lr}
 8014658:	429a      	cmp	r2, r3
 801465a:	d100      	bne.n	801465e <memcpy+0xa>
 801465c:	bd10      	pop	{r4, pc}
 801465e:	5ccc      	ldrb	r4, [r1, r3]
 8014660:	54c4      	strb	r4, [r0, r3]
 8014662:	3301      	adds	r3, #1
 8014664:	e7f8      	b.n	8014658 <memcpy+0x4>

08014666 <memset>:
 8014666:	0003      	movs	r3, r0
 8014668:	1812      	adds	r2, r2, r0
 801466a:	4293      	cmp	r3, r2
 801466c:	d100      	bne.n	8014670 <memset+0xa>
 801466e:	4770      	bx	lr
 8014670:	7019      	strb	r1, [r3, #0]
 8014672:	3301      	adds	r3, #1
 8014674:	e7f9      	b.n	801466a <memset+0x4>
	...

08014678 <__malloc_lock>:
 8014678:	b510      	push	{r4, lr}
 801467a:	4802      	ldr	r0, [pc, #8]	; (8014684 <__malloc_lock+0xc>)
 801467c:	f003 ff4a 	bl	8018514 <__retarget_lock_acquire_recursive>
 8014680:	bd10      	pop	{r4, pc}
 8014682:	46c0      	nop			; (mov r8, r8)
 8014684:	20007adc 	.word	0x20007adc

08014688 <__malloc_unlock>:
 8014688:	b510      	push	{r4, lr}
 801468a:	4802      	ldr	r0, [pc, #8]	; (8014694 <__malloc_unlock+0xc>)
 801468c:	f003 ff43 	bl	8018516 <__retarget_lock_release_recursive>
 8014690:	bd10      	pop	{r4, pc}
 8014692:	46c0      	nop			; (mov r8, r8)
 8014694:	20007adc 	.word	0x20007adc

08014698 <rand>:
 8014698:	4b09      	ldr	r3, [pc, #36]	; (80146c0 <rand+0x28>)
 801469a:	b510      	push	{r4, lr}
 801469c:	681c      	ldr	r4, [r3, #0]
 801469e:	4a09      	ldr	r2, [pc, #36]	; (80146c4 <rand+0x2c>)
 80146a0:	34a8      	adds	r4, #168	; 0xa8
 80146a2:	6820      	ldr	r0, [r4, #0]
 80146a4:	6861      	ldr	r1, [r4, #4]
 80146a6:	4b08      	ldr	r3, [pc, #32]	; (80146c8 <rand+0x30>)
 80146a8:	f7eb ff80 	bl	80005ac <__aeabi_lmul>
 80146ac:	2201      	movs	r2, #1
 80146ae:	2300      	movs	r3, #0
 80146b0:	1880      	adds	r0, r0, r2
 80146b2:	4159      	adcs	r1, r3
 80146b4:	6020      	str	r0, [r4, #0]
 80146b6:	6061      	str	r1, [r4, #4]
 80146b8:	0048      	lsls	r0, r1, #1
 80146ba:	0840      	lsrs	r0, r0, #1
 80146bc:	bd10      	pop	{r4, pc}
 80146be:	46c0      	nop			; (mov r8, r8)
 80146c0:	200000d0 	.word	0x200000d0
 80146c4:	4c957f2d 	.word	0x4c957f2d
 80146c8:	5851f42d 	.word	0x5851f42d

080146cc <realloc>:
 80146cc:	b510      	push	{r4, lr}
 80146ce:	4b03      	ldr	r3, [pc, #12]	; (80146dc <realloc+0x10>)
 80146d0:	000a      	movs	r2, r1
 80146d2:	0001      	movs	r1, r0
 80146d4:	6818      	ldr	r0, [r3, #0]
 80146d6:	f000 f803 	bl	80146e0 <_realloc_r>
 80146da:	bd10      	pop	{r4, pc}
 80146dc:	200000d0 	.word	0x200000d0

080146e0 <_realloc_r>:
 80146e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80146e2:	b087      	sub	sp, #28
 80146e4:	9003      	str	r0, [sp, #12]
 80146e6:	1e0c      	subs	r4, r1, #0
 80146e8:	9205      	str	r2, [sp, #20]
 80146ea:	d106      	bne.n	80146fa <_realloc_r+0x1a>
 80146ec:	0011      	movs	r1, r2
 80146ee:	f7ff fd87 	bl	8014200 <_malloc_r>
 80146f2:	0007      	movs	r7, r0
 80146f4:	0038      	movs	r0, r7
 80146f6:	b007      	add	sp, #28
 80146f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80146fa:	9803      	ldr	r0, [sp, #12]
 80146fc:	f7ff ffbc 	bl	8014678 <__malloc_lock>
 8014700:	0023      	movs	r3, r4
 8014702:	3b08      	subs	r3, #8
 8014704:	685f      	ldr	r7, [r3, #4]
 8014706:	9302      	str	r3, [sp, #8]
 8014708:	003a      	movs	r2, r7
 801470a:	2303      	movs	r3, #3
 801470c:	9e05      	ldr	r6, [sp, #20]
 801470e:	439a      	bics	r2, r3
 8014710:	360b      	adds	r6, #11
 8014712:	9204      	str	r2, [sp, #16]
 8014714:	2e16      	cmp	r6, #22
 8014716:	d908      	bls.n	801472a <_realloc_r+0x4a>
 8014718:	3304      	adds	r3, #4
 801471a:	439e      	bics	r6, r3
 801471c:	9601      	str	r6, [sp, #4]
 801471e:	d506      	bpl.n	801472e <_realloc_r+0x4e>
 8014720:	230c      	movs	r3, #12
 8014722:	9a03      	ldr	r2, [sp, #12]
 8014724:	2700      	movs	r7, #0
 8014726:	6013      	str	r3, [r2, #0]
 8014728:	e7e4      	b.n	80146f4 <_realloc_r+0x14>
 801472a:	2310      	movs	r3, #16
 801472c:	9301      	str	r3, [sp, #4]
 801472e:	9b01      	ldr	r3, [sp, #4]
 8014730:	9a05      	ldr	r2, [sp, #20]
 8014732:	4293      	cmp	r3, r2
 8014734:	d3f4      	bcc.n	8014720 <_realloc_r+0x40>
 8014736:	9b01      	ldr	r3, [sp, #4]
 8014738:	9a04      	ldr	r2, [sp, #16]
 801473a:	4293      	cmp	r3, r2
 801473c:	dc00      	bgt.n	8014740 <_realloc_r+0x60>
 801473e:	e16f      	b.n	8014a20 <_realloc_r+0x340>
 8014740:	9b02      	ldr	r3, [sp, #8]
 8014742:	48bc      	ldr	r0, [pc, #752]	; (8014a34 <_realloc_r+0x354>)
 8014744:	189b      	adds	r3, r3, r2
 8014746:	6882      	ldr	r2, [r0, #8]
 8014748:	4694      	mov	ip, r2
 801474a:	685a      	ldr	r2, [r3, #4]
 801474c:	459c      	cmp	ip, r3
 801474e:	d006      	beq.n	801475e <_realloc_r+0x7e>
 8014750:	2501      	movs	r5, #1
 8014752:	0011      	movs	r1, r2
 8014754:	43a9      	bics	r1, r5
 8014756:	1859      	adds	r1, r3, r1
 8014758:	6849      	ldr	r1, [r1, #4]
 801475a:	4229      	tst	r1, r5
 801475c:	d146      	bne.n	80147ec <_realloc_r+0x10c>
 801475e:	2103      	movs	r1, #3
 8014760:	438a      	bics	r2, r1
 8014762:	9904      	ldr	r1, [sp, #16]
 8014764:	188e      	adds	r6, r1, r2
 8014766:	9901      	ldr	r1, [sp, #4]
 8014768:	459c      	cmp	ip, r3
 801476a:	d117      	bne.n	801479c <_realloc_r+0xbc>
 801476c:	3110      	adds	r1, #16
 801476e:	42b1      	cmp	r1, r6
 8014770:	dc3e      	bgt.n	80147f0 <_realloc_r+0x110>
 8014772:	9901      	ldr	r1, [sp, #4]
 8014774:	9b02      	ldr	r3, [sp, #8]
 8014776:	468c      	mov	ip, r1
 8014778:	4463      	add	r3, ip
 801477a:	6083      	str	r3, [r0, #8]
 801477c:	001a      	movs	r2, r3
 801477e:	1a73      	subs	r3, r6, r1
 8014780:	2601      	movs	r6, #1
 8014782:	4333      	orrs	r3, r6
 8014784:	6053      	str	r3, [r2, #4]
 8014786:	0023      	movs	r3, r4
 8014788:	3b08      	subs	r3, #8
 801478a:	685a      	ldr	r2, [r3, #4]
 801478c:	9803      	ldr	r0, [sp, #12]
 801478e:	4016      	ands	r6, r2
 8014790:	430e      	orrs	r6, r1
 8014792:	605e      	str	r6, [r3, #4]
 8014794:	f7ff ff78 	bl	8014688 <__malloc_unlock>
 8014798:	0027      	movs	r7, r4
 801479a:	e7ab      	b.n	80146f4 <_realloc_r+0x14>
 801479c:	42b1      	cmp	r1, r6
 801479e:	dc27      	bgt.n	80147f0 <_realloc_r+0x110>
 80147a0:	68da      	ldr	r2, [r3, #12]
 80147a2:	689b      	ldr	r3, [r3, #8]
 80147a4:	60da      	str	r2, [r3, #12]
 80147a6:	6093      	str	r3, [r2, #8]
 80147a8:	9b01      	ldr	r3, [sp, #4]
 80147aa:	9a02      	ldr	r2, [sp, #8]
 80147ac:	1af4      	subs	r4, r6, r3
 80147ae:	9b02      	ldr	r3, [sp, #8]
 80147b0:	1992      	adds	r2, r2, r6
 80147b2:	685b      	ldr	r3, [r3, #4]
 80147b4:	9304      	str	r3, [sp, #16]
 80147b6:	2301      	movs	r3, #1
 80147b8:	9804      	ldr	r0, [sp, #16]
 80147ba:	4018      	ands	r0, r3
 80147bc:	2c0f      	cmp	r4, #15
 80147be:	d800      	bhi.n	80147c2 <_realloc_r+0xe2>
 80147c0:	e130      	b.n	8014a24 <_realloc_r+0x344>
 80147c2:	9d01      	ldr	r5, [sp, #4]
 80147c4:	9902      	ldr	r1, [sp, #8]
 80147c6:	4328      	orrs	r0, r5
 80147c8:	1949      	adds	r1, r1, r5
 80147ca:	9d02      	ldr	r5, [sp, #8]
 80147cc:	431c      	orrs	r4, r3
 80147ce:	6068      	str	r0, [r5, #4]
 80147d0:	604c      	str	r4, [r1, #4]
 80147d2:	6850      	ldr	r0, [r2, #4]
 80147d4:	3108      	adds	r1, #8
 80147d6:	4303      	orrs	r3, r0
 80147d8:	6053      	str	r3, [r2, #4]
 80147da:	9803      	ldr	r0, [sp, #12]
 80147dc:	f003 faa6 	bl	8017d2c <_free_r>
 80147e0:	9803      	ldr	r0, [sp, #12]
 80147e2:	f7ff ff51 	bl	8014688 <__malloc_unlock>
 80147e6:	9f02      	ldr	r7, [sp, #8]
 80147e8:	3708      	adds	r7, #8
 80147ea:	e783      	b.n	80146f4 <_realloc_r+0x14>
 80147ec:	2200      	movs	r2, #0
 80147ee:	0013      	movs	r3, r2
 80147f0:	07f9      	lsls	r1, r7, #31
 80147f2:	d500      	bpl.n	80147f6 <_realloc_r+0x116>
 80147f4:	e0c6      	b.n	8014984 <_realloc_r+0x2a4>
 80147f6:	0021      	movs	r1, r4
 80147f8:	3908      	subs	r1, #8
 80147fa:	680d      	ldr	r5, [r1, #0]
 80147fc:	9902      	ldr	r1, [sp, #8]
 80147fe:	1b4d      	subs	r5, r1, r5
 8014800:	2103      	movs	r1, #3
 8014802:	686f      	ldr	r7, [r5, #4]
 8014804:	438f      	bics	r7, r1
 8014806:	9904      	ldr	r1, [sp, #16]
 8014808:	187f      	adds	r7, r7, r1
 801480a:	2b00      	cmp	r3, #0
 801480c:	d100      	bne.n	8014810 <_realloc_r+0x130>
 801480e:	e084      	b.n	801491a <_realloc_r+0x23a>
 8014810:	19d6      	adds	r6, r2, r7
 8014812:	459c      	cmp	ip, r3
 8014814:	d148      	bne.n	80148a8 <_realloc_r+0x1c8>
 8014816:	9b01      	ldr	r3, [sp, #4]
 8014818:	3310      	adds	r3, #16
 801481a:	42b3      	cmp	r3, r6
 801481c:	dc7d      	bgt.n	801491a <_realloc_r+0x23a>
 801481e:	68aa      	ldr	r2, [r5, #8]
 8014820:	68eb      	ldr	r3, [r5, #12]
 8014822:	002f      	movs	r7, r5
 8014824:	60d3      	str	r3, [r2, #12]
 8014826:	609a      	str	r2, [r3, #8]
 8014828:	000a      	movs	r2, r1
 801482a:	3a04      	subs	r2, #4
 801482c:	3708      	adds	r7, #8
 801482e:	2a24      	cmp	r2, #36	; 0x24
 8014830:	d835      	bhi.n	801489e <_realloc_r+0x1be>
 8014832:	003b      	movs	r3, r7
 8014834:	2a13      	cmp	r2, #19
 8014836:	d908      	bls.n	801484a <_realloc_r+0x16a>
 8014838:	6823      	ldr	r3, [r4, #0]
 801483a:	60ab      	str	r3, [r5, #8]
 801483c:	6863      	ldr	r3, [r4, #4]
 801483e:	60eb      	str	r3, [r5, #12]
 8014840:	2a1b      	cmp	r2, #27
 8014842:	d81a      	bhi.n	801487a <_realloc_r+0x19a>
 8014844:	002b      	movs	r3, r5
 8014846:	3408      	adds	r4, #8
 8014848:	3310      	adds	r3, #16
 801484a:	6822      	ldr	r2, [r4, #0]
 801484c:	601a      	str	r2, [r3, #0]
 801484e:	6862      	ldr	r2, [r4, #4]
 8014850:	605a      	str	r2, [r3, #4]
 8014852:	68a2      	ldr	r2, [r4, #8]
 8014854:	609a      	str	r2, [r3, #8]
 8014856:	9b01      	ldr	r3, [sp, #4]
 8014858:	18ea      	adds	r2, r5, r3
 801485a:	4b76      	ldr	r3, [pc, #472]	; (8014a34 <_realloc_r+0x354>)
 801485c:	609a      	str	r2, [r3, #8]
 801485e:	9b01      	ldr	r3, [sp, #4]
 8014860:	1af3      	subs	r3, r6, r3
 8014862:	2601      	movs	r6, #1
 8014864:	4333      	orrs	r3, r6
 8014866:	6053      	str	r3, [r2, #4]
 8014868:	686b      	ldr	r3, [r5, #4]
 801486a:	401e      	ands	r6, r3
 801486c:	9b01      	ldr	r3, [sp, #4]
 801486e:	431e      	orrs	r6, r3
 8014870:	606e      	str	r6, [r5, #4]
 8014872:	9803      	ldr	r0, [sp, #12]
 8014874:	f7ff ff08 	bl	8014688 <__malloc_unlock>
 8014878:	e73c      	b.n	80146f4 <_realloc_r+0x14>
 801487a:	68a3      	ldr	r3, [r4, #8]
 801487c:	612b      	str	r3, [r5, #16]
 801487e:	68e3      	ldr	r3, [r4, #12]
 8014880:	616b      	str	r3, [r5, #20]
 8014882:	2a24      	cmp	r2, #36	; 0x24
 8014884:	d003      	beq.n	801488e <_realloc_r+0x1ae>
 8014886:	002b      	movs	r3, r5
 8014888:	3410      	adds	r4, #16
 801488a:	3318      	adds	r3, #24
 801488c:	e7dd      	b.n	801484a <_realloc_r+0x16a>
 801488e:	6923      	ldr	r3, [r4, #16]
 8014890:	61ab      	str	r3, [r5, #24]
 8014892:	002b      	movs	r3, r5
 8014894:	6962      	ldr	r2, [r4, #20]
 8014896:	3320      	adds	r3, #32
 8014898:	61ea      	str	r2, [r5, #28]
 801489a:	3418      	adds	r4, #24
 801489c:	e7d5      	b.n	801484a <_realloc_r+0x16a>
 801489e:	0021      	movs	r1, r4
 80148a0:	0038      	movs	r0, r7
 80148a2:	f003 fe44 	bl	801852e <memmove>
 80148a6:	e7d6      	b.n	8014856 <_realloc_r+0x176>
 80148a8:	9a01      	ldr	r2, [sp, #4]
 80148aa:	42b2      	cmp	r2, r6
 80148ac:	dc35      	bgt.n	801491a <_realloc_r+0x23a>
 80148ae:	0028      	movs	r0, r5
 80148b0:	68da      	ldr	r2, [r3, #12]
 80148b2:	689b      	ldr	r3, [r3, #8]
 80148b4:	3008      	adds	r0, #8
 80148b6:	60da      	str	r2, [r3, #12]
 80148b8:	6093      	str	r3, [r2, #8]
 80148ba:	68aa      	ldr	r2, [r5, #8]
 80148bc:	68eb      	ldr	r3, [r5, #12]
 80148be:	60d3      	str	r3, [r2, #12]
 80148c0:	609a      	str	r2, [r3, #8]
 80148c2:	9a04      	ldr	r2, [sp, #16]
 80148c4:	3a04      	subs	r2, #4
 80148c6:	2a24      	cmp	r2, #36	; 0x24
 80148c8:	d823      	bhi.n	8014912 <_realloc_r+0x232>
 80148ca:	2a13      	cmp	r2, #19
 80148cc:	d907      	bls.n	80148de <_realloc_r+0x1fe>
 80148ce:	6823      	ldr	r3, [r4, #0]
 80148d0:	60ab      	str	r3, [r5, #8]
 80148d2:	6863      	ldr	r3, [r4, #4]
 80148d4:	60eb      	str	r3, [r5, #12]
 80148d6:	2a1b      	cmp	r2, #27
 80148d8:	d809      	bhi.n	80148ee <_realloc_r+0x20e>
 80148da:	3408      	adds	r4, #8
 80148dc:	3008      	adds	r0, #8
 80148de:	6823      	ldr	r3, [r4, #0]
 80148e0:	6003      	str	r3, [r0, #0]
 80148e2:	6863      	ldr	r3, [r4, #4]
 80148e4:	6043      	str	r3, [r0, #4]
 80148e6:	68a3      	ldr	r3, [r4, #8]
 80148e8:	6083      	str	r3, [r0, #8]
 80148ea:	9502      	str	r5, [sp, #8]
 80148ec:	e75c      	b.n	80147a8 <_realloc_r+0xc8>
 80148ee:	68a3      	ldr	r3, [r4, #8]
 80148f0:	612b      	str	r3, [r5, #16]
 80148f2:	68e3      	ldr	r3, [r4, #12]
 80148f4:	616b      	str	r3, [r5, #20]
 80148f6:	2a24      	cmp	r2, #36	; 0x24
 80148f8:	d003      	beq.n	8014902 <_realloc_r+0x222>
 80148fa:	0028      	movs	r0, r5
 80148fc:	3410      	adds	r4, #16
 80148fe:	3018      	adds	r0, #24
 8014900:	e7ed      	b.n	80148de <_realloc_r+0x1fe>
 8014902:	0028      	movs	r0, r5
 8014904:	6923      	ldr	r3, [r4, #16]
 8014906:	3020      	adds	r0, #32
 8014908:	61ab      	str	r3, [r5, #24]
 801490a:	6963      	ldr	r3, [r4, #20]
 801490c:	3418      	adds	r4, #24
 801490e:	61eb      	str	r3, [r5, #28]
 8014910:	e7e5      	b.n	80148de <_realloc_r+0x1fe>
 8014912:	0021      	movs	r1, r4
 8014914:	f003 fe0b 	bl	801852e <memmove>
 8014918:	e7e7      	b.n	80148ea <_realloc_r+0x20a>
 801491a:	9b01      	ldr	r3, [sp, #4]
 801491c:	42bb      	cmp	r3, r7
 801491e:	dc31      	bgt.n	8014984 <_realloc_r+0x2a4>
 8014920:	0028      	movs	r0, r5
 8014922:	68aa      	ldr	r2, [r5, #8]
 8014924:	68eb      	ldr	r3, [r5, #12]
 8014926:	3008      	adds	r0, #8
 8014928:	60d3      	str	r3, [r2, #12]
 801492a:	609a      	str	r2, [r3, #8]
 801492c:	9a04      	ldr	r2, [sp, #16]
 801492e:	3a04      	subs	r2, #4
 8014930:	2a24      	cmp	r2, #36	; 0x24
 8014932:	d823      	bhi.n	801497c <_realloc_r+0x29c>
 8014934:	2a13      	cmp	r2, #19
 8014936:	d907      	bls.n	8014948 <_realloc_r+0x268>
 8014938:	6823      	ldr	r3, [r4, #0]
 801493a:	60ab      	str	r3, [r5, #8]
 801493c:	6863      	ldr	r3, [r4, #4]
 801493e:	60eb      	str	r3, [r5, #12]
 8014940:	2a1b      	cmp	r2, #27
 8014942:	d809      	bhi.n	8014958 <_realloc_r+0x278>
 8014944:	3408      	adds	r4, #8
 8014946:	3008      	adds	r0, #8
 8014948:	6823      	ldr	r3, [r4, #0]
 801494a:	6003      	str	r3, [r0, #0]
 801494c:	6863      	ldr	r3, [r4, #4]
 801494e:	6043      	str	r3, [r0, #4]
 8014950:	68a3      	ldr	r3, [r4, #8]
 8014952:	6083      	str	r3, [r0, #8]
 8014954:	003e      	movs	r6, r7
 8014956:	e7c8      	b.n	80148ea <_realloc_r+0x20a>
 8014958:	68a3      	ldr	r3, [r4, #8]
 801495a:	612b      	str	r3, [r5, #16]
 801495c:	68e3      	ldr	r3, [r4, #12]
 801495e:	616b      	str	r3, [r5, #20]
 8014960:	2a24      	cmp	r2, #36	; 0x24
 8014962:	d003      	beq.n	801496c <_realloc_r+0x28c>
 8014964:	0028      	movs	r0, r5
 8014966:	3410      	adds	r4, #16
 8014968:	3018      	adds	r0, #24
 801496a:	e7ed      	b.n	8014948 <_realloc_r+0x268>
 801496c:	0028      	movs	r0, r5
 801496e:	6923      	ldr	r3, [r4, #16]
 8014970:	3020      	adds	r0, #32
 8014972:	61ab      	str	r3, [r5, #24]
 8014974:	6963      	ldr	r3, [r4, #20]
 8014976:	3418      	adds	r4, #24
 8014978:	61eb      	str	r3, [r5, #28]
 801497a:	e7e5      	b.n	8014948 <_realloc_r+0x268>
 801497c:	0021      	movs	r1, r4
 801497e:	f003 fdd6 	bl	801852e <memmove>
 8014982:	e7e7      	b.n	8014954 <_realloc_r+0x274>
 8014984:	9905      	ldr	r1, [sp, #20]
 8014986:	9803      	ldr	r0, [sp, #12]
 8014988:	f7ff fc3a 	bl	8014200 <_malloc_r>
 801498c:	1e07      	subs	r7, r0, #0
 801498e:	d100      	bne.n	8014992 <_realloc_r+0x2b2>
 8014990:	e76f      	b.n	8014872 <_realloc_r+0x192>
 8014992:	0023      	movs	r3, r4
 8014994:	2201      	movs	r2, #1
 8014996:	3b08      	subs	r3, #8
 8014998:	685b      	ldr	r3, [r3, #4]
 801499a:	4393      	bics	r3, r2
 801499c:	9a02      	ldr	r2, [sp, #8]
 801499e:	18d3      	adds	r3, r2, r3
 80149a0:	0002      	movs	r2, r0
 80149a2:	3a08      	subs	r2, #8
 80149a4:	4293      	cmp	r3, r2
 80149a6:	d105      	bne.n	80149b4 <_realloc_r+0x2d4>
 80149a8:	685e      	ldr	r6, [r3, #4]
 80149aa:	2303      	movs	r3, #3
 80149ac:	439e      	bics	r6, r3
 80149ae:	9b04      	ldr	r3, [sp, #16]
 80149b0:	18f6      	adds	r6, r6, r3
 80149b2:	e6f9      	b.n	80147a8 <_realloc_r+0xc8>
 80149b4:	9a04      	ldr	r2, [sp, #16]
 80149b6:	3a04      	subs	r2, #4
 80149b8:	2a24      	cmp	r2, #36	; 0x24
 80149ba:	d82d      	bhi.n	8014a18 <_realloc_r+0x338>
 80149bc:	2a13      	cmp	r2, #19
 80149be:	d928      	bls.n	8014a12 <_realloc_r+0x332>
 80149c0:	6823      	ldr	r3, [r4, #0]
 80149c2:	6003      	str	r3, [r0, #0]
 80149c4:	6863      	ldr	r3, [r4, #4]
 80149c6:	6043      	str	r3, [r0, #4]
 80149c8:	2a1b      	cmp	r2, #27
 80149ca:	d80e      	bhi.n	80149ea <_realloc_r+0x30a>
 80149cc:	0022      	movs	r2, r4
 80149ce:	0003      	movs	r3, r0
 80149d0:	3208      	adds	r2, #8
 80149d2:	3308      	adds	r3, #8
 80149d4:	6811      	ldr	r1, [r2, #0]
 80149d6:	6019      	str	r1, [r3, #0]
 80149d8:	6851      	ldr	r1, [r2, #4]
 80149da:	6059      	str	r1, [r3, #4]
 80149dc:	6892      	ldr	r2, [r2, #8]
 80149de:	609a      	str	r2, [r3, #8]
 80149e0:	0021      	movs	r1, r4
 80149e2:	9803      	ldr	r0, [sp, #12]
 80149e4:	f003 f9a2 	bl	8017d2c <_free_r>
 80149e8:	e743      	b.n	8014872 <_realloc_r+0x192>
 80149ea:	68a3      	ldr	r3, [r4, #8]
 80149ec:	6083      	str	r3, [r0, #8]
 80149ee:	68e3      	ldr	r3, [r4, #12]
 80149f0:	60c3      	str	r3, [r0, #12]
 80149f2:	2a24      	cmp	r2, #36	; 0x24
 80149f4:	d004      	beq.n	8014a00 <_realloc_r+0x320>
 80149f6:	0022      	movs	r2, r4
 80149f8:	0003      	movs	r3, r0
 80149fa:	3210      	adds	r2, #16
 80149fc:	3310      	adds	r3, #16
 80149fe:	e7e9      	b.n	80149d4 <_realloc_r+0x2f4>
 8014a00:	6923      	ldr	r3, [r4, #16]
 8014a02:	0022      	movs	r2, r4
 8014a04:	6103      	str	r3, [r0, #16]
 8014a06:	0003      	movs	r3, r0
 8014a08:	6961      	ldr	r1, [r4, #20]
 8014a0a:	3218      	adds	r2, #24
 8014a0c:	3318      	adds	r3, #24
 8014a0e:	6141      	str	r1, [r0, #20]
 8014a10:	e7e0      	b.n	80149d4 <_realloc_r+0x2f4>
 8014a12:	0003      	movs	r3, r0
 8014a14:	0022      	movs	r2, r4
 8014a16:	e7dd      	b.n	80149d4 <_realloc_r+0x2f4>
 8014a18:	0021      	movs	r1, r4
 8014a1a:	f003 fd88 	bl	801852e <memmove>
 8014a1e:	e7df      	b.n	80149e0 <_realloc_r+0x300>
 8014a20:	9e04      	ldr	r6, [sp, #16]
 8014a22:	e6c1      	b.n	80147a8 <_realloc_r+0xc8>
 8014a24:	9902      	ldr	r1, [sp, #8]
 8014a26:	4306      	orrs	r6, r0
 8014a28:	604e      	str	r6, [r1, #4]
 8014a2a:	6851      	ldr	r1, [r2, #4]
 8014a2c:	430b      	orrs	r3, r1
 8014a2e:	6053      	str	r3, [r2, #4]
 8014a30:	e6d6      	b.n	80147e0 <_realloc_r+0x100>
 8014a32:	46c0      	nop			; (mov r8, r8)
 8014a34:	2000066c 	.word	0x2000066c

08014a38 <_sbrk_r>:
 8014a38:	2300      	movs	r3, #0
 8014a3a:	b570      	push	{r4, r5, r6, lr}
 8014a3c:	4c06      	ldr	r4, [pc, #24]	; (8014a58 <_sbrk_r+0x20>)
 8014a3e:	0005      	movs	r5, r0
 8014a40:	0008      	movs	r0, r1
 8014a42:	6023      	str	r3, [r4, #0]
 8014a44:	f004 fa84 	bl	8018f50 <_sbrk>
 8014a48:	1c43      	adds	r3, r0, #1
 8014a4a:	d103      	bne.n	8014a54 <_sbrk_r+0x1c>
 8014a4c:	6823      	ldr	r3, [r4, #0]
 8014a4e:	2b00      	cmp	r3, #0
 8014a50:	d000      	beq.n	8014a54 <_sbrk_r+0x1c>
 8014a52:	602b      	str	r3, [r5, #0]
 8014a54:	bd70      	pop	{r4, r5, r6, pc}
 8014a56:	46c0      	nop			; (mov r8, r8)
 8014a58:	20007ae4 	.word	0x20007ae4

08014a5c <sprintf>:
 8014a5c:	b40e      	push	{r1, r2, r3}
 8014a5e:	b500      	push	{lr}
 8014a60:	490b      	ldr	r1, [pc, #44]	; (8014a90 <sprintf+0x34>)
 8014a62:	b09c      	sub	sp, #112	; 0x70
 8014a64:	ab1d      	add	r3, sp, #116	; 0x74
 8014a66:	9002      	str	r0, [sp, #8]
 8014a68:	9006      	str	r0, [sp, #24]
 8014a6a:	9107      	str	r1, [sp, #28]
 8014a6c:	9104      	str	r1, [sp, #16]
 8014a6e:	4809      	ldr	r0, [pc, #36]	; (8014a94 <sprintf+0x38>)
 8014a70:	4909      	ldr	r1, [pc, #36]	; (8014a98 <sprintf+0x3c>)
 8014a72:	cb04      	ldmia	r3!, {r2}
 8014a74:	9105      	str	r1, [sp, #20]
 8014a76:	6800      	ldr	r0, [r0, #0]
 8014a78:	a902      	add	r1, sp, #8
 8014a7a:	9301      	str	r3, [sp, #4]
 8014a7c:	f001 f810 	bl	8015aa0 <_svfprintf_r>
 8014a80:	2300      	movs	r3, #0
 8014a82:	9a02      	ldr	r2, [sp, #8]
 8014a84:	7013      	strb	r3, [r2, #0]
 8014a86:	b01c      	add	sp, #112	; 0x70
 8014a88:	bc08      	pop	{r3}
 8014a8a:	b003      	add	sp, #12
 8014a8c:	4718      	bx	r3
 8014a8e:	46c0      	nop			; (mov r8, r8)
 8014a90:	7fffffff 	.word	0x7fffffff
 8014a94:	200000d0 	.word	0x200000d0
 8014a98:	ffff0208 	.word	0xffff0208

08014a9c <strcat>:
 8014a9c:	0002      	movs	r2, r0
 8014a9e:	b510      	push	{r4, lr}
 8014aa0:	7813      	ldrb	r3, [r2, #0]
 8014aa2:	1c54      	adds	r4, r2, #1
 8014aa4:	2b00      	cmp	r3, #0
 8014aa6:	d105      	bne.n	8014ab4 <strcat+0x18>
 8014aa8:	5ccc      	ldrb	r4, [r1, r3]
 8014aaa:	54d4      	strb	r4, [r2, r3]
 8014aac:	3301      	adds	r3, #1
 8014aae:	2c00      	cmp	r4, #0
 8014ab0:	d1fa      	bne.n	8014aa8 <strcat+0xc>
 8014ab2:	bd10      	pop	{r4, pc}
 8014ab4:	0022      	movs	r2, r4
 8014ab6:	e7f3      	b.n	8014aa0 <strcat+0x4>

08014ab8 <strchr>:
 8014ab8:	b2c9      	uxtb	r1, r1
 8014aba:	7803      	ldrb	r3, [r0, #0]
 8014abc:	2b00      	cmp	r3, #0
 8014abe:	d004      	beq.n	8014aca <strchr+0x12>
 8014ac0:	428b      	cmp	r3, r1
 8014ac2:	d100      	bne.n	8014ac6 <strchr+0xe>
 8014ac4:	4770      	bx	lr
 8014ac6:	3001      	adds	r0, #1
 8014ac8:	e7f7      	b.n	8014aba <strchr+0x2>
 8014aca:	424b      	negs	r3, r1
 8014acc:	4159      	adcs	r1, r3
 8014ace:	4249      	negs	r1, r1
 8014ad0:	4008      	ands	r0, r1
 8014ad2:	e7f7      	b.n	8014ac4 <strchr+0xc>

08014ad4 <strcpy>:
 8014ad4:	0003      	movs	r3, r0
 8014ad6:	780a      	ldrb	r2, [r1, #0]
 8014ad8:	3101      	adds	r1, #1
 8014ada:	701a      	strb	r2, [r3, #0]
 8014adc:	3301      	adds	r3, #1
 8014ade:	2a00      	cmp	r2, #0
 8014ae0:	d1f9      	bne.n	8014ad6 <strcpy+0x2>
 8014ae2:	4770      	bx	lr

08014ae4 <strncmp>:
 8014ae4:	2300      	movs	r3, #0
 8014ae6:	b530      	push	{r4, r5, lr}
 8014ae8:	429a      	cmp	r2, r3
 8014aea:	d00a      	beq.n	8014b02 <strncmp+0x1e>
 8014aec:	3a01      	subs	r2, #1
 8014aee:	5cc4      	ldrb	r4, [r0, r3]
 8014af0:	5ccd      	ldrb	r5, [r1, r3]
 8014af2:	42ac      	cmp	r4, r5
 8014af4:	d104      	bne.n	8014b00 <strncmp+0x1c>
 8014af6:	4293      	cmp	r3, r2
 8014af8:	d002      	beq.n	8014b00 <strncmp+0x1c>
 8014afa:	3301      	adds	r3, #1
 8014afc:	2c00      	cmp	r4, #0
 8014afe:	d1f6      	bne.n	8014aee <strncmp+0xa>
 8014b00:	1b63      	subs	r3, r4, r5
 8014b02:	0018      	movs	r0, r3
 8014b04:	bd30      	pop	{r4, r5, pc}

08014b06 <strncpy>:
 8014b06:	b530      	push	{r4, r5, lr}
 8014b08:	0005      	movs	r5, r0
 8014b0a:	2a00      	cmp	r2, #0
 8014b0c:	d100      	bne.n	8014b10 <strncpy+0xa>
 8014b0e:	bd30      	pop	{r4, r5, pc}
 8014b10:	780c      	ldrb	r4, [r1, #0]
 8014b12:	3a01      	subs	r2, #1
 8014b14:	1c6b      	adds	r3, r5, #1
 8014b16:	702c      	strb	r4, [r5, #0]
 8014b18:	3101      	adds	r1, #1
 8014b1a:	2c00      	cmp	r4, #0
 8014b1c:	d105      	bne.n	8014b2a <strncpy+0x24>
 8014b1e:	189a      	adds	r2, r3, r2
 8014b20:	429a      	cmp	r2, r3
 8014b22:	d0f4      	beq.n	8014b0e <strncpy+0x8>
 8014b24:	701c      	strb	r4, [r3, #0]
 8014b26:	3301      	adds	r3, #1
 8014b28:	e7fa      	b.n	8014b20 <strncpy+0x1a>
 8014b2a:	001d      	movs	r5, r3
 8014b2c:	e7ed      	b.n	8014b0a <strncpy+0x4>
	...

08014b30 <sulp>:
 8014b30:	b570      	push	{r4, r5, r6, lr}
 8014b32:	0016      	movs	r6, r2
 8014b34:	000d      	movs	r5, r1
 8014b36:	f003 ffaf 	bl	8018a98 <__ulp>
 8014b3a:	2e00      	cmp	r6, #0
 8014b3c:	d00d      	beq.n	8014b5a <sulp+0x2a>
 8014b3e:	236b      	movs	r3, #107	; 0x6b
 8014b40:	006a      	lsls	r2, r5, #1
 8014b42:	0d52      	lsrs	r2, r2, #21
 8014b44:	1a9b      	subs	r3, r3, r2
 8014b46:	2b00      	cmp	r3, #0
 8014b48:	dd07      	ble.n	8014b5a <sulp+0x2a>
 8014b4a:	2400      	movs	r4, #0
 8014b4c:	4a03      	ldr	r2, [pc, #12]	; (8014b5c <sulp+0x2c>)
 8014b4e:	051b      	lsls	r3, r3, #20
 8014b50:	189d      	adds	r5, r3, r2
 8014b52:	002b      	movs	r3, r5
 8014b54:	0022      	movs	r2, r4
 8014b56:	f7ed f92d 	bl	8001db4 <__aeabi_dmul>
 8014b5a:	bd70      	pop	{r4, r5, r6, pc}
 8014b5c:	3ff00000 	.word	0x3ff00000

08014b60 <_strtod_l>:
 8014b60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014b62:	b0a7      	sub	sp, #156	; 0x9c
 8014b64:	9307      	str	r3, [sp, #28]
 8014b66:	2300      	movs	r3, #0
 8014b68:	9004      	str	r0, [sp, #16]
 8014b6a:	9807      	ldr	r0, [sp, #28]
 8014b6c:	9322      	str	r3, [sp, #136]	; 0x88
 8014b6e:	9106      	str	r1, [sp, #24]
 8014b70:	921d      	str	r2, [sp, #116]	; 0x74
 8014b72:	f003 fcc0 	bl	80184f6 <__localeconv_l>
 8014b76:	0005      	movs	r5, r0
 8014b78:	6800      	ldr	r0, [r0, #0]
 8014b7a:	f7eb facd 	bl	8000118 <strlen>
 8014b7e:	2600      	movs	r6, #0
 8014b80:	2700      	movs	r7, #0
 8014b82:	9b06      	ldr	r3, [sp, #24]
 8014b84:	9005      	str	r0, [sp, #20]
 8014b86:	9321      	str	r3, [sp, #132]	; 0x84
 8014b88:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014b8a:	781a      	ldrb	r2, [r3, #0]
 8014b8c:	2a0d      	cmp	r2, #13
 8014b8e:	d839      	bhi.n	8014c04 <_strtod_l+0xa4>
 8014b90:	2a09      	cmp	r2, #9
 8014b92:	d23d      	bcs.n	8014c10 <_strtod_l+0xb0>
 8014b94:	2a00      	cmp	r2, #0
 8014b96:	d044      	beq.n	8014c22 <_strtod_l+0xc2>
 8014b98:	2300      	movs	r3, #0
 8014b9a:	9313      	str	r3, [sp, #76]	; 0x4c
 8014b9c:	2200      	movs	r2, #0
 8014b9e:	9c21      	ldr	r4, [sp, #132]	; 0x84
 8014ba0:	920c      	str	r2, [sp, #48]	; 0x30
 8014ba2:	7823      	ldrb	r3, [r4, #0]
 8014ba4:	2b30      	cmp	r3, #48	; 0x30
 8014ba6:	d000      	beq.n	8014baa <_strtod_l+0x4a>
 8014ba8:	e07e      	b.n	8014ca8 <_strtod_l+0x148>
 8014baa:	7863      	ldrb	r3, [r4, #1]
 8014bac:	2b58      	cmp	r3, #88	; 0x58
 8014bae:	d002      	beq.n	8014bb6 <_strtod_l+0x56>
 8014bb0:	2b78      	cmp	r3, #120	; 0x78
 8014bb2:	d000      	beq.n	8014bb6 <_strtod_l+0x56>
 8014bb4:	e06e      	b.n	8014c94 <_strtod_l+0x134>
 8014bb6:	9b07      	ldr	r3, [sp, #28]
 8014bb8:	4a96      	ldr	r2, [pc, #600]	; (8014e14 <_strtod_l+0x2b4>)
 8014bba:	9302      	str	r3, [sp, #8]
 8014bbc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8014bbe:	a921      	add	r1, sp, #132	; 0x84
 8014bc0:	9301      	str	r3, [sp, #4]
 8014bc2:	ab22      	add	r3, sp, #136	; 0x88
 8014bc4:	9300      	str	r3, [sp, #0]
 8014bc6:	9804      	ldr	r0, [sp, #16]
 8014bc8:	ab23      	add	r3, sp, #140	; 0x8c
 8014bca:	f003 f9ac 	bl	8017f26 <__gethex>
 8014bce:	2507      	movs	r5, #7
 8014bd0:	9005      	str	r0, [sp, #20]
 8014bd2:	4005      	ands	r5, r0
 8014bd4:	d005      	beq.n	8014be2 <_strtod_l+0x82>
 8014bd6:	2d06      	cmp	r5, #6
 8014bd8:	d12f      	bne.n	8014c3a <_strtod_l+0xda>
 8014bda:	2300      	movs	r3, #0
 8014bdc:	3401      	adds	r4, #1
 8014bde:	9421      	str	r4, [sp, #132]	; 0x84
 8014be0:	9313      	str	r3, [sp, #76]	; 0x4c
 8014be2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8014be4:	2b00      	cmp	r3, #0
 8014be6:	d002      	beq.n	8014bee <_strtod_l+0x8e>
 8014be8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8014bea:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8014bec:	601a      	str	r2, [r3, #0]
 8014bee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8014bf0:	2b00      	cmp	r3, #0
 8014bf2:	d01d      	beq.n	8014c30 <_strtod_l+0xd0>
 8014bf4:	2380      	movs	r3, #128	; 0x80
 8014bf6:	0032      	movs	r2, r6
 8014bf8:	061b      	lsls	r3, r3, #24
 8014bfa:	18fb      	adds	r3, r7, r3
 8014bfc:	0010      	movs	r0, r2
 8014bfe:	0019      	movs	r1, r3
 8014c00:	b027      	add	sp, #156	; 0x9c
 8014c02:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8014c04:	2a2b      	cmp	r2, #43	; 0x2b
 8014c06:	d016      	beq.n	8014c36 <_strtod_l+0xd6>
 8014c08:	2a2d      	cmp	r2, #45	; 0x2d
 8014c0a:	d003      	beq.n	8014c14 <_strtod_l+0xb4>
 8014c0c:	2a20      	cmp	r2, #32
 8014c0e:	d1c3      	bne.n	8014b98 <_strtod_l+0x38>
 8014c10:	3301      	adds	r3, #1
 8014c12:	e7b8      	b.n	8014b86 <_strtod_l+0x26>
 8014c14:	2201      	movs	r2, #1
 8014c16:	9213      	str	r2, [sp, #76]	; 0x4c
 8014c18:	1c5a      	adds	r2, r3, #1
 8014c1a:	9221      	str	r2, [sp, #132]	; 0x84
 8014c1c:	785b      	ldrb	r3, [r3, #1]
 8014c1e:	2b00      	cmp	r3, #0
 8014c20:	d1bc      	bne.n	8014b9c <_strtod_l+0x3c>
 8014c22:	9b06      	ldr	r3, [sp, #24]
 8014c24:	9321      	str	r3, [sp, #132]	; 0x84
 8014c26:	2300      	movs	r3, #0
 8014c28:	9313      	str	r3, [sp, #76]	; 0x4c
 8014c2a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8014c2c:	2b00      	cmp	r3, #0
 8014c2e:	d1db      	bne.n	8014be8 <_strtod_l+0x88>
 8014c30:	0032      	movs	r2, r6
 8014c32:	003b      	movs	r3, r7
 8014c34:	e7e2      	b.n	8014bfc <_strtod_l+0x9c>
 8014c36:	2200      	movs	r2, #0
 8014c38:	e7ed      	b.n	8014c16 <_strtod_l+0xb6>
 8014c3a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8014c3c:	2a00      	cmp	r2, #0
 8014c3e:	d007      	beq.n	8014c50 <_strtod_l+0xf0>
 8014c40:	2135      	movs	r1, #53	; 0x35
 8014c42:	a824      	add	r0, sp, #144	; 0x90
 8014c44:	f004 f815 	bl	8018c72 <__copybits>
 8014c48:	9922      	ldr	r1, [sp, #136]	; 0x88
 8014c4a:	9804      	ldr	r0, [sp, #16]
 8014c4c:	f003 fcaa 	bl	80185a4 <_Bfree>
 8014c50:	1e68      	subs	r0, r5, #1
 8014c52:	2804      	cmp	r0, #4
 8014c54:	d806      	bhi.n	8014c64 <_strtod_l+0x104>
 8014c56:	f7eb fa71 	bl	800013c <__gnu_thumb1_case_uqi>
 8014c5a:	030c      	.short	0x030c
 8014c5c:	1917      	.short	0x1917
 8014c5e:	0c          	.byte	0x0c
 8014c5f:	00          	.byte	0x00
 8014c60:	9e24      	ldr	r6, [sp, #144]	; 0x90
 8014c62:	9f25      	ldr	r7, [sp, #148]	; 0x94
 8014c64:	9b05      	ldr	r3, [sp, #20]
 8014c66:	071b      	lsls	r3, r3, #28
 8014c68:	d5bb      	bpl.n	8014be2 <_strtod_l+0x82>
 8014c6a:	2380      	movs	r3, #128	; 0x80
 8014c6c:	061b      	lsls	r3, r3, #24
 8014c6e:	431f      	orrs	r7, r3
 8014c70:	e7b7      	b.n	8014be2 <_strtod_l+0x82>
 8014c72:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8014c74:	4a68      	ldr	r2, [pc, #416]	; (8014e18 <_strtod_l+0x2b8>)
 8014c76:	4969      	ldr	r1, [pc, #420]	; (8014e1c <_strtod_l+0x2bc>)
 8014c78:	401a      	ands	r2, r3
 8014c7a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8014c7c:	9e24      	ldr	r6, [sp, #144]	; 0x90
 8014c7e:	185b      	adds	r3, r3, r1
 8014c80:	051b      	lsls	r3, r3, #20
 8014c82:	431a      	orrs	r2, r3
 8014c84:	0017      	movs	r7, r2
 8014c86:	e7ed      	b.n	8014c64 <_strtod_l+0x104>
 8014c88:	4f65      	ldr	r7, [pc, #404]	; (8014e20 <_strtod_l+0x2c0>)
 8014c8a:	e7eb      	b.n	8014c64 <_strtod_l+0x104>
 8014c8c:	2601      	movs	r6, #1
 8014c8e:	4f65      	ldr	r7, [pc, #404]	; (8014e24 <_strtod_l+0x2c4>)
 8014c90:	4276      	negs	r6, r6
 8014c92:	e7e7      	b.n	8014c64 <_strtod_l+0x104>
 8014c94:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014c96:	1c5a      	adds	r2, r3, #1
 8014c98:	9221      	str	r2, [sp, #132]	; 0x84
 8014c9a:	785b      	ldrb	r3, [r3, #1]
 8014c9c:	2b30      	cmp	r3, #48	; 0x30
 8014c9e:	d0f9      	beq.n	8014c94 <_strtod_l+0x134>
 8014ca0:	2b00      	cmp	r3, #0
 8014ca2:	d09e      	beq.n	8014be2 <_strtod_l+0x82>
 8014ca4:	2301      	movs	r3, #1
 8014ca6:	930c      	str	r3, [sp, #48]	; 0x30
 8014ca8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014caa:	220a      	movs	r2, #10
 8014cac:	9312      	str	r3, [sp, #72]	; 0x48
 8014cae:	2300      	movs	r3, #0
 8014cb0:	930b      	str	r3, [sp, #44]	; 0x2c
 8014cb2:	9308      	str	r3, [sp, #32]
 8014cb4:	930a      	str	r3, [sp, #40]	; 0x28
 8014cb6:	9821      	ldr	r0, [sp, #132]	; 0x84
 8014cb8:	7804      	ldrb	r4, [r0, #0]
 8014cba:	0023      	movs	r3, r4
 8014cbc:	3b30      	subs	r3, #48	; 0x30
 8014cbe:	b2d9      	uxtb	r1, r3
 8014cc0:	2909      	cmp	r1, #9
 8014cc2:	d934      	bls.n	8014d2e <_strtod_l+0x1ce>
 8014cc4:	9a05      	ldr	r2, [sp, #20]
 8014cc6:	6829      	ldr	r1, [r5, #0]
 8014cc8:	f7ff ff0c 	bl	8014ae4 <strncmp>
 8014ccc:	2800      	cmp	r0, #0
 8014cce:	d040      	beq.n	8014d52 <_strtod_l+0x1f2>
 8014cd0:	2000      	movs	r0, #0
 8014cd2:	0023      	movs	r3, r4
 8014cd4:	4684      	mov	ip, r0
 8014cd6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8014cd8:	9007      	str	r0, [sp, #28]
 8014cda:	9205      	str	r2, [sp, #20]
 8014cdc:	2220      	movs	r2, #32
 8014cde:	0019      	movs	r1, r3
 8014ce0:	4391      	bics	r1, r2
 8014ce2:	000a      	movs	r2, r1
 8014ce4:	2100      	movs	r1, #0
 8014ce6:	2a45      	cmp	r2, #69	; 0x45
 8014ce8:	d000      	beq.n	8014cec <_strtod_l+0x18c>
 8014cea:	e0bf      	b.n	8014e6c <_strtod_l+0x30c>
 8014cec:	9b05      	ldr	r3, [sp, #20]
 8014cee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8014cf0:	4303      	orrs	r3, r0
 8014cf2:	4313      	orrs	r3, r2
 8014cf4:	428b      	cmp	r3, r1
 8014cf6:	d094      	beq.n	8014c22 <_strtod_l+0xc2>
 8014cf8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014cfa:	9306      	str	r3, [sp, #24]
 8014cfc:	3301      	adds	r3, #1
 8014cfe:	9321      	str	r3, [sp, #132]	; 0x84
 8014d00:	9b06      	ldr	r3, [sp, #24]
 8014d02:	785b      	ldrb	r3, [r3, #1]
 8014d04:	2b2b      	cmp	r3, #43	; 0x2b
 8014d06:	d100      	bne.n	8014d0a <_strtod_l+0x1aa>
 8014d08:	e082      	b.n	8014e10 <_strtod_l+0x2b0>
 8014d0a:	000c      	movs	r4, r1
 8014d0c:	2b2d      	cmp	r3, #45	; 0x2d
 8014d0e:	d105      	bne.n	8014d1c <_strtod_l+0x1bc>
 8014d10:	2401      	movs	r4, #1
 8014d12:	9b06      	ldr	r3, [sp, #24]
 8014d14:	3302      	adds	r3, #2
 8014d16:	9321      	str	r3, [sp, #132]	; 0x84
 8014d18:	9b06      	ldr	r3, [sp, #24]
 8014d1a:	789b      	ldrb	r3, [r3, #2]
 8014d1c:	001a      	movs	r2, r3
 8014d1e:	3a30      	subs	r2, #48	; 0x30
 8014d20:	2a09      	cmp	r2, #9
 8014d22:	d800      	bhi.n	8014d26 <_strtod_l+0x1c6>
 8014d24:	e084      	b.n	8014e30 <_strtod_l+0x2d0>
 8014d26:	9a06      	ldr	r2, [sp, #24]
 8014d28:	2100      	movs	r1, #0
 8014d2a:	9221      	str	r2, [sp, #132]	; 0x84
 8014d2c:	e09e      	b.n	8014e6c <_strtod_l+0x30c>
 8014d2e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8014d30:	2908      	cmp	r1, #8
 8014d32:	dc09      	bgt.n	8014d48 <_strtod_l+0x1e8>
 8014d34:	9908      	ldr	r1, [sp, #32]
 8014d36:	4351      	muls	r1, r2
 8014d38:	18cb      	adds	r3, r1, r3
 8014d3a:	9308      	str	r3, [sp, #32]
 8014d3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014d3e:	3001      	adds	r0, #1
 8014d40:	3301      	adds	r3, #1
 8014d42:	930a      	str	r3, [sp, #40]	; 0x28
 8014d44:	9021      	str	r0, [sp, #132]	; 0x84
 8014d46:	e7b6      	b.n	8014cb6 <_strtod_l+0x156>
 8014d48:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8014d4a:	4351      	muls	r1, r2
 8014d4c:	18cb      	adds	r3, r1, r3
 8014d4e:	930b      	str	r3, [sp, #44]	; 0x2c
 8014d50:	e7f4      	b.n	8014d3c <_strtod_l+0x1dc>
 8014d52:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8014d54:	9b05      	ldr	r3, [sp, #20]
 8014d56:	4694      	mov	ip, r2
 8014d58:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8014d5a:	4463      	add	r3, ip
 8014d5c:	9321      	str	r3, [sp, #132]	; 0x84
 8014d5e:	781b      	ldrb	r3, [r3, #0]
 8014d60:	2a00      	cmp	r2, #0
 8014d62:	d036      	beq.n	8014dd2 <_strtod_l+0x272>
 8014d64:	4684      	mov	ip, r0
 8014d66:	9205      	str	r2, [sp, #20]
 8014d68:	001a      	movs	r2, r3
 8014d6a:	3a30      	subs	r2, #48	; 0x30
 8014d6c:	2a09      	cmp	r2, #9
 8014d6e:	d912      	bls.n	8014d96 <_strtod_l+0x236>
 8014d70:	2201      	movs	r2, #1
 8014d72:	9207      	str	r2, [sp, #28]
 8014d74:	e7b2      	b.n	8014cdc <_strtod_l+0x17c>
 8014d76:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014d78:	3001      	adds	r0, #1
 8014d7a:	1c5a      	adds	r2, r3, #1
 8014d7c:	9221      	str	r2, [sp, #132]	; 0x84
 8014d7e:	785b      	ldrb	r3, [r3, #1]
 8014d80:	2b30      	cmp	r3, #48	; 0x30
 8014d82:	d0f8      	beq.n	8014d76 <_strtod_l+0x216>
 8014d84:	001a      	movs	r2, r3
 8014d86:	3a31      	subs	r2, #49	; 0x31
 8014d88:	2a08      	cmp	r2, #8
 8014d8a:	d83c      	bhi.n	8014e06 <_strtod_l+0x2a6>
 8014d8c:	4684      	mov	ip, r0
 8014d8e:	2000      	movs	r0, #0
 8014d90:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8014d92:	9005      	str	r0, [sp, #20]
 8014d94:	9212      	str	r2, [sp, #72]	; 0x48
 8014d96:	3b30      	subs	r3, #48	; 0x30
 8014d98:	1c42      	adds	r2, r0, #1
 8014d9a:	2b00      	cmp	r3, #0
 8014d9c:	d013      	beq.n	8014dc6 <_strtod_l+0x266>
 8014d9e:	210a      	movs	r1, #10
 8014da0:	4494      	add	ip, r2
 8014da2:	9a05      	ldr	r2, [sp, #20]
 8014da4:	1885      	adds	r5, r0, r2
 8014da6:	42aa      	cmp	r2, r5
 8014da8:	d115      	bne.n	8014dd6 <_strtod_l+0x276>
 8014daa:	9905      	ldr	r1, [sp, #20]
 8014dac:	9a05      	ldr	r2, [sp, #20]
 8014dae:	3101      	adds	r1, #1
 8014db0:	1809      	adds	r1, r1, r0
 8014db2:	1812      	adds	r2, r2, r0
 8014db4:	9105      	str	r1, [sp, #20]
 8014db6:	2a08      	cmp	r2, #8
 8014db8:	dc1b      	bgt.n	8014df2 <_strtod_l+0x292>
 8014dba:	220a      	movs	r2, #10
 8014dbc:	9908      	ldr	r1, [sp, #32]
 8014dbe:	434a      	muls	r2, r1
 8014dc0:	189b      	adds	r3, r3, r2
 8014dc2:	2200      	movs	r2, #0
 8014dc4:	9308      	str	r3, [sp, #32]
 8014dc6:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014dc8:	0010      	movs	r0, r2
 8014dca:	1c59      	adds	r1, r3, #1
 8014dcc:	9121      	str	r1, [sp, #132]	; 0x84
 8014dce:	785b      	ldrb	r3, [r3, #1]
 8014dd0:	e7ca      	b.n	8014d68 <_strtod_l+0x208>
 8014dd2:	980a      	ldr	r0, [sp, #40]	; 0x28
 8014dd4:	e7d4      	b.n	8014d80 <_strtod_l+0x220>
 8014dd6:	1c54      	adds	r4, r2, #1
 8014dd8:	2a08      	cmp	r2, #8
 8014dda:	dc04      	bgt.n	8014de6 <_strtod_l+0x286>
 8014ddc:	9a08      	ldr	r2, [sp, #32]
 8014dde:	434a      	muls	r2, r1
 8014de0:	9208      	str	r2, [sp, #32]
 8014de2:	0022      	movs	r2, r4
 8014de4:	e7df      	b.n	8014da6 <_strtod_l+0x246>
 8014de6:	2c10      	cmp	r4, #16
 8014de8:	dcfb      	bgt.n	8014de2 <_strtod_l+0x282>
 8014dea:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8014dec:	434a      	muls	r2, r1
 8014dee:	920b      	str	r2, [sp, #44]	; 0x2c
 8014df0:	e7f7      	b.n	8014de2 <_strtod_l+0x282>
 8014df2:	9905      	ldr	r1, [sp, #20]
 8014df4:	2200      	movs	r2, #0
 8014df6:	2910      	cmp	r1, #16
 8014df8:	dce5      	bgt.n	8014dc6 <_strtod_l+0x266>
 8014dfa:	210a      	movs	r1, #10
 8014dfc:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8014dfe:	4341      	muls	r1, r0
 8014e00:	185b      	adds	r3, r3, r1
 8014e02:	930b      	str	r3, [sp, #44]	; 0x2c
 8014e04:	e7df      	b.n	8014dc6 <_strtod_l+0x266>
 8014e06:	2200      	movs	r2, #0
 8014e08:	4694      	mov	ip, r2
 8014e0a:	9205      	str	r2, [sp, #20]
 8014e0c:	3201      	adds	r2, #1
 8014e0e:	e7b0      	b.n	8014d72 <_strtod_l+0x212>
 8014e10:	000c      	movs	r4, r1
 8014e12:	e77e      	b.n	8014d12 <_strtod_l+0x1b2>
 8014e14:	0801c588 	.word	0x0801c588
 8014e18:	ffefffff 	.word	0xffefffff
 8014e1c:	00000433 	.word	0x00000433
 8014e20:	7ff00000 	.word	0x7ff00000
 8014e24:	7fffffff 	.word	0x7fffffff
 8014e28:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014e2a:	1c5a      	adds	r2, r3, #1
 8014e2c:	9221      	str	r2, [sp, #132]	; 0x84
 8014e2e:	785b      	ldrb	r3, [r3, #1]
 8014e30:	2b30      	cmp	r3, #48	; 0x30
 8014e32:	d0f9      	beq.n	8014e28 <_strtod_l+0x2c8>
 8014e34:	001a      	movs	r2, r3
 8014e36:	3a31      	subs	r2, #49	; 0x31
 8014e38:	2100      	movs	r1, #0
 8014e3a:	2a08      	cmp	r2, #8
 8014e3c:	d816      	bhi.n	8014e6c <_strtod_l+0x30c>
 8014e3e:	3b30      	subs	r3, #48	; 0x30
 8014e40:	9d21      	ldr	r5, [sp, #132]	; 0x84
 8014e42:	930e      	str	r3, [sp, #56]	; 0x38
 8014e44:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014e46:	1c59      	adds	r1, r3, #1
 8014e48:	9121      	str	r1, [sp, #132]	; 0x84
 8014e4a:	785b      	ldrb	r3, [r3, #1]
 8014e4c:	001a      	movs	r2, r3
 8014e4e:	3a30      	subs	r2, #48	; 0x30
 8014e50:	2a09      	cmp	r2, #9
 8014e52:	d932      	bls.n	8014eba <_strtod_l+0x35a>
 8014e54:	1b4a      	subs	r2, r1, r5
 8014e56:	4dad      	ldr	r5, [pc, #692]	; (801510c <_strtod_l+0x5ac>)
 8014e58:	0029      	movs	r1, r5
 8014e5a:	2a08      	cmp	r2, #8
 8014e5c:	dc03      	bgt.n	8014e66 <_strtod_l+0x306>
 8014e5e:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014e60:	42a9      	cmp	r1, r5
 8014e62:	dd00      	ble.n	8014e66 <_strtod_l+0x306>
 8014e64:	0029      	movs	r1, r5
 8014e66:	2c00      	cmp	r4, #0
 8014e68:	d000      	beq.n	8014e6c <_strtod_l+0x30c>
 8014e6a:	4249      	negs	r1, r1
 8014e6c:	9a05      	ldr	r2, [sp, #20]
 8014e6e:	2a00      	cmp	r2, #0
 8014e70:	d149      	bne.n	8014f06 <_strtod_l+0x3a6>
 8014e72:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8014e74:	4310      	orrs	r0, r2
 8014e76:	d000      	beq.n	8014e7a <_strtod_l+0x31a>
 8014e78:	e6b3      	b.n	8014be2 <_strtod_l+0x82>
 8014e7a:	9a07      	ldr	r2, [sp, #28]
 8014e7c:	2a00      	cmp	r2, #0
 8014e7e:	d000      	beq.n	8014e82 <_strtod_l+0x322>
 8014e80:	e6cf      	b.n	8014c22 <_strtod_l+0xc2>
 8014e82:	2b4e      	cmp	r3, #78	; 0x4e
 8014e84:	d025      	beq.n	8014ed2 <_strtod_l+0x372>
 8014e86:	dc1f      	bgt.n	8014ec8 <_strtod_l+0x368>
 8014e88:	2b49      	cmp	r3, #73	; 0x49
 8014e8a:	d000      	beq.n	8014e8e <_strtod_l+0x32e>
 8014e8c:	e6c9      	b.n	8014c22 <_strtod_l+0xc2>
 8014e8e:	49a0      	ldr	r1, [pc, #640]	; (8015110 <_strtod_l+0x5b0>)
 8014e90:	a821      	add	r0, sp, #132	; 0x84
 8014e92:	f003 fa85 	bl	80183a0 <__match>
 8014e96:	2800      	cmp	r0, #0
 8014e98:	d100      	bne.n	8014e9c <_strtod_l+0x33c>
 8014e9a:	e6c2      	b.n	8014c22 <_strtod_l+0xc2>
 8014e9c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014e9e:	499d      	ldr	r1, [pc, #628]	; (8015114 <_strtod_l+0x5b4>)
 8014ea0:	3b01      	subs	r3, #1
 8014ea2:	a821      	add	r0, sp, #132	; 0x84
 8014ea4:	9321      	str	r3, [sp, #132]	; 0x84
 8014ea6:	f003 fa7b 	bl	80183a0 <__match>
 8014eaa:	2800      	cmp	r0, #0
 8014eac:	d102      	bne.n	8014eb4 <_strtod_l+0x354>
 8014eae:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014eb0:	3301      	adds	r3, #1
 8014eb2:	9321      	str	r3, [sp, #132]	; 0x84
 8014eb4:	4f98      	ldr	r7, [pc, #608]	; (8015118 <_strtod_l+0x5b8>)
 8014eb6:	2600      	movs	r6, #0
 8014eb8:	e693      	b.n	8014be2 <_strtod_l+0x82>
 8014eba:	220a      	movs	r2, #10
 8014ebc:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014ebe:	434a      	muls	r2, r1
 8014ec0:	18d2      	adds	r2, r2, r3
 8014ec2:	3a30      	subs	r2, #48	; 0x30
 8014ec4:	920e      	str	r2, [sp, #56]	; 0x38
 8014ec6:	e7bd      	b.n	8014e44 <_strtod_l+0x2e4>
 8014ec8:	2b69      	cmp	r3, #105	; 0x69
 8014eca:	d0e0      	beq.n	8014e8e <_strtod_l+0x32e>
 8014ecc:	2b6e      	cmp	r3, #110	; 0x6e
 8014ece:	d000      	beq.n	8014ed2 <_strtod_l+0x372>
 8014ed0:	e6a7      	b.n	8014c22 <_strtod_l+0xc2>
 8014ed2:	4992      	ldr	r1, [pc, #584]	; (801511c <_strtod_l+0x5bc>)
 8014ed4:	a821      	add	r0, sp, #132	; 0x84
 8014ed6:	f003 fa63 	bl	80183a0 <__match>
 8014eda:	2800      	cmp	r0, #0
 8014edc:	d100      	bne.n	8014ee0 <_strtod_l+0x380>
 8014ede:	e6a0      	b.n	8014c22 <_strtod_l+0xc2>
 8014ee0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014ee2:	781b      	ldrb	r3, [r3, #0]
 8014ee4:	2b28      	cmp	r3, #40	; 0x28
 8014ee6:	d10c      	bne.n	8014f02 <_strtod_l+0x3a2>
 8014ee8:	aa24      	add	r2, sp, #144	; 0x90
 8014eea:	498d      	ldr	r1, [pc, #564]	; (8015120 <_strtod_l+0x5c0>)
 8014eec:	a821      	add	r0, sp, #132	; 0x84
 8014eee:	f003 fa6b 	bl	80183c8 <__hexnan>
 8014ef2:	2805      	cmp	r0, #5
 8014ef4:	d105      	bne.n	8014f02 <_strtod_l+0x3a2>
 8014ef6:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8014ef8:	4a87      	ldr	r2, [pc, #540]	; (8015118 <_strtod_l+0x5b8>)
 8014efa:	9e24      	ldr	r6, [sp, #144]	; 0x90
 8014efc:	431a      	orrs	r2, r3
 8014efe:	0017      	movs	r7, r2
 8014f00:	e66f      	b.n	8014be2 <_strtod_l+0x82>
 8014f02:	4f88      	ldr	r7, [pc, #544]	; (8015124 <_strtod_l+0x5c4>)
 8014f04:	e7d7      	b.n	8014eb6 <_strtod_l+0x356>
 8014f06:	4663      	mov	r3, ip
 8014f08:	1acb      	subs	r3, r1, r3
 8014f0a:	9307      	str	r3, [sp, #28]
 8014f0c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014f0e:	2b00      	cmp	r3, #0
 8014f10:	d101      	bne.n	8014f16 <_strtod_l+0x3b6>
 8014f12:	9b05      	ldr	r3, [sp, #20]
 8014f14:	930a      	str	r3, [sp, #40]	; 0x28
 8014f16:	9c05      	ldr	r4, [sp, #20]
 8014f18:	2c10      	cmp	r4, #16
 8014f1a:	dd00      	ble.n	8014f1e <_strtod_l+0x3be>
 8014f1c:	2410      	movs	r4, #16
 8014f1e:	9808      	ldr	r0, [sp, #32]
 8014f20:	f7ed fd8e 	bl	8002a40 <__aeabi_ui2d>
 8014f24:	9b05      	ldr	r3, [sp, #20]
 8014f26:	0006      	movs	r6, r0
 8014f28:	000f      	movs	r7, r1
 8014f2a:	2b09      	cmp	r3, #9
 8014f2c:	dc15      	bgt.n	8014f5a <_strtod_l+0x3fa>
 8014f2e:	9b07      	ldr	r3, [sp, #28]
 8014f30:	2b00      	cmp	r3, #0
 8014f32:	d100      	bne.n	8014f36 <_strtod_l+0x3d6>
 8014f34:	e655      	b.n	8014be2 <_strtod_l+0x82>
 8014f36:	9b07      	ldr	r3, [sp, #28]
 8014f38:	2b00      	cmp	r3, #0
 8014f3a:	dc00      	bgt.n	8014f3e <_strtod_l+0x3de>
 8014f3c:	e07d      	b.n	801503a <_strtod_l+0x4da>
 8014f3e:	2b16      	cmp	r3, #22
 8014f40:	dc62      	bgt.n	8015008 <_strtod_l+0x4a8>
 8014f42:	00dc      	lsls	r4, r3, #3
 8014f44:	4b78      	ldr	r3, [pc, #480]	; (8015128 <_strtod_l+0x5c8>)
 8014f46:	0032      	movs	r2, r6
 8014f48:	1919      	adds	r1, r3, r4
 8014f4a:	003b      	movs	r3, r7
 8014f4c:	6808      	ldr	r0, [r1, #0]
 8014f4e:	6849      	ldr	r1, [r1, #4]
 8014f50:	f7ec ff30 	bl	8001db4 <__aeabi_dmul>
 8014f54:	0006      	movs	r6, r0
 8014f56:	000f      	movs	r7, r1
 8014f58:	e643      	b.n	8014be2 <_strtod_l+0x82>
 8014f5a:	0022      	movs	r2, r4
 8014f5c:	4b72      	ldr	r3, [pc, #456]	; (8015128 <_strtod_l+0x5c8>)
 8014f5e:	3a09      	subs	r2, #9
 8014f60:	00d2      	lsls	r2, r2, #3
 8014f62:	189b      	adds	r3, r3, r2
 8014f64:	681a      	ldr	r2, [r3, #0]
 8014f66:	685b      	ldr	r3, [r3, #4]
 8014f68:	f7ec ff24 	bl	8001db4 <__aeabi_dmul>
 8014f6c:	0006      	movs	r6, r0
 8014f6e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8014f70:	000f      	movs	r7, r1
 8014f72:	f7ed fd65 	bl	8002a40 <__aeabi_ui2d>
 8014f76:	000b      	movs	r3, r1
 8014f78:	0002      	movs	r2, r0
 8014f7a:	0039      	movs	r1, r7
 8014f7c:	0030      	movs	r0, r6
 8014f7e:	f7eb fff3 	bl	8000f68 <__aeabi_dadd>
 8014f82:	9b05      	ldr	r3, [sp, #20]
 8014f84:	0006      	movs	r6, r0
 8014f86:	000f      	movs	r7, r1
 8014f88:	2b0f      	cmp	r3, #15
 8014f8a:	ddd0      	ble.n	8014f2e <_strtod_l+0x3ce>
 8014f8c:	9b05      	ldr	r3, [sp, #20]
 8014f8e:	1b1c      	subs	r4, r3, r4
 8014f90:	9b07      	ldr	r3, [sp, #28]
 8014f92:	18e4      	adds	r4, r4, r3
 8014f94:	2c00      	cmp	r4, #0
 8014f96:	dc00      	bgt.n	8014f9a <_strtod_l+0x43a>
 8014f98:	e094      	b.n	80150c4 <_strtod_l+0x564>
 8014f9a:	230f      	movs	r3, #15
 8014f9c:	4023      	ands	r3, r4
 8014f9e:	d00a      	beq.n	8014fb6 <_strtod_l+0x456>
 8014fa0:	4961      	ldr	r1, [pc, #388]	; (8015128 <_strtod_l+0x5c8>)
 8014fa2:	00db      	lsls	r3, r3, #3
 8014fa4:	18c9      	adds	r1, r1, r3
 8014fa6:	0032      	movs	r2, r6
 8014fa8:	6808      	ldr	r0, [r1, #0]
 8014faa:	6849      	ldr	r1, [r1, #4]
 8014fac:	003b      	movs	r3, r7
 8014fae:	f7ec ff01 	bl	8001db4 <__aeabi_dmul>
 8014fb2:	0006      	movs	r6, r0
 8014fb4:	000f      	movs	r7, r1
 8014fb6:	230f      	movs	r3, #15
 8014fb8:	439c      	bics	r4, r3
 8014fba:	d06e      	beq.n	801509a <_strtod_l+0x53a>
 8014fbc:	3326      	adds	r3, #38	; 0x26
 8014fbe:	33ff      	adds	r3, #255	; 0xff
 8014fc0:	429c      	cmp	r4, r3
 8014fc2:	dd48      	ble.n	8015056 <_strtod_l+0x4f6>
 8014fc4:	2400      	movs	r4, #0
 8014fc6:	9405      	str	r4, [sp, #20]
 8014fc8:	940b      	str	r4, [sp, #44]	; 0x2c
 8014fca:	940a      	str	r4, [sp, #40]	; 0x28
 8014fcc:	2322      	movs	r3, #34	; 0x22
 8014fce:	2600      	movs	r6, #0
 8014fd0:	9a04      	ldr	r2, [sp, #16]
 8014fd2:	4f51      	ldr	r7, [pc, #324]	; (8015118 <_strtod_l+0x5b8>)
 8014fd4:	6013      	str	r3, [r2, #0]
 8014fd6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014fd8:	42b3      	cmp	r3, r6
 8014fda:	d100      	bne.n	8014fde <_strtod_l+0x47e>
 8014fdc:	e601      	b.n	8014be2 <_strtod_l+0x82>
 8014fde:	9922      	ldr	r1, [sp, #136]	; 0x88
 8014fe0:	9804      	ldr	r0, [sp, #16]
 8014fe2:	f003 fadf 	bl	80185a4 <_Bfree>
 8014fe6:	990a      	ldr	r1, [sp, #40]	; 0x28
 8014fe8:	9804      	ldr	r0, [sp, #16]
 8014fea:	f003 fadb 	bl	80185a4 <_Bfree>
 8014fee:	9905      	ldr	r1, [sp, #20]
 8014ff0:	9804      	ldr	r0, [sp, #16]
 8014ff2:	f003 fad7 	bl	80185a4 <_Bfree>
 8014ff6:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8014ff8:	9804      	ldr	r0, [sp, #16]
 8014ffa:	f003 fad3 	bl	80185a4 <_Bfree>
 8014ffe:	0021      	movs	r1, r4
 8015000:	9804      	ldr	r0, [sp, #16]
 8015002:	f003 facf 	bl	80185a4 <_Bfree>
 8015006:	e5ec      	b.n	8014be2 <_strtod_l+0x82>
 8015008:	2325      	movs	r3, #37	; 0x25
 801500a:	9a05      	ldr	r2, [sp, #20]
 801500c:	1a9b      	subs	r3, r3, r2
 801500e:	9a07      	ldr	r2, [sp, #28]
 8015010:	4293      	cmp	r3, r2
 8015012:	dbbb      	blt.n	8014f8c <_strtod_l+0x42c>
 8015014:	230f      	movs	r3, #15
 8015016:	9a05      	ldr	r2, [sp, #20]
 8015018:	4c43      	ldr	r4, [pc, #268]	; (8015128 <_strtod_l+0x5c8>)
 801501a:	1a9d      	subs	r5, r3, r2
 801501c:	00e9      	lsls	r1, r5, #3
 801501e:	1861      	adds	r1, r4, r1
 8015020:	0032      	movs	r2, r6
 8015022:	6808      	ldr	r0, [r1, #0]
 8015024:	6849      	ldr	r1, [r1, #4]
 8015026:	003b      	movs	r3, r7
 8015028:	f7ec fec4 	bl	8001db4 <__aeabi_dmul>
 801502c:	9b07      	ldr	r3, [sp, #28]
 801502e:	1b5e      	subs	r6, r3, r5
 8015030:	00f6      	lsls	r6, r6, #3
 8015032:	19a6      	adds	r6, r4, r6
 8015034:	6832      	ldr	r2, [r6, #0]
 8015036:	6873      	ldr	r3, [r6, #4]
 8015038:	e78a      	b.n	8014f50 <_strtod_l+0x3f0>
 801503a:	9b07      	ldr	r3, [sp, #28]
 801503c:	3316      	adds	r3, #22
 801503e:	dba5      	blt.n	8014f8c <_strtod_l+0x42c>
 8015040:	9b07      	ldr	r3, [sp, #28]
 8015042:	0030      	movs	r0, r6
 8015044:	00da      	lsls	r2, r3, #3
 8015046:	4b38      	ldr	r3, [pc, #224]	; (8015128 <_strtod_l+0x5c8>)
 8015048:	0039      	movs	r1, r7
 801504a:	1a9b      	subs	r3, r3, r2
 801504c:	681a      	ldr	r2, [r3, #0]
 801504e:	685b      	ldr	r3, [r3, #4]
 8015050:	f7ec faa6 	bl	80015a0 <__aeabi_ddiv>
 8015054:	e77e      	b.n	8014f54 <_strtod_l+0x3f4>
 8015056:	2300      	movs	r3, #0
 8015058:	0030      	movs	r0, r6
 801505a:	0039      	movs	r1, r7
 801505c:	001d      	movs	r5, r3
 801505e:	1124      	asrs	r4, r4, #4
 8015060:	2c01      	cmp	r4, #1
 8015062:	dc1d      	bgt.n	80150a0 <_strtod_l+0x540>
 8015064:	2b00      	cmp	r3, #0
 8015066:	d001      	beq.n	801506c <_strtod_l+0x50c>
 8015068:	0006      	movs	r6, r0
 801506a:	000f      	movs	r7, r1
 801506c:	4b2f      	ldr	r3, [pc, #188]	; (801512c <_strtod_l+0x5cc>)
 801506e:	00ed      	lsls	r5, r5, #3
 8015070:	18ff      	adds	r7, r7, r3
 8015072:	4b2f      	ldr	r3, [pc, #188]	; (8015130 <_strtod_l+0x5d0>)
 8015074:	0032      	movs	r2, r6
 8015076:	195d      	adds	r5, r3, r5
 8015078:	6828      	ldr	r0, [r5, #0]
 801507a:	6869      	ldr	r1, [r5, #4]
 801507c:	003b      	movs	r3, r7
 801507e:	f7ec fe99 	bl	8001db4 <__aeabi_dmul>
 8015082:	4b25      	ldr	r3, [pc, #148]	; (8015118 <_strtod_l+0x5b8>)
 8015084:	4a2b      	ldr	r2, [pc, #172]	; (8015134 <_strtod_l+0x5d4>)
 8015086:	0006      	movs	r6, r0
 8015088:	400b      	ands	r3, r1
 801508a:	4293      	cmp	r3, r2
 801508c:	d89a      	bhi.n	8014fc4 <_strtod_l+0x464>
 801508e:	4a2a      	ldr	r2, [pc, #168]	; (8015138 <_strtod_l+0x5d8>)
 8015090:	4293      	cmp	r3, r2
 8015092:	d913      	bls.n	80150bc <_strtod_l+0x55c>
 8015094:	2601      	movs	r6, #1
 8015096:	4f29      	ldr	r7, [pc, #164]	; (801513c <_strtod_l+0x5dc>)
 8015098:	4276      	negs	r6, r6
 801509a:	2300      	movs	r3, #0
 801509c:	9306      	str	r3, [sp, #24]
 801509e:	e07b      	b.n	8015198 <_strtod_l+0x638>
 80150a0:	2201      	movs	r2, #1
 80150a2:	4214      	tst	r4, r2
 80150a4:	d007      	beq.n	80150b6 <_strtod_l+0x556>
 80150a6:	4a22      	ldr	r2, [pc, #136]	; (8015130 <_strtod_l+0x5d0>)
 80150a8:	00eb      	lsls	r3, r5, #3
 80150aa:	189b      	adds	r3, r3, r2
 80150ac:	681a      	ldr	r2, [r3, #0]
 80150ae:	685b      	ldr	r3, [r3, #4]
 80150b0:	f7ec fe80 	bl	8001db4 <__aeabi_dmul>
 80150b4:	2301      	movs	r3, #1
 80150b6:	3501      	adds	r5, #1
 80150b8:	1064      	asrs	r4, r4, #1
 80150ba:	e7d1      	b.n	8015060 <_strtod_l+0x500>
 80150bc:	23d4      	movs	r3, #212	; 0xd4
 80150be:	049b      	lsls	r3, r3, #18
 80150c0:	18cf      	adds	r7, r1, r3
 80150c2:	e7ea      	b.n	801509a <_strtod_l+0x53a>
 80150c4:	2c00      	cmp	r4, #0
 80150c6:	d0e8      	beq.n	801509a <_strtod_l+0x53a>
 80150c8:	230f      	movs	r3, #15
 80150ca:	4264      	negs	r4, r4
 80150cc:	4023      	ands	r3, r4
 80150ce:	d00a      	beq.n	80150e6 <_strtod_l+0x586>
 80150d0:	4a15      	ldr	r2, [pc, #84]	; (8015128 <_strtod_l+0x5c8>)
 80150d2:	00db      	lsls	r3, r3, #3
 80150d4:	18d3      	adds	r3, r2, r3
 80150d6:	0030      	movs	r0, r6
 80150d8:	681a      	ldr	r2, [r3, #0]
 80150da:	685b      	ldr	r3, [r3, #4]
 80150dc:	0039      	movs	r1, r7
 80150de:	f7ec fa5f 	bl	80015a0 <__aeabi_ddiv>
 80150e2:	0006      	movs	r6, r0
 80150e4:	000f      	movs	r7, r1
 80150e6:	1124      	asrs	r4, r4, #4
 80150e8:	d0d7      	beq.n	801509a <_strtod_l+0x53a>
 80150ea:	2c1f      	cmp	r4, #31
 80150ec:	dd28      	ble.n	8015140 <_strtod_l+0x5e0>
 80150ee:	2400      	movs	r4, #0
 80150f0:	9405      	str	r4, [sp, #20]
 80150f2:	940b      	str	r4, [sp, #44]	; 0x2c
 80150f4:	940a      	str	r4, [sp, #40]	; 0x28
 80150f6:	2322      	movs	r3, #34	; 0x22
 80150f8:	9a04      	ldr	r2, [sp, #16]
 80150fa:	2600      	movs	r6, #0
 80150fc:	6013      	str	r3, [r2, #0]
 80150fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015100:	2700      	movs	r7, #0
 8015102:	2b00      	cmp	r3, #0
 8015104:	d000      	beq.n	8015108 <_strtod_l+0x5a8>
 8015106:	e76a      	b.n	8014fde <_strtod_l+0x47e>
 8015108:	e56b      	b.n	8014be2 <_strtod_l+0x82>
 801510a:	46c0      	nop			; (mov r8, r8)
 801510c:	00004e1f 	.word	0x00004e1f
 8015110:	0801c5dd 	.word	0x0801c5dd
 8015114:	0801c72e 	.word	0x0801c72e
 8015118:	7ff00000 	.word	0x7ff00000
 801511c:	08019583 	.word	0x08019583
 8015120:	0801c59c 	.word	0x0801c59c
 8015124:	fff80000 	.word	0xfff80000
 8015128:	0801c760 	.word	0x0801c760
 801512c:	fcb00000 	.word	0xfcb00000
 8015130:	0801c738 	.word	0x0801c738
 8015134:	7ca00000 	.word	0x7ca00000
 8015138:	7c900000 	.word	0x7c900000
 801513c:	7fefffff 	.word	0x7fefffff
 8015140:	2310      	movs	r3, #16
 8015142:	4023      	ands	r3, r4
 8015144:	9306      	str	r3, [sp, #24]
 8015146:	d001      	beq.n	801514c <_strtod_l+0x5ec>
 8015148:	236a      	movs	r3, #106	; 0x6a
 801514a:	9306      	str	r3, [sp, #24]
 801514c:	2300      	movs	r3, #0
 801514e:	0030      	movs	r0, r6
 8015150:	0039      	movs	r1, r7
 8015152:	001d      	movs	r5, r3
 8015154:	2c00      	cmp	r4, #0
 8015156:	dd00      	ble.n	801515a <_strtod_l+0x5fa>
 8015158:	e10e      	b.n	8015378 <_strtod_l+0x818>
 801515a:	2b00      	cmp	r3, #0
 801515c:	d001      	beq.n	8015162 <_strtod_l+0x602>
 801515e:	0006      	movs	r6, r0
 8015160:	000f      	movs	r7, r1
 8015162:	9b06      	ldr	r3, [sp, #24]
 8015164:	2b00      	cmp	r3, #0
 8015166:	d00f      	beq.n	8015188 <_strtod_l+0x628>
 8015168:	236b      	movs	r3, #107	; 0x6b
 801516a:	0079      	lsls	r1, r7, #1
 801516c:	0d49      	lsrs	r1, r1, #21
 801516e:	003a      	movs	r2, r7
 8015170:	1a5b      	subs	r3, r3, r1
 8015172:	2b00      	cmp	r3, #0
 8015174:	dd08      	ble.n	8015188 <_strtod_l+0x628>
 8015176:	2b1f      	cmp	r3, #31
 8015178:	dc00      	bgt.n	801517c <_strtod_l+0x61c>
 801517a:	e112      	b.n	80153a2 <_strtod_l+0x842>
 801517c:	2600      	movs	r6, #0
 801517e:	2b34      	cmp	r3, #52	; 0x34
 8015180:	dc00      	bgt.n	8015184 <_strtod_l+0x624>
 8015182:	e107      	b.n	8015394 <_strtod_l+0x834>
 8015184:	27dc      	movs	r7, #220	; 0xdc
 8015186:	04bf      	lsls	r7, r7, #18
 8015188:	2200      	movs	r2, #0
 801518a:	2300      	movs	r3, #0
 801518c:	0030      	movs	r0, r6
 801518e:	0039      	movs	r1, r7
 8015190:	f7eb f984 	bl	800049c <__aeabi_dcmpeq>
 8015194:	2800      	cmp	r0, #0
 8015196:	d1aa      	bne.n	80150ee <_strtod_l+0x58e>
 8015198:	9b08      	ldr	r3, [sp, #32]
 801519a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801519c:	9300      	str	r3, [sp, #0]
 801519e:	9912      	ldr	r1, [sp, #72]	; 0x48
 80151a0:	9b05      	ldr	r3, [sp, #20]
 80151a2:	9804      	ldr	r0, [sp, #16]
 80151a4:	f003 fa46 	bl	8018634 <__s2b>
 80151a8:	900b      	str	r0, [sp, #44]	; 0x2c
 80151aa:	2800      	cmp	r0, #0
 80151ac:	d100      	bne.n	80151b0 <_strtod_l+0x650>
 80151ae:	e709      	b.n	8014fc4 <_strtod_l+0x464>
 80151b0:	9b07      	ldr	r3, [sp, #28]
 80151b2:	9a07      	ldr	r2, [sp, #28]
 80151b4:	17db      	asrs	r3, r3, #31
 80151b6:	4252      	negs	r2, r2
 80151b8:	4013      	ands	r3, r2
 80151ba:	9315      	str	r3, [sp, #84]	; 0x54
 80151bc:	9b07      	ldr	r3, [sp, #28]
 80151be:	2400      	movs	r4, #0
 80151c0:	43db      	mvns	r3, r3
 80151c2:	9a07      	ldr	r2, [sp, #28]
 80151c4:	17db      	asrs	r3, r3, #31
 80151c6:	401a      	ands	r2, r3
 80151c8:	921c      	str	r2, [sp, #112]	; 0x70
 80151ca:	9405      	str	r4, [sp, #20]
 80151cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80151ce:	9804      	ldr	r0, [sp, #16]
 80151d0:	6859      	ldr	r1, [r3, #4]
 80151d2:	f003 f9bf 	bl	8018554 <_Balloc>
 80151d6:	900a      	str	r0, [sp, #40]	; 0x28
 80151d8:	2800      	cmp	r0, #0
 80151da:	d100      	bne.n	80151de <_strtod_l+0x67e>
 80151dc:	e6f6      	b.n	8014fcc <_strtod_l+0x46c>
 80151de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80151e0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80151e2:	691b      	ldr	r3, [r3, #16]
 80151e4:	310c      	adds	r1, #12
 80151e6:	1c9a      	adds	r2, r3, #2
 80151e8:	0092      	lsls	r2, r2, #2
 80151ea:	300c      	adds	r0, #12
 80151ec:	9308      	str	r3, [sp, #32]
 80151ee:	f7ff fa31 	bl	8014654 <memcpy>
 80151f2:	ab24      	add	r3, sp, #144	; 0x90
 80151f4:	9301      	str	r3, [sp, #4]
 80151f6:	ab23      	add	r3, sp, #140	; 0x8c
 80151f8:	9300      	str	r3, [sp, #0]
 80151fa:	0032      	movs	r2, r6
 80151fc:	003b      	movs	r3, r7
 80151fe:	9804      	ldr	r0, [sp, #16]
 8015200:	960e      	str	r6, [sp, #56]	; 0x38
 8015202:	970f      	str	r7, [sp, #60]	; 0x3c
 8015204:	f003 fcba 	bl	8018b7c <__d2b>
 8015208:	9022      	str	r0, [sp, #136]	; 0x88
 801520a:	2800      	cmp	r0, #0
 801520c:	d100      	bne.n	8015210 <_strtod_l+0x6b0>
 801520e:	e6dd      	b.n	8014fcc <_strtod_l+0x46c>
 8015210:	2101      	movs	r1, #1
 8015212:	9804      	ldr	r0, [sp, #16]
 8015214:	f003 fa95 	bl	8018742 <__i2b>
 8015218:	9005      	str	r0, [sp, #20]
 801521a:	2800      	cmp	r0, #0
 801521c:	d100      	bne.n	8015220 <_strtod_l+0x6c0>
 801521e:	e6d5      	b.n	8014fcc <_strtod_l+0x46c>
 8015220:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8015222:	2b00      	cmp	r3, #0
 8015224:	da00      	bge.n	8015228 <_strtod_l+0x6c8>
 8015226:	e0c1      	b.n	80153ac <_strtod_l+0x84c>
 8015228:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801522a:	189d      	adds	r5, r3, r2
 801522c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 801522e:	4694      	mov	ip, r2
 8015230:	9906      	ldr	r1, [sp, #24]
 8015232:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8015234:	1a5b      	subs	r3, r3, r1
 8015236:	2136      	movs	r1, #54	; 0x36
 8015238:	189b      	adds	r3, r3, r2
 801523a:	1a8a      	subs	r2, r1, r2
 801523c:	49b2      	ldr	r1, [pc, #712]	; (8015508 <_strtod_l+0x9a8>)
 801523e:	3b01      	subs	r3, #1
 8015240:	2001      	movs	r0, #1
 8015242:	428b      	cmp	r3, r1
 8015244:	db00      	blt.n	8015248 <_strtod_l+0x6e8>
 8015246:	e0bd      	b.n	80153c4 <_strtod_l+0x864>
 8015248:	1ac9      	subs	r1, r1, r3
 801524a:	1a52      	subs	r2, r2, r1
 801524c:	291f      	cmp	r1, #31
 801524e:	dd00      	ble.n	8015252 <_strtod_l+0x6f2>
 8015250:	e0b1      	b.n	80153b6 <_strtod_l+0x856>
 8015252:	4088      	lsls	r0, r1
 8015254:	2300      	movs	r3, #0
 8015256:	9014      	str	r0, [sp, #80]	; 0x50
 8015258:	9310      	str	r3, [sp, #64]	; 0x40
 801525a:	18ab      	adds	r3, r5, r2
 801525c:	9308      	str	r3, [sp, #32]
 801525e:	0013      	movs	r3, r2
 8015260:	9a06      	ldr	r2, [sp, #24]
 8015262:	4463      	add	r3, ip
 8015264:	18d3      	adds	r3, r2, r3
 8015266:	9a08      	ldr	r2, [sp, #32]
 8015268:	930c      	str	r3, [sp, #48]	; 0x30
 801526a:	002b      	movs	r3, r5
 801526c:	4295      	cmp	r5, r2
 801526e:	dd00      	ble.n	8015272 <_strtod_l+0x712>
 8015270:	0013      	movs	r3, r2
 8015272:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8015274:	4293      	cmp	r3, r2
 8015276:	dd00      	ble.n	801527a <_strtod_l+0x71a>
 8015278:	0013      	movs	r3, r2
 801527a:	2b00      	cmp	r3, #0
 801527c:	dd06      	ble.n	801528c <_strtod_l+0x72c>
 801527e:	9a08      	ldr	r2, [sp, #32]
 8015280:	1aed      	subs	r5, r5, r3
 8015282:	1ad2      	subs	r2, r2, r3
 8015284:	9208      	str	r2, [sp, #32]
 8015286:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8015288:	1ad2      	subs	r2, r2, r3
 801528a:	920c      	str	r2, [sp, #48]	; 0x30
 801528c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801528e:	2b00      	cmp	r3, #0
 8015290:	d017      	beq.n	80152c2 <_strtod_l+0x762>
 8015292:	001a      	movs	r2, r3
 8015294:	9905      	ldr	r1, [sp, #20]
 8015296:	9804      	ldr	r0, [sp, #16]
 8015298:	f003 faec 	bl	8018874 <__pow5mult>
 801529c:	9005      	str	r0, [sp, #20]
 801529e:	2800      	cmp	r0, #0
 80152a0:	d100      	bne.n	80152a4 <_strtod_l+0x744>
 80152a2:	e693      	b.n	8014fcc <_strtod_l+0x46c>
 80152a4:	0001      	movs	r1, r0
 80152a6:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80152a8:	9804      	ldr	r0, [sp, #16]
 80152aa:	f003 fa53 	bl	8018754 <__multiply>
 80152ae:	9012      	str	r0, [sp, #72]	; 0x48
 80152b0:	2800      	cmp	r0, #0
 80152b2:	d100      	bne.n	80152b6 <_strtod_l+0x756>
 80152b4:	e68a      	b.n	8014fcc <_strtod_l+0x46c>
 80152b6:	9922      	ldr	r1, [sp, #136]	; 0x88
 80152b8:	9804      	ldr	r0, [sp, #16]
 80152ba:	f003 f973 	bl	80185a4 <_Bfree>
 80152be:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80152c0:	9322      	str	r3, [sp, #136]	; 0x88
 80152c2:	9b08      	ldr	r3, [sp, #32]
 80152c4:	2b00      	cmp	r3, #0
 80152c6:	dd00      	ble.n	80152ca <_strtod_l+0x76a>
 80152c8:	e07f      	b.n	80153ca <_strtod_l+0x86a>
 80152ca:	9b07      	ldr	r3, [sp, #28]
 80152cc:	2b00      	cmp	r3, #0
 80152ce:	dd08      	ble.n	80152e2 <_strtod_l+0x782>
 80152d0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80152d2:	990a      	ldr	r1, [sp, #40]	; 0x28
 80152d4:	9804      	ldr	r0, [sp, #16]
 80152d6:	f003 facd 	bl	8018874 <__pow5mult>
 80152da:	900a      	str	r0, [sp, #40]	; 0x28
 80152dc:	2800      	cmp	r0, #0
 80152de:	d100      	bne.n	80152e2 <_strtod_l+0x782>
 80152e0:	e674      	b.n	8014fcc <_strtod_l+0x46c>
 80152e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80152e4:	2b00      	cmp	r3, #0
 80152e6:	dd08      	ble.n	80152fa <_strtod_l+0x79a>
 80152e8:	001a      	movs	r2, r3
 80152ea:	990a      	ldr	r1, [sp, #40]	; 0x28
 80152ec:	9804      	ldr	r0, [sp, #16]
 80152ee:	f003 fb03 	bl	80188f8 <__lshift>
 80152f2:	900a      	str	r0, [sp, #40]	; 0x28
 80152f4:	2800      	cmp	r0, #0
 80152f6:	d100      	bne.n	80152fa <_strtod_l+0x79a>
 80152f8:	e668      	b.n	8014fcc <_strtod_l+0x46c>
 80152fa:	2d00      	cmp	r5, #0
 80152fc:	dd08      	ble.n	8015310 <_strtod_l+0x7b0>
 80152fe:	002a      	movs	r2, r5
 8015300:	9905      	ldr	r1, [sp, #20]
 8015302:	9804      	ldr	r0, [sp, #16]
 8015304:	f003 faf8 	bl	80188f8 <__lshift>
 8015308:	9005      	str	r0, [sp, #20]
 801530a:	2800      	cmp	r0, #0
 801530c:	d100      	bne.n	8015310 <_strtod_l+0x7b0>
 801530e:	e65d      	b.n	8014fcc <_strtod_l+0x46c>
 8015310:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8015312:	9922      	ldr	r1, [sp, #136]	; 0x88
 8015314:	9804      	ldr	r0, [sp, #16]
 8015316:	f003 fb5b 	bl	80189d0 <__mdiff>
 801531a:	1e04      	subs	r4, r0, #0
 801531c:	d100      	bne.n	8015320 <_strtod_l+0x7c0>
 801531e:	e655      	b.n	8014fcc <_strtod_l+0x46c>
 8015320:	2500      	movs	r5, #0
 8015322:	68c3      	ldr	r3, [r0, #12]
 8015324:	9905      	ldr	r1, [sp, #20]
 8015326:	60c5      	str	r5, [r0, #12]
 8015328:	9312      	str	r3, [sp, #72]	; 0x48
 801532a:	f003 fb37 	bl	801899c <__mcmp>
 801532e:	42a8      	cmp	r0, r5
 8015330:	da55      	bge.n	80153de <_strtod_l+0x87e>
 8015332:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8015334:	42ab      	cmp	r3, r5
 8015336:	d11b      	bne.n	8015370 <_strtod_l+0x810>
 8015338:	42ae      	cmp	r6, r5
 801533a:	d119      	bne.n	8015370 <_strtod_l+0x810>
 801533c:	033b      	lsls	r3, r7, #12
 801533e:	42ab      	cmp	r3, r5
 8015340:	d116      	bne.n	8015370 <_strtod_l+0x810>
 8015342:	22d6      	movs	r2, #214	; 0xd6
 8015344:	4b71      	ldr	r3, [pc, #452]	; (801550c <_strtod_l+0x9ac>)
 8015346:	04d2      	lsls	r2, r2, #19
 8015348:	403b      	ands	r3, r7
 801534a:	4293      	cmp	r3, r2
 801534c:	d910      	bls.n	8015370 <_strtod_l+0x810>
 801534e:	6963      	ldr	r3, [r4, #20]
 8015350:	42ab      	cmp	r3, r5
 8015352:	d102      	bne.n	801535a <_strtod_l+0x7fa>
 8015354:	6923      	ldr	r3, [r4, #16]
 8015356:	2b01      	cmp	r3, #1
 8015358:	dd0a      	ble.n	8015370 <_strtod_l+0x810>
 801535a:	0021      	movs	r1, r4
 801535c:	2201      	movs	r2, #1
 801535e:	9804      	ldr	r0, [sp, #16]
 8015360:	f003 faca 	bl	80188f8 <__lshift>
 8015364:	9905      	ldr	r1, [sp, #20]
 8015366:	0004      	movs	r4, r0
 8015368:	f003 fb18 	bl	801899c <__mcmp>
 801536c:	2800      	cmp	r0, #0
 801536e:	dc6b      	bgt.n	8015448 <_strtod_l+0x8e8>
 8015370:	9b06      	ldr	r3, [sp, #24]
 8015372:	2b00      	cmp	r3, #0
 8015374:	d178      	bne.n	8015468 <_strtod_l+0x908>
 8015376:	e632      	b.n	8014fde <_strtod_l+0x47e>
 8015378:	2201      	movs	r2, #1
 801537a:	4214      	tst	r4, r2
 801537c:	d007      	beq.n	801538e <_strtod_l+0x82e>
 801537e:	4a64      	ldr	r2, [pc, #400]	; (8015510 <_strtod_l+0x9b0>)
 8015380:	00eb      	lsls	r3, r5, #3
 8015382:	18d3      	adds	r3, r2, r3
 8015384:	681a      	ldr	r2, [r3, #0]
 8015386:	685b      	ldr	r3, [r3, #4]
 8015388:	f7ec fd14 	bl	8001db4 <__aeabi_dmul>
 801538c:	2301      	movs	r3, #1
 801538e:	3501      	adds	r5, #1
 8015390:	1064      	asrs	r4, r4, #1
 8015392:	e6df      	b.n	8015154 <_strtod_l+0x5f4>
 8015394:	2101      	movs	r1, #1
 8015396:	3b20      	subs	r3, #32
 8015398:	4249      	negs	r1, r1
 801539a:	4099      	lsls	r1, r3
 801539c:	400a      	ands	r2, r1
 801539e:	0017      	movs	r7, r2
 80153a0:	e6f2      	b.n	8015188 <_strtod_l+0x628>
 80153a2:	2201      	movs	r2, #1
 80153a4:	4252      	negs	r2, r2
 80153a6:	409a      	lsls	r2, r3
 80153a8:	4016      	ands	r6, r2
 80153aa:	e6ed      	b.n	8015188 <_strtod_l+0x628>
 80153ac:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80153ae:	9d15      	ldr	r5, [sp, #84]	; 0x54
 80153b0:	1ad2      	subs	r2, r2, r3
 80153b2:	4694      	mov	ip, r2
 80153b4:	e73c      	b.n	8015230 <_strtod_l+0x6d0>
 80153b6:	4957      	ldr	r1, [pc, #348]	; (8015514 <_strtod_l+0x9b4>)
 80153b8:	1acb      	subs	r3, r1, r3
 80153ba:	0001      	movs	r1, r0
 80153bc:	4099      	lsls	r1, r3
 80153be:	9110      	str	r1, [sp, #64]	; 0x40
 80153c0:	9014      	str	r0, [sp, #80]	; 0x50
 80153c2:	e74a      	b.n	801525a <_strtod_l+0x6fa>
 80153c4:	2300      	movs	r3, #0
 80153c6:	9310      	str	r3, [sp, #64]	; 0x40
 80153c8:	e7fa      	b.n	80153c0 <_strtod_l+0x860>
 80153ca:	9a08      	ldr	r2, [sp, #32]
 80153cc:	9922      	ldr	r1, [sp, #136]	; 0x88
 80153ce:	9804      	ldr	r0, [sp, #16]
 80153d0:	f003 fa92 	bl	80188f8 <__lshift>
 80153d4:	9022      	str	r0, [sp, #136]	; 0x88
 80153d6:	2800      	cmp	r0, #0
 80153d8:	d000      	beq.n	80153dc <_strtod_l+0x87c>
 80153da:	e776      	b.n	80152ca <_strtod_l+0x76a>
 80153dc:	e5f6      	b.n	8014fcc <_strtod_l+0x46c>
 80153de:	970c      	str	r7, [sp, #48]	; 0x30
 80153e0:	2800      	cmp	r0, #0
 80153e2:	d000      	beq.n	80153e6 <_strtod_l+0x886>
 80153e4:	e0a0      	b.n	8015528 <_strtod_l+0x9c8>
 80153e6:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80153e8:	033b      	lsls	r3, r7, #12
 80153ea:	0b1b      	lsrs	r3, r3, #12
 80153ec:	2a00      	cmp	r2, #0
 80153ee:	d027      	beq.n	8015440 <_strtod_l+0x8e0>
 80153f0:	4a49      	ldr	r2, [pc, #292]	; (8015518 <_strtod_l+0x9b8>)
 80153f2:	4293      	cmp	r3, r2
 80153f4:	d157      	bne.n	80154a6 <_strtod_l+0x946>
 80153f6:	2201      	movs	r2, #1
 80153f8:	9b06      	ldr	r3, [sp, #24]
 80153fa:	4252      	negs	r2, r2
 80153fc:	0031      	movs	r1, r6
 80153fe:	0010      	movs	r0, r2
 8015400:	2b00      	cmp	r3, #0
 8015402:	d00b      	beq.n	801541c <_strtod_l+0x8bc>
 8015404:	25d4      	movs	r5, #212	; 0xd4
 8015406:	4b41      	ldr	r3, [pc, #260]	; (801550c <_strtod_l+0x9ac>)
 8015408:	04ed      	lsls	r5, r5, #19
 801540a:	403b      	ands	r3, r7
 801540c:	0010      	movs	r0, r2
 801540e:	42ab      	cmp	r3, r5
 8015410:	d804      	bhi.n	801541c <_strtod_l+0x8bc>
 8015412:	306c      	adds	r0, #108	; 0x6c
 8015414:	0d1b      	lsrs	r3, r3, #20
 8015416:	1ac3      	subs	r3, r0, r3
 8015418:	409a      	lsls	r2, r3
 801541a:	0010      	movs	r0, r2
 801541c:	4281      	cmp	r1, r0
 801541e:	d142      	bne.n	80154a6 <_strtod_l+0x946>
 8015420:	4b3e      	ldr	r3, [pc, #248]	; (801551c <_strtod_l+0x9bc>)
 8015422:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8015424:	429a      	cmp	r2, r3
 8015426:	d102      	bne.n	801542e <_strtod_l+0x8ce>
 8015428:	1c4b      	adds	r3, r1, #1
 801542a:	d100      	bne.n	801542e <_strtod_l+0x8ce>
 801542c:	e5ce      	b.n	8014fcc <_strtod_l+0x46c>
 801542e:	4b37      	ldr	r3, [pc, #220]	; (801550c <_strtod_l+0x9ac>)
 8015430:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8015432:	2600      	movs	r6, #0
 8015434:	401a      	ands	r2, r3
 8015436:	0013      	movs	r3, r2
 8015438:	2280      	movs	r2, #128	; 0x80
 801543a:	0352      	lsls	r2, r2, #13
 801543c:	189f      	adds	r7, r3, r2
 801543e:	e797      	b.n	8015370 <_strtod_l+0x810>
 8015440:	2b00      	cmp	r3, #0
 8015442:	d130      	bne.n	80154a6 <_strtod_l+0x946>
 8015444:	2e00      	cmp	r6, #0
 8015446:	d12e      	bne.n	80154a6 <_strtod_l+0x946>
 8015448:	9906      	ldr	r1, [sp, #24]
 801544a:	003b      	movs	r3, r7
 801544c:	4a2f      	ldr	r2, [pc, #188]	; (801550c <_strtod_l+0x9ac>)
 801544e:	2900      	cmp	r1, #0
 8015450:	d020      	beq.n	8015494 <_strtod_l+0x934>
 8015452:	0011      	movs	r1, r2
 8015454:	20d6      	movs	r0, #214	; 0xd6
 8015456:	4039      	ands	r1, r7
 8015458:	04c0      	lsls	r0, r0, #19
 801545a:	4281      	cmp	r1, r0
 801545c:	dc1a      	bgt.n	8015494 <_strtod_l+0x934>
 801545e:	23dc      	movs	r3, #220	; 0xdc
 8015460:	049b      	lsls	r3, r3, #18
 8015462:	4299      	cmp	r1, r3
 8015464:	dc00      	bgt.n	8015468 <_strtod_l+0x908>
 8015466:	e646      	b.n	80150f6 <_strtod_l+0x596>
 8015468:	4b2d      	ldr	r3, [pc, #180]	; (8015520 <_strtod_l+0x9c0>)
 801546a:	0030      	movs	r0, r6
 801546c:	931b      	str	r3, [sp, #108]	; 0x6c
 801546e:	2300      	movs	r3, #0
 8015470:	931a      	str	r3, [sp, #104]	; 0x68
 8015472:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8015474:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8015476:	0039      	movs	r1, r7
 8015478:	f7ec fc9c 	bl	8001db4 <__aeabi_dmul>
 801547c:	0006      	movs	r6, r0
 801547e:	000f      	movs	r7, r1
 8015480:	1e0b      	subs	r3, r1, #0
 8015482:	d000      	beq.n	8015486 <_strtod_l+0x926>
 8015484:	e5ab      	b.n	8014fde <_strtod_l+0x47e>
 8015486:	2800      	cmp	r0, #0
 8015488:	d000      	beq.n	801548c <_strtod_l+0x92c>
 801548a:	e5a8      	b.n	8014fde <_strtod_l+0x47e>
 801548c:	9a04      	ldr	r2, [sp, #16]
 801548e:	3322      	adds	r3, #34	; 0x22
 8015490:	6013      	str	r3, [r2, #0]
 8015492:	e5a4      	b.n	8014fde <_strtod_l+0x47e>
 8015494:	2601      	movs	r6, #1
 8015496:	4013      	ands	r3, r2
 8015498:	4a22      	ldr	r2, [pc, #136]	; (8015524 <_strtod_l+0x9c4>)
 801549a:	4276      	negs	r6, r6
 801549c:	189b      	adds	r3, r3, r2
 801549e:	4a1e      	ldr	r2, [pc, #120]	; (8015518 <_strtod_l+0x9b8>)
 80154a0:	431a      	orrs	r2, r3
 80154a2:	0017      	movs	r7, r2
 80154a4:	e764      	b.n	8015370 <_strtod_l+0x810>
 80154a6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80154a8:	2b00      	cmp	r3, #0
 80154aa:	d015      	beq.n	80154d8 <_strtod_l+0x978>
 80154ac:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80154ae:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80154b0:	4213      	tst	r3, r2
 80154b2:	d100      	bne.n	80154b6 <_strtod_l+0x956>
 80154b4:	e75c      	b.n	8015370 <_strtod_l+0x810>
 80154b6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80154b8:	9a06      	ldr	r2, [sp, #24]
 80154ba:	0030      	movs	r0, r6
 80154bc:	0039      	movs	r1, r7
 80154be:	2b00      	cmp	r3, #0
 80154c0:	d00f      	beq.n	80154e2 <_strtod_l+0x982>
 80154c2:	f7ff fb35 	bl	8014b30 <sulp>
 80154c6:	0002      	movs	r2, r0
 80154c8:	000b      	movs	r3, r1
 80154ca:	980e      	ldr	r0, [sp, #56]	; 0x38
 80154cc:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80154ce:	f7eb fd4b 	bl	8000f68 <__aeabi_dadd>
 80154d2:	0006      	movs	r6, r0
 80154d4:	000f      	movs	r7, r1
 80154d6:	e74b      	b.n	8015370 <_strtod_l+0x810>
 80154d8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80154da:	4233      	tst	r3, r6
 80154dc:	d100      	bne.n	80154e0 <_strtod_l+0x980>
 80154de:	e747      	b.n	8015370 <_strtod_l+0x810>
 80154e0:	e7e9      	b.n	80154b6 <_strtod_l+0x956>
 80154e2:	f7ff fb25 	bl	8014b30 <sulp>
 80154e6:	0002      	movs	r2, r0
 80154e8:	000b      	movs	r3, r1
 80154ea:	980e      	ldr	r0, [sp, #56]	; 0x38
 80154ec:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80154ee:	f7ec fed3 	bl	8002298 <__aeabi_dsub>
 80154f2:	2200      	movs	r2, #0
 80154f4:	2300      	movs	r3, #0
 80154f6:	0006      	movs	r6, r0
 80154f8:	000f      	movs	r7, r1
 80154fa:	f7ea ffcf 	bl	800049c <__aeabi_dcmpeq>
 80154fe:	2800      	cmp	r0, #0
 8015500:	d000      	beq.n	8015504 <_strtod_l+0x9a4>
 8015502:	e5f8      	b.n	80150f6 <_strtod_l+0x596>
 8015504:	e734      	b.n	8015370 <_strtod_l+0x810>
 8015506:	46c0      	nop			; (mov r8, r8)
 8015508:	fffffc02 	.word	0xfffffc02
 801550c:	7ff00000 	.word	0x7ff00000
 8015510:	0801c5b0 	.word	0x0801c5b0
 8015514:	fffffbe2 	.word	0xfffffbe2
 8015518:	000fffff 	.word	0x000fffff
 801551c:	7fefffff 	.word	0x7fefffff
 8015520:	39500000 	.word	0x39500000
 8015524:	fff00000 	.word	0xfff00000
 8015528:	9905      	ldr	r1, [sp, #20]
 801552a:	0020      	movs	r0, r4
 801552c:	f003 fb7a 	bl	8018c24 <__ratio>
 8015530:	2380      	movs	r3, #128	; 0x80
 8015532:	2200      	movs	r2, #0
 8015534:	05db      	lsls	r3, r3, #23
 8015536:	9008      	str	r0, [sp, #32]
 8015538:	9109      	str	r1, [sp, #36]	; 0x24
 801553a:	f7ea ffbf 	bl	80004bc <__aeabi_dcmple>
 801553e:	2800      	cmp	r0, #0
 8015540:	d100      	bne.n	8015544 <_strtod_l+0x9e4>
 8015542:	e07f      	b.n	8015644 <_strtod_l+0xae4>
 8015544:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8015546:	2b00      	cmp	r3, #0
 8015548:	d04b      	beq.n	80155e2 <_strtod_l+0xa82>
 801554a:	2200      	movs	r2, #0
 801554c:	4b8a      	ldr	r3, [pc, #552]	; (8015778 <_strtod_l+0xc18>)
 801554e:	9210      	str	r2, [sp, #64]	; 0x40
 8015550:	9311      	str	r3, [sp, #68]	; 0x44
 8015552:	4b89      	ldr	r3, [pc, #548]	; (8015778 <_strtod_l+0xc18>)
 8015554:	9308      	str	r3, [sp, #32]
 8015556:	4a89      	ldr	r2, [pc, #548]	; (801577c <_strtod_l+0xc1c>)
 8015558:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801555a:	4013      	ands	r3, r2
 801555c:	9314      	str	r3, [sp, #80]	; 0x50
 801555e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8015560:	4b87      	ldr	r3, [pc, #540]	; (8015780 <_strtod_l+0xc20>)
 8015562:	429a      	cmp	r2, r3
 8015564:	d000      	beq.n	8015568 <_strtod_l+0xa08>
 8015566:	e0ba      	b.n	80156de <_strtod_l+0xb7e>
 8015568:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801556a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801556c:	921a      	str	r2, [sp, #104]	; 0x68
 801556e:	931b      	str	r3, [sp, #108]	; 0x6c
 8015570:	4a84      	ldr	r2, [pc, #528]	; (8015784 <_strtod_l+0xc24>)
 8015572:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8015574:	4694      	mov	ip, r2
 8015576:	4463      	add	r3, ip
 8015578:	001f      	movs	r7, r3
 801557a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801557c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801557e:	0030      	movs	r0, r6
 8015580:	0039      	movs	r1, r7
 8015582:	920c      	str	r2, [sp, #48]	; 0x30
 8015584:	930d      	str	r3, [sp, #52]	; 0x34
 8015586:	f003 fa87 	bl	8018a98 <__ulp>
 801558a:	0002      	movs	r2, r0
 801558c:	000b      	movs	r3, r1
 801558e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8015590:	990d      	ldr	r1, [sp, #52]	; 0x34
 8015592:	f7ec fc0f 	bl	8001db4 <__aeabi_dmul>
 8015596:	0032      	movs	r2, r6
 8015598:	003b      	movs	r3, r7
 801559a:	f7eb fce5 	bl	8000f68 <__aeabi_dadd>
 801559e:	4a77      	ldr	r2, [pc, #476]	; (801577c <_strtod_l+0xc1c>)
 80155a0:	4b79      	ldr	r3, [pc, #484]	; (8015788 <_strtod_l+0xc28>)
 80155a2:	0006      	movs	r6, r0
 80155a4:	400a      	ands	r2, r1
 80155a6:	429a      	cmp	r2, r3
 80155a8:	d964      	bls.n	8015674 <_strtod_l+0xb14>
 80155aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80155ac:	4a77      	ldr	r2, [pc, #476]	; (801578c <_strtod_l+0xc2c>)
 80155ae:	4293      	cmp	r3, r2
 80155b0:	d103      	bne.n	80155ba <_strtod_l+0xa5a>
 80155b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80155b4:	3301      	adds	r3, #1
 80155b6:	d100      	bne.n	80155ba <_strtod_l+0xa5a>
 80155b8:	e508      	b.n	8014fcc <_strtod_l+0x46c>
 80155ba:	2601      	movs	r6, #1
 80155bc:	4f73      	ldr	r7, [pc, #460]	; (801578c <_strtod_l+0xc2c>)
 80155be:	4276      	negs	r6, r6
 80155c0:	9922      	ldr	r1, [sp, #136]	; 0x88
 80155c2:	9804      	ldr	r0, [sp, #16]
 80155c4:	f002 ffee 	bl	80185a4 <_Bfree>
 80155c8:	990a      	ldr	r1, [sp, #40]	; 0x28
 80155ca:	9804      	ldr	r0, [sp, #16]
 80155cc:	f002 ffea 	bl	80185a4 <_Bfree>
 80155d0:	9905      	ldr	r1, [sp, #20]
 80155d2:	9804      	ldr	r0, [sp, #16]
 80155d4:	f002 ffe6 	bl	80185a4 <_Bfree>
 80155d8:	0021      	movs	r1, r4
 80155da:	9804      	ldr	r0, [sp, #16]
 80155dc:	f002 ffe2 	bl	80185a4 <_Bfree>
 80155e0:	e5f4      	b.n	80151cc <_strtod_l+0x66c>
 80155e2:	2e00      	cmp	r6, #0
 80155e4:	d11e      	bne.n	8015624 <_strtod_l+0xac4>
 80155e6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80155e8:	031b      	lsls	r3, r3, #12
 80155ea:	d121      	bne.n	8015630 <_strtod_l+0xad0>
 80155ec:	9808      	ldr	r0, [sp, #32]
 80155ee:	9909      	ldr	r1, [sp, #36]	; 0x24
 80155f0:	2200      	movs	r2, #0
 80155f2:	4b61      	ldr	r3, [pc, #388]	; (8015778 <_strtod_l+0xc18>)
 80155f4:	f7ea ff58 	bl	80004a8 <__aeabi_dcmplt>
 80155f8:	2800      	cmp	r0, #0
 80155fa:	d11f      	bne.n	801563c <_strtod_l+0xadc>
 80155fc:	9808      	ldr	r0, [sp, #32]
 80155fe:	9909      	ldr	r1, [sp, #36]	; 0x24
 8015600:	2200      	movs	r2, #0
 8015602:	4b63      	ldr	r3, [pc, #396]	; (8015790 <_strtod_l+0xc30>)
 8015604:	f7ec fbd6 	bl	8001db4 <__aeabi_dmul>
 8015608:	0005      	movs	r5, r0
 801560a:	9108      	str	r1, [sp, #32]
 801560c:	2280      	movs	r2, #128	; 0x80
 801560e:	0612      	lsls	r2, r2, #24
 8015610:	4694      	mov	ip, r2
 8015612:	9b08      	ldr	r3, [sp, #32]
 8015614:	951e      	str	r5, [sp, #120]	; 0x78
 8015616:	4463      	add	r3, ip
 8015618:	931f      	str	r3, [sp, #124]	; 0x7c
 801561a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801561c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801561e:	9210      	str	r2, [sp, #64]	; 0x40
 8015620:	9311      	str	r3, [sp, #68]	; 0x44
 8015622:	e798      	b.n	8015556 <_strtod_l+0x9f6>
 8015624:	2e01      	cmp	r6, #1
 8015626:	d103      	bne.n	8015630 <_strtod_l+0xad0>
 8015628:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801562a:	2b00      	cmp	r3, #0
 801562c:	d100      	bne.n	8015630 <_strtod_l+0xad0>
 801562e:	e562      	b.n	80150f6 <_strtod_l+0x596>
 8015630:	2200      	movs	r2, #0
 8015632:	4b58      	ldr	r3, [pc, #352]	; (8015794 <_strtod_l+0xc34>)
 8015634:	2500      	movs	r5, #0
 8015636:	9210      	str	r2, [sp, #64]	; 0x40
 8015638:	9311      	str	r3, [sp, #68]	; 0x44
 801563a:	e78a      	b.n	8015552 <_strtod_l+0x9f2>
 801563c:	4b54      	ldr	r3, [pc, #336]	; (8015790 <_strtod_l+0xc30>)
 801563e:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8015640:	9308      	str	r3, [sp, #32]
 8015642:	e7e3      	b.n	801560c <_strtod_l+0xaac>
 8015644:	4b52      	ldr	r3, [pc, #328]	; (8015790 <_strtod_l+0xc30>)
 8015646:	9808      	ldr	r0, [sp, #32]
 8015648:	9909      	ldr	r1, [sp, #36]	; 0x24
 801564a:	2200      	movs	r2, #0
 801564c:	f7ec fbb2 	bl	8001db4 <__aeabi_dmul>
 8015650:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8015652:	0005      	movs	r5, r0
 8015654:	9108      	str	r1, [sp, #32]
 8015656:	2b00      	cmp	r3, #0
 8015658:	d107      	bne.n	801566a <_strtod_l+0xb0a>
 801565a:	2380      	movs	r3, #128	; 0x80
 801565c:	061b      	lsls	r3, r3, #24
 801565e:	18cb      	adds	r3, r1, r3
 8015660:	9016      	str	r0, [sp, #88]	; 0x58
 8015662:	9317      	str	r3, [sp, #92]	; 0x5c
 8015664:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8015666:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8015668:	e7d9      	b.n	801561e <_strtod_l+0xabe>
 801566a:	0002      	movs	r2, r0
 801566c:	9b08      	ldr	r3, [sp, #32]
 801566e:	9216      	str	r2, [sp, #88]	; 0x58
 8015670:	9317      	str	r3, [sp, #92]	; 0x5c
 8015672:	e7f7      	b.n	8015664 <_strtod_l+0xb04>
 8015674:	23d4      	movs	r3, #212	; 0xd4
 8015676:	049b      	lsls	r3, r3, #18
 8015678:	18cf      	adds	r7, r1, r3
 801567a:	9b06      	ldr	r3, [sp, #24]
 801567c:	2b00      	cmp	r3, #0
 801567e:	d19f      	bne.n	80155c0 <_strtod_l+0xa60>
 8015680:	4b3e      	ldr	r3, [pc, #248]	; (801577c <_strtod_l+0xc1c>)
 8015682:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8015684:	970c      	str	r7, [sp, #48]	; 0x30
 8015686:	403b      	ands	r3, r7
 8015688:	429a      	cmp	r2, r3
 801568a:	d199      	bne.n	80155c0 <_strtod_l+0xa60>
 801568c:	9908      	ldr	r1, [sp, #32]
 801568e:	0028      	movs	r0, r5
 8015690:	f7ed f966 	bl	8002960 <__aeabi_d2iz>
 8015694:	f7ed f99a 	bl	80029cc <__aeabi_i2d>
 8015698:	000b      	movs	r3, r1
 801569a:	0002      	movs	r2, r0
 801569c:	9908      	ldr	r1, [sp, #32]
 801569e:	0028      	movs	r0, r5
 80156a0:	f7ec fdfa 	bl	8002298 <__aeabi_dsub>
 80156a4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80156a6:	9008      	str	r0, [sp, #32]
 80156a8:	9109      	str	r1, [sp, #36]	; 0x24
 80156aa:	2b00      	cmp	r3, #0
 80156ac:	d104      	bne.n	80156b8 <_strtod_l+0xb58>
 80156ae:	2e00      	cmp	r6, #0
 80156b0:	d102      	bne.n	80156b8 <_strtod_l+0xb58>
 80156b2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80156b4:	031b      	lsls	r3, r3, #12
 80156b6:	d058      	beq.n	801576a <_strtod_l+0xc0a>
 80156b8:	9808      	ldr	r0, [sp, #32]
 80156ba:	9909      	ldr	r1, [sp, #36]	; 0x24
 80156bc:	4a36      	ldr	r2, [pc, #216]	; (8015798 <_strtod_l+0xc38>)
 80156be:	4b37      	ldr	r3, [pc, #220]	; (801579c <_strtod_l+0xc3c>)
 80156c0:	f7ea fef2 	bl	80004a8 <__aeabi_dcmplt>
 80156c4:	2800      	cmp	r0, #0
 80156c6:	d000      	beq.n	80156ca <_strtod_l+0xb6a>
 80156c8:	e489      	b.n	8014fde <_strtod_l+0x47e>
 80156ca:	9808      	ldr	r0, [sp, #32]
 80156cc:	9909      	ldr	r1, [sp, #36]	; 0x24
 80156ce:	4a34      	ldr	r2, [pc, #208]	; (80157a0 <_strtod_l+0xc40>)
 80156d0:	4b2f      	ldr	r3, [pc, #188]	; (8015790 <_strtod_l+0xc30>)
 80156d2:	f7ea fefd 	bl	80004d0 <__aeabi_dcmpgt>
 80156d6:	2800      	cmp	r0, #0
 80156d8:	d100      	bne.n	80156dc <_strtod_l+0xb7c>
 80156da:	e771      	b.n	80155c0 <_strtod_l+0xa60>
 80156dc:	e47f      	b.n	8014fde <_strtod_l+0x47e>
 80156de:	9b06      	ldr	r3, [sp, #24]
 80156e0:	2b00      	cmp	r3, #0
 80156e2:	d02a      	beq.n	801573a <_strtod_l+0xbda>
 80156e4:	23d4      	movs	r3, #212	; 0xd4
 80156e6:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80156e8:	04db      	lsls	r3, r3, #19
 80156ea:	429a      	cmp	r2, r3
 80156ec:	d825      	bhi.n	801573a <_strtod_l+0xbda>
 80156ee:	4a2d      	ldr	r2, [pc, #180]	; (80157a4 <_strtod_l+0xc44>)
 80156f0:	4b2d      	ldr	r3, [pc, #180]	; (80157a8 <_strtod_l+0xc48>)
 80156f2:	0028      	movs	r0, r5
 80156f4:	9908      	ldr	r1, [sp, #32]
 80156f6:	f7ea fee1 	bl	80004bc <__aeabi_dcmple>
 80156fa:	2800      	cmp	r0, #0
 80156fc:	d016      	beq.n	801572c <_strtod_l+0xbcc>
 80156fe:	0028      	movs	r0, r5
 8015700:	9908      	ldr	r1, [sp, #32]
 8015702:	f7ea ff95 	bl	8000630 <__aeabi_d2uiz>
 8015706:	2800      	cmp	r0, #0
 8015708:	d100      	bne.n	801570c <_strtod_l+0xbac>
 801570a:	3001      	adds	r0, #1
 801570c:	f7ed f998 	bl	8002a40 <__aeabi_ui2d>
 8015710:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8015712:	0005      	movs	r5, r0
 8015714:	9108      	str	r1, [sp, #32]
 8015716:	2b00      	cmp	r3, #0
 8015718:	d122      	bne.n	8015760 <_strtod_l+0xc00>
 801571a:	2380      	movs	r3, #128	; 0x80
 801571c:	061b      	lsls	r3, r3, #24
 801571e:	18cb      	adds	r3, r1, r3
 8015720:	9018      	str	r0, [sp, #96]	; 0x60
 8015722:	9319      	str	r3, [sp, #100]	; 0x64
 8015724:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8015726:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8015728:	9210      	str	r2, [sp, #64]	; 0x40
 801572a:	9311      	str	r3, [sp, #68]	; 0x44
 801572c:	22d6      	movs	r2, #214	; 0xd6
 801572e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015730:	04d2      	lsls	r2, r2, #19
 8015732:	189b      	adds	r3, r3, r2
 8015734:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8015736:	1a9b      	subs	r3, r3, r2
 8015738:	9311      	str	r3, [sp, #68]	; 0x44
 801573a:	980e      	ldr	r0, [sp, #56]	; 0x38
 801573c:	990f      	ldr	r1, [sp, #60]	; 0x3c
 801573e:	9e10      	ldr	r6, [sp, #64]	; 0x40
 8015740:	9f11      	ldr	r7, [sp, #68]	; 0x44
 8015742:	f003 f9a9 	bl	8018a98 <__ulp>
 8015746:	0002      	movs	r2, r0
 8015748:	000b      	movs	r3, r1
 801574a:	0030      	movs	r0, r6
 801574c:	0039      	movs	r1, r7
 801574e:	f7ec fb31 	bl	8001db4 <__aeabi_dmul>
 8015752:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8015754:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8015756:	f7eb fc07 	bl	8000f68 <__aeabi_dadd>
 801575a:	0006      	movs	r6, r0
 801575c:	000f      	movs	r7, r1
 801575e:	e78c      	b.n	801567a <_strtod_l+0xb1a>
 8015760:	0002      	movs	r2, r0
 8015762:	9b08      	ldr	r3, [sp, #32]
 8015764:	9218      	str	r2, [sp, #96]	; 0x60
 8015766:	9319      	str	r3, [sp, #100]	; 0x64
 8015768:	e7dc      	b.n	8015724 <_strtod_l+0xbc4>
 801576a:	4a0b      	ldr	r2, [pc, #44]	; (8015798 <_strtod_l+0xc38>)
 801576c:	4b0f      	ldr	r3, [pc, #60]	; (80157ac <_strtod_l+0xc4c>)
 801576e:	9808      	ldr	r0, [sp, #32]
 8015770:	9909      	ldr	r1, [sp, #36]	; 0x24
 8015772:	f7ea fe99 	bl	80004a8 <__aeabi_dcmplt>
 8015776:	e7ae      	b.n	80156d6 <_strtod_l+0xb76>
 8015778:	3ff00000 	.word	0x3ff00000
 801577c:	7ff00000 	.word	0x7ff00000
 8015780:	7fe00000 	.word	0x7fe00000
 8015784:	fcb00000 	.word	0xfcb00000
 8015788:	7c9fffff 	.word	0x7c9fffff
 801578c:	7fefffff 	.word	0x7fefffff
 8015790:	3fe00000 	.word	0x3fe00000
 8015794:	bff00000 	.word	0xbff00000
 8015798:	94a03595 	.word	0x94a03595
 801579c:	3fdfffff 	.word	0x3fdfffff
 80157a0:	35afe535 	.word	0x35afe535
 80157a4:	ffc00000 	.word	0xffc00000
 80157a8:	41dfffff 	.word	0x41dfffff
 80157ac:	3fcfffff 	.word	0x3fcfffff

080157b0 <strtod>:
 80157b0:	4b06      	ldr	r3, [pc, #24]	; (80157cc <strtod+0x1c>)
 80157b2:	b510      	push	{r4, lr}
 80157b4:	0004      	movs	r4, r0
 80157b6:	6818      	ldr	r0, [r3, #0]
 80157b8:	000a      	movs	r2, r1
 80157ba:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80157bc:	2b00      	cmp	r3, #0
 80157be:	d100      	bne.n	80157c2 <strtod+0x12>
 80157c0:	4b03      	ldr	r3, [pc, #12]	; (80157d0 <strtod+0x20>)
 80157c2:	0021      	movs	r1, r4
 80157c4:	f7ff f9cc 	bl	8014b60 <_strtod_l>
 80157c8:	bd10      	pop	{r4, pc}
 80157ca:	46c0      	nop			; (mov r8, r8)
 80157cc:	200000d0 	.word	0x200000d0
 80157d0:	20000500 	.word	0x20000500

080157d4 <strtok>:
 80157d4:	4b03      	ldr	r3, [pc, #12]	; (80157e4 <strtok+0x10>)
 80157d6:	b510      	push	{r4, lr}
 80157d8:	681a      	ldr	r2, [r3, #0]
 80157da:	2301      	movs	r3, #1
 80157dc:	325c      	adds	r2, #92	; 0x5c
 80157de:	f000 f803 	bl	80157e8 <__strtok_r>
 80157e2:	bd10      	pop	{r4, pc}
 80157e4:	200000d0 	.word	0x200000d0

080157e8 <__strtok_r>:
 80157e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80157ea:	2800      	cmp	r0, #0
 80157ec:	d104      	bne.n	80157f8 <__strtok_r+0x10>
 80157ee:	6810      	ldr	r0, [r2, #0]
 80157f0:	2800      	cmp	r0, #0
 80157f2:	d101      	bne.n	80157f8 <__strtok_r+0x10>
 80157f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80157f6:	0020      	movs	r0, r4
 80157f8:	000e      	movs	r6, r1
 80157fa:	7805      	ldrb	r5, [r0, #0]
 80157fc:	1c44      	adds	r4, r0, #1
 80157fe:	7837      	ldrb	r7, [r6, #0]
 8015800:	2f00      	cmp	r7, #0
 8015802:	d104      	bne.n	801580e <__strtok_r+0x26>
 8015804:	2d00      	cmp	r5, #0
 8015806:	d110      	bne.n	801582a <__strtok_r+0x42>
 8015808:	6015      	str	r5, [r2, #0]
 801580a:	0028      	movs	r0, r5
 801580c:	e7f2      	b.n	80157f4 <__strtok_r+0xc>
 801580e:	3601      	adds	r6, #1
 8015810:	42bd      	cmp	r5, r7
 8015812:	d1f4      	bne.n	80157fe <__strtok_r+0x16>
 8015814:	2b00      	cmp	r3, #0
 8015816:	d1ee      	bne.n	80157f6 <__strtok_r+0xe>
 8015818:	6014      	str	r4, [r2, #0]
 801581a:	7003      	strb	r3, [r0, #0]
 801581c:	e7ea      	b.n	80157f4 <__strtok_r+0xc>
 801581e:	0033      	movs	r3, r6
 8015820:	e00d      	b.n	801583e <__strtok_r+0x56>
 8015822:	3501      	adds	r5, #1
 8015824:	2f00      	cmp	r7, #0
 8015826:	d103      	bne.n	8015830 <__strtok_r+0x48>
 8015828:	001c      	movs	r4, r3
 801582a:	000d      	movs	r5, r1
 801582c:	7826      	ldrb	r6, [r4, #0]
 801582e:	1c63      	adds	r3, r4, #1
 8015830:	782f      	ldrb	r7, [r5, #0]
 8015832:	42be      	cmp	r6, r7
 8015834:	d1f5      	bne.n	8015822 <__strtok_r+0x3a>
 8015836:	2e00      	cmp	r6, #0
 8015838:	d0f1      	beq.n	801581e <__strtok_r+0x36>
 801583a:	2100      	movs	r1, #0
 801583c:	7021      	strb	r1, [r4, #0]
 801583e:	6013      	str	r3, [r2, #0]
 8015840:	e7d8      	b.n	80157f4 <__strtok_r+0xc>
	...

08015844 <_strtol_l.isra.0>:
 8015844:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015846:	001f      	movs	r7, r3
 8015848:	000e      	movs	r6, r1
 801584a:	b087      	sub	sp, #28
 801584c:	9005      	str	r0, [sp, #20]
 801584e:	9101      	str	r1, [sp, #4]
 8015850:	9202      	str	r2, [sp, #8]
 8015852:	980c      	ldr	r0, [sp, #48]	; 0x30
 8015854:	7834      	ldrb	r4, [r6, #0]
 8015856:	f7fe fcad 	bl	80141b4 <__locale_ctype_ptr_l>
 801585a:	2208      	movs	r2, #8
 801585c:	1900      	adds	r0, r0, r4
 801585e:	7843      	ldrb	r3, [r0, #1]
 8015860:	1c75      	adds	r5, r6, #1
 8015862:	4013      	ands	r3, r2
 8015864:	d136      	bne.n	80158d4 <_strtol_l.isra.0+0x90>
 8015866:	2c2d      	cmp	r4, #45	; 0x2d
 8015868:	d136      	bne.n	80158d8 <_strtol_l.isra.0+0x94>
 801586a:	1cb5      	adds	r5, r6, #2
 801586c:	7874      	ldrb	r4, [r6, #1]
 801586e:	2601      	movs	r6, #1
 8015870:	2f00      	cmp	r7, #0
 8015872:	d062      	beq.n	801593a <_strtol_l.isra.0+0xf6>
 8015874:	2f10      	cmp	r7, #16
 8015876:	d109      	bne.n	801588c <_strtol_l.isra.0+0x48>
 8015878:	2c30      	cmp	r4, #48	; 0x30
 801587a:	d107      	bne.n	801588c <_strtol_l.isra.0+0x48>
 801587c:	2220      	movs	r2, #32
 801587e:	782b      	ldrb	r3, [r5, #0]
 8015880:	4393      	bics	r3, r2
 8015882:	2b58      	cmp	r3, #88	; 0x58
 8015884:	d154      	bne.n	8015930 <_strtol_l.isra.0+0xec>
 8015886:	2710      	movs	r7, #16
 8015888:	786c      	ldrb	r4, [r5, #1]
 801588a:	3502      	adds	r5, #2
 801588c:	4b2d      	ldr	r3, [pc, #180]	; (8015944 <_strtol_l.isra.0+0x100>)
 801588e:	0039      	movs	r1, r7
 8015890:	18f3      	adds	r3, r6, r3
 8015892:	0018      	movs	r0, r3
 8015894:	9303      	str	r3, [sp, #12]
 8015896:	f7ea fcf5 	bl	8000284 <__aeabi_uidivmod>
 801589a:	9104      	str	r1, [sp, #16]
 801589c:	2101      	movs	r1, #1
 801589e:	2300      	movs	r3, #0
 80158a0:	4249      	negs	r1, r1
 80158a2:	0002      	movs	r2, r0
 80158a4:	468c      	mov	ip, r1
 80158a6:	0018      	movs	r0, r3
 80158a8:	0021      	movs	r1, r4
 80158aa:	3930      	subs	r1, #48	; 0x30
 80158ac:	2909      	cmp	r1, #9
 80158ae:	d81a      	bhi.n	80158e6 <_strtol_l.isra.0+0xa2>
 80158b0:	000c      	movs	r4, r1
 80158b2:	42a7      	cmp	r7, r4
 80158b4:	dd23      	ble.n	80158fe <_strtol_l.isra.0+0xba>
 80158b6:	1c59      	adds	r1, r3, #1
 80158b8:	d009      	beq.n	80158ce <_strtol_l.isra.0+0x8a>
 80158ba:	4663      	mov	r3, ip
 80158bc:	4282      	cmp	r2, r0
 80158be:	d306      	bcc.n	80158ce <_strtol_l.isra.0+0x8a>
 80158c0:	d102      	bne.n	80158c8 <_strtol_l.isra.0+0x84>
 80158c2:	9904      	ldr	r1, [sp, #16]
 80158c4:	42a1      	cmp	r1, r4
 80158c6:	db02      	blt.n	80158ce <_strtol_l.isra.0+0x8a>
 80158c8:	2301      	movs	r3, #1
 80158ca:	4378      	muls	r0, r7
 80158cc:	1820      	adds	r0, r4, r0
 80158ce:	782c      	ldrb	r4, [r5, #0]
 80158d0:	3501      	adds	r5, #1
 80158d2:	e7e9      	b.n	80158a8 <_strtol_l.isra.0+0x64>
 80158d4:	002e      	movs	r6, r5
 80158d6:	e7bc      	b.n	8015852 <_strtol_l.isra.0+0xe>
 80158d8:	2c2b      	cmp	r4, #43	; 0x2b
 80158da:	d001      	beq.n	80158e0 <_strtol_l.isra.0+0x9c>
 80158dc:	001e      	movs	r6, r3
 80158de:	e7c7      	b.n	8015870 <_strtol_l.isra.0+0x2c>
 80158e0:	1cb5      	adds	r5, r6, #2
 80158e2:	7874      	ldrb	r4, [r6, #1]
 80158e4:	e7fa      	b.n	80158dc <_strtol_l.isra.0+0x98>
 80158e6:	0021      	movs	r1, r4
 80158e8:	3941      	subs	r1, #65	; 0x41
 80158ea:	2919      	cmp	r1, #25
 80158ec:	d801      	bhi.n	80158f2 <_strtol_l.isra.0+0xae>
 80158ee:	3c37      	subs	r4, #55	; 0x37
 80158f0:	e7df      	b.n	80158b2 <_strtol_l.isra.0+0x6e>
 80158f2:	0021      	movs	r1, r4
 80158f4:	3961      	subs	r1, #97	; 0x61
 80158f6:	2919      	cmp	r1, #25
 80158f8:	d801      	bhi.n	80158fe <_strtol_l.isra.0+0xba>
 80158fa:	3c57      	subs	r4, #87	; 0x57
 80158fc:	e7d9      	b.n	80158b2 <_strtol_l.isra.0+0x6e>
 80158fe:	1c5a      	adds	r2, r3, #1
 8015900:	d108      	bne.n	8015914 <_strtol_l.isra.0+0xd0>
 8015902:	9a05      	ldr	r2, [sp, #20]
 8015904:	3323      	adds	r3, #35	; 0x23
 8015906:	6013      	str	r3, [r2, #0]
 8015908:	9b02      	ldr	r3, [sp, #8]
 801590a:	9803      	ldr	r0, [sp, #12]
 801590c:	2b00      	cmp	r3, #0
 801590e:	d109      	bne.n	8015924 <_strtol_l.isra.0+0xe0>
 8015910:	b007      	add	sp, #28
 8015912:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015914:	2e00      	cmp	r6, #0
 8015916:	d000      	beq.n	801591a <_strtol_l.isra.0+0xd6>
 8015918:	4240      	negs	r0, r0
 801591a:	9a02      	ldr	r2, [sp, #8]
 801591c:	2a00      	cmp	r2, #0
 801591e:	d0f7      	beq.n	8015910 <_strtol_l.isra.0+0xcc>
 8015920:	2b00      	cmp	r3, #0
 8015922:	d001      	beq.n	8015928 <_strtol_l.isra.0+0xe4>
 8015924:	1e6b      	subs	r3, r5, #1
 8015926:	9301      	str	r3, [sp, #4]
 8015928:	9b02      	ldr	r3, [sp, #8]
 801592a:	9a01      	ldr	r2, [sp, #4]
 801592c:	601a      	str	r2, [r3, #0]
 801592e:	e7ef      	b.n	8015910 <_strtol_l.isra.0+0xcc>
 8015930:	2430      	movs	r4, #48	; 0x30
 8015932:	2f00      	cmp	r7, #0
 8015934:	d1aa      	bne.n	801588c <_strtol_l.isra.0+0x48>
 8015936:	2708      	movs	r7, #8
 8015938:	e7a8      	b.n	801588c <_strtol_l.isra.0+0x48>
 801593a:	2c30      	cmp	r4, #48	; 0x30
 801593c:	d09e      	beq.n	801587c <_strtol_l.isra.0+0x38>
 801593e:	270a      	movs	r7, #10
 8015940:	e7a4      	b.n	801588c <_strtol_l.isra.0+0x48>
 8015942:	46c0      	nop			; (mov r8, r8)
 8015944:	7fffffff 	.word	0x7fffffff

08015948 <strtol>:
 8015948:	b537      	push	{r0, r1, r2, r4, r5, lr}
 801594a:	0013      	movs	r3, r2
 801594c:	4a06      	ldr	r2, [pc, #24]	; (8015968 <strtol+0x20>)
 801594e:	0005      	movs	r5, r0
 8015950:	6810      	ldr	r0, [r2, #0]
 8015952:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8015954:	2c00      	cmp	r4, #0
 8015956:	d100      	bne.n	801595a <strtol+0x12>
 8015958:	4c04      	ldr	r4, [pc, #16]	; (801596c <strtol+0x24>)
 801595a:	000a      	movs	r2, r1
 801595c:	9400      	str	r4, [sp, #0]
 801595e:	0029      	movs	r1, r5
 8015960:	f7ff ff70 	bl	8015844 <_strtol_l.isra.0>
 8015964:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8015966:	46c0      	nop			; (mov r8, r8)
 8015968:	200000d0 	.word	0x200000d0
 801596c:	20000500 	.word	0x20000500

08015970 <_strtoul_l.isra.0>:
 8015970:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015972:	001f      	movs	r7, r3
 8015974:	000e      	movs	r6, r1
 8015976:	b085      	sub	sp, #20
 8015978:	9003      	str	r0, [sp, #12]
 801597a:	9101      	str	r1, [sp, #4]
 801597c:	9202      	str	r2, [sp, #8]
 801597e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015980:	7834      	ldrb	r4, [r6, #0]
 8015982:	f7fe fc17 	bl	80141b4 <__locale_ctype_ptr_l>
 8015986:	2208      	movs	r2, #8
 8015988:	1900      	adds	r0, r0, r4
 801598a:	7843      	ldrb	r3, [r0, #1]
 801598c:	1c75      	adds	r5, r6, #1
 801598e:	4013      	ands	r3, r2
 8015990:	d138      	bne.n	8015a04 <_strtoul_l.isra.0+0x94>
 8015992:	2c2d      	cmp	r4, #45	; 0x2d
 8015994:	d138      	bne.n	8015a08 <_strtoul_l.isra.0+0x98>
 8015996:	7874      	ldrb	r4, [r6, #1]
 8015998:	1cb5      	adds	r5, r6, #2
 801599a:	3301      	adds	r3, #1
 801599c:	9300      	str	r3, [sp, #0]
 801599e:	2f00      	cmp	r7, #0
 80159a0:	d065      	beq.n	8015a6e <_strtoul_l.isra.0+0xfe>
 80159a2:	2f10      	cmp	r7, #16
 80159a4:	d109      	bne.n	80159ba <_strtoul_l.isra.0+0x4a>
 80159a6:	2c30      	cmp	r4, #48	; 0x30
 80159a8:	d107      	bne.n	80159ba <_strtoul_l.isra.0+0x4a>
 80159aa:	2220      	movs	r2, #32
 80159ac:	782b      	ldrb	r3, [r5, #0]
 80159ae:	4393      	bics	r3, r2
 80159b0:	2b58      	cmp	r3, #88	; 0x58
 80159b2:	d157      	bne.n	8015a64 <_strtoul_l.isra.0+0xf4>
 80159b4:	2710      	movs	r7, #16
 80159b6:	786c      	ldrb	r4, [r5, #1]
 80159b8:	3502      	adds	r5, #2
 80159ba:	2001      	movs	r0, #1
 80159bc:	0039      	movs	r1, r7
 80159be:	4240      	negs	r0, r0
 80159c0:	f7ea fbda 	bl	8000178 <__udivsi3>
 80159c4:	0006      	movs	r6, r0
 80159c6:	2001      	movs	r0, #1
 80159c8:	0039      	movs	r1, r7
 80159ca:	4240      	negs	r0, r0
 80159cc:	f7ea fc5a 	bl	8000284 <__aeabi_uidivmod>
 80159d0:	2300      	movs	r3, #0
 80159d2:	2201      	movs	r2, #1
 80159d4:	468c      	mov	ip, r1
 80159d6:	0018      	movs	r0, r3
 80159d8:	4252      	negs	r2, r2
 80159da:	0021      	movs	r1, r4
 80159dc:	3930      	subs	r1, #48	; 0x30
 80159de:	2909      	cmp	r1, #9
 80159e0:	d817      	bhi.n	8015a12 <_strtoul_l.isra.0+0xa2>
 80159e2:	000c      	movs	r4, r1
 80159e4:	42a7      	cmp	r7, r4
 80159e6:	dd22      	ble.n	8015a2e <_strtoul_l.isra.0+0xbe>
 80159e8:	2b00      	cmp	r3, #0
 80159ea:	db1e      	blt.n	8015a2a <_strtoul_l.isra.0+0xba>
 80159ec:	0013      	movs	r3, r2
 80159ee:	4286      	cmp	r6, r0
 80159f0:	d305      	bcc.n	80159fe <_strtoul_l.isra.0+0x8e>
 80159f2:	d101      	bne.n	80159f8 <_strtoul_l.isra.0+0x88>
 80159f4:	45a4      	cmp	ip, r4
 80159f6:	db02      	blt.n	80159fe <_strtoul_l.isra.0+0x8e>
 80159f8:	2301      	movs	r3, #1
 80159fa:	4378      	muls	r0, r7
 80159fc:	1820      	adds	r0, r4, r0
 80159fe:	782c      	ldrb	r4, [r5, #0]
 8015a00:	3501      	adds	r5, #1
 8015a02:	e7ea      	b.n	80159da <_strtoul_l.isra.0+0x6a>
 8015a04:	002e      	movs	r6, r5
 8015a06:	e7ba      	b.n	801597e <_strtoul_l.isra.0+0xe>
 8015a08:	2c2b      	cmp	r4, #43	; 0x2b
 8015a0a:	d1c7      	bne.n	801599c <_strtoul_l.isra.0+0x2c>
 8015a0c:	1cb5      	adds	r5, r6, #2
 8015a0e:	7874      	ldrb	r4, [r6, #1]
 8015a10:	e7c4      	b.n	801599c <_strtoul_l.isra.0+0x2c>
 8015a12:	0021      	movs	r1, r4
 8015a14:	3941      	subs	r1, #65	; 0x41
 8015a16:	2919      	cmp	r1, #25
 8015a18:	d801      	bhi.n	8015a1e <_strtoul_l.isra.0+0xae>
 8015a1a:	3c37      	subs	r4, #55	; 0x37
 8015a1c:	e7e2      	b.n	80159e4 <_strtoul_l.isra.0+0x74>
 8015a1e:	0021      	movs	r1, r4
 8015a20:	3961      	subs	r1, #97	; 0x61
 8015a22:	2919      	cmp	r1, #25
 8015a24:	d803      	bhi.n	8015a2e <_strtoul_l.isra.0+0xbe>
 8015a26:	3c57      	subs	r4, #87	; 0x57
 8015a28:	e7dc      	b.n	80159e4 <_strtoul_l.isra.0+0x74>
 8015a2a:	0013      	movs	r3, r2
 8015a2c:	e7e7      	b.n	80159fe <_strtoul_l.isra.0+0x8e>
 8015a2e:	2b00      	cmp	r3, #0
 8015a30:	da09      	bge.n	8015a46 <_strtoul_l.isra.0+0xd6>
 8015a32:	2322      	movs	r3, #34	; 0x22
 8015a34:	2001      	movs	r0, #1
 8015a36:	9a03      	ldr	r2, [sp, #12]
 8015a38:	4240      	negs	r0, r0
 8015a3a:	6013      	str	r3, [r2, #0]
 8015a3c:	9b02      	ldr	r3, [sp, #8]
 8015a3e:	2b00      	cmp	r3, #0
 8015a40:	d10a      	bne.n	8015a58 <_strtoul_l.isra.0+0xe8>
 8015a42:	b005      	add	sp, #20
 8015a44:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015a46:	9a00      	ldr	r2, [sp, #0]
 8015a48:	2a00      	cmp	r2, #0
 8015a4a:	d000      	beq.n	8015a4e <_strtoul_l.isra.0+0xde>
 8015a4c:	4240      	negs	r0, r0
 8015a4e:	9a02      	ldr	r2, [sp, #8]
 8015a50:	2a00      	cmp	r2, #0
 8015a52:	d0f6      	beq.n	8015a42 <_strtoul_l.isra.0+0xd2>
 8015a54:	2b00      	cmp	r3, #0
 8015a56:	d001      	beq.n	8015a5c <_strtoul_l.isra.0+0xec>
 8015a58:	1e6b      	subs	r3, r5, #1
 8015a5a:	9301      	str	r3, [sp, #4]
 8015a5c:	9b02      	ldr	r3, [sp, #8]
 8015a5e:	9a01      	ldr	r2, [sp, #4]
 8015a60:	601a      	str	r2, [r3, #0]
 8015a62:	e7ee      	b.n	8015a42 <_strtoul_l.isra.0+0xd2>
 8015a64:	2430      	movs	r4, #48	; 0x30
 8015a66:	2f00      	cmp	r7, #0
 8015a68:	d1a7      	bne.n	80159ba <_strtoul_l.isra.0+0x4a>
 8015a6a:	2708      	movs	r7, #8
 8015a6c:	e7a5      	b.n	80159ba <_strtoul_l.isra.0+0x4a>
 8015a6e:	2c30      	cmp	r4, #48	; 0x30
 8015a70:	d09b      	beq.n	80159aa <_strtoul_l.isra.0+0x3a>
 8015a72:	270a      	movs	r7, #10
 8015a74:	e7a1      	b.n	80159ba <_strtoul_l.isra.0+0x4a>
	...

08015a78 <strtoul>:
 8015a78:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8015a7a:	0013      	movs	r3, r2
 8015a7c:	4a06      	ldr	r2, [pc, #24]	; (8015a98 <strtoul+0x20>)
 8015a7e:	0005      	movs	r5, r0
 8015a80:	6810      	ldr	r0, [r2, #0]
 8015a82:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8015a84:	2c00      	cmp	r4, #0
 8015a86:	d100      	bne.n	8015a8a <strtoul+0x12>
 8015a88:	4c04      	ldr	r4, [pc, #16]	; (8015a9c <strtoul+0x24>)
 8015a8a:	000a      	movs	r2, r1
 8015a8c:	9400      	str	r4, [sp, #0]
 8015a8e:	0029      	movs	r1, r5
 8015a90:	f7ff ff6e 	bl	8015970 <_strtoul_l.isra.0>
 8015a94:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8015a96:	46c0      	nop			; (mov r8, r8)
 8015a98:	200000d0 	.word	0x200000d0
 8015a9c:	20000500 	.word	0x20000500

08015aa0 <_svfprintf_r>:
 8015aa0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015aa2:	b0d9      	sub	sp, #356	; 0x164
 8015aa4:	910b      	str	r1, [sp, #44]	; 0x2c
 8015aa6:	9209      	str	r2, [sp, #36]	; 0x24
 8015aa8:	001c      	movs	r4, r3
 8015aaa:	900a      	str	r0, [sp, #40]	; 0x28
 8015aac:	f002 fd26 	bl	80184fc <_localeconv_r>
 8015ab0:	6803      	ldr	r3, [r0, #0]
 8015ab2:	0018      	movs	r0, r3
 8015ab4:	931c      	str	r3, [sp, #112]	; 0x70
 8015ab6:	f7ea fb2f 	bl	8000118 <strlen>
 8015aba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015abc:	9014      	str	r0, [sp, #80]	; 0x50
 8015abe:	899b      	ldrh	r3, [r3, #12]
 8015ac0:	061b      	lsls	r3, r3, #24
 8015ac2:	d518      	bpl.n	8015af6 <_svfprintf_r+0x56>
 8015ac4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015ac6:	691b      	ldr	r3, [r3, #16]
 8015ac8:	9308      	str	r3, [sp, #32]
 8015aca:	2b00      	cmp	r3, #0
 8015acc:	d113      	bne.n	8015af6 <_svfprintf_r+0x56>
 8015ace:	2140      	movs	r1, #64	; 0x40
 8015ad0:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015ad2:	f7fe fb95 	bl	8014200 <_malloc_r>
 8015ad6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015ad8:	6018      	str	r0, [r3, #0]
 8015ada:	6118      	str	r0, [r3, #16]
 8015adc:	2800      	cmp	r0, #0
 8015ade:	d107      	bne.n	8015af0 <_svfprintf_r+0x50>
 8015ae0:	230c      	movs	r3, #12
 8015ae2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8015ae4:	6013      	str	r3, [r2, #0]
 8015ae6:	3b0d      	subs	r3, #13
 8015ae8:	9315      	str	r3, [sp, #84]	; 0x54
 8015aea:	9815      	ldr	r0, [sp, #84]	; 0x54
 8015aec:	b059      	add	sp, #356	; 0x164
 8015aee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015af0:	2340      	movs	r3, #64	; 0x40
 8015af2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8015af4:	6153      	str	r3, [r2, #20]
 8015af6:	2600      	movs	r6, #0
 8015af8:	af2f      	add	r7, sp, #188	; 0xbc
 8015afa:	972c      	str	r7, [sp, #176]	; 0xb0
 8015afc:	962e      	str	r6, [sp, #184]	; 0xb8
 8015afe:	962d      	str	r6, [sp, #180]	; 0xb4
 8015b00:	960d      	str	r6, [sp, #52]	; 0x34
 8015b02:	961a      	str	r6, [sp, #104]	; 0x68
 8015b04:	9619      	str	r6, [sp, #100]	; 0x64
 8015b06:	961e      	str	r6, [sp, #120]	; 0x78
 8015b08:	961d      	str	r6, [sp, #116]	; 0x74
 8015b0a:	9613      	str	r6, [sp, #76]	; 0x4c
 8015b0c:	961b      	str	r6, [sp, #108]	; 0x6c
 8015b0e:	961f      	str	r6, [sp, #124]	; 0x7c
 8015b10:	9615      	str	r6, [sp, #84]	; 0x54
 8015b12:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8015b14:	782b      	ldrb	r3, [r5, #0]
 8015b16:	2b00      	cmp	r3, #0
 8015b18:	d002      	beq.n	8015b20 <_svfprintf_r+0x80>
 8015b1a:	2b25      	cmp	r3, #37	; 0x25
 8015b1c:	d000      	beq.n	8015b20 <_svfprintf_r+0x80>
 8015b1e:	e095      	b.n	8015c4c <_svfprintf_r+0x1ac>
 8015b20:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8015b22:	1aee      	subs	r6, r5, r3
 8015b24:	d017      	beq.n	8015b56 <_svfprintf_r+0xb6>
 8015b26:	603b      	str	r3, [r7, #0]
 8015b28:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8015b2a:	607e      	str	r6, [r7, #4]
 8015b2c:	199b      	adds	r3, r3, r6
 8015b2e:	932e      	str	r3, [sp, #184]	; 0xb8
 8015b30:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8015b32:	3708      	adds	r7, #8
 8015b34:	9308      	str	r3, [sp, #32]
 8015b36:	3301      	adds	r3, #1
 8015b38:	932d      	str	r3, [sp, #180]	; 0xb4
 8015b3a:	2b07      	cmp	r3, #7
 8015b3c:	dd08      	ble.n	8015b50 <_svfprintf_r+0xb0>
 8015b3e:	aa2c      	add	r2, sp, #176	; 0xb0
 8015b40:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8015b42:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015b44:	f003 f900 	bl	8018d48 <__ssprint_r>
 8015b48:	2800      	cmp	r0, #0
 8015b4a:	d000      	beq.n	8015b4e <_svfprintf_r+0xae>
 8015b4c:	e2d9      	b.n	8016102 <_svfprintf_r+0x662>
 8015b4e:	af2f      	add	r7, sp, #188	; 0xbc
 8015b50:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8015b52:	199b      	adds	r3, r3, r6
 8015b54:	9315      	str	r3, [sp, #84]	; 0x54
 8015b56:	782b      	ldrb	r3, [r5, #0]
 8015b58:	2b00      	cmp	r3, #0
 8015b5a:	d101      	bne.n	8015b60 <_svfprintf_r+0xc0>
 8015b5c:	f001 f9e5 	bl	8016f2a <_svfprintf_r+0x148a>
 8015b60:	1c6b      	adds	r3, r5, #1
 8015b62:	221b      	movs	r2, #27
 8015b64:	9311      	str	r3, [sp, #68]	; 0x44
 8015b66:	2300      	movs	r3, #0
 8015b68:	a91e      	add	r1, sp, #120	; 0x78
 8015b6a:	1852      	adds	r2, r2, r1
 8015b6c:	7013      	strb	r3, [r2, #0]
 8015b6e:	2201      	movs	r2, #1
 8015b70:	001e      	movs	r6, r3
 8015b72:	2520      	movs	r5, #32
 8015b74:	4252      	negs	r2, r2
 8015b76:	9208      	str	r2, [sp, #32]
 8015b78:	9316      	str	r3, [sp, #88]	; 0x58
 8015b7a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015b7c:	781b      	ldrb	r3, [r3, #0]
 8015b7e:	930e      	str	r3, [sp, #56]	; 0x38
 8015b80:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015b82:	3301      	adds	r3, #1
 8015b84:	9311      	str	r3, [sp, #68]	; 0x44
 8015b86:	980e      	ldr	r0, [sp, #56]	; 0x38
 8015b88:	3820      	subs	r0, #32
 8015b8a:	285a      	cmp	r0, #90	; 0x5a
 8015b8c:	d901      	bls.n	8015b92 <_svfprintf_r+0xf2>
 8015b8e:	f000 fe3d 	bl	801680c <_svfprintf_r+0xd6c>
 8015b92:	f7ea fadd 	bl	8000150 <__gnu_thumb1_case_shi>
 8015b96:	009e      	.short	0x009e
 8015b98:	063b063b 	.word	0x063b063b
 8015b9c:	063b00a7 	.word	0x063b00a7
 8015ba0:	063b063b 	.word	0x063b063b
 8015ba4:	063b0080 	.word	0x063b0080
 8015ba8:	00a9063b 	.word	0x00a9063b
 8015bac:	063b00b3 	.word	0x063b00b3
 8015bb0:	00b900b1 	.word	0x00b900b1
 8015bb4:	00dd063b 	.word	0x00dd063b
 8015bb8:	00df00df 	.word	0x00df00df
 8015bbc:	00df00df 	.word	0x00df00df
 8015bc0:	00df00df 	.word	0x00df00df
 8015bc4:	00df00df 	.word	0x00df00df
 8015bc8:	063b00df 	.word	0x063b00df
 8015bcc:	063b063b 	.word	0x063b063b
 8015bd0:	063b063b 	.word	0x063b063b
 8015bd4:	063b063b 	.word	0x063b063b
 8015bd8:	063b0240 	.word	0x063b0240
 8015bdc:	01fd010a 	.word	0x01fd010a
 8015be0:	02400240 	.word	0x02400240
 8015be4:	063b0240 	.word	0x063b0240
 8015be8:	063b063b 	.word	0x063b063b
 8015bec:	00f1063b 	.word	0x00f1063b
 8015bf0:	063b063b 	.word	0x063b063b
 8015bf4:	063b04e2 	.word	0x063b04e2
 8015bf8:	063b063b 	.word	0x063b063b
 8015bfc:	063b0537 	.word	0x063b0537
 8015c00:	063b0557 	.word	0x063b0557
 8015c04:	005d063b 	.word	0x005d063b
 8015c08:	063b063b 	.word	0x063b063b
 8015c0c:	063b063b 	.word	0x063b063b
 8015c10:	063b063b 	.word	0x063b063b
 8015c14:	063b063b 	.word	0x063b063b
 8015c18:	063b0240 	.word	0x063b0240
 8015c1c:	01ff010a 	.word	0x01ff010a
 8015c20:	02400240 	.word	0x02400240
 8015c24:	00f30240 	.word	0x00f30240
 8015c28:	010601ff 	.word	0x010601ff
 8015c2c:	00ff063b 	.word	0x00ff063b
 8015c30:	04c5063b 	.word	0x04c5063b
 8015c34:	052704e4 	.word	0x052704e4
 8015c38:	063b0106 	.word	0x063b0106
 8015c3c:	fff20537 	.word	0xfff20537
 8015c40:	063b0559 	.word	0x063b0559
 8015c44:	0582063b 	.word	0x0582063b
 8015c48:	fff2063b 	.word	0xfff2063b
 8015c4c:	3501      	adds	r5, #1
 8015c4e:	e761      	b.n	8015b14 <_svfprintf_r+0x74>
 8015c50:	4bcb      	ldr	r3, [pc, #812]	; (8015f80 <_svfprintf_r+0x4e0>)
 8015c52:	2220      	movs	r2, #32
 8015c54:	931e      	str	r3, [sp, #120]	; 0x78
 8015c56:	4032      	ands	r2, r6
 8015c58:	d101      	bne.n	8015c5e <_svfprintf_r+0x1be>
 8015c5a:	f000 fd21 	bl	80166a0 <_svfprintf_r+0xc00>
 8015c5e:	2307      	movs	r3, #7
 8015c60:	3407      	adds	r4, #7
 8015c62:	439c      	bics	r4, r3
 8015c64:	0023      	movs	r3, r4
 8015c66:	3308      	adds	r3, #8
 8015c68:	9312      	str	r3, [sp, #72]	; 0x48
 8015c6a:	6823      	ldr	r3, [r4, #0]
 8015c6c:	6864      	ldr	r4, [r4, #4]
 8015c6e:	9306      	str	r3, [sp, #24]
 8015c70:	9407      	str	r4, [sp, #28]
 8015c72:	07f3      	lsls	r3, r6, #31
 8015c74:	d50a      	bpl.n	8015c8c <_svfprintf_r+0x1ec>
 8015c76:	9b06      	ldr	r3, [sp, #24]
 8015c78:	9a07      	ldr	r2, [sp, #28]
 8015c7a:	4313      	orrs	r3, r2
 8015c7c:	d006      	beq.n	8015c8c <_svfprintf_r+0x1ec>
 8015c7e:	2230      	movs	r2, #48	; 0x30
 8015c80:	ab25      	add	r3, sp, #148	; 0x94
 8015c82:	701a      	strb	r2, [r3, #0]
 8015c84:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8015c86:	705a      	strb	r2, [r3, #1]
 8015c88:	2302      	movs	r3, #2
 8015c8a:	431e      	orrs	r6, r3
 8015c8c:	4bbd      	ldr	r3, [pc, #756]	; (8015f84 <_svfprintf_r+0x4e4>)
 8015c8e:	401e      	ands	r6, r3
 8015c90:	2302      	movs	r3, #2
 8015c92:	f000 fc74 	bl	801657e <_svfprintf_r+0xade>
 8015c96:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015c98:	f002 fc30 	bl	80184fc <_localeconv_r>
 8015c9c:	6843      	ldr	r3, [r0, #4]
 8015c9e:	0018      	movs	r0, r3
 8015ca0:	931f      	str	r3, [sp, #124]	; 0x7c
 8015ca2:	f7ea fa39 	bl	8000118 <strlen>
 8015ca6:	901b      	str	r0, [sp, #108]	; 0x6c
 8015ca8:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015caa:	f002 fc27 	bl	80184fc <_localeconv_r>
 8015cae:	6883      	ldr	r3, [r0, #8]
 8015cb0:	9313      	str	r3, [sp, #76]	; 0x4c
 8015cb2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8015cb4:	2b00      	cmp	r3, #0
 8015cb6:	d100      	bne.n	8015cba <_svfprintf_r+0x21a>
 8015cb8:	e75f      	b.n	8015b7a <_svfprintf_r+0xda>
 8015cba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8015cbc:	2b00      	cmp	r3, #0
 8015cbe:	d100      	bne.n	8015cc2 <_svfprintf_r+0x222>
 8015cc0:	e75b      	b.n	8015b7a <_svfprintf_r+0xda>
 8015cc2:	781b      	ldrb	r3, [r3, #0]
 8015cc4:	2b00      	cmp	r3, #0
 8015cc6:	d100      	bne.n	8015cca <_svfprintf_r+0x22a>
 8015cc8:	e757      	b.n	8015b7a <_svfprintf_r+0xda>
 8015cca:	2380      	movs	r3, #128	; 0x80
 8015ccc:	00db      	lsls	r3, r3, #3
 8015cce:	431e      	orrs	r6, r3
 8015cd0:	e753      	b.n	8015b7a <_svfprintf_r+0xda>
 8015cd2:	231b      	movs	r3, #27
 8015cd4:	aa1e      	add	r2, sp, #120	; 0x78
 8015cd6:	189b      	adds	r3, r3, r2
 8015cd8:	781a      	ldrb	r2, [r3, #0]
 8015cda:	2a00      	cmp	r2, #0
 8015cdc:	d000      	beq.n	8015ce0 <_svfprintf_r+0x240>
 8015cde:	e74c      	b.n	8015b7a <_svfprintf_r+0xda>
 8015ce0:	701d      	strb	r5, [r3, #0]
 8015ce2:	e74a      	b.n	8015b7a <_svfprintf_r+0xda>
 8015ce4:	2301      	movs	r3, #1
 8015ce6:	e7f2      	b.n	8015cce <_svfprintf_r+0x22e>
 8015ce8:	6823      	ldr	r3, [r4, #0]
 8015cea:	3404      	adds	r4, #4
 8015cec:	9316      	str	r3, [sp, #88]	; 0x58
 8015cee:	2b00      	cmp	r3, #0
 8015cf0:	db00      	blt.n	8015cf4 <_svfprintf_r+0x254>
 8015cf2:	e742      	b.n	8015b7a <_svfprintf_r+0xda>
 8015cf4:	425b      	negs	r3, r3
 8015cf6:	9316      	str	r3, [sp, #88]	; 0x58
 8015cf8:	2304      	movs	r3, #4
 8015cfa:	e7e8      	b.n	8015cce <_svfprintf_r+0x22e>
 8015cfc:	231b      	movs	r3, #27
 8015cfe:	aa1e      	add	r2, sp, #120	; 0x78
 8015d00:	189b      	adds	r3, r3, r2
 8015d02:	222b      	movs	r2, #43	; 0x2b
 8015d04:	701a      	strb	r2, [r3, #0]
 8015d06:	e738      	b.n	8015b7a <_svfprintf_r+0xda>
 8015d08:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8015d0a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015d0c:	7812      	ldrb	r2, [r2, #0]
 8015d0e:	3301      	adds	r3, #1
 8015d10:	920e      	str	r2, [sp, #56]	; 0x38
 8015d12:	2a2a      	cmp	r2, #42	; 0x2a
 8015d14:	d008      	beq.n	8015d28 <_svfprintf_r+0x288>
 8015d16:	2200      	movs	r2, #0
 8015d18:	9208      	str	r2, [sp, #32]
 8015d1a:	990e      	ldr	r1, [sp, #56]	; 0x38
 8015d1c:	001a      	movs	r2, r3
 8015d1e:	3930      	subs	r1, #48	; 0x30
 8015d20:	2909      	cmp	r1, #9
 8015d22:	d90c      	bls.n	8015d3e <_svfprintf_r+0x29e>
 8015d24:	9211      	str	r2, [sp, #68]	; 0x44
 8015d26:	e72e      	b.n	8015b86 <_svfprintf_r+0xe6>
 8015d28:	6821      	ldr	r1, [r4, #0]
 8015d2a:	1d22      	adds	r2, r4, #4
 8015d2c:	9108      	str	r1, [sp, #32]
 8015d2e:	2900      	cmp	r1, #0
 8015d30:	da02      	bge.n	8015d38 <_svfprintf_r+0x298>
 8015d32:	2101      	movs	r1, #1
 8015d34:	4249      	negs	r1, r1
 8015d36:	9108      	str	r1, [sp, #32]
 8015d38:	0014      	movs	r4, r2
 8015d3a:	9311      	str	r3, [sp, #68]	; 0x44
 8015d3c:	e71d      	b.n	8015b7a <_svfprintf_r+0xda>
 8015d3e:	200a      	movs	r0, #10
 8015d40:	9a08      	ldr	r2, [sp, #32]
 8015d42:	4342      	muls	r2, r0
 8015d44:	1852      	adds	r2, r2, r1
 8015d46:	9208      	str	r2, [sp, #32]
 8015d48:	781a      	ldrb	r2, [r3, #0]
 8015d4a:	3301      	adds	r3, #1
 8015d4c:	920e      	str	r2, [sp, #56]	; 0x38
 8015d4e:	e7e4      	b.n	8015d1a <_svfprintf_r+0x27a>
 8015d50:	2380      	movs	r3, #128	; 0x80
 8015d52:	e7bc      	b.n	8015cce <_svfprintf_r+0x22e>
 8015d54:	2300      	movs	r3, #0
 8015d56:	9316      	str	r3, [sp, #88]	; 0x58
 8015d58:	220a      	movs	r2, #10
 8015d5a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8015d5c:	4353      	muls	r3, r2
 8015d5e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8015d60:	3a30      	subs	r2, #48	; 0x30
 8015d62:	18d3      	adds	r3, r2, r3
 8015d64:	9316      	str	r3, [sp, #88]	; 0x58
 8015d66:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015d68:	1c5a      	adds	r2, r3, #1
 8015d6a:	781b      	ldrb	r3, [r3, #0]
 8015d6c:	9211      	str	r2, [sp, #68]	; 0x44
 8015d6e:	930e      	str	r3, [sp, #56]	; 0x38
 8015d70:	3b30      	subs	r3, #48	; 0x30
 8015d72:	2b09      	cmp	r3, #9
 8015d74:	d9f0      	bls.n	8015d58 <_svfprintf_r+0x2b8>
 8015d76:	e7d5      	b.n	8015d24 <_svfprintf_r+0x284>
 8015d78:	2308      	movs	r3, #8
 8015d7a:	e7a8      	b.n	8015cce <_svfprintf_r+0x22e>
 8015d7c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015d7e:	781b      	ldrb	r3, [r3, #0]
 8015d80:	2b68      	cmp	r3, #104	; 0x68
 8015d82:	d105      	bne.n	8015d90 <_svfprintf_r+0x2f0>
 8015d84:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015d86:	3301      	adds	r3, #1
 8015d88:	9311      	str	r3, [sp, #68]	; 0x44
 8015d8a:	2380      	movs	r3, #128	; 0x80
 8015d8c:	009b      	lsls	r3, r3, #2
 8015d8e:	e79e      	b.n	8015cce <_svfprintf_r+0x22e>
 8015d90:	2340      	movs	r3, #64	; 0x40
 8015d92:	e79c      	b.n	8015cce <_svfprintf_r+0x22e>
 8015d94:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015d96:	781b      	ldrb	r3, [r3, #0]
 8015d98:	2b6c      	cmp	r3, #108	; 0x6c
 8015d9a:	d104      	bne.n	8015da6 <_svfprintf_r+0x306>
 8015d9c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8015d9e:	3301      	adds	r3, #1
 8015da0:	9311      	str	r3, [sp, #68]	; 0x44
 8015da2:	432e      	orrs	r6, r5
 8015da4:	e6e9      	b.n	8015b7a <_svfprintf_r+0xda>
 8015da6:	2310      	movs	r3, #16
 8015da8:	e791      	b.n	8015cce <_svfprintf_r+0x22e>
 8015daa:	1d23      	adds	r3, r4, #4
 8015dac:	6822      	ldr	r2, [r4, #0]
 8015dae:	9312      	str	r3, [sp, #72]	; 0x48
 8015db0:	ab3f      	add	r3, sp, #252	; 0xfc
 8015db2:	701a      	strb	r2, [r3, #0]
 8015db4:	221b      	movs	r2, #27
 8015db6:	2000      	movs	r0, #0
 8015db8:	a91e      	add	r1, sp, #120	; 0x78
 8015dba:	1852      	adds	r2, r2, r1
 8015dbc:	7010      	strb	r0, [r2, #0]
 8015dbe:	2201      	movs	r2, #1
 8015dc0:	0005      	movs	r5, r0
 8015dc2:	900c      	str	r0, [sp, #48]	; 0x30
 8015dc4:	9208      	str	r2, [sp, #32]
 8015dc6:	9017      	str	r0, [sp, #92]	; 0x5c
 8015dc8:	9010      	str	r0, [sp, #64]	; 0x40
 8015dca:	900f      	str	r0, [sp, #60]	; 0x3c
 8015dcc:	9309      	str	r3, [sp, #36]	; 0x24
 8015dce:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8015dd0:	9a08      	ldr	r2, [sp, #32]
 8015dd2:	9318      	str	r3, [sp, #96]	; 0x60
 8015dd4:	4293      	cmp	r3, r2
 8015dd6:	da00      	bge.n	8015dda <_svfprintf_r+0x33a>
 8015dd8:	9218      	str	r2, [sp, #96]	; 0x60
 8015dda:	231b      	movs	r3, #27
 8015ddc:	aa1e      	add	r2, sp, #120	; 0x78
 8015dde:	189b      	adds	r3, r3, r2
 8015de0:	781b      	ldrb	r3, [r3, #0]
 8015de2:	1e5a      	subs	r2, r3, #1
 8015de4:	4193      	sbcs	r3, r2
 8015de6:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8015de8:	18d3      	adds	r3, r2, r3
 8015dea:	9318      	str	r3, [sp, #96]	; 0x60
 8015dec:	2302      	movs	r3, #2
 8015dee:	4033      	ands	r3, r6
 8015df0:	9320      	str	r3, [sp, #128]	; 0x80
 8015df2:	d002      	beq.n	8015dfa <_svfprintf_r+0x35a>
 8015df4:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8015df6:	3302      	adds	r3, #2
 8015df8:	9318      	str	r3, [sp, #96]	; 0x60
 8015dfa:	2384      	movs	r3, #132	; 0x84
 8015dfc:	4033      	ands	r3, r6
 8015dfe:	9321      	str	r3, [sp, #132]	; 0x84
 8015e00:	d121      	bne.n	8015e46 <_svfprintf_r+0x3a6>
 8015e02:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8015e04:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8015e06:	1a9c      	subs	r4, r3, r2
 8015e08:	2c00      	cmp	r4, #0
 8015e0a:	dd1c      	ble.n	8015e46 <_svfprintf_r+0x3a6>
 8015e0c:	0039      	movs	r1, r7
 8015e0e:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8015e10:	485d      	ldr	r0, [pc, #372]	; (8015f88 <_svfprintf_r+0x4e8>)
 8015e12:	9322      	str	r3, [sp, #136]	; 0x88
 8015e14:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8015e16:	3301      	adds	r3, #1
 8015e18:	3108      	adds	r1, #8
 8015e1a:	6038      	str	r0, [r7, #0]
 8015e1c:	2c10      	cmp	r4, #16
 8015e1e:	dd01      	ble.n	8015e24 <_svfprintf_r+0x384>
 8015e20:	f000 fd08 	bl	8016834 <_svfprintf_r+0xd94>
 8015e24:	607c      	str	r4, [r7, #4]
 8015e26:	18a4      	adds	r4, r4, r2
 8015e28:	942e      	str	r4, [sp, #184]	; 0xb8
 8015e2a:	932d      	str	r3, [sp, #180]	; 0xb4
 8015e2c:	000f      	movs	r7, r1
 8015e2e:	2b07      	cmp	r3, #7
 8015e30:	dd09      	ble.n	8015e46 <_svfprintf_r+0x3a6>
 8015e32:	aa2c      	add	r2, sp, #176	; 0xb0
 8015e34:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8015e36:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015e38:	f002 ff86 	bl	8018d48 <__ssprint_r>
 8015e3c:	2800      	cmp	r0, #0
 8015e3e:	d001      	beq.n	8015e44 <_svfprintf_r+0x3a4>
 8015e40:	f001 f852 	bl	8016ee8 <_svfprintf_r+0x1448>
 8015e44:	af2f      	add	r7, sp, #188	; 0xbc
 8015e46:	231b      	movs	r3, #27
 8015e48:	aa1e      	add	r2, sp, #120	; 0x78
 8015e4a:	189b      	adds	r3, r3, r2
 8015e4c:	781a      	ldrb	r2, [r3, #0]
 8015e4e:	2a00      	cmp	r2, #0
 8015e50:	d017      	beq.n	8015e82 <_svfprintf_r+0x3e2>
 8015e52:	603b      	str	r3, [r7, #0]
 8015e54:	2301      	movs	r3, #1
 8015e56:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8015e58:	607b      	str	r3, [r7, #4]
 8015e5a:	0013      	movs	r3, r2
 8015e5c:	3301      	adds	r3, #1
 8015e5e:	932e      	str	r3, [sp, #184]	; 0xb8
 8015e60:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8015e62:	3708      	adds	r7, #8
 8015e64:	9322      	str	r3, [sp, #136]	; 0x88
 8015e66:	3301      	adds	r3, #1
 8015e68:	932d      	str	r3, [sp, #180]	; 0xb4
 8015e6a:	2b07      	cmp	r3, #7
 8015e6c:	dd09      	ble.n	8015e82 <_svfprintf_r+0x3e2>
 8015e6e:	aa2c      	add	r2, sp, #176	; 0xb0
 8015e70:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8015e72:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015e74:	f002 ff68 	bl	8018d48 <__ssprint_r>
 8015e78:	2800      	cmp	r0, #0
 8015e7a:	d001      	beq.n	8015e80 <_svfprintf_r+0x3e0>
 8015e7c:	f001 f834 	bl	8016ee8 <_svfprintf_r+0x1448>
 8015e80:	af2f      	add	r7, sp, #188	; 0xbc
 8015e82:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8015e84:	2b00      	cmp	r3, #0
 8015e86:	d019      	beq.n	8015ebc <_svfprintf_r+0x41c>
 8015e88:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8015e8a:	9320      	str	r3, [sp, #128]	; 0x80
 8015e8c:	ab25      	add	r3, sp, #148	; 0x94
 8015e8e:	603b      	str	r3, [r7, #0]
 8015e90:	2302      	movs	r3, #2
 8015e92:	607b      	str	r3, [r7, #4]
 8015e94:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8015e96:	3708      	adds	r7, #8
 8015e98:	3302      	adds	r3, #2
 8015e9a:	932e      	str	r3, [sp, #184]	; 0xb8
 8015e9c:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8015e9e:	9320      	str	r3, [sp, #128]	; 0x80
 8015ea0:	3301      	adds	r3, #1
 8015ea2:	932d      	str	r3, [sp, #180]	; 0xb4
 8015ea4:	2b07      	cmp	r3, #7
 8015ea6:	dd09      	ble.n	8015ebc <_svfprintf_r+0x41c>
 8015ea8:	aa2c      	add	r2, sp, #176	; 0xb0
 8015eaa:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8015eac:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015eae:	f002 ff4b 	bl	8018d48 <__ssprint_r>
 8015eb2:	2800      	cmp	r0, #0
 8015eb4:	d001      	beq.n	8015eba <_svfprintf_r+0x41a>
 8015eb6:	f001 f817 	bl	8016ee8 <_svfprintf_r+0x1448>
 8015eba:	af2f      	add	r7, sp, #188	; 0xbc
 8015ebc:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8015ebe:	2b80      	cmp	r3, #128	; 0x80
 8015ec0:	d121      	bne.n	8015f06 <_svfprintf_r+0x466>
 8015ec2:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8015ec4:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8015ec6:	1a9c      	subs	r4, r3, r2
 8015ec8:	2c00      	cmp	r4, #0
 8015eca:	dd1c      	ble.n	8015f06 <_svfprintf_r+0x466>
 8015ecc:	0039      	movs	r1, r7
 8015ece:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8015ed0:	482e      	ldr	r0, [pc, #184]	; (8015f8c <_svfprintf_r+0x4ec>)
 8015ed2:	9320      	str	r3, [sp, #128]	; 0x80
 8015ed4:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8015ed6:	3301      	adds	r3, #1
 8015ed8:	3108      	adds	r1, #8
 8015eda:	6038      	str	r0, [r7, #0]
 8015edc:	2c10      	cmp	r4, #16
 8015ede:	dd01      	ble.n	8015ee4 <_svfprintf_r+0x444>
 8015ee0:	f000 fcbc 	bl	801685c <_svfprintf_r+0xdbc>
 8015ee4:	607c      	str	r4, [r7, #4]
 8015ee6:	18a4      	adds	r4, r4, r2
 8015ee8:	942e      	str	r4, [sp, #184]	; 0xb8
 8015eea:	932d      	str	r3, [sp, #180]	; 0xb4
 8015eec:	000f      	movs	r7, r1
 8015eee:	2b07      	cmp	r3, #7
 8015ef0:	dd09      	ble.n	8015f06 <_svfprintf_r+0x466>
 8015ef2:	aa2c      	add	r2, sp, #176	; 0xb0
 8015ef4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8015ef6:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015ef8:	f002 ff26 	bl	8018d48 <__ssprint_r>
 8015efc:	2800      	cmp	r0, #0
 8015efe:	d001      	beq.n	8015f04 <_svfprintf_r+0x464>
 8015f00:	f000 fff2 	bl	8016ee8 <_svfprintf_r+0x1448>
 8015f04:	af2f      	add	r7, sp, #188	; 0xbc
 8015f06:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8015f08:	9a08      	ldr	r2, [sp, #32]
 8015f0a:	1a9c      	subs	r4, r3, r2
 8015f0c:	2c00      	cmp	r4, #0
 8015f0e:	dd1c      	ble.n	8015f4a <_svfprintf_r+0x4aa>
 8015f10:	0039      	movs	r1, r7
 8015f12:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8015f14:	481d      	ldr	r0, [pc, #116]	; (8015f8c <_svfprintf_r+0x4ec>)
 8015f16:	9317      	str	r3, [sp, #92]	; 0x5c
 8015f18:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8015f1a:	3301      	adds	r3, #1
 8015f1c:	3108      	adds	r1, #8
 8015f1e:	6038      	str	r0, [r7, #0]
 8015f20:	2c10      	cmp	r4, #16
 8015f22:	dd01      	ble.n	8015f28 <_svfprintf_r+0x488>
 8015f24:	f000 fcb4 	bl	8016890 <_svfprintf_r+0xdf0>
 8015f28:	18a2      	adds	r2, r4, r2
 8015f2a:	607c      	str	r4, [r7, #4]
 8015f2c:	922e      	str	r2, [sp, #184]	; 0xb8
 8015f2e:	932d      	str	r3, [sp, #180]	; 0xb4
 8015f30:	000f      	movs	r7, r1
 8015f32:	2b07      	cmp	r3, #7
 8015f34:	dd09      	ble.n	8015f4a <_svfprintf_r+0x4aa>
 8015f36:	aa2c      	add	r2, sp, #176	; 0xb0
 8015f38:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8015f3a:	980a      	ldr	r0, [sp, #40]	; 0x28
 8015f3c:	f002 ff04 	bl	8018d48 <__ssprint_r>
 8015f40:	2800      	cmp	r0, #0
 8015f42:	d001      	beq.n	8015f48 <_svfprintf_r+0x4a8>
 8015f44:	f000 ffd0 	bl	8016ee8 <_svfprintf_r+0x1448>
 8015f48:	af2f      	add	r7, sp, #188	; 0xbc
 8015f4a:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8015f4c:	9317      	str	r3, [sp, #92]	; 0x5c
 8015f4e:	05f3      	lsls	r3, r6, #23
 8015f50:	d501      	bpl.n	8015f56 <_svfprintf_r+0x4b6>
 8015f52:	f000 fcb1 	bl	80168b8 <_svfprintf_r+0xe18>
 8015f56:	9a08      	ldr	r2, [sp, #32]
 8015f58:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8015f5a:	4694      	mov	ip, r2
 8015f5c:	603b      	str	r3, [r7, #0]
 8015f5e:	9b08      	ldr	r3, [sp, #32]
 8015f60:	607b      	str	r3, [r7, #4]
 8015f62:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8015f64:	4463      	add	r3, ip
 8015f66:	932e      	str	r3, [sp, #184]	; 0xb8
 8015f68:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8015f6a:	9308      	str	r3, [sp, #32]
 8015f6c:	3301      	adds	r3, #1
 8015f6e:	932d      	str	r3, [sp, #180]	; 0xb4
 8015f70:	2b07      	cmp	r3, #7
 8015f72:	dd01      	ble.n	8015f78 <_svfprintf_r+0x4d8>
 8015f74:	f000 fd94 	bl	8016aa0 <_svfprintf_r+0x1000>
 8015f78:	3708      	adds	r7, #8
 8015f7a:	f000 fce4 	bl	8016946 <_svfprintf_r+0xea6>
 8015f7e:	46c0      	nop			; (mov r8, r8)
 8015f80:	0801c5f9 	.word	0x0801c5f9
 8015f84:	fffffbff 	.word	0xfffffbff
 8015f88:	0801c60a 	.word	0x0801c60a
 8015f8c:	0801c61a 	.word	0x0801c61a
 8015f90:	2310      	movs	r3, #16
 8015f92:	431e      	orrs	r6, r3
 8015f94:	06b3      	lsls	r3, r6, #26
 8015f96:	d52c      	bpl.n	8015ff2 <_svfprintf_r+0x552>
 8015f98:	2307      	movs	r3, #7
 8015f9a:	3407      	adds	r4, #7
 8015f9c:	439c      	bics	r4, r3
 8015f9e:	0023      	movs	r3, r4
 8015fa0:	3308      	adds	r3, #8
 8015fa2:	9312      	str	r3, [sp, #72]	; 0x48
 8015fa4:	6823      	ldr	r3, [r4, #0]
 8015fa6:	6864      	ldr	r4, [r4, #4]
 8015fa8:	9306      	str	r3, [sp, #24]
 8015faa:	9407      	str	r4, [sp, #28]
 8015fac:	9b07      	ldr	r3, [sp, #28]
 8015fae:	2b00      	cmp	r3, #0
 8015fb0:	da0b      	bge.n	8015fca <_svfprintf_r+0x52a>
 8015fb2:	9906      	ldr	r1, [sp, #24]
 8015fb4:	9a07      	ldr	r2, [sp, #28]
 8015fb6:	2400      	movs	r4, #0
 8015fb8:	424b      	negs	r3, r1
 8015fba:	4194      	sbcs	r4, r2
 8015fbc:	9306      	str	r3, [sp, #24]
 8015fbe:	9407      	str	r4, [sp, #28]
 8015fc0:	231b      	movs	r3, #27
 8015fc2:	aa1e      	add	r2, sp, #120	; 0x78
 8015fc4:	189b      	adds	r3, r3, r2
 8015fc6:	222d      	movs	r2, #45	; 0x2d
 8015fc8:	701a      	strb	r2, [r3, #0]
 8015fca:	9b08      	ldr	r3, [sp, #32]
 8015fcc:	3301      	adds	r3, #1
 8015fce:	d000      	beq.n	8015fd2 <_svfprintf_r+0x532>
 8015fd0:	e382      	b.n	80166d8 <_svfprintf_r+0xc38>
 8015fd2:	9b07      	ldr	r3, [sp, #28]
 8015fd4:	2b00      	cmp	r3, #0
 8015fd6:	d000      	beq.n	8015fda <_svfprintf_r+0x53a>
 8015fd8:	e3b0      	b.n	801673c <_svfprintf_r+0xc9c>
 8015fda:	9b06      	ldr	r3, [sp, #24]
 8015fdc:	2b09      	cmp	r3, #9
 8015fde:	d900      	bls.n	8015fe2 <_svfprintf_r+0x542>
 8015fe0:	e3ac      	b.n	801673c <_svfprintf_r+0xc9c>
 8015fe2:	23e7      	movs	r3, #231	; 0xe7
 8015fe4:	aa1e      	add	r2, sp, #120	; 0x78
 8015fe6:	189b      	adds	r3, r3, r2
 8015fe8:	9a06      	ldr	r2, [sp, #24]
 8015fea:	3230      	adds	r2, #48	; 0x30
 8015fec:	701a      	strb	r2, [r3, #0]
 8015fee:	9309      	str	r3, [sp, #36]	; 0x24
 8015ff0:	e395      	b.n	801671e <_svfprintf_r+0xc7e>
 8015ff2:	1d23      	adds	r3, r4, #4
 8015ff4:	9312      	str	r3, [sp, #72]	; 0x48
 8015ff6:	06f3      	lsls	r3, r6, #27
 8015ff8:	d504      	bpl.n	8016004 <_svfprintf_r+0x564>
 8015ffa:	6823      	ldr	r3, [r4, #0]
 8015ffc:	9306      	str	r3, [sp, #24]
 8015ffe:	17db      	asrs	r3, r3, #31
 8016000:	9307      	str	r3, [sp, #28]
 8016002:	e7d3      	b.n	8015fac <_svfprintf_r+0x50c>
 8016004:	6823      	ldr	r3, [r4, #0]
 8016006:	0672      	lsls	r2, r6, #25
 8016008:	d501      	bpl.n	801600e <_svfprintf_r+0x56e>
 801600a:	b21b      	sxth	r3, r3
 801600c:	e7f6      	b.n	8015ffc <_svfprintf_r+0x55c>
 801600e:	05b2      	lsls	r2, r6, #22
 8016010:	d5f4      	bpl.n	8015ffc <_svfprintf_r+0x55c>
 8016012:	b25b      	sxtb	r3, r3
 8016014:	e7f2      	b.n	8015ffc <_svfprintf_r+0x55c>
 8016016:	2307      	movs	r3, #7
 8016018:	3407      	adds	r4, #7
 801601a:	439c      	bics	r4, r3
 801601c:	0023      	movs	r3, r4
 801601e:	2201      	movs	r2, #1
 8016020:	3308      	adds	r3, #8
 8016022:	9312      	str	r3, [sp, #72]	; 0x48
 8016024:	6823      	ldr	r3, [r4, #0]
 8016026:	4252      	negs	r2, r2
 8016028:	931a      	str	r3, [sp, #104]	; 0x68
 801602a:	6863      	ldr	r3, [r4, #4]
 801602c:	9d1a      	ldr	r5, [sp, #104]	; 0x68
 801602e:	005c      	lsls	r4, r3, #1
 8016030:	0864      	lsrs	r4, r4, #1
 8016032:	9319      	str	r3, [sp, #100]	; 0x64
 8016034:	0028      	movs	r0, r5
 8016036:	4bcf      	ldr	r3, [pc, #828]	; (8016374 <_svfprintf_r+0x8d4>)
 8016038:	0021      	movs	r1, r4
 801603a:	f7ec fc75 	bl	8002928 <__aeabi_dcmpun>
 801603e:	2800      	cmp	r0, #0
 8016040:	d125      	bne.n	801608e <_svfprintf_r+0x5ee>
 8016042:	2201      	movs	r2, #1
 8016044:	4bcb      	ldr	r3, [pc, #812]	; (8016374 <_svfprintf_r+0x8d4>)
 8016046:	4252      	negs	r2, r2
 8016048:	0028      	movs	r0, r5
 801604a:	0021      	movs	r1, r4
 801604c:	f7ea fa36 	bl	80004bc <__aeabi_dcmple>
 8016050:	2800      	cmp	r0, #0
 8016052:	d11c      	bne.n	801608e <_svfprintf_r+0x5ee>
 8016054:	2200      	movs	r2, #0
 8016056:	2300      	movs	r3, #0
 8016058:	981a      	ldr	r0, [sp, #104]	; 0x68
 801605a:	9919      	ldr	r1, [sp, #100]	; 0x64
 801605c:	f7ea fa24 	bl	80004a8 <__aeabi_dcmplt>
 8016060:	2800      	cmp	r0, #0
 8016062:	d004      	beq.n	801606e <_svfprintf_r+0x5ce>
 8016064:	231b      	movs	r3, #27
 8016066:	aa1e      	add	r2, sp, #120	; 0x78
 8016068:	189b      	adds	r3, r3, r2
 801606a:	222d      	movs	r2, #45	; 0x2d
 801606c:	701a      	strb	r2, [r3, #0]
 801606e:	4bc2      	ldr	r3, [pc, #776]	; (8016378 <_svfprintf_r+0x8d8>)
 8016070:	9309      	str	r3, [sp, #36]	; 0x24
 8016072:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8016074:	2b47      	cmp	r3, #71	; 0x47
 8016076:	dc01      	bgt.n	801607c <_svfprintf_r+0x5dc>
 8016078:	4bc0      	ldr	r3, [pc, #768]	; (801637c <_svfprintf_r+0x8dc>)
 801607a:	9309      	str	r3, [sp, #36]	; 0x24
 801607c:	2380      	movs	r3, #128	; 0x80
 801607e:	439e      	bics	r6, r3
 8016080:	2300      	movs	r3, #0
 8016082:	930c      	str	r3, [sp, #48]	; 0x30
 8016084:	3303      	adds	r3, #3
 8016086:	9308      	str	r3, [sp, #32]
 8016088:	2300      	movs	r3, #0
 801608a:	9317      	str	r3, [sp, #92]	; 0x5c
 801608c:	e34f      	b.n	801672e <_svfprintf_r+0xc8e>
 801608e:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8016090:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8016092:	981a      	ldr	r0, [sp, #104]	; 0x68
 8016094:	9919      	ldr	r1, [sp, #100]	; 0x64
 8016096:	f7ec fc47 	bl	8002928 <__aeabi_dcmpun>
 801609a:	2800      	cmp	r0, #0
 801609c:	d00e      	beq.n	80160bc <_svfprintf_r+0x61c>
 801609e:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80160a0:	2b00      	cmp	r3, #0
 80160a2:	da04      	bge.n	80160ae <_svfprintf_r+0x60e>
 80160a4:	231b      	movs	r3, #27
 80160a6:	aa1e      	add	r2, sp, #120	; 0x78
 80160a8:	189b      	adds	r3, r3, r2
 80160aa:	222d      	movs	r2, #45	; 0x2d
 80160ac:	701a      	strb	r2, [r3, #0]
 80160ae:	4bb4      	ldr	r3, [pc, #720]	; (8016380 <_svfprintf_r+0x8e0>)
 80160b0:	9309      	str	r3, [sp, #36]	; 0x24
 80160b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80160b4:	2b47      	cmp	r3, #71	; 0x47
 80160b6:	dce1      	bgt.n	801607c <_svfprintf_r+0x5dc>
 80160b8:	4bb2      	ldr	r3, [pc, #712]	; (8016384 <_svfprintf_r+0x8e4>)
 80160ba:	e7de      	b.n	801607a <_svfprintf_r+0x5da>
 80160bc:	2320      	movs	r3, #32
 80160be:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80160c0:	439a      	bics	r2, r3
 80160c2:	920f      	str	r2, [sp, #60]	; 0x3c
 80160c4:	2a41      	cmp	r2, #65	; 0x41
 80160c6:	d124      	bne.n	8016112 <_svfprintf_r+0x672>
 80160c8:	2230      	movs	r2, #48	; 0x30
 80160ca:	990e      	ldr	r1, [sp, #56]	; 0x38
 80160cc:	ab25      	add	r3, sp, #148	; 0x94
 80160ce:	701a      	strb	r2, [r3, #0]
 80160d0:	3228      	adds	r2, #40	; 0x28
 80160d2:	2961      	cmp	r1, #97	; 0x61
 80160d4:	d100      	bne.n	80160d8 <_svfprintf_r+0x638>
 80160d6:	3220      	adds	r2, #32
 80160d8:	705a      	strb	r2, [r3, #1]
 80160da:	2302      	movs	r3, #2
 80160dc:	431e      	orrs	r6, r3
 80160de:	9b08      	ldr	r3, [sp, #32]
 80160e0:	2b63      	cmp	r3, #99	; 0x63
 80160e2:	dc00      	bgt.n	80160e6 <_svfprintf_r+0x646>
 80160e4:	e09e      	b.n	8016224 <_svfprintf_r+0x784>
 80160e6:	1c59      	adds	r1, r3, #1
 80160e8:	980a      	ldr	r0, [sp, #40]	; 0x28
 80160ea:	f7fe f889 	bl	8014200 <_malloc_r>
 80160ee:	9009      	str	r0, [sp, #36]	; 0x24
 80160f0:	2800      	cmp	r0, #0
 80160f2:	d000      	beq.n	80160f6 <_svfprintf_r+0x656>
 80160f4:	e09b      	b.n	801622e <_svfprintf_r+0x78e>
 80160f6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80160f8:	899a      	ldrh	r2, [r3, #12]
 80160fa:	2340      	movs	r3, #64	; 0x40
 80160fc:	4313      	orrs	r3, r2
 80160fe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8016100:	8193      	strh	r3, [r2, #12]
 8016102:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8016104:	899b      	ldrh	r3, [r3, #12]
 8016106:	065b      	lsls	r3, r3, #25
 8016108:	d400      	bmi.n	801610c <_svfprintf_r+0x66c>
 801610a:	e4ee      	b.n	8015aea <_svfprintf_r+0x4a>
 801610c:	2301      	movs	r3, #1
 801610e:	425b      	negs	r3, r3
 8016110:	e4ea      	b.n	8015ae8 <_svfprintf_r+0x48>
 8016112:	9b08      	ldr	r3, [sp, #32]
 8016114:	900c      	str	r0, [sp, #48]	; 0x30
 8016116:	3301      	adds	r3, #1
 8016118:	d100      	bne.n	801611c <_svfprintf_r+0x67c>
 801611a:	e08b      	b.n	8016234 <_svfprintf_r+0x794>
 801611c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801611e:	2b47      	cmp	r3, #71	; 0x47
 8016120:	d103      	bne.n	801612a <_svfprintf_r+0x68a>
 8016122:	9b08      	ldr	r3, [sp, #32]
 8016124:	2b00      	cmp	r3, #0
 8016126:	d100      	bne.n	801612a <_svfprintf_r+0x68a>
 8016128:	e087      	b.n	801623a <_svfprintf_r+0x79a>
 801612a:	2380      	movs	r3, #128	; 0x80
 801612c:	005b      	lsls	r3, r3, #1
 801612e:	4333      	orrs	r3, r6
 8016130:	9320      	str	r3, [sp, #128]	; 0x80
 8016132:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8016134:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 8016136:	2b00      	cmp	r3, #0
 8016138:	db00      	blt.n	801613c <_svfprintf_r+0x69c>
 801613a:	e082      	b.n	8016242 <_svfprintf_r+0x7a2>
 801613c:	2280      	movs	r2, #128	; 0x80
 801613e:	0612      	lsls	r2, r2, #24
 8016140:	4694      	mov	ip, r2
 8016142:	4463      	add	r3, ip
 8016144:	930d      	str	r3, [sp, #52]	; 0x34
 8016146:	232d      	movs	r3, #45	; 0x2d
 8016148:	9322      	str	r3, [sp, #136]	; 0x88
 801614a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801614c:	2b41      	cmp	r3, #65	; 0x41
 801614e:	d000      	beq.n	8016152 <_svfprintf_r+0x6b2>
 8016150:	e105      	b.n	801635e <_svfprintf_r+0x8be>
 8016152:	aa26      	add	r2, sp, #152	; 0x98
 8016154:	0020      	movs	r0, r4
 8016156:	990d      	ldr	r1, [sp, #52]	; 0x34
 8016158:	f002 fdc4 	bl	8018ce4 <frexp>
 801615c:	23ff      	movs	r3, #255	; 0xff
 801615e:	2200      	movs	r2, #0
 8016160:	059b      	lsls	r3, r3, #22
 8016162:	f7eb fe27 	bl	8001db4 <__aeabi_dmul>
 8016166:	2200      	movs	r2, #0
 8016168:	2300      	movs	r3, #0
 801616a:	0004      	movs	r4, r0
 801616c:	000d      	movs	r5, r1
 801616e:	f7ea f995 	bl	800049c <__aeabi_dcmpeq>
 8016172:	2800      	cmp	r0, #0
 8016174:	d001      	beq.n	801617a <_svfprintf_r+0x6da>
 8016176:	2301      	movs	r3, #1
 8016178:	9326      	str	r3, [sp, #152]	; 0x98
 801617a:	4b83      	ldr	r3, [pc, #524]	; (8016388 <_svfprintf_r+0x8e8>)
 801617c:	9317      	str	r3, [sp, #92]	; 0x5c
 801617e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8016180:	2b61      	cmp	r3, #97	; 0x61
 8016182:	d101      	bne.n	8016188 <_svfprintf_r+0x6e8>
 8016184:	4b81      	ldr	r3, [pc, #516]	; (801638c <_svfprintf_r+0x8ec>)
 8016186:	9317      	str	r3, [sp, #92]	; 0x5c
 8016188:	9b08      	ldr	r3, [sp, #32]
 801618a:	3b01      	subs	r3, #1
 801618c:	9310      	str	r3, [sp, #64]	; 0x40
 801618e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016190:	9318      	str	r3, [sp, #96]	; 0x60
 8016192:	2200      	movs	r2, #0
 8016194:	4b7e      	ldr	r3, [pc, #504]	; (8016390 <_svfprintf_r+0x8f0>)
 8016196:	0020      	movs	r0, r4
 8016198:	0029      	movs	r1, r5
 801619a:	f7eb fe0b 	bl	8001db4 <__aeabi_dmul>
 801619e:	000d      	movs	r5, r1
 80161a0:	0004      	movs	r4, r0
 80161a2:	f7ec fbdd 	bl	8002960 <__aeabi_d2iz>
 80161a6:	9021      	str	r0, [sp, #132]	; 0x84
 80161a8:	f7ec fc10 	bl	80029cc <__aeabi_i2d>
 80161ac:	0002      	movs	r2, r0
 80161ae:	000b      	movs	r3, r1
 80161b0:	0020      	movs	r0, r4
 80161b2:	0029      	movs	r1, r5
 80161b4:	f7ec f870 	bl	8002298 <__aeabi_dsub>
 80161b8:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80161ba:	9a21      	ldr	r2, [sp, #132]	; 0x84
 80161bc:	3301      	adds	r3, #1
 80161be:	930d      	str	r3, [sp, #52]	; 0x34
 80161c0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80161c2:	0004      	movs	r4, r0
 80161c4:	5c9b      	ldrb	r3, [r3, r2]
 80161c6:	9a18      	ldr	r2, [sp, #96]	; 0x60
 80161c8:	000d      	movs	r5, r1
 80161ca:	7013      	strb	r3, [r2, #0]
 80161cc:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80161ce:	9323      	str	r3, [sp, #140]	; 0x8c
 80161d0:	3301      	adds	r3, #1
 80161d2:	d00a      	beq.n	80161ea <_svfprintf_r+0x74a>
 80161d4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80161d6:	2200      	movs	r2, #0
 80161d8:	3b01      	subs	r3, #1
 80161da:	9310      	str	r3, [sp, #64]	; 0x40
 80161dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80161de:	9318      	str	r3, [sp, #96]	; 0x60
 80161e0:	2300      	movs	r3, #0
 80161e2:	f7ea f95b 	bl	800049c <__aeabi_dcmpeq>
 80161e6:	2800      	cmp	r0, #0
 80161e8:	d0d3      	beq.n	8016192 <_svfprintf_r+0x6f2>
 80161ea:	2200      	movs	r2, #0
 80161ec:	4b69      	ldr	r3, [pc, #420]	; (8016394 <_svfprintf_r+0x8f4>)
 80161ee:	0020      	movs	r0, r4
 80161f0:	0029      	movs	r1, r5
 80161f2:	f7ea f96d 	bl	80004d0 <__aeabi_dcmpgt>
 80161f6:	2800      	cmp	r0, #0
 80161f8:	d126      	bne.n	8016248 <_svfprintf_r+0x7a8>
 80161fa:	2200      	movs	r2, #0
 80161fc:	4b65      	ldr	r3, [pc, #404]	; (8016394 <_svfprintf_r+0x8f4>)
 80161fe:	0020      	movs	r0, r4
 8016200:	0029      	movs	r1, r5
 8016202:	f7ea f94b 	bl	800049c <__aeabi_dcmpeq>
 8016206:	2800      	cmp	r0, #0
 8016208:	d002      	beq.n	8016210 <_svfprintf_r+0x770>
 801620a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801620c:	07db      	lsls	r3, r3, #31
 801620e:	d41b      	bmi.n	8016248 <_svfprintf_r+0x7a8>
 8016210:	2130      	movs	r1, #48	; 0x30
 8016212:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016214:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8016216:	1898      	adds	r0, r3, r2
 8016218:	930d      	str	r3, [sp, #52]	; 0x34
 801621a:	1ac2      	subs	r2, r0, r3
 801621c:	d426      	bmi.n	801626c <_svfprintf_r+0x7cc>
 801621e:	7019      	strb	r1, [r3, #0]
 8016220:	3301      	adds	r3, #1
 8016222:	e7f9      	b.n	8016218 <_svfprintf_r+0x778>
 8016224:	2300      	movs	r3, #0
 8016226:	930c      	str	r3, [sp, #48]	; 0x30
 8016228:	ab3f      	add	r3, sp, #252	; 0xfc
 801622a:	9309      	str	r3, [sp, #36]	; 0x24
 801622c:	e77d      	b.n	801612a <_svfprintf_r+0x68a>
 801622e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016230:	930c      	str	r3, [sp, #48]	; 0x30
 8016232:	e77a      	b.n	801612a <_svfprintf_r+0x68a>
 8016234:	2306      	movs	r3, #6
 8016236:	9308      	str	r3, [sp, #32]
 8016238:	e777      	b.n	801612a <_svfprintf_r+0x68a>
 801623a:	9b08      	ldr	r3, [sp, #32]
 801623c:	930c      	str	r3, [sp, #48]	; 0x30
 801623e:	2301      	movs	r3, #1
 8016240:	e7f9      	b.n	8016236 <_svfprintf_r+0x796>
 8016242:	930d      	str	r3, [sp, #52]	; 0x34
 8016244:	2300      	movs	r3, #0
 8016246:	e77f      	b.n	8016148 <_svfprintf_r+0x6a8>
 8016248:	2030      	movs	r0, #48	; 0x30
 801624a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801624c:	932a      	str	r3, [sp, #168]	; 0xa8
 801624e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8016250:	7bda      	ldrb	r2, [r3, #15]
 8016252:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8016254:	3b01      	subs	r3, #1
 8016256:	932a      	str	r3, [sp, #168]	; 0xa8
 8016258:	7819      	ldrb	r1, [r3, #0]
 801625a:	4291      	cmp	r1, r2
 801625c:	d07d      	beq.n	801635a <_svfprintf_r+0x8ba>
 801625e:	1c4a      	adds	r2, r1, #1
 8016260:	b2d2      	uxtb	r2, r2
 8016262:	2939      	cmp	r1, #57	; 0x39
 8016264:	d101      	bne.n	801626a <_svfprintf_r+0x7ca>
 8016266:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8016268:	7a92      	ldrb	r2, [r2, #10]
 801626a:	701a      	strb	r2, [r3, #0]
 801626c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801626e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8016270:	9d26      	ldr	r5, [sp, #152]	; 0x98
 8016272:	1a9b      	subs	r3, r3, r2
 8016274:	930d      	str	r3, [sp, #52]	; 0x34
 8016276:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8016278:	2b47      	cmp	r3, #71	; 0x47
 801627a:	d000      	beq.n	801627e <_svfprintf_r+0x7de>
 801627c:	e0d2      	b.n	8016424 <_svfprintf_r+0x984>
 801627e:	1ceb      	adds	r3, r5, #3
 8016280:	db03      	blt.n	801628a <_svfprintf_r+0x7ea>
 8016282:	9b08      	ldr	r3, [sp, #32]
 8016284:	42ab      	cmp	r3, r5
 8016286:	db00      	blt.n	801628a <_svfprintf_r+0x7ea>
 8016288:	e0fd      	b.n	8016486 <_svfprintf_r+0x9e6>
 801628a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801628c:	3b02      	subs	r3, #2
 801628e:	930e      	str	r3, [sp, #56]	; 0x38
 8016290:	2238      	movs	r2, #56	; 0x38
 8016292:	466b      	mov	r3, sp
 8016294:	990e      	ldr	r1, [sp, #56]	; 0x38
 8016296:	189b      	adds	r3, r3, r2
 8016298:	3a18      	subs	r2, #24
 801629a:	4391      	bics	r1, r2
 801629c:	1e6c      	subs	r4, r5, #1
 801629e:	000a      	movs	r2, r1
 80162a0:	9426      	str	r4, [sp, #152]	; 0x98
 80162a2:	781b      	ldrb	r3, [r3, #0]
 80162a4:	2100      	movs	r1, #0
 80162a6:	2a41      	cmp	r2, #65	; 0x41
 80162a8:	d102      	bne.n	80162b0 <_svfprintf_r+0x810>
 80162aa:	330f      	adds	r3, #15
 80162ac:	b2db      	uxtb	r3, r3
 80162ae:	3101      	adds	r1, #1
 80162b0:	aa28      	add	r2, sp, #160	; 0xa0
 80162b2:	7013      	strb	r3, [r2, #0]
 80162b4:	232b      	movs	r3, #43	; 0x2b
 80162b6:	2c00      	cmp	r4, #0
 80162b8:	da02      	bge.n	80162c0 <_svfprintf_r+0x820>
 80162ba:	2401      	movs	r4, #1
 80162bc:	232d      	movs	r3, #45	; 0x2d
 80162be:	1b64      	subs	r4, r4, r5
 80162c0:	7053      	strb	r3, [r2, #1]
 80162c2:	2c09      	cmp	r4, #9
 80162c4:	dc00      	bgt.n	80162c8 <_svfprintf_r+0x828>
 80162c6:	e0c7      	b.n	8016458 <_svfprintf_r+0x9b8>
 80162c8:	2537      	movs	r5, #55	; 0x37
 80162ca:	ab1e      	add	r3, sp, #120	; 0x78
 80162cc:	18ed      	adds	r5, r5, r3
 80162ce:	1e6b      	subs	r3, r5, #1
 80162d0:	0020      	movs	r0, r4
 80162d2:	210a      	movs	r1, #10
 80162d4:	9308      	str	r3, [sp, #32]
 80162d6:	f7ea f8bf 	bl	8000458 <__aeabi_idivmod>
 80162da:	1e6b      	subs	r3, r5, #1
 80162dc:	3130      	adds	r1, #48	; 0x30
 80162de:	7019      	strb	r1, [r3, #0]
 80162e0:	0020      	movs	r0, r4
 80162e2:	210a      	movs	r1, #10
 80162e4:	f7e9 ffd2 	bl	800028c <__divsi3>
 80162e8:	0004      	movs	r4, r0
 80162ea:	2809      	cmp	r0, #9
 80162ec:	dd00      	ble.n	80162f0 <_svfprintf_r+0x850>
 80162ee:	e0ac      	b.n	801644a <_svfprintf_r+0x9aa>
 80162f0:	232a      	movs	r3, #42	; 0x2a
 80162f2:	2137      	movs	r1, #55	; 0x37
 80162f4:	aa1e      	add	r2, sp, #120	; 0x78
 80162f6:	3d02      	subs	r5, #2
 80162f8:	3430      	adds	r4, #48	; 0x30
 80162fa:	702c      	strb	r4, [r5, #0]
 80162fc:	189b      	adds	r3, r3, r2
 80162fe:	1889      	adds	r1, r1, r2
 8016300:	001a      	movs	r2, r3
 8016302:	428d      	cmp	r5, r1
 8016304:	d200      	bcs.n	8016308 <_svfprintf_r+0x868>
 8016306:	e0a2      	b.n	801644e <_svfprintf_r+0x9ae>
 8016308:	ab28      	add	r3, sp, #160	; 0xa0
 801630a:	1ad3      	subs	r3, r2, r3
 801630c:	931d      	str	r3, [sp, #116]	; 0x74
 801630e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8016310:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016312:	4694      	mov	ip, r2
 8016314:	4463      	add	r3, ip
 8016316:	9308      	str	r3, [sp, #32]
 8016318:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801631a:	2b01      	cmp	r3, #1
 801631c:	dc01      	bgt.n	8016322 <_svfprintf_r+0x882>
 801631e:	07f3      	lsls	r3, r6, #31
 8016320:	d504      	bpl.n	801632c <_svfprintf_r+0x88c>
 8016322:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8016324:	9b08      	ldr	r3, [sp, #32]
 8016326:	4694      	mov	ip, r2
 8016328:	4463      	add	r3, ip
 801632a:	9308      	str	r3, [sp, #32]
 801632c:	2280      	movs	r2, #128	; 0x80
 801632e:	4b1a      	ldr	r3, [pc, #104]	; (8016398 <_svfprintf_r+0x8f8>)
 8016330:	0052      	lsls	r2, r2, #1
 8016332:	4033      	ands	r3, r6
 8016334:	431a      	orrs	r2, r3
 8016336:	2300      	movs	r3, #0
 8016338:	001d      	movs	r5, r3
 801633a:	9220      	str	r2, [sp, #128]	; 0x80
 801633c:	9310      	str	r3, [sp, #64]	; 0x40
 801633e:	930f      	str	r3, [sp, #60]	; 0x3c
 8016340:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8016342:	2b00      	cmp	r3, #0
 8016344:	d100      	bne.n	8016348 <_svfprintf_r+0x8a8>
 8016346:	e270      	b.n	801682a <_svfprintf_r+0xd8a>
 8016348:	231b      	movs	r3, #27
 801634a:	aa1e      	add	r2, sp, #120	; 0x78
 801634c:	189b      	adds	r3, r3, r2
 801634e:	222d      	movs	r2, #45	; 0x2d
 8016350:	701a      	strb	r2, [r3, #0]
 8016352:	2300      	movs	r3, #0
 8016354:	9e20      	ldr	r6, [sp, #128]	; 0x80
 8016356:	9317      	str	r3, [sp, #92]	; 0x5c
 8016358:	e539      	b.n	8015dce <_svfprintf_r+0x32e>
 801635a:	7018      	strb	r0, [r3, #0]
 801635c:	e779      	b.n	8016252 <_svfprintf_r+0x7b2>
 801635e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8016360:	2b46      	cmp	r3, #70	; 0x46
 8016362:	d01b      	beq.n	801639c <_svfprintf_r+0x8fc>
 8016364:	9d08      	ldr	r5, [sp, #32]
 8016366:	2b45      	cmp	r3, #69	; 0x45
 8016368:	d101      	bne.n	801636e <_svfprintf_r+0x8ce>
 801636a:	9b08      	ldr	r3, [sp, #32]
 801636c:	1c5d      	adds	r5, r3, #1
 801636e:	2302      	movs	r3, #2
 8016370:	e016      	b.n	80163a0 <_svfprintf_r+0x900>
 8016372:	46c0      	nop			; (mov r8, r8)
 8016374:	7fefffff 	.word	0x7fefffff
 8016378:	0801c5dc 	.word	0x0801c5dc
 801637c:	0801c5d8 	.word	0x0801c5d8
 8016380:	0801c5e4 	.word	0x0801c5e4
 8016384:	0801c5e0 	.word	0x0801c5e0
 8016388:	0801c5f9 	.word	0x0801c5f9
 801638c:	0801c5e8 	.word	0x0801c5e8
 8016390:	40300000 	.word	0x40300000
 8016394:	3fe00000 	.word	0x3fe00000
 8016398:	fffffbff 	.word	0xfffffbff
 801639c:	2303      	movs	r3, #3
 801639e:	9d08      	ldr	r5, [sp, #32]
 80163a0:	aa2a      	add	r2, sp, #168	; 0xa8
 80163a2:	9204      	str	r2, [sp, #16]
 80163a4:	aa27      	add	r2, sp, #156	; 0x9c
 80163a6:	9203      	str	r2, [sp, #12]
 80163a8:	aa26      	add	r2, sp, #152	; 0x98
 80163aa:	9202      	str	r2, [sp, #8]
 80163ac:	9300      	str	r3, [sp, #0]
 80163ae:	9501      	str	r5, [sp, #4]
 80163b0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80163b2:	0022      	movs	r2, r4
 80163b4:	980a      	ldr	r0, [sp, #40]	; 0x28
 80163b6:	f000 fe79 	bl	80170ac <_dtoa_r>
 80163ba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80163bc:	9009      	str	r0, [sp, #36]	; 0x24
 80163be:	2b47      	cmp	r3, #71	; 0x47
 80163c0:	d101      	bne.n	80163c6 <_svfprintf_r+0x926>
 80163c2:	07f3      	lsls	r3, r6, #31
 80163c4:	d524      	bpl.n	8016410 <_svfprintf_r+0x970>
 80163c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80163c8:	195b      	adds	r3, r3, r5
 80163ca:	9310      	str	r3, [sp, #64]	; 0x40
 80163cc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80163ce:	2b46      	cmp	r3, #70	; 0x46
 80163d0:	d113      	bne.n	80163fa <_svfprintf_r+0x95a>
 80163d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80163d4:	781b      	ldrb	r3, [r3, #0]
 80163d6:	2b30      	cmp	r3, #48	; 0x30
 80163d8:	d10a      	bne.n	80163f0 <_svfprintf_r+0x950>
 80163da:	2200      	movs	r2, #0
 80163dc:	2300      	movs	r3, #0
 80163de:	0020      	movs	r0, r4
 80163e0:	990d      	ldr	r1, [sp, #52]	; 0x34
 80163e2:	f7ea f85b 	bl	800049c <__aeabi_dcmpeq>
 80163e6:	2800      	cmp	r0, #0
 80163e8:	d102      	bne.n	80163f0 <_svfprintf_r+0x950>
 80163ea:	2301      	movs	r3, #1
 80163ec:	1b5d      	subs	r5, r3, r5
 80163ee:	9526      	str	r5, [sp, #152]	; 0x98
 80163f0:	9a26      	ldr	r2, [sp, #152]	; 0x98
 80163f2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80163f4:	4694      	mov	ip, r2
 80163f6:	4463      	add	r3, ip
 80163f8:	9310      	str	r3, [sp, #64]	; 0x40
 80163fa:	2200      	movs	r2, #0
 80163fc:	2300      	movs	r3, #0
 80163fe:	0020      	movs	r0, r4
 8016400:	990d      	ldr	r1, [sp, #52]	; 0x34
 8016402:	f7ea f84b 	bl	800049c <__aeabi_dcmpeq>
 8016406:	2230      	movs	r2, #48	; 0x30
 8016408:	2800      	cmp	r0, #0
 801640a:	d006      	beq.n	801641a <_svfprintf_r+0x97a>
 801640c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801640e:	932a      	str	r3, [sp, #168]	; 0xa8
 8016410:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8016412:	e72c      	b.n	801626e <_svfprintf_r+0x7ce>
 8016414:	1c59      	adds	r1, r3, #1
 8016416:	912a      	str	r1, [sp, #168]	; 0xa8
 8016418:	701a      	strb	r2, [r3, #0]
 801641a:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801641c:	9910      	ldr	r1, [sp, #64]	; 0x40
 801641e:	4299      	cmp	r1, r3
 8016420:	d8f8      	bhi.n	8016414 <_svfprintf_r+0x974>
 8016422:	e7f5      	b.n	8016410 <_svfprintf_r+0x970>
 8016424:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8016426:	2b46      	cmp	r3, #70	; 0x46
 8016428:	d000      	beq.n	801642c <_svfprintf_r+0x98c>
 801642a:	e731      	b.n	8016290 <_svfprintf_r+0x7f0>
 801642c:	9b08      	ldr	r3, [sp, #32]
 801642e:	2d00      	cmp	r5, #0
 8016430:	dd21      	ble.n	8016476 <_svfprintf_r+0x9d6>
 8016432:	2b00      	cmp	r3, #0
 8016434:	d101      	bne.n	801643a <_svfprintf_r+0x99a>
 8016436:	07f3      	lsls	r3, r6, #31
 8016438:	d54a      	bpl.n	80164d0 <_svfprintf_r+0xa30>
 801643a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801643c:	18eb      	adds	r3, r5, r3
 801643e:	9a08      	ldr	r2, [sp, #32]
 8016440:	18d3      	adds	r3, r2, r3
 8016442:	9308      	str	r3, [sp, #32]
 8016444:	2366      	movs	r3, #102	; 0x66
 8016446:	930e      	str	r3, [sp, #56]	; 0x38
 8016448:	e034      	b.n	80164b4 <_svfprintf_r+0xa14>
 801644a:	9d08      	ldr	r5, [sp, #32]
 801644c:	e73f      	b.n	80162ce <_svfprintf_r+0x82e>
 801644e:	782a      	ldrb	r2, [r5, #0]
 8016450:	3501      	adds	r5, #1
 8016452:	701a      	strb	r2, [r3, #0]
 8016454:	3301      	adds	r3, #1
 8016456:	e753      	b.n	8016300 <_svfprintf_r+0x860>
 8016458:	232a      	movs	r3, #42	; 0x2a
 801645a:	aa1e      	add	r2, sp, #120	; 0x78
 801645c:	189b      	adds	r3, r3, r2
 801645e:	2900      	cmp	r1, #0
 8016460:	d105      	bne.n	801646e <_svfprintf_r+0x9ce>
 8016462:	2230      	movs	r2, #48	; 0x30
 8016464:	ab28      	add	r3, sp, #160	; 0xa0
 8016466:	709a      	strb	r2, [r3, #2]
 8016468:	232b      	movs	r3, #43	; 0x2b
 801646a:	aa1e      	add	r2, sp, #120	; 0x78
 801646c:	189b      	adds	r3, r3, r2
 801646e:	3430      	adds	r4, #48	; 0x30
 8016470:	1c5a      	adds	r2, r3, #1
 8016472:	701c      	strb	r4, [r3, #0]
 8016474:	e748      	b.n	8016308 <_svfprintf_r+0x868>
 8016476:	2b00      	cmp	r3, #0
 8016478:	d102      	bne.n	8016480 <_svfprintf_r+0x9e0>
 801647a:	3301      	adds	r3, #1
 801647c:	421e      	tst	r6, r3
 801647e:	d029      	beq.n	80164d4 <_svfprintf_r+0xa34>
 8016480:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8016482:	3301      	adds	r3, #1
 8016484:	e7db      	b.n	801643e <_svfprintf_r+0x99e>
 8016486:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016488:	42ab      	cmp	r3, r5
 801648a:	dc06      	bgt.n	801649a <_svfprintf_r+0x9fa>
 801648c:	07f3      	lsls	r3, r6, #31
 801648e:	d524      	bpl.n	80164da <_svfprintf_r+0xa3a>
 8016490:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8016492:	18eb      	adds	r3, r5, r3
 8016494:	9308      	str	r3, [sp, #32]
 8016496:	2367      	movs	r3, #103	; 0x67
 8016498:	e7d5      	b.n	8016446 <_svfprintf_r+0x9a6>
 801649a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801649c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801649e:	4694      	mov	ip, r2
 80164a0:	4463      	add	r3, ip
 80164a2:	9308      	str	r3, [sp, #32]
 80164a4:	2367      	movs	r3, #103	; 0x67
 80164a6:	930e      	str	r3, [sp, #56]	; 0x38
 80164a8:	2d00      	cmp	r5, #0
 80164aa:	dc03      	bgt.n	80164b4 <_svfprintf_r+0xa14>
 80164ac:	9b08      	ldr	r3, [sp, #32]
 80164ae:	1b5b      	subs	r3, r3, r5
 80164b0:	3301      	adds	r3, #1
 80164b2:	9308      	str	r3, [sp, #32]
 80164b4:	2380      	movs	r3, #128	; 0x80
 80164b6:	00db      	lsls	r3, r3, #3
 80164b8:	401e      	ands	r6, r3
 80164ba:	2300      	movs	r3, #0
 80164bc:	960f      	str	r6, [sp, #60]	; 0x3c
 80164be:	9310      	str	r3, [sp, #64]	; 0x40
 80164c0:	2e00      	cmp	r6, #0
 80164c2:	d100      	bne.n	80164c6 <_svfprintf_r+0xa26>
 80164c4:	e73c      	b.n	8016340 <_svfprintf_r+0x8a0>
 80164c6:	2d00      	cmp	r5, #0
 80164c8:	dc27      	bgt.n	801651a <_svfprintf_r+0xa7a>
 80164ca:	2300      	movs	r3, #0
 80164cc:	930f      	str	r3, [sp, #60]	; 0x3c
 80164ce:	e737      	b.n	8016340 <_svfprintf_r+0x8a0>
 80164d0:	9508      	str	r5, [sp, #32]
 80164d2:	e7b7      	b.n	8016444 <_svfprintf_r+0x9a4>
 80164d4:	2266      	movs	r2, #102	; 0x66
 80164d6:	920e      	str	r2, [sp, #56]	; 0x38
 80164d8:	e7eb      	b.n	80164b2 <_svfprintf_r+0xa12>
 80164da:	9508      	str	r5, [sp, #32]
 80164dc:	e7db      	b.n	8016496 <_svfprintf_r+0x9f6>
 80164de:	42ab      	cmp	r3, r5
 80164e0:	da0e      	bge.n	8016500 <_svfprintf_r+0xa60>
 80164e2:	1aed      	subs	r5, r5, r3
 80164e4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80164e6:	785b      	ldrb	r3, [r3, #1]
 80164e8:	2b00      	cmp	r3, #0
 80164ea:	d012      	beq.n	8016512 <_svfprintf_r+0xa72>
 80164ec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80164ee:	3301      	adds	r3, #1
 80164f0:	930f      	str	r3, [sp, #60]	; 0x3c
 80164f2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80164f4:	3301      	adds	r3, #1
 80164f6:	9313      	str	r3, [sp, #76]	; 0x4c
 80164f8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80164fa:	781b      	ldrb	r3, [r3, #0]
 80164fc:	2bff      	cmp	r3, #255	; 0xff
 80164fe:	d1ee      	bne.n	80164de <_svfprintf_r+0xa3e>
 8016500:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8016502:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8016504:	189b      	adds	r3, r3, r2
 8016506:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8016508:	4353      	muls	r3, r2
 801650a:	9a08      	ldr	r2, [sp, #32]
 801650c:	189b      	adds	r3, r3, r2
 801650e:	9308      	str	r3, [sp, #32]
 8016510:	e716      	b.n	8016340 <_svfprintf_r+0x8a0>
 8016512:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8016514:	3301      	adds	r3, #1
 8016516:	9310      	str	r3, [sp, #64]	; 0x40
 8016518:	e7ee      	b.n	80164f8 <_svfprintf_r+0xa58>
 801651a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801651c:	930f      	str	r3, [sp, #60]	; 0x3c
 801651e:	e7eb      	b.n	80164f8 <_svfprintf_r+0xa58>
 8016520:	0022      	movs	r2, r4
 8016522:	ca08      	ldmia	r2!, {r3}
 8016524:	9212      	str	r2, [sp, #72]	; 0x48
 8016526:	06b2      	lsls	r2, r6, #26
 8016528:	d508      	bpl.n	801653c <_svfprintf_r+0xa9c>
 801652a:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801652c:	601a      	str	r2, [r3, #0]
 801652e:	17d2      	asrs	r2, r2, #31
 8016530:	605a      	str	r2, [r3, #4]
 8016532:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8016534:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8016536:	9309      	str	r3, [sp, #36]	; 0x24
 8016538:	f7ff faeb 	bl	8015b12 <_svfprintf_r+0x72>
 801653c:	06f2      	lsls	r2, r6, #27
 801653e:	d502      	bpl.n	8016546 <_svfprintf_r+0xaa6>
 8016540:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8016542:	601a      	str	r2, [r3, #0]
 8016544:	e7f5      	b.n	8016532 <_svfprintf_r+0xa92>
 8016546:	0672      	lsls	r2, r6, #25
 8016548:	d502      	bpl.n	8016550 <_svfprintf_r+0xab0>
 801654a:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801654c:	801a      	strh	r2, [r3, #0]
 801654e:	e7f0      	b.n	8016532 <_svfprintf_r+0xa92>
 8016550:	05b2      	lsls	r2, r6, #22
 8016552:	d5f5      	bpl.n	8016540 <_svfprintf_r+0xaa0>
 8016554:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8016556:	701a      	strb	r2, [r3, #0]
 8016558:	e7eb      	b.n	8016532 <_svfprintf_r+0xa92>
 801655a:	2310      	movs	r3, #16
 801655c:	431e      	orrs	r6, r3
 801655e:	2220      	movs	r2, #32
 8016560:	4032      	ands	r2, r6
 8016562:	d025      	beq.n	80165b0 <_svfprintf_r+0xb10>
 8016564:	2307      	movs	r3, #7
 8016566:	3407      	adds	r4, #7
 8016568:	439c      	bics	r4, r3
 801656a:	0023      	movs	r3, r4
 801656c:	3308      	adds	r3, #8
 801656e:	9312      	str	r3, [sp, #72]	; 0x48
 8016570:	6823      	ldr	r3, [r4, #0]
 8016572:	6864      	ldr	r4, [r4, #4]
 8016574:	9306      	str	r3, [sp, #24]
 8016576:	9407      	str	r4, [sp, #28]
 8016578:	4bc2      	ldr	r3, [pc, #776]	; (8016884 <_svfprintf_r+0xde4>)
 801657a:	401e      	ands	r6, r3
 801657c:	2300      	movs	r3, #0
 801657e:	221b      	movs	r2, #27
 8016580:	a91e      	add	r1, sp, #120	; 0x78
 8016582:	1852      	adds	r2, r2, r1
 8016584:	2100      	movs	r1, #0
 8016586:	7011      	strb	r1, [r2, #0]
 8016588:	9a08      	ldr	r2, [sp, #32]
 801658a:	3201      	adds	r2, #1
 801658c:	d100      	bne.n	8016590 <_svfprintf_r+0xaf0>
 801658e:	e0a6      	b.n	80166de <_svfprintf_r+0xc3e>
 8016590:	0032      	movs	r2, r6
 8016592:	2180      	movs	r1, #128	; 0x80
 8016594:	9807      	ldr	r0, [sp, #28]
 8016596:	438e      	bics	r6, r1
 8016598:	9906      	ldr	r1, [sp, #24]
 801659a:	4301      	orrs	r1, r0
 801659c:	d000      	beq.n	80165a0 <_svfprintf_r+0xb00>
 801659e:	e09e      	b.n	80166de <_svfprintf_r+0xc3e>
 80165a0:	9908      	ldr	r1, [sp, #32]
 80165a2:	2900      	cmp	r1, #0
 80165a4:	d100      	bne.n	80165a8 <_svfprintf_r+0xb08>
 80165a6:	e125      	b.n	80167f4 <_svfprintf_r+0xd54>
 80165a8:	2b01      	cmp	r3, #1
 80165aa:	d000      	beq.n	80165ae <_svfprintf_r+0xb0e>
 80165ac:	e09a      	b.n	80166e4 <_svfprintf_r+0xc44>
 80165ae:	e518      	b.n	8015fe2 <_svfprintf_r+0x542>
 80165b0:	1d23      	adds	r3, r4, #4
 80165b2:	9312      	str	r3, [sp, #72]	; 0x48
 80165b4:	2310      	movs	r3, #16
 80165b6:	4033      	ands	r3, r6
 80165b8:	d003      	beq.n	80165c2 <_svfprintf_r+0xb22>
 80165ba:	6823      	ldr	r3, [r4, #0]
 80165bc:	9306      	str	r3, [sp, #24]
 80165be:	9207      	str	r2, [sp, #28]
 80165c0:	e7da      	b.n	8016578 <_svfprintf_r+0xad8>
 80165c2:	2240      	movs	r2, #64	; 0x40
 80165c4:	4032      	ands	r2, r6
 80165c6:	d004      	beq.n	80165d2 <_svfprintf_r+0xb32>
 80165c8:	6822      	ldr	r2, [r4, #0]
 80165ca:	b292      	uxth	r2, r2
 80165cc:	9206      	str	r2, [sp, #24]
 80165ce:	9307      	str	r3, [sp, #28]
 80165d0:	e7d2      	b.n	8016578 <_svfprintf_r+0xad8>
 80165d2:	2380      	movs	r3, #128	; 0x80
 80165d4:	009b      	lsls	r3, r3, #2
 80165d6:	4033      	ands	r3, r6
 80165d8:	d002      	beq.n	80165e0 <_svfprintf_r+0xb40>
 80165da:	6823      	ldr	r3, [r4, #0]
 80165dc:	b2db      	uxtb	r3, r3
 80165de:	e7ed      	b.n	80165bc <_svfprintf_r+0xb1c>
 80165e0:	6822      	ldr	r2, [r4, #0]
 80165e2:	e7f3      	b.n	80165cc <_svfprintf_r+0xb2c>
 80165e4:	1d23      	adds	r3, r4, #4
 80165e6:	49a8      	ldr	r1, [pc, #672]	; (8016888 <_svfprintf_r+0xde8>)
 80165e8:	aa25      	add	r2, sp, #148	; 0x94
 80165ea:	9312      	str	r3, [sp, #72]	; 0x48
 80165ec:	6823      	ldr	r3, [r4, #0]
 80165ee:	8011      	strh	r1, [r2, #0]
 80165f0:	4aa6      	ldr	r2, [pc, #664]	; (801688c <_svfprintf_r+0xdec>)
 80165f2:	9306      	str	r3, [sp, #24]
 80165f4:	2300      	movs	r3, #0
 80165f6:	921e      	str	r2, [sp, #120]	; 0x78
 80165f8:	2278      	movs	r2, #120	; 0x78
 80165fa:	9307      	str	r3, [sp, #28]
 80165fc:	3302      	adds	r3, #2
 80165fe:	431e      	orrs	r6, r3
 8016600:	920e      	str	r2, [sp, #56]	; 0x38
 8016602:	e7bc      	b.n	801657e <_svfprintf_r+0xade>
 8016604:	1d23      	adds	r3, r4, #4
 8016606:	9312      	str	r3, [sp, #72]	; 0x48
 8016608:	6823      	ldr	r3, [r4, #0]
 801660a:	2400      	movs	r4, #0
 801660c:	9309      	str	r3, [sp, #36]	; 0x24
 801660e:	231b      	movs	r3, #27
 8016610:	aa1e      	add	r2, sp, #120	; 0x78
 8016612:	189b      	adds	r3, r3, r2
 8016614:	701c      	strb	r4, [r3, #0]
 8016616:	9b08      	ldr	r3, [sp, #32]
 8016618:	3301      	adds	r3, #1
 801661a:	d00e      	beq.n	801663a <_svfprintf_r+0xb9a>
 801661c:	9a08      	ldr	r2, [sp, #32]
 801661e:	0021      	movs	r1, r4
 8016620:	9809      	ldr	r0, [sp, #36]	; 0x24
 8016622:	f001 ff79 	bl	8018518 <memchr>
 8016626:	900c      	str	r0, [sp, #48]	; 0x30
 8016628:	42a0      	cmp	r0, r4
 801662a:	d100      	bne.n	801662e <_svfprintf_r+0xb8e>
 801662c:	e100      	b.n	8016830 <_svfprintf_r+0xd90>
 801662e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8016630:	1a83      	subs	r3, r0, r2
 8016632:	9308      	str	r3, [sp, #32]
 8016634:	940c      	str	r4, [sp, #48]	; 0x30
 8016636:	0023      	movs	r3, r4
 8016638:	e527      	b.n	801608a <_svfprintf_r+0x5ea>
 801663a:	9809      	ldr	r0, [sp, #36]	; 0x24
 801663c:	f7e9 fd6c 	bl	8000118 <strlen>
 8016640:	9008      	str	r0, [sp, #32]
 8016642:	e7f7      	b.n	8016634 <_svfprintf_r+0xb94>
 8016644:	2310      	movs	r3, #16
 8016646:	431e      	orrs	r6, r3
 8016648:	2220      	movs	r2, #32
 801664a:	4032      	ands	r2, r6
 801664c:	d00b      	beq.n	8016666 <_svfprintf_r+0xbc6>
 801664e:	2307      	movs	r3, #7
 8016650:	3407      	adds	r4, #7
 8016652:	439c      	bics	r4, r3
 8016654:	0023      	movs	r3, r4
 8016656:	3308      	adds	r3, #8
 8016658:	9312      	str	r3, [sp, #72]	; 0x48
 801665a:	6823      	ldr	r3, [r4, #0]
 801665c:	6864      	ldr	r4, [r4, #4]
 801665e:	9306      	str	r3, [sp, #24]
 8016660:	9407      	str	r4, [sp, #28]
 8016662:	2301      	movs	r3, #1
 8016664:	e78b      	b.n	801657e <_svfprintf_r+0xade>
 8016666:	1d23      	adds	r3, r4, #4
 8016668:	9312      	str	r3, [sp, #72]	; 0x48
 801666a:	2310      	movs	r3, #16
 801666c:	4033      	ands	r3, r6
 801666e:	d003      	beq.n	8016678 <_svfprintf_r+0xbd8>
 8016670:	6823      	ldr	r3, [r4, #0]
 8016672:	9306      	str	r3, [sp, #24]
 8016674:	9207      	str	r2, [sp, #28]
 8016676:	e7f4      	b.n	8016662 <_svfprintf_r+0xbc2>
 8016678:	2240      	movs	r2, #64	; 0x40
 801667a:	4032      	ands	r2, r6
 801667c:	d004      	beq.n	8016688 <_svfprintf_r+0xbe8>
 801667e:	6822      	ldr	r2, [r4, #0]
 8016680:	b292      	uxth	r2, r2
 8016682:	9206      	str	r2, [sp, #24]
 8016684:	9307      	str	r3, [sp, #28]
 8016686:	e7ec      	b.n	8016662 <_svfprintf_r+0xbc2>
 8016688:	2380      	movs	r3, #128	; 0x80
 801668a:	009b      	lsls	r3, r3, #2
 801668c:	4033      	ands	r3, r6
 801668e:	d002      	beq.n	8016696 <_svfprintf_r+0xbf6>
 8016690:	6823      	ldr	r3, [r4, #0]
 8016692:	b2db      	uxtb	r3, r3
 8016694:	e7ed      	b.n	8016672 <_svfprintf_r+0xbd2>
 8016696:	6822      	ldr	r2, [r4, #0]
 8016698:	e7f3      	b.n	8016682 <_svfprintf_r+0xbe2>
 801669a:	4b7c      	ldr	r3, [pc, #496]	; (801688c <_svfprintf_r+0xdec>)
 801669c:	f7ff fad9 	bl	8015c52 <_svfprintf_r+0x1b2>
 80166a0:	1d23      	adds	r3, r4, #4
 80166a2:	9312      	str	r3, [sp, #72]	; 0x48
 80166a4:	2310      	movs	r3, #16
 80166a6:	4033      	ands	r3, r6
 80166a8:	d004      	beq.n	80166b4 <_svfprintf_r+0xc14>
 80166aa:	6823      	ldr	r3, [r4, #0]
 80166ac:	9306      	str	r3, [sp, #24]
 80166ae:	9207      	str	r2, [sp, #28]
 80166b0:	f7ff fadf 	bl	8015c72 <_svfprintf_r+0x1d2>
 80166b4:	2240      	movs	r2, #64	; 0x40
 80166b6:	4032      	ands	r2, r6
 80166b8:	d005      	beq.n	80166c6 <_svfprintf_r+0xc26>
 80166ba:	6822      	ldr	r2, [r4, #0]
 80166bc:	b292      	uxth	r2, r2
 80166be:	9206      	str	r2, [sp, #24]
 80166c0:	9307      	str	r3, [sp, #28]
 80166c2:	f7ff fad6 	bl	8015c72 <_svfprintf_r+0x1d2>
 80166c6:	2380      	movs	r3, #128	; 0x80
 80166c8:	009b      	lsls	r3, r3, #2
 80166ca:	4033      	ands	r3, r6
 80166cc:	d002      	beq.n	80166d4 <_svfprintf_r+0xc34>
 80166ce:	6823      	ldr	r3, [r4, #0]
 80166d0:	b2db      	uxtb	r3, r3
 80166d2:	e7eb      	b.n	80166ac <_svfprintf_r+0xc0c>
 80166d4:	6822      	ldr	r2, [r4, #0]
 80166d6:	e7f2      	b.n	80166be <_svfprintf_r+0xc1e>
 80166d8:	0032      	movs	r2, r6
 80166da:	2301      	movs	r3, #1
 80166dc:	e759      	b.n	8016592 <_svfprintf_r+0xaf2>
 80166de:	2b01      	cmp	r3, #1
 80166e0:	d100      	bne.n	80166e4 <_svfprintf_r+0xc44>
 80166e2:	e476      	b.n	8015fd2 <_svfprintf_r+0x532>
 80166e4:	2b02      	cmp	r3, #2
 80166e6:	d06b      	beq.n	80167c0 <_svfprintf_r+0xd20>
 80166e8:	2507      	movs	r5, #7
 80166ea:	ab58      	add	r3, sp, #352	; 0x160
 80166ec:	1e5a      	subs	r2, r3, #1
 80166ee:	9209      	str	r2, [sp, #36]	; 0x24
 80166f0:	9a06      	ldr	r2, [sp, #24]
 80166f2:	1e59      	subs	r1, r3, #1
 80166f4:	402a      	ands	r2, r5
 80166f6:	3230      	adds	r2, #48	; 0x30
 80166f8:	700a      	strb	r2, [r1, #0]
 80166fa:	9907      	ldr	r1, [sp, #28]
 80166fc:	074c      	lsls	r4, r1, #29
 80166fe:	9906      	ldr	r1, [sp, #24]
 8016700:	08c8      	lsrs	r0, r1, #3
 8016702:	9907      	ldr	r1, [sp, #28]
 8016704:	4304      	orrs	r4, r0
 8016706:	08c9      	lsrs	r1, r1, #3
 8016708:	9107      	str	r1, [sp, #28]
 801670a:	0021      	movs	r1, r4
 801670c:	9807      	ldr	r0, [sp, #28]
 801670e:	9406      	str	r4, [sp, #24]
 8016710:	4301      	orrs	r1, r0
 8016712:	d111      	bne.n	8016738 <_svfprintf_r+0xc98>
 8016714:	07f1      	lsls	r1, r6, #31
 8016716:	d502      	bpl.n	801671e <_svfprintf_r+0xc7e>
 8016718:	3b02      	subs	r3, #2
 801671a:	2a30      	cmp	r2, #48	; 0x30
 801671c:	d173      	bne.n	8016806 <_svfprintf_r+0xd66>
 801671e:	9b08      	ldr	r3, [sp, #32]
 8016720:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8016722:	9317      	str	r3, [sp, #92]	; 0x5c
 8016724:	ab58      	add	r3, sp, #352	; 0x160
 8016726:	1a9b      	subs	r3, r3, r2
 8016728:	9308      	str	r3, [sp, #32]
 801672a:	2300      	movs	r3, #0
 801672c:	930c      	str	r3, [sp, #48]	; 0x30
 801672e:	9310      	str	r3, [sp, #64]	; 0x40
 8016730:	930f      	str	r3, [sp, #60]	; 0x3c
 8016732:	001d      	movs	r5, r3
 8016734:	f7ff fb4b 	bl	8015dce <_svfprintf_r+0x32e>
 8016738:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801673a:	e7d7      	b.n	80166ec <_svfprintf_r+0xc4c>
 801673c:	2480      	movs	r4, #128	; 0x80
 801673e:	2300      	movs	r3, #0
 8016740:	00e4      	lsls	r4, r4, #3
 8016742:	930d      	str	r3, [sp, #52]	; 0x34
 8016744:	4034      	ands	r4, r6
 8016746:	ab58      	add	r3, sp, #352	; 0x160
 8016748:	3b01      	subs	r3, #1
 801674a:	9309      	str	r3, [sp, #36]	; 0x24
 801674c:	220a      	movs	r2, #10
 801674e:	9806      	ldr	r0, [sp, #24]
 8016750:	9907      	ldr	r1, [sp, #28]
 8016752:	2300      	movs	r3, #0
 8016754:	f7e9 ff0a 	bl	800056c <__aeabi_uldivmod>
 8016758:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801675a:	3230      	adds	r2, #48	; 0x30
 801675c:	701a      	strb	r2, [r3, #0]
 801675e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016760:	3301      	adds	r3, #1
 8016762:	930d      	str	r3, [sp, #52]	; 0x34
 8016764:	2c00      	cmp	r4, #0
 8016766:	d01d      	beq.n	80167a4 <_svfprintf_r+0xd04>
 8016768:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801676a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801676c:	781b      	ldrb	r3, [r3, #0]
 801676e:	429a      	cmp	r2, r3
 8016770:	d118      	bne.n	80167a4 <_svfprintf_r+0xd04>
 8016772:	2aff      	cmp	r2, #255	; 0xff
 8016774:	d016      	beq.n	80167a4 <_svfprintf_r+0xd04>
 8016776:	9b07      	ldr	r3, [sp, #28]
 8016778:	2b00      	cmp	r3, #0
 801677a:	d102      	bne.n	8016782 <_svfprintf_r+0xce2>
 801677c:	9b06      	ldr	r3, [sp, #24]
 801677e:	2b09      	cmp	r3, #9
 8016780:	d910      	bls.n	80167a4 <_svfprintf_r+0xd04>
 8016782:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016784:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8016786:	991f      	ldr	r1, [sp, #124]	; 0x7c
 8016788:	1a9b      	subs	r3, r3, r2
 801678a:	0018      	movs	r0, r3
 801678c:	9309      	str	r3, [sp, #36]	; 0x24
 801678e:	f7fe f9ba 	bl	8014b06 <strncpy>
 8016792:	2200      	movs	r2, #0
 8016794:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8016796:	920d      	str	r2, [sp, #52]	; 0x34
 8016798:	785b      	ldrb	r3, [r3, #1]
 801679a:	1e5a      	subs	r2, r3, #1
 801679c:	4193      	sbcs	r3, r2
 801679e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80167a0:	18d3      	adds	r3, r2, r3
 80167a2:	9313      	str	r3, [sp, #76]	; 0x4c
 80167a4:	220a      	movs	r2, #10
 80167a6:	9806      	ldr	r0, [sp, #24]
 80167a8:	9907      	ldr	r1, [sp, #28]
 80167aa:	2300      	movs	r3, #0
 80167ac:	f7e9 fede 	bl	800056c <__aeabi_uldivmod>
 80167b0:	9006      	str	r0, [sp, #24]
 80167b2:	9107      	str	r1, [sp, #28]
 80167b4:	9b06      	ldr	r3, [sp, #24]
 80167b6:	9a07      	ldr	r2, [sp, #28]
 80167b8:	4313      	orrs	r3, r2
 80167ba:	d0b0      	beq.n	801671e <_svfprintf_r+0xc7e>
 80167bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80167be:	e7c3      	b.n	8016748 <_svfprintf_r+0xca8>
 80167c0:	200f      	movs	r0, #15
 80167c2:	ab58      	add	r3, sp, #352	; 0x160
 80167c4:	9309      	str	r3, [sp, #36]	; 0x24
 80167c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80167c8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 80167ca:	3b01      	subs	r3, #1
 80167cc:	9309      	str	r3, [sp, #36]	; 0x24
 80167ce:	9b06      	ldr	r3, [sp, #24]
 80167d0:	4003      	ands	r3, r0
 80167d2:	5cd3      	ldrb	r3, [r2, r3]
 80167d4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80167d6:	7013      	strb	r3, [r2, #0]
 80167d8:	9b07      	ldr	r3, [sp, #28]
 80167da:	0719      	lsls	r1, r3, #28
 80167dc:	9b06      	ldr	r3, [sp, #24]
 80167de:	091a      	lsrs	r2, r3, #4
 80167e0:	9b07      	ldr	r3, [sp, #28]
 80167e2:	4311      	orrs	r1, r2
 80167e4:	091b      	lsrs	r3, r3, #4
 80167e6:	9307      	str	r3, [sp, #28]
 80167e8:	000b      	movs	r3, r1
 80167ea:	9a07      	ldr	r2, [sp, #28]
 80167ec:	9106      	str	r1, [sp, #24]
 80167ee:	4313      	orrs	r3, r2
 80167f0:	d1e9      	bne.n	80167c6 <_svfprintf_r+0xd26>
 80167f2:	e794      	b.n	801671e <_svfprintf_r+0xc7e>
 80167f4:	a958      	add	r1, sp, #352	; 0x160
 80167f6:	9109      	str	r1, [sp, #36]	; 0x24
 80167f8:	2b00      	cmp	r3, #0
 80167fa:	d190      	bne.n	801671e <_svfprintf_r+0xc7e>
 80167fc:	07d3      	lsls	r3, r2, #31
 80167fe:	d58e      	bpl.n	801671e <_svfprintf_r+0xc7e>
 8016800:	23e7      	movs	r3, #231	; 0xe7
 8016802:	aa1e      	add	r2, sp, #120	; 0x78
 8016804:	189b      	adds	r3, r3, r2
 8016806:	2230      	movs	r2, #48	; 0x30
 8016808:	f7ff fbf0 	bl	8015fec <_svfprintf_r+0x54c>
 801680c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801680e:	2b00      	cmp	r3, #0
 8016810:	d100      	bne.n	8016814 <_svfprintf_r+0xd74>
 8016812:	e38a      	b.n	8016f2a <_svfprintf_r+0x148a>
 8016814:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8016816:	ab3f      	add	r3, sp, #252	; 0xfc
 8016818:	701a      	strb	r2, [r3, #0]
 801681a:	221b      	movs	r2, #27
 801681c:	2000      	movs	r0, #0
 801681e:	a91e      	add	r1, sp, #120	; 0x78
 8016820:	1852      	adds	r2, r2, r1
 8016822:	7010      	strb	r0, [r2, #0]
 8016824:	9412      	str	r4, [sp, #72]	; 0x48
 8016826:	f7ff faca 	bl	8015dbe <_svfprintf_r+0x31e>
 801682a:	9e20      	ldr	r6, [sp, #128]	; 0x80
 801682c:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801682e:	e592      	b.n	8016356 <_svfprintf_r+0x8b6>
 8016830:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8016832:	e42a      	b.n	801608a <_svfprintf_r+0x5ea>
 8016834:	2010      	movs	r0, #16
 8016836:	1812      	adds	r2, r2, r0
 8016838:	6078      	str	r0, [r7, #4]
 801683a:	922e      	str	r2, [sp, #184]	; 0xb8
 801683c:	932d      	str	r3, [sp, #180]	; 0xb4
 801683e:	2b07      	cmp	r3, #7
 8016840:	dd08      	ble.n	8016854 <_svfprintf_r+0xdb4>
 8016842:	aa2c      	add	r2, sp, #176	; 0xb0
 8016844:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016846:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016848:	f002 fa7e 	bl	8018d48 <__ssprint_r>
 801684c:	2800      	cmp	r0, #0
 801684e:	d000      	beq.n	8016852 <_svfprintf_r+0xdb2>
 8016850:	e34a      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016852:	a92f      	add	r1, sp, #188	; 0xbc
 8016854:	3c10      	subs	r4, #16
 8016856:	000f      	movs	r7, r1
 8016858:	f7ff fad8 	bl	8015e0c <_svfprintf_r+0x36c>
 801685c:	2010      	movs	r0, #16
 801685e:	1812      	adds	r2, r2, r0
 8016860:	6078      	str	r0, [r7, #4]
 8016862:	922e      	str	r2, [sp, #184]	; 0xb8
 8016864:	932d      	str	r3, [sp, #180]	; 0xb4
 8016866:	2b07      	cmp	r3, #7
 8016868:	dd08      	ble.n	801687c <_svfprintf_r+0xddc>
 801686a:	aa2c      	add	r2, sp, #176	; 0xb0
 801686c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801686e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016870:	f002 fa6a 	bl	8018d48 <__ssprint_r>
 8016874:	2800      	cmp	r0, #0
 8016876:	d000      	beq.n	801687a <_svfprintf_r+0xdda>
 8016878:	e336      	b.n	8016ee8 <_svfprintf_r+0x1448>
 801687a:	a92f      	add	r1, sp, #188	; 0xbc
 801687c:	3c10      	subs	r4, #16
 801687e:	000f      	movs	r7, r1
 8016880:	f7ff fb24 	bl	8015ecc <_svfprintf_r+0x42c>
 8016884:	fffffbff 	.word	0xfffffbff
 8016888:	00007830 	.word	0x00007830
 801688c:	0801c5e8 	.word	0x0801c5e8
 8016890:	2010      	movs	r0, #16
 8016892:	1812      	adds	r2, r2, r0
 8016894:	6078      	str	r0, [r7, #4]
 8016896:	922e      	str	r2, [sp, #184]	; 0xb8
 8016898:	932d      	str	r3, [sp, #180]	; 0xb4
 801689a:	2b07      	cmp	r3, #7
 801689c:	dd08      	ble.n	80168b0 <_svfprintf_r+0xe10>
 801689e:	aa2c      	add	r2, sp, #176	; 0xb0
 80168a0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80168a2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80168a4:	f002 fa50 	bl	8018d48 <__ssprint_r>
 80168a8:	2800      	cmp	r0, #0
 80168aa:	d000      	beq.n	80168ae <_svfprintf_r+0xe0e>
 80168ac:	e31c      	b.n	8016ee8 <_svfprintf_r+0x1448>
 80168ae:	a92f      	add	r1, sp, #188	; 0xbc
 80168b0:	3c10      	subs	r4, #16
 80168b2:	000f      	movs	r7, r1
 80168b4:	f7ff fb2c 	bl	8015f10 <_svfprintf_r+0x470>
 80168b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80168ba:	2b65      	cmp	r3, #101	; 0x65
 80168bc:	dc00      	bgt.n	80168c0 <_svfprintf_r+0xe20>
 80168be:	e259      	b.n	8016d74 <_svfprintf_r+0x12d4>
 80168c0:	2200      	movs	r2, #0
 80168c2:	2300      	movs	r3, #0
 80168c4:	981a      	ldr	r0, [sp, #104]	; 0x68
 80168c6:	9919      	ldr	r1, [sp, #100]	; 0x64
 80168c8:	f7e9 fde8 	bl	800049c <__aeabi_dcmpeq>
 80168cc:	2800      	cmp	r0, #0
 80168ce:	d07c      	beq.n	80169ca <_svfprintf_r+0xf2a>
 80168d0:	4b81      	ldr	r3, [pc, #516]	; (8016ad8 <_svfprintf_r+0x1038>)
 80168d2:	603b      	str	r3, [r7, #0]
 80168d4:	2301      	movs	r3, #1
 80168d6:	607b      	str	r3, [r7, #4]
 80168d8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80168da:	3708      	adds	r7, #8
 80168dc:	3301      	adds	r3, #1
 80168de:	932e      	str	r3, [sp, #184]	; 0xb8
 80168e0:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 80168e2:	9308      	str	r3, [sp, #32]
 80168e4:	3301      	adds	r3, #1
 80168e6:	932d      	str	r3, [sp, #180]	; 0xb4
 80168e8:	2b07      	cmp	r3, #7
 80168ea:	dd08      	ble.n	80168fe <_svfprintf_r+0xe5e>
 80168ec:	aa2c      	add	r2, sp, #176	; 0xb0
 80168ee:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80168f0:	980a      	ldr	r0, [sp, #40]	; 0x28
 80168f2:	f002 fa29 	bl	8018d48 <__ssprint_r>
 80168f6:	2800      	cmp	r0, #0
 80168f8:	d000      	beq.n	80168fc <_svfprintf_r+0xe5c>
 80168fa:	e2f5      	b.n	8016ee8 <_svfprintf_r+0x1448>
 80168fc:	af2f      	add	r7, sp, #188	; 0xbc
 80168fe:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8016900:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8016902:	4293      	cmp	r3, r2
 8016904:	db01      	blt.n	801690a <_svfprintf_r+0xe6a>
 8016906:	07f3      	lsls	r3, r6, #31
 8016908:	d51d      	bpl.n	8016946 <_svfprintf_r+0xea6>
 801690a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801690c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801690e:	4694      	mov	ip, r2
 8016910:	603b      	str	r3, [r7, #0]
 8016912:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8016914:	607b      	str	r3, [r7, #4]
 8016916:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016918:	3708      	adds	r7, #8
 801691a:	4463      	add	r3, ip
 801691c:	932e      	str	r3, [sp, #184]	; 0xb8
 801691e:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016920:	9308      	str	r3, [sp, #32]
 8016922:	3301      	adds	r3, #1
 8016924:	932d      	str	r3, [sp, #180]	; 0xb4
 8016926:	2b07      	cmp	r3, #7
 8016928:	dd08      	ble.n	801693c <_svfprintf_r+0xe9c>
 801692a:	aa2c      	add	r2, sp, #176	; 0xb0
 801692c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801692e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016930:	f002 fa0a 	bl	8018d48 <__ssprint_r>
 8016934:	2800      	cmp	r0, #0
 8016936:	d000      	beq.n	801693a <_svfprintf_r+0xe9a>
 8016938:	e2d6      	b.n	8016ee8 <_svfprintf_r+0x1448>
 801693a:	af2f      	add	r7, sp, #188	; 0xbc
 801693c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801693e:	2510      	movs	r5, #16
 8016940:	1e5c      	subs	r4, r3, #1
 8016942:	2c00      	cmp	r4, #0
 8016944:	dc2f      	bgt.n	80169a6 <_svfprintf_r+0xf06>
 8016946:	0773      	lsls	r3, r6, #29
 8016948:	d500      	bpl.n	801694c <_svfprintf_r+0xeac>
 801694a:	e2af      	b.n	8016eac <_svfprintf_r+0x140c>
 801694c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801694e:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8016950:	4293      	cmp	r3, r2
 8016952:	da00      	bge.n	8016956 <_svfprintf_r+0xeb6>
 8016954:	0013      	movs	r3, r2
 8016956:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8016958:	18d3      	adds	r3, r2, r3
 801695a:	9315      	str	r3, [sp, #84]	; 0x54
 801695c:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 801695e:	9308      	str	r3, [sp, #32]
 8016960:	2b00      	cmp	r3, #0
 8016962:	d007      	beq.n	8016974 <_svfprintf_r+0xed4>
 8016964:	aa2c      	add	r2, sp, #176	; 0xb0
 8016966:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016968:	980a      	ldr	r0, [sp, #40]	; 0x28
 801696a:	f002 f9ed 	bl	8018d48 <__ssprint_r>
 801696e:	2800      	cmp	r0, #0
 8016970:	d000      	beq.n	8016974 <_svfprintf_r+0xed4>
 8016972:	e2b9      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016974:	2300      	movs	r3, #0
 8016976:	932d      	str	r3, [sp, #180]	; 0xb4
 8016978:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801697a:	2b00      	cmp	r3, #0
 801697c:	d000      	beq.n	8016980 <_svfprintf_r+0xee0>
 801697e:	e2cf      	b.n	8016f20 <_svfprintf_r+0x1480>
 8016980:	af2f      	add	r7, sp, #188	; 0xbc
 8016982:	e5d6      	b.n	8016532 <_svfprintf_r+0xa92>
 8016984:	3210      	adds	r2, #16
 8016986:	607d      	str	r5, [r7, #4]
 8016988:	922e      	str	r2, [sp, #184]	; 0xb8
 801698a:	932d      	str	r3, [sp, #180]	; 0xb4
 801698c:	2b07      	cmp	r3, #7
 801698e:	dd08      	ble.n	80169a2 <_svfprintf_r+0xf02>
 8016990:	aa2c      	add	r2, sp, #176	; 0xb0
 8016992:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016994:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016996:	f002 f9d7 	bl	8018d48 <__ssprint_r>
 801699a:	2800      	cmp	r0, #0
 801699c:	d000      	beq.n	80169a0 <_svfprintf_r+0xf00>
 801699e:	e2a3      	b.n	8016ee8 <_svfprintf_r+0x1448>
 80169a0:	a92f      	add	r1, sp, #188	; 0xbc
 80169a2:	000f      	movs	r7, r1
 80169a4:	3c10      	subs	r4, #16
 80169a6:	0039      	movs	r1, r7
 80169a8:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 80169aa:	484c      	ldr	r0, [pc, #304]	; (8016adc <_svfprintf_r+0x103c>)
 80169ac:	9308      	str	r3, [sp, #32]
 80169ae:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 80169b0:	3301      	adds	r3, #1
 80169b2:	3108      	adds	r1, #8
 80169b4:	6038      	str	r0, [r7, #0]
 80169b6:	2c10      	cmp	r4, #16
 80169b8:	dce4      	bgt.n	8016984 <_svfprintf_r+0xee4>
 80169ba:	607c      	str	r4, [r7, #4]
 80169bc:	18a4      	adds	r4, r4, r2
 80169be:	942e      	str	r4, [sp, #184]	; 0xb8
 80169c0:	932d      	str	r3, [sp, #180]	; 0xb4
 80169c2:	000f      	movs	r7, r1
 80169c4:	2b07      	cmp	r3, #7
 80169c6:	ddbe      	ble.n	8016946 <_svfprintf_r+0xea6>
 80169c8:	e06a      	b.n	8016aa0 <_svfprintf_r+0x1000>
 80169ca:	9b26      	ldr	r3, [sp, #152]	; 0x98
 80169cc:	2b00      	cmp	r3, #0
 80169ce:	dd00      	ble.n	80169d2 <_svfprintf_r+0xf32>
 80169d0:	e086      	b.n	8016ae0 <_svfprintf_r+0x1040>
 80169d2:	4b41      	ldr	r3, [pc, #260]	; (8016ad8 <_svfprintf_r+0x1038>)
 80169d4:	603b      	str	r3, [r7, #0]
 80169d6:	2301      	movs	r3, #1
 80169d8:	607b      	str	r3, [r7, #4]
 80169da:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80169dc:	3708      	adds	r7, #8
 80169de:	3301      	adds	r3, #1
 80169e0:	932e      	str	r3, [sp, #184]	; 0xb8
 80169e2:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 80169e4:	9308      	str	r3, [sp, #32]
 80169e6:	3301      	adds	r3, #1
 80169e8:	932d      	str	r3, [sp, #180]	; 0xb4
 80169ea:	2b07      	cmp	r3, #7
 80169ec:	dd08      	ble.n	8016a00 <_svfprintf_r+0xf60>
 80169ee:	aa2c      	add	r2, sp, #176	; 0xb0
 80169f0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80169f2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80169f4:	f002 f9a8 	bl	8018d48 <__ssprint_r>
 80169f8:	2800      	cmp	r0, #0
 80169fa:	d000      	beq.n	80169fe <_svfprintf_r+0xf5e>
 80169fc:	e274      	b.n	8016ee8 <_svfprintf_r+0x1448>
 80169fe:	af2f      	add	r7, sp, #188	; 0xbc
 8016a00:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8016a02:	2b00      	cmp	r3, #0
 8016a04:	d104      	bne.n	8016a10 <_svfprintf_r+0xf70>
 8016a06:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016a08:	2b00      	cmp	r3, #0
 8016a0a:	d101      	bne.n	8016a10 <_svfprintf_r+0xf70>
 8016a0c:	07f3      	lsls	r3, r6, #31
 8016a0e:	d59a      	bpl.n	8016946 <_svfprintf_r+0xea6>
 8016a10:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8016a12:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8016a14:	4694      	mov	ip, r2
 8016a16:	603b      	str	r3, [r7, #0]
 8016a18:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8016a1a:	607b      	str	r3, [r7, #4]
 8016a1c:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016a1e:	3708      	adds	r7, #8
 8016a20:	4463      	add	r3, ip
 8016a22:	932e      	str	r3, [sp, #184]	; 0xb8
 8016a24:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016a26:	9308      	str	r3, [sp, #32]
 8016a28:	3301      	adds	r3, #1
 8016a2a:	932d      	str	r3, [sp, #180]	; 0xb4
 8016a2c:	2b07      	cmp	r3, #7
 8016a2e:	dd08      	ble.n	8016a42 <_svfprintf_r+0xfa2>
 8016a30:	aa2c      	add	r2, sp, #176	; 0xb0
 8016a32:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016a34:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016a36:	f002 f987 	bl	8018d48 <__ssprint_r>
 8016a3a:	2800      	cmp	r0, #0
 8016a3c:	d000      	beq.n	8016a40 <_svfprintf_r+0xfa0>
 8016a3e:	e253      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016a40:	af2f      	add	r7, sp, #188	; 0xbc
 8016a42:	9c26      	ldr	r4, [sp, #152]	; 0x98
 8016a44:	2c00      	cmp	r4, #0
 8016a46:	da1a      	bge.n	8016a7e <_svfprintf_r+0xfde>
 8016a48:	0039      	movs	r1, r7
 8016a4a:	2510      	movs	r5, #16
 8016a4c:	4264      	negs	r4, r4
 8016a4e:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016a50:	982e      	ldr	r0, [sp, #184]	; 0xb8
 8016a52:	9308      	str	r3, [sp, #32]
 8016a54:	1c5a      	adds	r2, r3, #1
 8016a56:	4b21      	ldr	r3, [pc, #132]	; (8016adc <_svfprintf_r+0x103c>)
 8016a58:	3708      	adds	r7, #8
 8016a5a:	600b      	str	r3, [r1, #0]
 8016a5c:	2c10      	cmp	r4, #16
 8016a5e:	dc29      	bgt.n	8016ab4 <_svfprintf_r+0x1014>
 8016a60:	604c      	str	r4, [r1, #4]
 8016a62:	1824      	adds	r4, r4, r0
 8016a64:	942e      	str	r4, [sp, #184]	; 0xb8
 8016a66:	922d      	str	r2, [sp, #180]	; 0xb4
 8016a68:	2a07      	cmp	r2, #7
 8016a6a:	dd08      	ble.n	8016a7e <_svfprintf_r+0xfde>
 8016a6c:	aa2c      	add	r2, sp, #176	; 0xb0
 8016a6e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016a70:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016a72:	f002 f969 	bl	8018d48 <__ssprint_r>
 8016a76:	2800      	cmp	r0, #0
 8016a78:	d000      	beq.n	8016a7c <_svfprintf_r+0xfdc>
 8016a7a:	e235      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016a7c:	af2f      	add	r7, sp, #188	; 0xbc
 8016a7e:	990d      	ldr	r1, [sp, #52]	; 0x34
 8016a80:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016a82:	468c      	mov	ip, r1
 8016a84:	603b      	str	r3, [r7, #0]
 8016a86:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016a88:	607b      	str	r3, [r7, #4]
 8016a8a:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016a8c:	4463      	add	r3, ip
 8016a8e:	932e      	str	r3, [sp, #184]	; 0xb8
 8016a90:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016a92:	1c5a      	adds	r2, r3, #1
 8016a94:	9308      	str	r3, [sp, #32]
 8016a96:	922d      	str	r2, [sp, #180]	; 0xb4
 8016a98:	2a07      	cmp	r2, #7
 8016a9a:	dc01      	bgt.n	8016aa0 <_svfprintf_r+0x1000>
 8016a9c:	f7ff fa6c 	bl	8015f78 <_svfprintf_r+0x4d8>
 8016aa0:	aa2c      	add	r2, sp, #176	; 0xb0
 8016aa2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016aa4:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016aa6:	f002 f94f 	bl	8018d48 <__ssprint_r>
 8016aaa:	2800      	cmp	r0, #0
 8016aac:	d000      	beq.n	8016ab0 <_svfprintf_r+0x1010>
 8016aae:	e21b      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016ab0:	af2f      	add	r7, sp, #188	; 0xbc
 8016ab2:	e748      	b.n	8016946 <_svfprintf_r+0xea6>
 8016ab4:	3010      	adds	r0, #16
 8016ab6:	604d      	str	r5, [r1, #4]
 8016ab8:	902e      	str	r0, [sp, #184]	; 0xb8
 8016aba:	922d      	str	r2, [sp, #180]	; 0xb4
 8016abc:	2a07      	cmp	r2, #7
 8016abe:	dd08      	ble.n	8016ad2 <_svfprintf_r+0x1032>
 8016ac0:	aa2c      	add	r2, sp, #176	; 0xb0
 8016ac2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016ac4:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016ac6:	f002 f93f 	bl	8018d48 <__ssprint_r>
 8016aca:	2800      	cmp	r0, #0
 8016acc:	d000      	beq.n	8016ad0 <_svfprintf_r+0x1030>
 8016ace:	e20b      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016ad0:	af2f      	add	r7, sp, #188	; 0xbc
 8016ad2:	3c10      	subs	r4, #16
 8016ad4:	0039      	movs	r1, r7
 8016ad6:	e7ba      	b.n	8016a4e <_svfprintf_r+0xfae>
 8016ad8:	08019147 	.word	0x08019147
 8016adc:	0801c61a 	.word	0x0801c61a
 8016ae0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016ae2:	002c      	movs	r4, r5
 8016ae4:	429d      	cmp	r5, r3
 8016ae6:	dd00      	ble.n	8016aea <_svfprintf_r+0x104a>
 8016ae8:	001c      	movs	r4, r3
 8016aea:	2c00      	cmp	r4, #0
 8016aec:	dd15      	ble.n	8016b1a <_svfprintf_r+0x107a>
 8016aee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016af0:	607c      	str	r4, [r7, #4]
 8016af2:	603b      	str	r3, [r7, #0]
 8016af4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8016af6:	3708      	adds	r7, #8
 8016af8:	18e3      	adds	r3, r4, r3
 8016afa:	932e      	str	r3, [sp, #184]	; 0xb8
 8016afc:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016afe:	9308      	str	r3, [sp, #32]
 8016b00:	3301      	adds	r3, #1
 8016b02:	932d      	str	r3, [sp, #180]	; 0xb4
 8016b04:	2b07      	cmp	r3, #7
 8016b06:	dd08      	ble.n	8016b1a <_svfprintf_r+0x107a>
 8016b08:	aa2c      	add	r2, sp, #176	; 0xb0
 8016b0a:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016b0c:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016b0e:	f002 f91b 	bl	8018d48 <__ssprint_r>
 8016b12:	2800      	cmp	r0, #0
 8016b14:	d000      	beq.n	8016b18 <_svfprintf_r+0x1078>
 8016b16:	e1e7      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016b18:	af2f      	add	r7, sp, #188	; 0xbc
 8016b1a:	43e3      	mvns	r3, r4
 8016b1c:	17db      	asrs	r3, r3, #31
 8016b1e:	401c      	ands	r4, r3
 8016b20:	1b2c      	subs	r4, r5, r4
 8016b22:	2c00      	cmp	r4, #0
 8016b24:	dd1a      	ble.n	8016b5c <_svfprintf_r+0x10bc>
 8016b26:	0039      	movs	r1, r7
 8016b28:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016b2a:	48d4      	ldr	r0, [pc, #848]	; (8016e7c <_svfprintf_r+0x13dc>)
 8016b2c:	9308      	str	r3, [sp, #32]
 8016b2e:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8016b30:	3301      	adds	r3, #1
 8016b32:	3108      	adds	r1, #8
 8016b34:	6038      	str	r0, [r7, #0]
 8016b36:	2c10      	cmp	r4, #16
 8016b38:	dd00      	ble.n	8016b3c <_svfprintf_r+0x109c>
 8016b3a:	e089      	b.n	8016c50 <_svfprintf_r+0x11b0>
 8016b3c:	607c      	str	r4, [r7, #4]
 8016b3e:	18a4      	adds	r4, r4, r2
 8016b40:	942e      	str	r4, [sp, #184]	; 0xb8
 8016b42:	932d      	str	r3, [sp, #180]	; 0xb4
 8016b44:	000f      	movs	r7, r1
 8016b46:	2b07      	cmp	r3, #7
 8016b48:	dd08      	ble.n	8016b5c <_svfprintf_r+0x10bc>
 8016b4a:	aa2c      	add	r2, sp, #176	; 0xb0
 8016b4c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016b4e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016b50:	f002 f8fa 	bl	8018d48 <__ssprint_r>
 8016b54:	2800      	cmp	r0, #0
 8016b56:	d000      	beq.n	8016b5a <_svfprintf_r+0x10ba>
 8016b58:	e1c6      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016b5a:	af2f      	add	r7, sp, #188	; 0xbc
 8016b5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016b5e:	195d      	adds	r5, r3, r5
 8016b60:	0573      	lsls	r3, r6, #21
 8016b62:	d50d      	bpl.n	8016b80 <_svfprintf_r+0x10e0>
 8016b64:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8016b66:	2b00      	cmp	r3, #0
 8016b68:	d000      	beq.n	8016b6c <_svfprintf_r+0x10cc>
 8016b6a:	e084      	b.n	8016c76 <_svfprintf_r+0x11d6>
 8016b6c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8016b6e:	2b00      	cmp	r3, #0
 8016b70:	d000      	beq.n	8016b74 <_svfprintf_r+0x10d4>
 8016b72:	e083      	b.n	8016c7c <_svfprintf_r+0x11dc>
 8016b74:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016b76:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8016b78:	189b      	adds	r3, r3, r2
 8016b7a:	429d      	cmp	r5, r3
 8016b7c:	d900      	bls.n	8016b80 <_svfprintf_r+0x10e0>
 8016b7e:	001d      	movs	r5, r3
 8016b80:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8016b82:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8016b84:	4293      	cmp	r3, r2
 8016b86:	db01      	blt.n	8016b8c <_svfprintf_r+0x10ec>
 8016b88:	07f3      	lsls	r3, r6, #31
 8016b8a:	d518      	bpl.n	8016bbe <_svfprintf_r+0x111e>
 8016b8c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8016b8e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8016b90:	4694      	mov	ip, r2
 8016b92:	603b      	str	r3, [r7, #0]
 8016b94:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8016b96:	607b      	str	r3, [r7, #4]
 8016b98:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016b9a:	3708      	adds	r7, #8
 8016b9c:	4463      	add	r3, ip
 8016b9e:	932e      	str	r3, [sp, #184]	; 0xb8
 8016ba0:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016ba2:	9308      	str	r3, [sp, #32]
 8016ba4:	3301      	adds	r3, #1
 8016ba6:	932d      	str	r3, [sp, #180]	; 0xb4
 8016ba8:	2b07      	cmp	r3, #7
 8016baa:	dd08      	ble.n	8016bbe <_svfprintf_r+0x111e>
 8016bac:	aa2c      	add	r2, sp, #176	; 0xb0
 8016bae:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016bb0:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016bb2:	f002 f8c9 	bl	8018d48 <__ssprint_r>
 8016bb6:	2800      	cmp	r0, #0
 8016bb8:	d000      	beq.n	8016bbc <_svfprintf_r+0x111c>
 8016bba:	e195      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016bbc:	af2f      	add	r7, sp, #188	; 0xbc
 8016bbe:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8016bc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016bc2:	4694      	mov	ip, r2
 8016bc4:	9926      	ldr	r1, [sp, #152]	; 0x98
 8016bc6:	4463      	add	r3, ip
 8016bc8:	1b5b      	subs	r3, r3, r5
 8016bca:	1a54      	subs	r4, r2, r1
 8016bcc:	429c      	cmp	r4, r3
 8016bce:	dd00      	ble.n	8016bd2 <_svfprintf_r+0x1132>
 8016bd0:	001c      	movs	r4, r3
 8016bd2:	2c00      	cmp	r4, #0
 8016bd4:	dd14      	ble.n	8016c00 <_svfprintf_r+0x1160>
 8016bd6:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016bd8:	603d      	str	r5, [r7, #0]
 8016bda:	18e3      	adds	r3, r4, r3
 8016bdc:	932e      	str	r3, [sp, #184]	; 0xb8
 8016bde:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016be0:	607c      	str	r4, [r7, #4]
 8016be2:	9308      	str	r3, [sp, #32]
 8016be4:	3301      	adds	r3, #1
 8016be6:	932d      	str	r3, [sp, #180]	; 0xb4
 8016be8:	3708      	adds	r7, #8
 8016bea:	2b07      	cmp	r3, #7
 8016bec:	dd08      	ble.n	8016c00 <_svfprintf_r+0x1160>
 8016bee:	aa2c      	add	r2, sp, #176	; 0xb0
 8016bf0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016bf2:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016bf4:	f002 f8a8 	bl	8018d48 <__ssprint_r>
 8016bf8:	2800      	cmp	r0, #0
 8016bfa:	d000      	beq.n	8016bfe <_svfprintf_r+0x115e>
 8016bfc:	e174      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016bfe:	af2f      	add	r7, sp, #188	; 0xbc
 8016c00:	43e3      	mvns	r3, r4
 8016c02:	17db      	asrs	r3, r3, #31
 8016c04:	401c      	ands	r4, r3
 8016c06:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8016c08:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016c0a:	2510      	movs	r5, #16
 8016c0c:	1a9b      	subs	r3, r3, r2
 8016c0e:	1b1c      	subs	r4, r3, r4
 8016c10:	2c00      	cmp	r4, #0
 8016c12:	dc00      	bgt.n	8016c16 <_svfprintf_r+0x1176>
 8016c14:	e697      	b.n	8016946 <_svfprintf_r+0xea6>
 8016c16:	0039      	movs	r1, r7
 8016c18:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016c1a:	4898      	ldr	r0, [pc, #608]	; (8016e7c <_svfprintf_r+0x13dc>)
 8016c1c:	9308      	str	r3, [sp, #32]
 8016c1e:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8016c20:	3301      	adds	r3, #1
 8016c22:	3108      	adds	r1, #8
 8016c24:	6038      	str	r0, [r7, #0]
 8016c26:	2c10      	cmp	r4, #16
 8016c28:	dc00      	bgt.n	8016c2c <_svfprintf_r+0x118c>
 8016c2a:	e6c6      	b.n	80169ba <_svfprintf_r+0xf1a>
 8016c2c:	3210      	adds	r2, #16
 8016c2e:	607d      	str	r5, [r7, #4]
 8016c30:	922e      	str	r2, [sp, #184]	; 0xb8
 8016c32:	932d      	str	r3, [sp, #180]	; 0xb4
 8016c34:	2b07      	cmp	r3, #7
 8016c36:	dd08      	ble.n	8016c4a <_svfprintf_r+0x11aa>
 8016c38:	aa2c      	add	r2, sp, #176	; 0xb0
 8016c3a:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016c3c:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016c3e:	f002 f883 	bl	8018d48 <__ssprint_r>
 8016c42:	2800      	cmp	r0, #0
 8016c44:	d000      	beq.n	8016c48 <_svfprintf_r+0x11a8>
 8016c46:	e14f      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016c48:	a92f      	add	r1, sp, #188	; 0xbc
 8016c4a:	3c10      	subs	r4, #16
 8016c4c:	000f      	movs	r7, r1
 8016c4e:	e7e2      	b.n	8016c16 <_svfprintf_r+0x1176>
 8016c50:	2010      	movs	r0, #16
 8016c52:	1812      	adds	r2, r2, r0
 8016c54:	6078      	str	r0, [r7, #4]
 8016c56:	922e      	str	r2, [sp, #184]	; 0xb8
 8016c58:	932d      	str	r3, [sp, #180]	; 0xb4
 8016c5a:	2b07      	cmp	r3, #7
 8016c5c:	dd08      	ble.n	8016c70 <_svfprintf_r+0x11d0>
 8016c5e:	aa2c      	add	r2, sp, #176	; 0xb0
 8016c60:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016c62:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016c64:	f002 f870 	bl	8018d48 <__ssprint_r>
 8016c68:	2800      	cmp	r0, #0
 8016c6a:	d000      	beq.n	8016c6e <_svfprintf_r+0x11ce>
 8016c6c:	e13c      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016c6e:	a92f      	add	r1, sp, #188	; 0xbc
 8016c70:	3c10      	subs	r4, #16
 8016c72:	000f      	movs	r7, r1
 8016c74:	e757      	b.n	8016b26 <_svfprintf_r+0x1086>
 8016c76:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8016c78:	2b00      	cmp	r3, #0
 8016c7a:	d061      	beq.n	8016d40 <_svfprintf_r+0x12a0>
 8016c7c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8016c7e:	3b01      	subs	r3, #1
 8016c80:	9310      	str	r3, [sp, #64]	; 0x40
 8016c82:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8016c84:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8016c86:	4694      	mov	ip, r2
 8016c88:	603b      	str	r3, [r7, #0]
 8016c8a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8016c8c:	607b      	str	r3, [r7, #4]
 8016c8e:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016c90:	3708      	adds	r7, #8
 8016c92:	4463      	add	r3, ip
 8016c94:	932e      	str	r3, [sp, #184]	; 0xb8
 8016c96:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016c98:	9308      	str	r3, [sp, #32]
 8016c9a:	3301      	adds	r3, #1
 8016c9c:	932d      	str	r3, [sp, #180]	; 0xb4
 8016c9e:	2b07      	cmp	r3, #7
 8016ca0:	dd08      	ble.n	8016cb4 <_svfprintf_r+0x1214>
 8016ca2:	aa2c      	add	r2, sp, #176	; 0xb0
 8016ca4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016ca6:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016ca8:	f002 f84e 	bl	8018d48 <__ssprint_r>
 8016cac:	2800      	cmp	r0, #0
 8016cae:	d000      	beq.n	8016cb2 <_svfprintf_r+0x1212>
 8016cb0:	e11a      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016cb2:	af2f      	add	r7, sp, #188	; 0xbc
 8016cb4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8016cb6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016cb8:	189b      	adds	r3, r3, r2
 8016cba:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8016cbc:	1b5b      	subs	r3, r3, r5
 8016cbe:	7814      	ldrb	r4, [r2, #0]
 8016cc0:	429c      	cmp	r4, r3
 8016cc2:	dd00      	ble.n	8016cc6 <_svfprintf_r+0x1226>
 8016cc4:	001c      	movs	r4, r3
 8016cc6:	2c00      	cmp	r4, #0
 8016cc8:	dd14      	ble.n	8016cf4 <_svfprintf_r+0x1254>
 8016cca:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016ccc:	603d      	str	r5, [r7, #0]
 8016cce:	18e3      	adds	r3, r4, r3
 8016cd0:	932e      	str	r3, [sp, #184]	; 0xb8
 8016cd2:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016cd4:	607c      	str	r4, [r7, #4]
 8016cd6:	9308      	str	r3, [sp, #32]
 8016cd8:	3301      	adds	r3, #1
 8016cda:	932d      	str	r3, [sp, #180]	; 0xb4
 8016cdc:	3708      	adds	r7, #8
 8016cde:	2b07      	cmp	r3, #7
 8016ce0:	dd08      	ble.n	8016cf4 <_svfprintf_r+0x1254>
 8016ce2:	aa2c      	add	r2, sp, #176	; 0xb0
 8016ce4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016ce6:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016ce8:	f002 f82e 	bl	8018d48 <__ssprint_r>
 8016cec:	2800      	cmp	r0, #0
 8016cee:	d000      	beq.n	8016cf2 <_svfprintf_r+0x1252>
 8016cf0:	e0fa      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016cf2:	af2f      	add	r7, sp, #188	; 0xbc
 8016cf4:	43e3      	mvns	r3, r4
 8016cf6:	17db      	asrs	r3, r3, #31
 8016cf8:	401c      	ands	r4, r3
 8016cfa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8016cfc:	781b      	ldrb	r3, [r3, #0]
 8016cfe:	1b1c      	subs	r4, r3, r4
 8016d00:	2c00      	cmp	r4, #0
 8016d02:	dd19      	ble.n	8016d38 <_svfprintf_r+0x1298>
 8016d04:	0039      	movs	r1, r7
 8016d06:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016d08:	485c      	ldr	r0, [pc, #368]	; (8016e7c <_svfprintf_r+0x13dc>)
 8016d0a:	9308      	str	r3, [sp, #32]
 8016d0c:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8016d0e:	3301      	adds	r3, #1
 8016d10:	3108      	adds	r1, #8
 8016d12:	6038      	str	r0, [r7, #0]
 8016d14:	2c10      	cmp	r4, #16
 8016d16:	dc1a      	bgt.n	8016d4e <_svfprintf_r+0x12ae>
 8016d18:	607c      	str	r4, [r7, #4]
 8016d1a:	18a4      	adds	r4, r4, r2
 8016d1c:	942e      	str	r4, [sp, #184]	; 0xb8
 8016d1e:	932d      	str	r3, [sp, #180]	; 0xb4
 8016d20:	000f      	movs	r7, r1
 8016d22:	2b07      	cmp	r3, #7
 8016d24:	dd08      	ble.n	8016d38 <_svfprintf_r+0x1298>
 8016d26:	aa2c      	add	r2, sp, #176	; 0xb0
 8016d28:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016d2a:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016d2c:	f002 f80c 	bl	8018d48 <__ssprint_r>
 8016d30:	2800      	cmp	r0, #0
 8016d32:	d000      	beq.n	8016d36 <_svfprintf_r+0x1296>
 8016d34:	e0d8      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016d36:	af2f      	add	r7, sp, #188	; 0xbc
 8016d38:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8016d3a:	781b      	ldrb	r3, [r3, #0]
 8016d3c:	18ed      	adds	r5, r5, r3
 8016d3e:	e711      	b.n	8016b64 <_svfprintf_r+0x10c4>
 8016d40:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8016d42:	3b01      	subs	r3, #1
 8016d44:	9313      	str	r3, [sp, #76]	; 0x4c
 8016d46:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8016d48:	3b01      	subs	r3, #1
 8016d4a:	930f      	str	r3, [sp, #60]	; 0x3c
 8016d4c:	e799      	b.n	8016c82 <_svfprintf_r+0x11e2>
 8016d4e:	2010      	movs	r0, #16
 8016d50:	1812      	adds	r2, r2, r0
 8016d52:	6078      	str	r0, [r7, #4]
 8016d54:	922e      	str	r2, [sp, #184]	; 0xb8
 8016d56:	932d      	str	r3, [sp, #180]	; 0xb4
 8016d58:	2b07      	cmp	r3, #7
 8016d5a:	dd08      	ble.n	8016d6e <_svfprintf_r+0x12ce>
 8016d5c:	aa2c      	add	r2, sp, #176	; 0xb0
 8016d5e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016d60:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016d62:	f001 fff1 	bl	8018d48 <__ssprint_r>
 8016d66:	2800      	cmp	r0, #0
 8016d68:	d000      	beq.n	8016d6c <_svfprintf_r+0x12cc>
 8016d6a:	e0bd      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016d6c:	a92f      	add	r1, sp, #188	; 0xbc
 8016d6e:	3c10      	subs	r4, #16
 8016d70:	000f      	movs	r7, r1
 8016d72:	e7c7      	b.n	8016d04 <_svfprintf_r+0x1264>
 8016d74:	003c      	movs	r4, r7
 8016d76:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016d78:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8016d7a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8016d7c:	9308      	str	r3, [sp, #32]
 8016d7e:	3101      	adds	r1, #1
 8016d80:	3301      	adds	r3, #1
 8016d82:	3408      	adds	r4, #8
 8016d84:	2a01      	cmp	r2, #1
 8016d86:	dc03      	bgt.n	8016d90 <_svfprintf_r+0x12f0>
 8016d88:	2201      	movs	r2, #1
 8016d8a:	4216      	tst	r6, r2
 8016d8c:	d100      	bne.n	8016d90 <_svfprintf_r+0x12f0>
 8016d8e:	e088      	b.n	8016ea2 <_svfprintf_r+0x1402>
 8016d90:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8016d92:	912e      	str	r1, [sp, #184]	; 0xb8
 8016d94:	603a      	str	r2, [r7, #0]
 8016d96:	2201      	movs	r2, #1
 8016d98:	932d      	str	r3, [sp, #180]	; 0xb4
 8016d9a:	607a      	str	r2, [r7, #4]
 8016d9c:	2b07      	cmp	r3, #7
 8016d9e:	dd08      	ble.n	8016db2 <_svfprintf_r+0x1312>
 8016da0:	aa2c      	add	r2, sp, #176	; 0xb0
 8016da2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016da4:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016da6:	f001 ffcf 	bl	8018d48 <__ssprint_r>
 8016daa:	2800      	cmp	r0, #0
 8016dac:	d000      	beq.n	8016db0 <_svfprintf_r+0x1310>
 8016dae:	e09b      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016db0:	ac2f      	add	r4, sp, #188	; 0xbc
 8016db2:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8016db4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8016db6:	4694      	mov	ip, r2
 8016db8:	6023      	str	r3, [r4, #0]
 8016dba:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8016dbc:	6063      	str	r3, [r4, #4]
 8016dbe:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016dc0:	3408      	adds	r4, #8
 8016dc2:	4463      	add	r3, ip
 8016dc4:	932e      	str	r3, [sp, #184]	; 0xb8
 8016dc6:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016dc8:	9308      	str	r3, [sp, #32]
 8016dca:	3301      	adds	r3, #1
 8016dcc:	932d      	str	r3, [sp, #180]	; 0xb4
 8016dce:	2b07      	cmp	r3, #7
 8016dd0:	dd08      	ble.n	8016de4 <_svfprintf_r+0x1344>
 8016dd2:	aa2c      	add	r2, sp, #176	; 0xb0
 8016dd4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016dd6:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016dd8:	f001 ffb6 	bl	8018d48 <__ssprint_r>
 8016ddc:	2800      	cmp	r0, #0
 8016dde:	d000      	beq.n	8016de2 <_svfprintf_r+0x1342>
 8016de0:	e082      	b.n	8016ee8 <_svfprintf_r+0x1448>
 8016de2:	ac2f      	add	r4, sp, #188	; 0xbc
 8016de4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016de6:	2200      	movs	r2, #0
 8016de8:	1e5d      	subs	r5, r3, #1
 8016dea:	981a      	ldr	r0, [sp, #104]	; 0x68
 8016dec:	2300      	movs	r3, #0
 8016dee:	9919      	ldr	r1, [sp, #100]	; 0x64
 8016df0:	f7e9 fb54 	bl	800049c <__aeabi_dcmpeq>
 8016df4:	2800      	cmp	r0, #0
 8016df6:	d12c      	bne.n	8016e52 <_svfprintf_r+0x13b2>
 8016df8:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016dfa:	990d      	ldr	r1, [sp, #52]	; 0x34
 8016dfc:	9308      	str	r3, [sp, #32]
 8016dfe:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016e00:	6065      	str	r5, [r4, #4]
 8016e02:	1c5a      	adds	r2, r3, #1
 8016e04:	930e      	str	r3, [sp, #56]	; 0x38
 8016e06:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016e08:	922d      	str	r2, [sp, #180]	; 0xb4
 8016e0a:	3301      	adds	r3, #1
 8016e0c:	6023      	str	r3, [r4, #0]
 8016e0e:	9b08      	ldr	r3, [sp, #32]
 8016e10:	3408      	adds	r4, #8
 8016e12:	3b01      	subs	r3, #1
 8016e14:	185b      	adds	r3, r3, r1
 8016e16:	932e      	str	r3, [sp, #184]	; 0xb8
 8016e18:	2a07      	cmp	r2, #7
 8016e1a:	dd07      	ble.n	8016e2c <_svfprintf_r+0x138c>
 8016e1c:	aa2c      	add	r2, sp, #176	; 0xb0
 8016e1e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016e20:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016e22:	f001 ff91 	bl	8018d48 <__ssprint_r>
 8016e26:	2800      	cmp	r0, #0
 8016e28:	d15e      	bne.n	8016ee8 <_svfprintf_r+0x1448>
 8016e2a:	ac2f      	add	r4, sp, #188	; 0xbc
 8016e2c:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8016e2e:	ab28      	add	r3, sp, #160	; 0xa0
 8016e30:	4694      	mov	ip, r2
 8016e32:	6023      	str	r3, [r4, #0]
 8016e34:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016e36:	6063      	str	r3, [r4, #4]
 8016e38:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016e3a:	4463      	add	r3, ip
 8016e3c:	932e      	str	r3, [sp, #184]	; 0xb8
 8016e3e:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016e40:	9308      	str	r3, [sp, #32]
 8016e42:	3301      	adds	r3, #1
 8016e44:	932d      	str	r3, [sp, #180]	; 0xb4
 8016e46:	2b07      	cmp	r3, #7
 8016e48:	dd00      	ble.n	8016e4c <_svfprintf_r+0x13ac>
 8016e4a:	e629      	b.n	8016aa0 <_svfprintf_r+0x1000>
 8016e4c:	3408      	adds	r4, #8
 8016e4e:	0027      	movs	r7, r4
 8016e50:	e579      	b.n	8016946 <_svfprintf_r+0xea6>
 8016e52:	2710      	movs	r7, #16
 8016e54:	2d00      	cmp	r5, #0
 8016e56:	dde9      	ble.n	8016e2c <_svfprintf_r+0x138c>
 8016e58:	0021      	movs	r1, r4
 8016e5a:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016e5c:	4807      	ldr	r0, [pc, #28]	; (8016e7c <_svfprintf_r+0x13dc>)
 8016e5e:	9308      	str	r3, [sp, #32]
 8016e60:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8016e62:	3301      	adds	r3, #1
 8016e64:	3108      	adds	r1, #8
 8016e66:	6020      	str	r0, [r4, #0]
 8016e68:	2d10      	cmp	r5, #16
 8016e6a:	dc09      	bgt.n	8016e80 <_svfprintf_r+0x13e0>
 8016e6c:	6065      	str	r5, [r4, #4]
 8016e6e:	000c      	movs	r4, r1
 8016e70:	18ad      	adds	r5, r5, r2
 8016e72:	952e      	str	r5, [sp, #184]	; 0xb8
 8016e74:	932d      	str	r3, [sp, #180]	; 0xb4
 8016e76:	2b07      	cmp	r3, #7
 8016e78:	ddd8      	ble.n	8016e2c <_svfprintf_r+0x138c>
 8016e7a:	e7cf      	b.n	8016e1c <_svfprintf_r+0x137c>
 8016e7c:	0801c61a 	.word	0x0801c61a
 8016e80:	3210      	adds	r2, #16
 8016e82:	6067      	str	r7, [r4, #4]
 8016e84:	922e      	str	r2, [sp, #184]	; 0xb8
 8016e86:	932d      	str	r3, [sp, #180]	; 0xb4
 8016e88:	2b07      	cmp	r3, #7
 8016e8a:	dd07      	ble.n	8016e9c <_svfprintf_r+0x13fc>
 8016e8c:	aa2c      	add	r2, sp, #176	; 0xb0
 8016e8e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016e90:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016e92:	f001 ff59 	bl	8018d48 <__ssprint_r>
 8016e96:	2800      	cmp	r0, #0
 8016e98:	d126      	bne.n	8016ee8 <_svfprintf_r+0x1448>
 8016e9a:	a92f      	add	r1, sp, #188	; 0xbc
 8016e9c:	3d10      	subs	r5, #16
 8016e9e:	000c      	movs	r4, r1
 8016ea0:	e7da      	b.n	8016e58 <_svfprintf_r+0x13b8>
 8016ea2:	9809      	ldr	r0, [sp, #36]	; 0x24
 8016ea4:	912e      	str	r1, [sp, #184]	; 0xb8
 8016ea6:	c705      	stmia	r7!, {r0, r2}
 8016ea8:	932d      	str	r3, [sp, #180]	; 0xb4
 8016eaa:	e7e4      	b.n	8016e76 <_svfprintf_r+0x13d6>
 8016eac:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8016eae:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8016eb0:	2510      	movs	r5, #16
 8016eb2:	1a9c      	subs	r4, r3, r2
 8016eb4:	2c00      	cmp	r4, #0
 8016eb6:	dc00      	bgt.n	8016eba <_svfprintf_r+0x141a>
 8016eb8:	e548      	b.n	801694c <_svfprintf_r+0xeac>
 8016eba:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8016ebc:	4921      	ldr	r1, [pc, #132]	; (8016f44 <_svfprintf_r+0x14a4>)
 8016ebe:	9308      	str	r3, [sp, #32]
 8016ec0:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8016ec2:	3301      	adds	r3, #1
 8016ec4:	6039      	str	r1, [r7, #0]
 8016ec6:	2c10      	cmp	r4, #16
 8016ec8:	dc19      	bgt.n	8016efe <_svfprintf_r+0x145e>
 8016eca:	607c      	str	r4, [r7, #4]
 8016ecc:	18a4      	adds	r4, r4, r2
 8016ece:	942e      	str	r4, [sp, #184]	; 0xb8
 8016ed0:	932d      	str	r3, [sp, #180]	; 0xb4
 8016ed2:	2b07      	cmp	r3, #7
 8016ed4:	dc00      	bgt.n	8016ed8 <_svfprintf_r+0x1438>
 8016ed6:	e539      	b.n	801694c <_svfprintf_r+0xeac>
 8016ed8:	aa2c      	add	r2, sp, #176	; 0xb0
 8016eda:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016edc:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016ede:	f001 ff33 	bl	8018d48 <__ssprint_r>
 8016ee2:	2800      	cmp	r0, #0
 8016ee4:	d100      	bne.n	8016ee8 <_svfprintf_r+0x1448>
 8016ee6:	e531      	b.n	801694c <_svfprintf_r+0xeac>
 8016ee8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8016eea:	2b00      	cmp	r3, #0
 8016eec:	d101      	bne.n	8016ef2 <_svfprintf_r+0x1452>
 8016eee:	f7ff f908 	bl	8016102 <_svfprintf_r+0x662>
 8016ef2:	0019      	movs	r1, r3
 8016ef4:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016ef6:	f000 ff19 	bl	8017d2c <_free_r>
 8016efa:	f7ff f902 	bl	8016102 <_svfprintf_r+0x662>
 8016efe:	3210      	adds	r2, #16
 8016f00:	607d      	str	r5, [r7, #4]
 8016f02:	922e      	str	r2, [sp, #184]	; 0xb8
 8016f04:	932d      	str	r3, [sp, #180]	; 0xb4
 8016f06:	3708      	adds	r7, #8
 8016f08:	2b07      	cmp	r3, #7
 8016f0a:	dd07      	ble.n	8016f1c <_svfprintf_r+0x147c>
 8016f0c:	aa2c      	add	r2, sp, #176	; 0xb0
 8016f0e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016f10:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016f12:	f001 ff19 	bl	8018d48 <__ssprint_r>
 8016f16:	2800      	cmp	r0, #0
 8016f18:	d1e6      	bne.n	8016ee8 <_svfprintf_r+0x1448>
 8016f1a:	af2f      	add	r7, sp, #188	; 0xbc
 8016f1c:	3c10      	subs	r4, #16
 8016f1e:	e7cc      	b.n	8016eba <_svfprintf_r+0x141a>
 8016f20:	990c      	ldr	r1, [sp, #48]	; 0x30
 8016f22:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016f24:	f000 ff02 	bl	8017d2c <_free_r>
 8016f28:	e52a      	b.n	8016980 <_svfprintf_r+0xee0>
 8016f2a:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8016f2c:	9306      	str	r3, [sp, #24]
 8016f2e:	2b00      	cmp	r3, #0
 8016f30:	d101      	bne.n	8016f36 <_svfprintf_r+0x1496>
 8016f32:	f7ff f8e6 	bl	8016102 <_svfprintf_r+0x662>
 8016f36:	aa2c      	add	r2, sp, #176	; 0xb0
 8016f38:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8016f3a:	980a      	ldr	r0, [sp, #40]	; 0x28
 8016f3c:	f001 ff04 	bl	8018d48 <__ssprint_r>
 8016f40:	f7ff f8df 	bl	8016102 <_svfprintf_r+0x662>
 8016f44:	0801c60a 	.word	0x0801c60a

08016f48 <sysconf>:
 8016f48:	2380      	movs	r3, #128	; 0x80
 8016f4a:	b510      	push	{r4, lr}
 8016f4c:	015b      	lsls	r3, r3, #5
 8016f4e:	2808      	cmp	r0, #8
 8016f50:	d004      	beq.n	8016f5c <sysconf+0x14>
 8016f52:	f000 fe7d 	bl	8017c50 <__errno>
 8016f56:	2316      	movs	r3, #22
 8016f58:	6003      	str	r3, [r0, #0]
 8016f5a:	3b17      	subs	r3, #23
 8016f5c:	0018      	movs	r0, r3
 8016f5e:	bd10      	pop	{r4, pc}

08016f60 <__ascii_wctomb>:
 8016f60:	1e0b      	subs	r3, r1, #0
 8016f62:	d004      	beq.n	8016f6e <__ascii_wctomb+0xe>
 8016f64:	2aff      	cmp	r2, #255	; 0xff
 8016f66:	d904      	bls.n	8016f72 <__ascii_wctomb+0x12>
 8016f68:	238a      	movs	r3, #138	; 0x8a
 8016f6a:	6003      	str	r3, [r0, #0]
 8016f6c:	3b8b      	subs	r3, #139	; 0x8b
 8016f6e:	0018      	movs	r0, r3
 8016f70:	4770      	bx	lr
 8016f72:	700a      	strb	r2, [r1, #0]
 8016f74:	2301      	movs	r3, #1
 8016f76:	e7fa      	b.n	8016f6e <__ascii_wctomb+0xe>

08016f78 <register_fini>:
 8016f78:	4b03      	ldr	r3, [pc, #12]	; (8016f88 <register_fini+0x10>)
 8016f7a:	b510      	push	{r4, lr}
 8016f7c:	2b00      	cmp	r3, #0
 8016f7e:	d002      	beq.n	8016f86 <register_fini+0xe>
 8016f80:	4802      	ldr	r0, [pc, #8]	; (8016f8c <register_fini+0x14>)
 8016f82:	f000 f805 	bl	8016f90 <atexit>
 8016f86:	bd10      	pop	{r4, pc}
 8016f88:	00000000 	.word	0x00000000
 8016f8c:	08017c5d 	.word	0x08017c5d

08016f90 <atexit>:
 8016f90:	2300      	movs	r3, #0
 8016f92:	b510      	push	{r4, lr}
 8016f94:	0001      	movs	r1, r0
 8016f96:	001a      	movs	r2, r3
 8016f98:	0018      	movs	r0, r3
 8016f9a:	f001 ff53 	bl	8018e44 <__register_exitproc>
 8016f9e:	bd10      	pop	{r4, pc}

08016fa0 <quorem>:
 8016fa0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016fa2:	6903      	ldr	r3, [r0, #16]
 8016fa4:	690c      	ldr	r4, [r1, #16]
 8016fa6:	b089      	sub	sp, #36	; 0x24
 8016fa8:	0007      	movs	r7, r0
 8016faa:	9105      	str	r1, [sp, #20]
 8016fac:	2600      	movs	r6, #0
 8016fae:	42a3      	cmp	r3, r4
 8016fb0:	db65      	blt.n	801707e <quorem+0xde>
 8016fb2:	000b      	movs	r3, r1
 8016fb4:	3c01      	subs	r4, #1
 8016fb6:	3314      	adds	r3, #20
 8016fb8:	00a5      	lsls	r5, r4, #2
 8016fba:	9303      	str	r3, [sp, #12]
 8016fbc:	195b      	adds	r3, r3, r5
 8016fbe:	9304      	str	r3, [sp, #16]
 8016fc0:	0003      	movs	r3, r0
 8016fc2:	3314      	adds	r3, #20
 8016fc4:	9302      	str	r3, [sp, #8]
 8016fc6:	195d      	adds	r5, r3, r5
 8016fc8:	9b04      	ldr	r3, [sp, #16]
 8016fca:	6828      	ldr	r0, [r5, #0]
 8016fcc:	681b      	ldr	r3, [r3, #0]
 8016fce:	1c59      	adds	r1, r3, #1
 8016fd0:	9301      	str	r3, [sp, #4]
 8016fd2:	f7e9 f8d1 	bl	8000178 <__udivsi3>
 8016fd6:	9001      	str	r0, [sp, #4]
 8016fd8:	42b0      	cmp	r0, r6
 8016fda:	d029      	beq.n	8017030 <quorem+0x90>
 8016fdc:	9b03      	ldr	r3, [sp, #12]
 8016fde:	9802      	ldr	r0, [sp, #8]
 8016fe0:	469c      	mov	ip, r3
 8016fe2:	9606      	str	r6, [sp, #24]
 8016fe4:	4662      	mov	r2, ip
 8016fe6:	ca08      	ldmia	r2!, {r3}
 8016fe8:	4694      	mov	ip, r2
 8016fea:	9a01      	ldr	r2, [sp, #4]
 8016fec:	b299      	uxth	r1, r3
 8016fee:	4351      	muls	r1, r2
 8016ff0:	0c1b      	lsrs	r3, r3, #16
 8016ff2:	4353      	muls	r3, r2
 8016ff4:	1989      	adds	r1, r1, r6
 8016ff6:	0c0a      	lsrs	r2, r1, #16
 8016ff8:	189b      	adds	r3, r3, r2
 8016ffa:	9307      	str	r3, [sp, #28]
 8016ffc:	0c1e      	lsrs	r6, r3, #16
 8016ffe:	6803      	ldr	r3, [r0, #0]
 8017000:	b289      	uxth	r1, r1
 8017002:	b29a      	uxth	r2, r3
 8017004:	9b06      	ldr	r3, [sp, #24]
 8017006:	18d2      	adds	r2, r2, r3
 8017008:	6803      	ldr	r3, [r0, #0]
 801700a:	1a52      	subs	r2, r2, r1
 801700c:	0c19      	lsrs	r1, r3, #16
 801700e:	466b      	mov	r3, sp
 8017010:	8b9b      	ldrh	r3, [r3, #28]
 8017012:	1acb      	subs	r3, r1, r3
 8017014:	1411      	asrs	r1, r2, #16
 8017016:	185b      	adds	r3, r3, r1
 8017018:	1419      	asrs	r1, r3, #16
 801701a:	b292      	uxth	r2, r2
 801701c:	041b      	lsls	r3, r3, #16
 801701e:	431a      	orrs	r2, r3
 8017020:	9b04      	ldr	r3, [sp, #16]
 8017022:	9106      	str	r1, [sp, #24]
 8017024:	c004      	stmia	r0!, {r2}
 8017026:	4563      	cmp	r3, ip
 8017028:	d2dc      	bcs.n	8016fe4 <quorem+0x44>
 801702a:	682b      	ldr	r3, [r5, #0]
 801702c:	2b00      	cmp	r3, #0
 801702e:	d02d      	beq.n	801708c <quorem+0xec>
 8017030:	9905      	ldr	r1, [sp, #20]
 8017032:	0038      	movs	r0, r7
 8017034:	f001 fcb2 	bl	801899c <__mcmp>
 8017038:	2800      	cmp	r0, #0
 801703a:	db1f      	blt.n	801707c <quorem+0xdc>
 801703c:	2500      	movs	r5, #0
 801703e:	9b01      	ldr	r3, [sp, #4]
 8017040:	9802      	ldr	r0, [sp, #8]
 8017042:	3301      	adds	r3, #1
 8017044:	9903      	ldr	r1, [sp, #12]
 8017046:	9301      	str	r3, [sp, #4]
 8017048:	6802      	ldr	r2, [r0, #0]
 801704a:	c908      	ldmia	r1!, {r3}
 801704c:	b292      	uxth	r2, r2
 801704e:	1955      	adds	r5, r2, r5
 8017050:	b29a      	uxth	r2, r3
 8017052:	1aaa      	subs	r2, r5, r2
 8017054:	6805      	ldr	r5, [r0, #0]
 8017056:	0c1b      	lsrs	r3, r3, #16
 8017058:	0c2d      	lsrs	r5, r5, #16
 801705a:	1aeb      	subs	r3, r5, r3
 801705c:	1415      	asrs	r5, r2, #16
 801705e:	195b      	adds	r3, r3, r5
 8017060:	141d      	asrs	r5, r3, #16
 8017062:	b292      	uxth	r2, r2
 8017064:	041b      	lsls	r3, r3, #16
 8017066:	4313      	orrs	r3, r2
 8017068:	c008      	stmia	r0!, {r3}
 801706a:	9b04      	ldr	r3, [sp, #16]
 801706c:	428b      	cmp	r3, r1
 801706e:	d2eb      	bcs.n	8017048 <quorem+0xa8>
 8017070:	9a02      	ldr	r2, [sp, #8]
 8017072:	00a3      	lsls	r3, r4, #2
 8017074:	18d3      	adds	r3, r2, r3
 8017076:	681a      	ldr	r2, [r3, #0]
 8017078:	2a00      	cmp	r2, #0
 801707a:	d011      	beq.n	80170a0 <quorem+0x100>
 801707c:	9e01      	ldr	r6, [sp, #4]
 801707e:	0030      	movs	r0, r6
 8017080:	b009      	add	sp, #36	; 0x24
 8017082:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017084:	682b      	ldr	r3, [r5, #0]
 8017086:	2b00      	cmp	r3, #0
 8017088:	d104      	bne.n	8017094 <quorem+0xf4>
 801708a:	3c01      	subs	r4, #1
 801708c:	9b02      	ldr	r3, [sp, #8]
 801708e:	3d04      	subs	r5, #4
 8017090:	42ab      	cmp	r3, r5
 8017092:	d3f7      	bcc.n	8017084 <quorem+0xe4>
 8017094:	613c      	str	r4, [r7, #16]
 8017096:	e7cb      	b.n	8017030 <quorem+0x90>
 8017098:	681a      	ldr	r2, [r3, #0]
 801709a:	2a00      	cmp	r2, #0
 801709c:	d104      	bne.n	80170a8 <quorem+0x108>
 801709e:	3c01      	subs	r4, #1
 80170a0:	9a02      	ldr	r2, [sp, #8]
 80170a2:	3b04      	subs	r3, #4
 80170a4:	429a      	cmp	r2, r3
 80170a6:	d3f7      	bcc.n	8017098 <quorem+0xf8>
 80170a8:	613c      	str	r4, [r7, #16]
 80170aa:	e7e7      	b.n	801707c <quorem+0xdc>

080170ac <_dtoa_r>:
 80170ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80170ae:	0014      	movs	r4, r2
 80170b0:	001d      	movs	r5, r3
 80170b2:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80170b4:	b09b      	sub	sp, #108	; 0x6c
 80170b6:	9002      	str	r0, [sp, #8]
 80170b8:	9e23      	ldr	r6, [sp, #140]	; 0x8c
 80170ba:	9406      	str	r4, [sp, #24]
 80170bc:	9507      	str	r5, [sp, #28]
 80170be:	2900      	cmp	r1, #0
 80170c0:	d009      	beq.n	80170d6 <_dtoa_r+0x2a>
 80170c2:	2301      	movs	r3, #1
 80170c4:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80170c6:	4093      	lsls	r3, r2
 80170c8:	604a      	str	r2, [r1, #4]
 80170ca:	608b      	str	r3, [r1, #8]
 80170cc:	f001 fa6a 	bl	80185a4 <_Bfree>
 80170d0:	2300      	movs	r3, #0
 80170d2:	9a02      	ldr	r2, [sp, #8]
 80170d4:	6413      	str	r3, [r2, #64]	; 0x40
 80170d6:	2d00      	cmp	r5, #0
 80170d8:	da20      	bge.n	801711c <_dtoa_r+0x70>
 80170da:	2301      	movs	r3, #1
 80170dc:	6033      	str	r3, [r6, #0]
 80170de:	006b      	lsls	r3, r5, #1
 80170e0:	085b      	lsrs	r3, r3, #1
 80170e2:	9307      	str	r3, [sp, #28]
 80170e4:	9c07      	ldr	r4, [sp, #28]
 80170e6:	4bb2      	ldr	r3, [pc, #712]	; (80173b0 <_dtoa_r+0x304>)
 80170e8:	0022      	movs	r2, r4
 80170ea:	9317      	str	r3, [sp, #92]	; 0x5c
 80170ec:	401a      	ands	r2, r3
 80170ee:	429a      	cmp	r2, r3
 80170f0:	d117      	bne.n	8017122 <_dtoa_r+0x76>
 80170f2:	4bb0      	ldr	r3, [pc, #704]	; (80173b4 <_dtoa_r+0x308>)
 80170f4:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80170f6:	6013      	str	r3, [r2, #0]
 80170f8:	9b06      	ldr	r3, [sp, #24]
 80170fa:	2b00      	cmp	r3, #0
 80170fc:	d103      	bne.n	8017106 <_dtoa_r+0x5a>
 80170fe:	0324      	lsls	r4, r4, #12
 8017100:	d101      	bne.n	8017106 <_dtoa_r+0x5a>
 8017102:	f000 fd89 	bl	8017c18 <_dtoa_r+0xb6c>
 8017106:	4bac      	ldr	r3, [pc, #688]	; (80173b8 <_dtoa_r+0x30c>)
 8017108:	9a24      	ldr	r2, [sp, #144]	; 0x90
 801710a:	9308      	str	r3, [sp, #32]
 801710c:	2a00      	cmp	r2, #0
 801710e:	d002      	beq.n	8017116 <_dtoa_r+0x6a>
 8017110:	4baa      	ldr	r3, [pc, #680]	; (80173bc <_dtoa_r+0x310>)
 8017112:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8017114:	6013      	str	r3, [r2, #0]
 8017116:	9808      	ldr	r0, [sp, #32]
 8017118:	b01b      	add	sp, #108	; 0x6c
 801711a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801711c:	2300      	movs	r3, #0
 801711e:	6033      	str	r3, [r6, #0]
 8017120:	e7e0      	b.n	80170e4 <_dtoa_r+0x38>
 8017122:	9e06      	ldr	r6, [sp, #24]
 8017124:	9f07      	ldr	r7, [sp, #28]
 8017126:	2200      	movs	r2, #0
 8017128:	2300      	movs	r3, #0
 801712a:	0030      	movs	r0, r6
 801712c:	0039      	movs	r1, r7
 801712e:	f7e9 f9b5 	bl	800049c <__aeabi_dcmpeq>
 8017132:	1e05      	subs	r5, r0, #0
 8017134:	d00b      	beq.n	801714e <_dtoa_r+0xa2>
 8017136:	2301      	movs	r3, #1
 8017138:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801713a:	6013      	str	r3, [r2, #0]
 801713c:	4ba0      	ldr	r3, [pc, #640]	; (80173c0 <_dtoa_r+0x314>)
 801713e:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8017140:	9308      	str	r3, [sp, #32]
 8017142:	2a00      	cmp	r2, #0
 8017144:	d0e7      	beq.n	8017116 <_dtoa_r+0x6a>
 8017146:	4a9f      	ldr	r2, [pc, #636]	; (80173c4 <_dtoa_r+0x318>)
 8017148:	9924      	ldr	r1, [sp, #144]	; 0x90
 801714a:	600a      	str	r2, [r1, #0]
 801714c:	e7e3      	b.n	8017116 <_dtoa_r+0x6a>
 801714e:	ab18      	add	r3, sp, #96	; 0x60
 8017150:	9301      	str	r3, [sp, #4]
 8017152:	ab19      	add	r3, sp, #100	; 0x64
 8017154:	9300      	str	r3, [sp, #0]
 8017156:	0032      	movs	r2, r6
 8017158:	003b      	movs	r3, r7
 801715a:	9802      	ldr	r0, [sp, #8]
 801715c:	f001 fd0e 	bl	8018b7c <__d2b>
 8017160:	0063      	lsls	r3, r4, #1
 8017162:	9003      	str	r0, [sp, #12]
 8017164:	0d5b      	lsrs	r3, r3, #21
 8017166:	d074      	beq.n	8017252 <_dtoa_r+0x1a6>
 8017168:	033a      	lsls	r2, r7, #12
 801716a:	4c97      	ldr	r4, [pc, #604]	; (80173c8 <_dtoa_r+0x31c>)
 801716c:	0b12      	lsrs	r2, r2, #12
 801716e:	4314      	orrs	r4, r2
 8017170:	0021      	movs	r1, r4
 8017172:	4a96      	ldr	r2, [pc, #600]	; (80173cc <_dtoa_r+0x320>)
 8017174:	0030      	movs	r0, r6
 8017176:	9516      	str	r5, [sp, #88]	; 0x58
 8017178:	189e      	adds	r6, r3, r2
 801717a:	2200      	movs	r2, #0
 801717c:	4b94      	ldr	r3, [pc, #592]	; (80173d0 <_dtoa_r+0x324>)
 801717e:	f7eb f88b 	bl	8002298 <__aeabi_dsub>
 8017182:	4a94      	ldr	r2, [pc, #592]	; (80173d4 <_dtoa_r+0x328>)
 8017184:	4b94      	ldr	r3, [pc, #592]	; (80173d8 <_dtoa_r+0x32c>)
 8017186:	f7ea fe15 	bl	8001db4 <__aeabi_dmul>
 801718a:	4a94      	ldr	r2, [pc, #592]	; (80173dc <_dtoa_r+0x330>)
 801718c:	4b94      	ldr	r3, [pc, #592]	; (80173e0 <_dtoa_r+0x334>)
 801718e:	f7e9 feeb 	bl	8000f68 <__aeabi_dadd>
 8017192:	0004      	movs	r4, r0
 8017194:	0030      	movs	r0, r6
 8017196:	000d      	movs	r5, r1
 8017198:	f7eb fc18 	bl	80029cc <__aeabi_i2d>
 801719c:	4a91      	ldr	r2, [pc, #580]	; (80173e4 <_dtoa_r+0x338>)
 801719e:	4b92      	ldr	r3, [pc, #584]	; (80173e8 <_dtoa_r+0x33c>)
 80171a0:	f7ea fe08 	bl	8001db4 <__aeabi_dmul>
 80171a4:	0002      	movs	r2, r0
 80171a6:	000b      	movs	r3, r1
 80171a8:	0020      	movs	r0, r4
 80171aa:	0029      	movs	r1, r5
 80171ac:	f7e9 fedc 	bl	8000f68 <__aeabi_dadd>
 80171b0:	0004      	movs	r4, r0
 80171b2:	000d      	movs	r5, r1
 80171b4:	f7eb fbd4 	bl	8002960 <__aeabi_d2iz>
 80171b8:	2200      	movs	r2, #0
 80171ba:	0007      	movs	r7, r0
 80171bc:	2300      	movs	r3, #0
 80171be:	0020      	movs	r0, r4
 80171c0:	0029      	movs	r1, r5
 80171c2:	f7e9 f971 	bl	80004a8 <__aeabi_dcmplt>
 80171c6:	2800      	cmp	r0, #0
 80171c8:	d009      	beq.n	80171de <_dtoa_r+0x132>
 80171ca:	0038      	movs	r0, r7
 80171cc:	f7eb fbfe 	bl	80029cc <__aeabi_i2d>
 80171d0:	002b      	movs	r3, r5
 80171d2:	0022      	movs	r2, r4
 80171d4:	f7e9 f962 	bl	800049c <__aeabi_dcmpeq>
 80171d8:	4243      	negs	r3, r0
 80171da:	4158      	adcs	r0, r3
 80171dc:	1a3f      	subs	r7, r7, r0
 80171de:	2301      	movs	r3, #1
 80171e0:	9314      	str	r3, [sp, #80]	; 0x50
 80171e2:	2f16      	cmp	r7, #22
 80171e4:	d80d      	bhi.n	8017202 <_dtoa_r+0x156>
 80171e6:	4981      	ldr	r1, [pc, #516]	; (80173ec <_dtoa_r+0x340>)
 80171e8:	00fb      	lsls	r3, r7, #3
 80171ea:	18c9      	adds	r1, r1, r3
 80171ec:	6808      	ldr	r0, [r1, #0]
 80171ee:	6849      	ldr	r1, [r1, #4]
 80171f0:	9a06      	ldr	r2, [sp, #24]
 80171f2:	9b07      	ldr	r3, [sp, #28]
 80171f4:	f7e9 f96c 	bl	80004d0 <__aeabi_dcmpgt>
 80171f8:	2800      	cmp	r0, #0
 80171fa:	d046      	beq.n	801728a <_dtoa_r+0x1de>
 80171fc:	2300      	movs	r3, #0
 80171fe:	3f01      	subs	r7, #1
 8017200:	9314      	str	r3, [sp, #80]	; 0x50
 8017202:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8017204:	1b9e      	subs	r6, r3, r6
 8017206:	2300      	movs	r3, #0
 8017208:	930a      	str	r3, [sp, #40]	; 0x28
 801720a:	0033      	movs	r3, r6
 801720c:	3b01      	subs	r3, #1
 801720e:	930b      	str	r3, [sp, #44]	; 0x2c
 8017210:	d504      	bpl.n	801721c <_dtoa_r+0x170>
 8017212:	2301      	movs	r3, #1
 8017214:	1b9b      	subs	r3, r3, r6
 8017216:	930a      	str	r3, [sp, #40]	; 0x28
 8017218:	2300      	movs	r3, #0
 801721a:	930b      	str	r3, [sp, #44]	; 0x2c
 801721c:	2f00      	cmp	r7, #0
 801721e:	db36      	blt.n	801728e <_dtoa_r+0x1e2>
 8017220:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8017222:	9711      	str	r7, [sp, #68]	; 0x44
 8017224:	19db      	adds	r3, r3, r7
 8017226:	930b      	str	r3, [sp, #44]	; 0x2c
 8017228:	2300      	movs	r3, #0
 801722a:	9304      	str	r3, [sp, #16]
 801722c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801722e:	2401      	movs	r4, #1
 8017230:	2b09      	cmp	r3, #9
 8017232:	d900      	bls.n	8017236 <_dtoa_r+0x18a>
 8017234:	e082      	b.n	801733c <_dtoa_r+0x290>
 8017236:	2b05      	cmp	r3, #5
 8017238:	dd02      	ble.n	8017240 <_dtoa_r+0x194>
 801723a:	2400      	movs	r4, #0
 801723c:	3b04      	subs	r3, #4
 801723e:	9320      	str	r3, [sp, #128]	; 0x80
 8017240:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8017242:	1e98      	subs	r0, r3, #2
 8017244:	2803      	cmp	r0, #3
 8017246:	d900      	bls.n	801724a <_dtoa_r+0x19e>
 8017248:	e082      	b.n	8017350 <_dtoa_r+0x2a4>
 801724a:	f7e8 ff77 	bl	800013c <__gnu_thumb1_case_uqi>
 801724e:	7573      	.short	0x7573
 8017250:	6828      	.short	0x6828
 8017252:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8017254:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8017256:	189e      	adds	r6, r3, r2
 8017258:	4b65      	ldr	r3, [pc, #404]	; (80173f0 <_dtoa_r+0x344>)
 801725a:	18f2      	adds	r2, r6, r3
 801725c:	2a20      	cmp	r2, #32
 801725e:	dd0f      	ble.n	8017280 <_dtoa_r+0x1d4>
 8017260:	2340      	movs	r3, #64	; 0x40
 8017262:	1a9b      	subs	r3, r3, r2
 8017264:	409c      	lsls	r4, r3
 8017266:	4b63      	ldr	r3, [pc, #396]	; (80173f4 <_dtoa_r+0x348>)
 8017268:	9806      	ldr	r0, [sp, #24]
 801726a:	18f3      	adds	r3, r6, r3
 801726c:	40d8      	lsrs	r0, r3
 801726e:	4320      	orrs	r0, r4
 8017270:	f7eb fbe6 	bl	8002a40 <__aeabi_ui2d>
 8017274:	2301      	movs	r3, #1
 8017276:	4c60      	ldr	r4, [pc, #384]	; (80173f8 <_dtoa_r+0x34c>)
 8017278:	3e01      	subs	r6, #1
 801727a:	1909      	adds	r1, r1, r4
 801727c:	9316      	str	r3, [sp, #88]	; 0x58
 801727e:	e77c      	b.n	801717a <_dtoa_r+0xce>
 8017280:	2320      	movs	r3, #32
 8017282:	9806      	ldr	r0, [sp, #24]
 8017284:	1a9b      	subs	r3, r3, r2
 8017286:	4098      	lsls	r0, r3
 8017288:	e7f2      	b.n	8017270 <_dtoa_r+0x1c4>
 801728a:	9014      	str	r0, [sp, #80]	; 0x50
 801728c:	e7b9      	b.n	8017202 <_dtoa_r+0x156>
 801728e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017290:	1bdb      	subs	r3, r3, r7
 8017292:	930a      	str	r3, [sp, #40]	; 0x28
 8017294:	427b      	negs	r3, r7
 8017296:	9304      	str	r3, [sp, #16]
 8017298:	2300      	movs	r3, #0
 801729a:	9311      	str	r3, [sp, #68]	; 0x44
 801729c:	e7c6      	b.n	801722c <_dtoa_r+0x180>
 801729e:	2301      	movs	r3, #1
 80172a0:	930d      	str	r3, [sp, #52]	; 0x34
 80172a2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80172a4:	2b00      	cmp	r3, #0
 80172a6:	dd57      	ble.n	8017358 <_dtoa_r+0x2ac>
 80172a8:	930c      	str	r3, [sp, #48]	; 0x30
 80172aa:	9309      	str	r3, [sp, #36]	; 0x24
 80172ac:	2200      	movs	r2, #0
 80172ae:	9902      	ldr	r1, [sp, #8]
 80172b0:	644a      	str	r2, [r1, #68]	; 0x44
 80172b2:	3204      	adds	r2, #4
 80172b4:	0010      	movs	r0, r2
 80172b6:	9902      	ldr	r1, [sp, #8]
 80172b8:	3014      	adds	r0, #20
 80172ba:	6c49      	ldr	r1, [r1, #68]	; 0x44
 80172bc:	4298      	cmp	r0, r3
 80172be:	d950      	bls.n	8017362 <_dtoa_r+0x2b6>
 80172c0:	9802      	ldr	r0, [sp, #8]
 80172c2:	f001 f947 	bl	8018554 <_Balloc>
 80172c6:	9b02      	ldr	r3, [sp, #8]
 80172c8:	9008      	str	r0, [sp, #32]
 80172ca:	6418      	str	r0, [r3, #64]	; 0x40
 80172cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80172ce:	2b0e      	cmp	r3, #14
 80172d0:	d900      	bls.n	80172d4 <_dtoa_r+0x228>
 80172d2:	e10c      	b.n	80174ee <_dtoa_r+0x442>
 80172d4:	2c00      	cmp	r4, #0
 80172d6:	d100      	bne.n	80172da <_dtoa_r+0x22e>
 80172d8:	e109      	b.n	80174ee <_dtoa_r+0x442>
 80172da:	9b06      	ldr	r3, [sp, #24]
 80172dc:	9c07      	ldr	r4, [sp, #28]
 80172de:	9312      	str	r3, [sp, #72]	; 0x48
 80172e0:	9413      	str	r4, [sp, #76]	; 0x4c
 80172e2:	2f00      	cmp	r7, #0
 80172e4:	dc00      	bgt.n	80172e8 <_dtoa_r+0x23c>
 80172e6:	e08b      	b.n	8017400 <_dtoa_r+0x354>
 80172e8:	210f      	movs	r1, #15
 80172ea:	003a      	movs	r2, r7
 80172ec:	4b3f      	ldr	r3, [pc, #252]	; (80173ec <_dtoa_r+0x340>)
 80172ee:	400a      	ands	r2, r1
 80172f0:	00d2      	lsls	r2, r2, #3
 80172f2:	189b      	adds	r3, r3, r2
 80172f4:	681d      	ldr	r5, [r3, #0]
 80172f6:	685e      	ldr	r6, [r3, #4]
 80172f8:	2302      	movs	r3, #2
 80172fa:	113c      	asrs	r4, r7, #4
 80172fc:	930e      	str	r3, [sp, #56]	; 0x38
 80172fe:	06e3      	lsls	r3, r4, #27
 8017300:	d50b      	bpl.n	801731a <_dtoa_r+0x26e>
 8017302:	4b3e      	ldr	r3, [pc, #248]	; (80173fc <_dtoa_r+0x350>)
 8017304:	400c      	ands	r4, r1
 8017306:	6a1a      	ldr	r2, [r3, #32]
 8017308:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801730a:	9812      	ldr	r0, [sp, #72]	; 0x48
 801730c:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801730e:	f7ea f947 	bl	80015a0 <__aeabi_ddiv>
 8017312:	2303      	movs	r3, #3
 8017314:	9006      	str	r0, [sp, #24]
 8017316:	9107      	str	r1, [sp, #28]
 8017318:	930e      	str	r3, [sp, #56]	; 0x38
 801731a:	2300      	movs	r3, #0
 801731c:	e03b      	b.n	8017396 <_dtoa_r+0x2ea>
 801731e:	2301      	movs	r3, #1
 8017320:	930d      	str	r3, [sp, #52]	; 0x34
 8017322:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8017324:	18fb      	adds	r3, r7, r3
 8017326:	930c      	str	r3, [sp, #48]	; 0x30
 8017328:	3301      	adds	r3, #1
 801732a:	9309      	str	r3, [sp, #36]	; 0x24
 801732c:	2b00      	cmp	r3, #0
 801732e:	dcbd      	bgt.n	80172ac <_dtoa_r+0x200>
 8017330:	2301      	movs	r3, #1
 8017332:	e7bb      	b.n	80172ac <_dtoa_r+0x200>
 8017334:	2300      	movs	r3, #0
 8017336:	e7b3      	b.n	80172a0 <_dtoa_r+0x1f4>
 8017338:	2300      	movs	r3, #0
 801733a:	e7f1      	b.n	8017320 <_dtoa_r+0x274>
 801733c:	2300      	movs	r3, #0
 801733e:	940d      	str	r4, [sp, #52]	; 0x34
 8017340:	9320      	str	r3, [sp, #128]	; 0x80
 8017342:	3b01      	subs	r3, #1
 8017344:	2200      	movs	r2, #0
 8017346:	930c      	str	r3, [sp, #48]	; 0x30
 8017348:	9309      	str	r3, [sp, #36]	; 0x24
 801734a:	3313      	adds	r3, #19
 801734c:	9221      	str	r2, [sp, #132]	; 0x84
 801734e:	e7ad      	b.n	80172ac <_dtoa_r+0x200>
 8017350:	2301      	movs	r3, #1
 8017352:	930d      	str	r3, [sp, #52]	; 0x34
 8017354:	3b02      	subs	r3, #2
 8017356:	e7f5      	b.n	8017344 <_dtoa_r+0x298>
 8017358:	2301      	movs	r3, #1
 801735a:	930c      	str	r3, [sp, #48]	; 0x30
 801735c:	9309      	str	r3, [sp, #36]	; 0x24
 801735e:	001a      	movs	r2, r3
 8017360:	e7f4      	b.n	801734c <_dtoa_r+0x2a0>
 8017362:	9802      	ldr	r0, [sp, #8]
 8017364:	3101      	adds	r1, #1
 8017366:	6441      	str	r1, [r0, #68]	; 0x44
 8017368:	0052      	lsls	r2, r2, #1
 801736a:	e7a3      	b.n	80172b4 <_dtoa_r+0x208>
 801736c:	2301      	movs	r3, #1
 801736e:	421c      	tst	r4, r3
 8017370:	d00e      	beq.n	8017390 <_dtoa_r+0x2e4>
 8017372:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8017374:	4a21      	ldr	r2, [pc, #132]	; (80173fc <_dtoa_r+0x350>)
 8017376:	3301      	adds	r3, #1
 8017378:	930e      	str	r3, [sp, #56]	; 0x38
 801737a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801737c:	0028      	movs	r0, r5
 801737e:	00db      	lsls	r3, r3, #3
 8017380:	189b      	adds	r3, r3, r2
 8017382:	0031      	movs	r1, r6
 8017384:	681a      	ldr	r2, [r3, #0]
 8017386:	685b      	ldr	r3, [r3, #4]
 8017388:	f7ea fd14 	bl	8001db4 <__aeabi_dmul>
 801738c:	0005      	movs	r5, r0
 801738e:	000e      	movs	r6, r1
 8017390:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8017392:	1064      	asrs	r4, r4, #1
 8017394:	3301      	adds	r3, #1
 8017396:	9310      	str	r3, [sp, #64]	; 0x40
 8017398:	2c00      	cmp	r4, #0
 801739a:	d1e7      	bne.n	801736c <_dtoa_r+0x2c0>
 801739c:	9806      	ldr	r0, [sp, #24]
 801739e:	9907      	ldr	r1, [sp, #28]
 80173a0:	002a      	movs	r2, r5
 80173a2:	0033      	movs	r3, r6
 80173a4:	f7ea f8fc 	bl	80015a0 <__aeabi_ddiv>
 80173a8:	9006      	str	r0, [sp, #24]
 80173aa:	9107      	str	r1, [sp, #28]
 80173ac:	e043      	b.n	8017436 <_dtoa_r+0x38a>
 80173ae:	46c0      	nop			; (mov r8, r8)
 80173b0:	7ff00000 	.word	0x7ff00000
 80173b4:	0000270f 	.word	0x0000270f
 80173b8:	0801c734 	.word	0x0801c734
 80173bc:	0801c737 	.word	0x0801c737
 80173c0:	08019147 	.word	0x08019147
 80173c4:	08019148 	.word	0x08019148
 80173c8:	3ff00000 	.word	0x3ff00000
 80173cc:	fffffc01 	.word	0xfffffc01
 80173d0:	3ff80000 	.word	0x3ff80000
 80173d4:	636f4361 	.word	0x636f4361
 80173d8:	3fd287a7 	.word	0x3fd287a7
 80173dc:	8b60c8b3 	.word	0x8b60c8b3
 80173e0:	3fc68a28 	.word	0x3fc68a28
 80173e4:	509f79fb 	.word	0x509f79fb
 80173e8:	3fd34413 	.word	0x3fd34413
 80173ec:	0801c760 	.word	0x0801c760
 80173f0:	00000432 	.word	0x00000432
 80173f4:	00000412 	.word	0x00000412
 80173f8:	fe100000 	.word	0xfe100000
 80173fc:	0801c738 	.word	0x0801c738
 8017400:	2302      	movs	r3, #2
 8017402:	930e      	str	r3, [sp, #56]	; 0x38
 8017404:	2f00      	cmp	r7, #0
 8017406:	d016      	beq.n	8017436 <_dtoa_r+0x38a>
 8017408:	9812      	ldr	r0, [sp, #72]	; 0x48
 801740a:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801740c:	427c      	negs	r4, r7
 801740e:	330d      	adds	r3, #13
 8017410:	4023      	ands	r3, r4
 8017412:	4acf      	ldr	r2, [pc, #828]	; (8017750 <_dtoa_r+0x6a4>)
 8017414:	00db      	lsls	r3, r3, #3
 8017416:	18d3      	adds	r3, r2, r3
 8017418:	681a      	ldr	r2, [r3, #0]
 801741a:	685b      	ldr	r3, [r3, #4]
 801741c:	f7ea fcca 	bl	8001db4 <__aeabi_dmul>
 8017420:	2300      	movs	r3, #0
 8017422:	2601      	movs	r6, #1
 8017424:	001d      	movs	r5, r3
 8017426:	9006      	str	r0, [sp, #24]
 8017428:	9107      	str	r1, [sp, #28]
 801742a:	1124      	asrs	r4, r4, #4
 801742c:	2c00      	cmp	r4, #0
 801742e:	d000      	beq.n	8017432 <_dtoa_r+0x386>
 8017430:	e08c      	b.n	801754c <_dtoa_r+0x4a0>
 8017432:	2b00      	cmp	r3, #0
 8017434:	d1b8      	bne.n	80173a8 <_dtoa_r+0x2fc>
 8017436:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8017438:	2b00      	cmp	r3, #0
 801743a:	d100      	bne.n	801743e <_dtoa_r+0x392>
 801743c:	e096      	b.n	801756c <_dtoa_r+0x4c0>
 801743e:	9c06      	ldr	r4, [sp, #24]
 8017440:	9d07      	ldr	r5, [sp, #28]
 8017442:	2200      	movs	r2, #0
 8017444:	4bc3      	ldr	r3, [pc, #780]	; (8017754 <_dtoa_r+0x6a8>)
 8017446:	0020      	movs	r0, r4
 8017448:	0029      	movs	r1, r5
 801744a:	f7e9 f82d 	bl	80004a8 <__aeabi_dcmplt>
 801744e:	2800      	cmp	r0, #0
 8017450:	d100      	bne.n	8017454 <_dtoa_r+0x3a8>
 8017452:	e08b      	b.n	801756c <_dtoa_r+0x4c0>
 8017454:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017456:	2b00      	cmp	r3, #0
 8017458:	d100      	bne.n	801745c <_dtoa_r+0x3b0>
 801745a:	e087      	b.n	801756c <_dtoa_r+0x4c0>
 801745c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801745e:	2b00      	cmp	r3, #0
 8017460:	dd41      	ble.n	80174e6 <_dtoa_r+0x43a>
 8017462:	4bbd      	ldr	r3, [pc, #756]	; (8017758 <_dtoa_r+0x6ac>)
 8017464:	2200      	movs	r2, #0
 8017466:	0020      	movs	r0, r4
 8017468:	0029      	movs	r1, r5
 801746a:	f7ea fca3 	bl	8001db4 <__aeabi_dmul>
 801746e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8017470:	9006      	str	r0, [sp, #24]
 8017472:	9107      	str	r1, [sp, #28]
 8017474:	3301      	adds	r3, #1
 8017476:	930e      	str	r3, [sp, #56]	; 0x38
 8017478:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801747a:	1e7e      	subs	r6, r7, #1
 801747c:	980e      	ldr	r0, [sp, #56]	; 0x38
 801747e:	9310      	str	r3, [sp, #64]	; 0x40
 8017480:	f7eb faa4 	bl	80029cc <__aeabi_i2d>
 8017484:	9a06      	ldr	r2, [sp, #24]
 8017486:	9b07      	ldr	r3, [sp, #28]
 8017488:	f7ea fc94 	bl	8001db4 <__aeabi_dmul>
 801748c:	2200      	movs	r2, #0
 801748e:	4bb3      	ldr	r3, [pc, #716]	; (801775c <_dtoa_r+0x6b0>)
 8017490:	f7e9 fd6a 	bl	8000f68 <__aeabi_dadd>
 8017494:	4ab2      	ldr	r2, [pc, #712]	; (8017760 <_dtoa_r+0x6b4>)
 8017496:	900e      	str	r0, [sp, #56]	; 0x38
 8017498:	910f      	str	r1, [sp, #60]	; 0x3c
 801749a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 801749c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 801749e:	4694      	mov	ip, r2
 80174a0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80174a2:	4463      	add	r3, ip
 80174a4:	9315      	str	r3, [sp, #84]	; 0x54
 80174a6:	001d      	movs	r5, r3
 80174a8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80174aa:	2b00      	cmp	r3, #0
 80174ac:	d161      	bne.n	8017572 <_dtoa_r+0x4c6>
 80174ae:	9806      	ldr	r0, [sp, #24]
 80174b0:	9907      	ldr	r1, [sp, #28]
 80174b2:	2200      	movs	r2, #0
 80174b4:	4bab      	ldr	r3, [pc, #684]	; (8017764 <_dtoa_r+0x6b8>)
 80174b6:	f7ea feef 	bl	8002298 <__aeabi_dsub>
 80174ba:	0022      	movs	r2, r4
 80174bc:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80174be:	9006      	str	r0, [sp, #24]
 80174c0:	9107      	str	r1, [sp, #28]
 80174c2:	f7e9 f805 	bl	80004d0 <__aeabi_dcmpgt>
 80174c6:	2800      	cmp	r0, #0
 80174c8:	d000      	beq.n	80174cc <_dtoa_r+0x420>
 80174ca:	e2aa      	b.n	8017a22 <_dtoa_r+0x976>
 80174cc:	48a6      	ldr	r0, [pc, #664]	; (8017768 <_dtoa_r+0x6bc>)
 80174ce:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80174d0:	4684      	mov	ip, r0
 80174d2:	4461      	add	r1, ip
 80174d4:	000b      	movs	r3, r1
 80174d6:	9806      	ldr	r0, [sp, #24]
 80174d8:	9907      	ldr	r1, [sp, #28]
 80174da:	0022      	movs	r2, r4
 80174dc:	f7e8 ffe4 	bl	80004a8 <__aeabi_dcmplt>
 80174e0:	2800      	cmp	r0, #0
 80174e2:	d000      	beq.n	80174e6 <_dtoa_r+0x43a>
 80174e4:	e297      	b.n	8017a16 <_dtoa_r+0x96a>
 80174e6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80174e8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 80174ea:	9306      	str	r3, [sp, #24]
 80174ec:	9407      	str	r4, [sp, #28]
 80174ee:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80174f0:	2b00      	cmp	r3, #0
 80174f2:	da00      	bge.n	80174f6 <_dtoa_r+0x44a>
 80174f4:	e15e      	b.n	80177b4 <_dtoa_r+0x708>
 80174f6:	2f0e      	cmp	r7, #14
 80174f8:	dd00      	ble.n	80174fc <_dtoa_r+0x450>
 80174fa:	e15b      	b.n	80177b4 <_dtoa_r+0x708>
 80174fc:	4b94      	ldr	r3, [pc, #592]	; (8017750 <_dtoa_r+0x6a4>)
 80174fe:	00fa      	lsls	r2, r7, #3
 8017500:	189b      	adds	r3, r3, r2
 8017502:	685c      	ldr	r4, [r3, #4]
 8017504:	681b      	ldr	r3, [r3, #0]
 8017506:	9304      	str	r3, [sp, #16]
 8017508:	9405      	str	r4, [sp, #20]
 801750a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801750c:	2b00      	cmp	r3, #0
 801750e:	db00      	blt.n	8017512 <_dtoa_r+0x466>
 8017510:	e0da      	b.n	80176c8 <_dtoa_r+0x61c>
 8017512:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017514:	2b00      	cmp	r3, #0
 8017516:	dd00      	ble.n	801751a <_dtoa_r+0x46e>
 8017518:	e0d6      	b.n	80176c8 <_dtoa_r+0x61c>
 801751a:	d000      	beq.n	801751e <_dtoa_r+0x472>
 801751c:	e27f      	b.n	8017a1e <_dtoa_r+0x972>
 801751e:	9804      	ldr	r0, [sp, #16]
 8017520:	9905      	ldr	r1, [sp, #20]
 8017522:	2200      	movs	r2, #0
 8017524:	4b8f      	ldr	r3, [pc, #572]	; (8017764 <_dtoa_r+0x6b8>)
 8017526:	f7ea fc45 	bl	8001db4 <__aeabi_dmul>
 801752a:	9a06      	ldr	r2, [sp, #24]
 801752c:	9b07      	ldr	r3, [sp, #28]
 801752e:	f7e8 ffd9 	bl	80004e4 <__aeabi_dcmpge>
 8017532:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017534:	9304      	str	r3, [sp, #16]
 8017536:	001e      	movs	r6, r3
 8017538:	2800      	cmp	r0, #0
 801753a:	d000      	beq.n	801753e <_dtoa_r+0x492>
 801753c:	e251      	b.n	80179e2 <_dtoa_r+0x936>
 801753e:	9b08      	ldr	r3, [sp, #32]
 8017540:	9a08      	ldr	r2, [sp, #32]
 8017542:	1c5d      	adds	r5, r3, #1
 8017544:	2331      	movs	r3, #49	; 0x31
 8017546:	3701      	adds	r7, #1
 8017548:	7013      	strb	r3, [r2, #0]
 801754a:	e24d      	b.n	80179e8 <_dtoa_r+0x93c>
 801754c:	4234      	tst	r4, r6
 801754e:	d00a      	beq.n	8017566 <_dtoa_r+0x4ba>
 8017550:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8017552:	4a86      	ldr	r2, [pc, #536]	; (801776c <_dtoa_r+0x6c0>)
 8017554:	3301      	adds	r3, #1
 8017556:	930e      	str	r3, [sp, #56]	; 0x38
 8017558:	00eb      	lsls	r3, r5, #3
 801755a:	189b      	adds	r3, r3, r2
 801755c:	681a      	ldr	r2, [r3, #0]
 801755e:	685b      	ldr	r3, [r3, #4]
 8017560:	f7ea fc28 	bl	8001db4 <__aeabi_dmul>
 8017564:	0033      	movs	r3, r6
 8017566:	1064      	asrs	r4, r4, #1
 8017568:	3501      	adds	r5, #1
 801756a:	e75f      	b.n	801742c <_dtoa_r+0x380>
 801756c:	003e      	movs	r6, r7
 801756e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017570:	e784      	b.n	801747c <_dtoa_r+0x3d0>
 8017572:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8017574:	1e5a      	subs	r2, r3, #1
 8017576:	4b76      	ldr	r3, [pc, #472]	; (8017750 <_dtoa_r+0x6a4>)
 8017578:	00d2      	lsls	r2, r2, #3
 801757a:	189b      	adds	r3, r3, r2
 801757c:	6818      	ldr	r0, [r3, #0]
 801757e:	6859      	ldr	r1, [r3, #4]
 8017580:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8017582:	2b00      	cmp	r3, #0
 8017584:	d04b      	beq.n	801761e <_dtoa_r+0x572>
 8017586:	0002      	movs	r2, r0
 8017588:	000b      	movs	r3, r1
 801758a:	2000      	movs	r0, #0
 801758c:	4978      	ldr	r1, [pc, #480]	; (8017770 <_dtoa_r+0x6c4>)
 801758e:	f7ea f807 	bl	80015a0 <__aeabi_ddiv>
 8017592:	002b      	movs	r3, r5
 8017594:	0022      	movs	r2, r4
 8017596:	f7ea fe7f 	bl	8002298 <__aeabi_dsub>
 801759a:	9b08      	ldr	r3, [sp, #32]
 801759c:	900e      	str	r0, [sp, #56]	; 0x38
 801759e:	910f      	str	r1, [sp, #60]	; 0x3c
 80175a0:	9315      	str	r3, [sp, #84]	; 0x54
 80175a2:	9806      	ldr	r0, [sp, #24]
 80175a4:	9907      	ldr	r1, [sp, #28]
 80175a6:	f7eb f9db 	bl	8002960 <__aeabi_d2iz>
 80175aa:	0004      	movs	r4, r0
 80175ac:	f7eb fa0e 	bl	80029cc <__aeabi_i2d>
 80175b0:	0002      	movs	r2, r0
 80175b2:	000b      	movs	r3, r1
 80175b4:	9806      	ldr	r0, [sp, #24]
 80175b6:	9907      	ldr	r1, [sp, #28]
 80175b8:	f7ea fe6e 	bl	8002298 <__aeabi_dsub>
 80175bc:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80175be:	3430      	adds	r4, #48	; 0x30
 80175c0:	1c5d      	adds	r5, r3, #1
 80175c2:	701c      	strb	r4, [r3, #0]
 80175c4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80175c6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80175c8:	9006      	str	r0, [sp, #24]
 80175ca:	9107      	str	r1, [sp, #28]
 80175cc:	f7e8 ff6c 	bl	80004a8 <__aeabi_dcmplt>
 80175d0:	2800      	cmp	r0, #0
 80175d2:	d16c      	bne.n	80176ae <_dtoa_r+0x602>
 80175d4:	9a06      	ldr	r2, [sp, #24]
 80175d6:	9b07      	ldr	r3, [sp, #28]
 80175d8:	2000      	movs	r0, #0
 80175da:	495e      	ldr	r1, [pc, #376]	; (8017754 <_dtoa_r+0x6a8>)
 80175dc:	f7ea fe5c 	bl	8002298 <__aeabi_dsub>
 80175e0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80175e2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80175e4:	f7e8 ff60 	bl	80004a8 <__aeabi_dcmplt>
 80175e8:	2800      	cmp	r0, #0
 80175ea:	d000      	beq.n	80175ee <_dtoa_r+0x542>
 80175ec:	e0c3      	b.n	8017776 <_dtoa_r+0x6ca>
 80175ee:	9b08      	ldr	r3, [sp, #32]
 80175f0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80175f2:	1aeb      	subs	r3, r5, r3
 80175f4:	429a      	cmp	r2, r3
 80175f6:	dc00      	bgt.n	80175fa <_dtoa_r+0x54e>
 80175f8:	e775      	b.n	80174e6 <_dtoa_r+0x43a>
 80175fa:	980e      	ldr	r0, [sp, #56]	; 0x38
 80175fc:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80175fe:	2200      	movs	r2, #0
 8017600:	4b55      	ldr	r3, [pc, #340]	; (8017758 <_dtoa_r+0x6ac>)
 8017602:	f7ea fbd7 	bl	8001db4 <__aeabi_dmul>
 8017606:	2200      	movs	r2, #0
 8017608:	900e      	str	r0, [sp, #56]	; 0x38
 801760a:	910f      	str	r1, [sp, #60]	; 0x3c
 801760c:	9806      	ldr	r0, [sp, #24]
 801760e:	9907      	ldr	r1, [sp, #28]
 8017610:	4b51      	ldr	r3, [pc, #324]	; (8017758 <_dtoa_r+0x6ac>)
 8017612:	f7ea fbcf 	bl	8001db4 <__aeabi_dmul>
 8017616:	9515      	str	r5, [sp, #84]	; 0x54
 8017618:	9006      	str	r0, [sp, #24]
 801761a:	9107      	str	r1, [sp, #28]
 801761c:	e7c1      	b.n	80175a2 <_dtoa_r+0x4f6>
 801761e:	0022      	movs	r2, r4
 8017620:	002b      	movs	r3, r5
 8017622:	f7ea fbc7 	bl	8001db4 <__aeabi_dmul>
 8017626:	9c08      	ldr	r4, [sp, #32]
 8017628:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801762a:	0023      	movs	r3, r4
 801762c:	4694      	mov	ip, r2
 801762e:	900e      	str	r0, [sp, #56]	; 0x38
 8017630:	910f      	str	r1, [sp, #60]	; 0x3c
 8017632:	4463      	add	r3, ip
 8017634:	9315      	str	r3, [sp, #84]	; 0x54
 8017636:	9806      	ldr	r0, [sp, #24]
 8017638:	9907      	ldr	r1, [sp, #28]
 801763a:	f7eb f991 	bl	8002960 <__aeabi_d2iz>
 801763e:	0005      	movs	r5, r0
 8017640:	f7eb f9c4 	bl	80029cc <__aeabi_i2d>
 8017644:	000b      	movs	r3, r1
 8017646:	0002      	movs	r2, r0
 8017648:	9806      	ldr	r0, [sp, #24]
 801764a:	9907      	ldr	r1, [sp, #28]
 801764c:	f7ea fe24 	bl	8002298 <__aeabi_dsub>
 8017650:	3530      	adds	r5, #48	; 0x30
 8017652:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8017654:	7025      	strb	r5, [r4, #0]
 8017656:	3401      	adds	r4, #1
 8017658:	9006      	str	r0, [sp, #24]
 801765a:	9107      	str	r1, [sp, #28]
 801765c:	42a3      	cmp	r3, r4
 801765e:	d12a      	bne.n	80176b6 <_dtoa_r+0x60a>
 8017660:	980e      	ldr	r0, [sp, #56]	; 0x38
 8017662:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8017664:	9a08      	ldr	r2, [sp, #32]
 8017666:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8017668:	4694      	mov	ip, r2
 801766a:	4463      	add	r3, ip
 801766c:	2200      	movs	r2, #0
 801766e:	001d      	movs	r5, r3
 8017670:	4b3f      	ldr	r3, [pc, #252]	; (8017770 <_dtoa_r+0x6c4>)
 8017672:	f7e9 fc79 	bl	8000f68 <__aeabi_dadd>
 8017676:	0002      	movs	r2, r0
 8017678:	000b      	movs	r3, r1
 801767a:	9806      	ldr	r0, [sp, #24]
 801767c:	9907      	ldr	r1, [sp, #28]
 801767e:	f7e8 ff27 	bl	80004d0 <__aeabi_dcmpgt>
 8017682:	2800      	cmp	r0, #0
 8017684:	d000      	beq.n	8017688 <_dtoa_r+0x5dc>
 8017686:	e076      	b.n	8017776 <_dtoa_r+0x6ca>
 8017688:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801768a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801768c:	2000      	movs	r0, #0
 801768e:	4938      	ldr	r1, [pc, #224]	; (8017770 <_dtoa_r+0x6c4>)
 8017690:	f7ea fe02 	bl	8002298 <__aeabi_dsub>
 8017694:	0002      	movs	r2, r0
 8017696:	000b      	movs	r3, r1
 8017698:	9806      	ldr	r0, [sp, #24]
 801769a:	9907      	ldr	r1, [sp, #28]
 801769c:	f7e8 ff04 	bl	80004a8 <__aeabi_dcmplt>
 80176a0:	2800      	cmp	r0, #0
 80176a2:	d100      	bne.n	80176a6 <_dtoa_r+0x5fa>
 80176a4:	e71f      	b.n	80174e6 <_dtoa_r+0x43a>
 80176a6:	1e6b      	subs	r3, r5, #1
 80176a8:	781a      	ldrb	r2, [r3, #0]
 80176aa:	2a30      	cmp	r2, #48	; 0x30
 80176ac:	d001      	beq.n	80176b2 <_dtoa_r+0x606>
 80176ae:	0037      	movs	r7, r6
 80176b0:	e03f      	b.n	8017732 <_dtoa_r+0x686>
 80176b2:	001d      	movs	r5, r3
 80176b4:	e7f7      	b.n	80176a6 <_dtoa_r+0x5fa>
 80176b6:	9806      	ldr	r0, [sp, #24]
 80176b8:	9907      	ldr	r1, [sp, #28]
 80176ba:	2200      	movs	r2, #0
 80176bc:	4b26      	ldr	r3, [pc, #152]	; (8017758 <_dtoa_r+0x6ac>)
 80176be:	f7ea fb79 	bl	8001db4 <__aeabi_dmul>
 80176c2:	9006      	str	r0, [sp, #24]
 80176c4:	9107      	str	r1, [sp, #28]
 80176c6:	e7b6      	b.n	8017636 <_dtoa_r+0x58a>
 80176c8:	9e08      	ldr	r6, [sp, #32]
 80176ca:	9a04      	ldr	r2, [sp, #16]
 80176cc:	9b05      	ldr	r3, [sp, #20]
 80176ce:	9806      	ldr	r0, [sp, #24]
 80176d0:	9907      	ldr	r1, [sp, #28]
 80176d2:	f7e9 ff65 	bl	80015a0 <__aeabi_ddiv>
 80176d6:	f7eb f943 	bl	8002960 <__aeabi_d2iz>
 80176da:	0004      	movs	r4, r0
 80176dc:	f7eb f976 	bl	80029cc <__aeabi_i2d>
 80176e0:	9a04      	ldr	r2, [sp, #16]
 80176e2:	9b05      	ldr	r3, [sp, #20]
 80176e4:	f7ea fb66 	bl	8001db4 <__aeabi_dmul>
 80176e8:	0002      	movs	r2, r0
 80176ea:	000b      	movs	r3, r1
 80176ec:	9806      	ldr	r0, [sp, #24]
 80176ee:	9907      	ldr	r1, [sp, #28]
 80176f0:	f7ea fdd2 	bl	8002298 <__aeabi_dsub>
 80176f4:	0023      	movs	r3, r4
 80176f6:	3330      	adds	r3, #48	; 0x30
 80176f8:	7033      	strb	r3, [r6, #0]
 80176fa:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80176fc:	9b08      	ldr	r3, [sp, #32]
 80176fe:	1c75      	adds	r5, r6, #1
 8017700:	1aeb      	subs	r3, r5, r3
 8017702:	429a      	cmp	r2, r3
 8017704:	d148      	bne.n	8017798 <_dtoa_r+0x6ec>
 8017706:	0002      	movs	r2, r0
 8017708:	000b      	movs	r3, r1
 801770a:	f7e9 fc2d 	bl	8000f68 <__aeabi_dadd>
 801770e:	9a04      	ldr	r2, [sp, #16]
 8017710:	9b05      	ldr	r3, [sp, #20]
 8017712:	9006      	str	r0, [sp, #24]
 8017714:	9107      	str	r1, [sp, #28]
 8017716:	f7e8 fedb 	bl	80004d0 <__aeabi_dcmpgt>
 801771a:	2800      	cmp	r0, #0
 801771c:	d12a      	bne.n	8017774 <_dtoa_r+0x6c8>
 801771e:	9a04      	ldr	r2, [sp, #16]
 8017720:	9b05      	ldr	r3, [sp, #20]
 8017722:	9806      	ldr	r0, [sp, #24]
 8017724:	9907      	ldr	r1, [sp, #28]
 8017726:	f7e8 feb9 	bl	800049c <__aeabi_dcmpeq>
 801772a:	2800      	cmp	r0, #0
 801772c:	d001      	beq.n	8017732 <_dtoa_r+0x686>
 801772e:	07e3      	lsls	r3, r4, #31
 8017730:	d420      	bmi.n	8017774 <_dtoa_r+0x6c8>
 8017732:	9903      	ldr	r1, [sp, #12]
 8017734:	9802      	ldr	r0, [sp, #8]
 8017736:	f000 ff35 	bl	80185a4 <_Bfree>
 801773a:	2300      	movs	r3, #0
 801773c:	702b      	strb	r3, [r5, #0]
 801773e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8017740:	3701      	adds	r7, #1
 8017742:	601f      	str	r7, [r3, #0]
 8017744:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8017746:	2b00      	cmp	r3, #0
 8017748:	d100      	bne.n	801774c <_dtoa_r+0x6a0>
 801774a:	e4e4      	b.n	8017116 <_dtoa_r+0x6a>
 801774c:	601d      	str	r5, [r3, #0]
 801774e:	e4e2      	b.n	8017116 <_dtoa_r+0x6a>
 8017750:	0801c760 	.word	0x0801c760
 8017754:	3ff00000 	.word	0x3ff00000
 8017758:	40240000 	.word	0x40240000
 801775c:	401c0000 	.word	0x401c0000
 8017760:	fcc00000 	.word	0xfcc00000
 8017764:	40140000 	.word	0x40140000
 8017768:	7cc00000 	.word	0x7cc00000
 801776c:	0801c738 	.word	0x0801c738
 8017770:	3fe00000 	.word	0x3fe00000
 8017774:	003e      	movs	r6, r7
 8017776:	1e6b      	subs	r3, r5, #1
 8017778:	781a      	ldrb	r2, [r3, #0]
 801777a:	2a39      	cmp	r2, #57	; 0x39
 801777c:	d106      	bne.n	801778c <_dtoa_r+0x6e0>
 801777e:	9a08      	ldr	r2, [sp, #32]
 8017780:	429a      	cmp	r2, r3
 8017782:	d107      	bne.n	8017794 <_dtoa_r+0x6e8>
 8017784:	2330      	movs	r3, #48	; 0x30
 8017786:	7013      	strb	r3, [r2, #0]
 8017788:	0013      	movs	r3, r2
 801778a:	3601      	adds	r6, #1
 801778c:	781a      	ldrb	r2, [r3, #0]
 801778e:	3201      	adds	r2, #1
 8017790:	701a      	strb	r2, [r3, #0]
 8017792:	e78c      	b.n	80176ae <_dtoa_r+0x602>
 8017794:	001d      	movs	r5, r3
 8017796:	e7ee      	b.n	8017776 <_dtoa_r+0x6ca>
 8017798:	2200      	movs	r2, #0
 801779a:	4ba4      	ldr	r3, [pc, #656]	; (8017a2c <_dtoa_r+0x980>)
 801779c:	f7ea fb0a 	bl	8001db4 <__aeabi_dmul>
 80177a0:	2200      	movs	r2, #0
 80177a2:	2300      	movs	r3, #0
 80177a4:	9006      	str	r0, [sp, #24]
 80177a6:	9107      	str	r1, [sp, #28]
 80177a8:	002e      	movs	r6, r5
 80177aa:	f7e8 fe77 	bl	800049c <__aeabi_dcmpeq>
 80177ae:	2800      	cmp	r0, #0
 80177b0:	d08b      	beq.n	80176ca <_dtoa_r+0x61e>
 80177b2:	e7be      	b.n	8017732 <_dtoa_r+0x686>
 80177b4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80177b6:	2a00      	cmp	r2, #0
 80177b8:	d100      	bne.n	80177bc <_dtoa_r+0x710>
 80177ba:	e0da      	b.n	8017972 <_dtoa_r+0x8c6>
 80177bc:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80177be:	2a01      	cmp	r2, #1
 80177c0:	dd00      	ble.n	80177c4 <_dtoa_r+0x718>
 80177c2:	e0bd      	b.n	8017940 <_dtoa_r+0x894>
 80177c4:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80177c6:	2a00      	cmp	r2, #0
 80177c8:	d100      	bne.n	80177cc <_dtoa_r+0x720>
 80177ca:	e0b5      	b.n	8017938 <_dtoa_r+0x88c>
 80177cc:	4a98      	ldr	r2, [pc, #608]	; (8017a30 <_dtoa_r+0x984>)
 80177ce:	189b      	adds	r3, r3, r2
 80177d0:	9d04      	ldr	r5, [sp, #16]
 80177d2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80177d4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80177d6:	2101      	movs	r1, #1
 80177d8:	18d2      	adds	r2, r2, r3
 80177da:	920a      	str	r2, [sp, #40]	; 0x28
 80177dc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80177de:	9802      	ldr	r0, [sp, #8]
 80177e0:	18d3      	adds	r3, r2, r3
 80177e2:	930b      	str	r3, [sp, #44]	; 0x2c
 80177e4:	f000 ffad 	bl	8018742 <__i2b>
 80177e8:	0006      	movs	r6, r0
 80177ea:	2c00      	cmp	r4, #0
 80177ec:	dd0e      	ble.n	801780c <_dtoa_r+0x760>
 80177ee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80177f0:	2b00      	cmp	r3, #0
 80177f2:	dd0b      	ble.n	801780c <_dtoa_r+0x760>
 80177f4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80177f6:	0023      	movs	r3, r4
 80177f8:	4294      	cmp	r4, r2
 80177fa:	dd00      	ble.n	80177fe <_dtoa_r+0x752>
 80177fc:	0013      	movs	r3, r2
 80177fe:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8017800:	1ae4      	subs	r4, r4, r3
 8017802:	1ad2      	subs	r2, r2, r3
 8017804:	920a      	str	r2, [sp, #40]	; 0x28
 8017806:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8017808:	1ad3      	subs	r3, r2, r3
 801780a:	930b      	str	r3, [sp, #44]	; 0x2c
 801780c:	9b04      	ldr	r3, [sp, #16]
 801780e:	2b00      	cmp	r3, #0
 8017810:	d01f      	beq.n	8017852 <_dtoa_r+0x7a6>
 8017812:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8017814:	2b00      	cmp	r3, #0
 8017816:	d100      	bne.n	801781a <_dtoa_r+0x76e>
 8017818:	e0af      	b.n	801797a <_dtoa_r+0x8ce>
 801781a:	2d00      	cmp	r5, #0
 801781c:	d011      	beq.n	8017842 <_dtoa_r+0x796>
 801781e:	0031      	movs	r1, r6
 8017820:	002a      	movs	r2, r5
 8017822:	9802      	ldr	r0, [sp, #8]
 8017824:	f001 f826 	bl	8018874 <__pow5mult>
 8017828:	9a03      	ldr	r2, [sp, #12]
 801782a:	0001      	movs	r1, r0
 801782c:	0006      	movs	r6, r0
 801782e:	9802      	ldr	r0, [sp, #8]
 8017830:	f000 ff90 	bl	8018754 <__multiply>
 8017834:	9903      	ldr	r1, [sp, #12]
 8017836:	9010      	str	r0, [sp, #64]	; 0x40
 8017838:	9802      	ldr	r0, [sp, #8]
 801783a:	f000 feb3 	bl	80185a4 <_Bfree>
 801783e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8017840:	9303      	str	r3, [sp, #12]
 8017842:	9b04      	ldr	r3, [sp, #16]
 8017844:	1b5a      	subs	r2, r3, r5
 8017846:	d004      	beq.n	8017852 <_dtoa_r+0x7a6>
 8017848:	9903      	ldr	r1, [sp, #12]
 801784a:	9802      	ldr	r0, [sp, #8]
 801784c:	f001 f812 	bl	8018874 <__pow5mult>
 8017850:	9003      	str	r0, [sp, #12]
 8017852:	2101      	movs	r1, #1
 8017854:	9802      	ldr	r0, [sp, #8]
 8017856:	f000 ff74 	bl	8018742 <__i2b>
 801785a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801785c:	9004      	str	r0, [sp, #16]
 801785e:	2b00      	cmp	r3, #0
 8017860:	d100      	bne.n	8017864 <_dtoa_r+0x7b8>
 8017862:	e1e3      	b.n	8017c2c <_dtoa_r+0xb80>
 8017864:	001a      	movs	r2, r3
 8017866:	0001      	movs	r1, r0
 8017868:	9802      	ldr	r0, [sp, #8]
 801786a:	f001 f803 	bl	8018874 <__pow5mult>
 801786e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8017870:	9004      	str	r0, [sp, #16]
 8017872:	2b01      	cmp	r3, #1
 8017874:	dd00      	ble.n	8017878 <_dtoa_r+0x7cc>
 8017876:	e082      	b.n	801797e <_dtoa_r+0x8d2>
 8017878:	2500      	movs	r5, #0
 801787a:	9b06      	ldr	r3, [sp, #24]
 801787c:	42ab      	cmp	r3, r5
 801787e:	d10e      	bne.n	801789e <_dtoa_r+0x7f2>
 8017880:	9b07      	ldr	r3, [sp, #28]
 8017882:	031b      	lsls	r3, r3, #12
 8017884:	42ab      	cmp	r3, r5
 8017886:	d10a      	bne.n	801789e <_dtoa_r+0x7f2>
 8017888:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801788a:	9a07      	ldr	r2, [sp, #28]
 801788c:	4213      	tst	r3, r2
 801788e:	d006      	beq.n	801789e <_dtoa_r+0x7f2>
 8017890:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017892:	3501      	adds	r5, #1
 8017894:	3301      	adds	r3, #1
 8017896:	930a      	str	r3, [sp, #40]	; 0x28
 8017898:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801789a:	3301      	adds	r3, #1
 801789c:	930b      	str	r3, [sp, #44]	; 0x2c
 801789e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80178a0:	2001      	movs	r0, #1
 80178a2:	2b00      	cmp	r3, #0
 80178a4:	d16c      	bne.n	8017980 <_dtoa_r+0x8d4>
 80178a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80178a8:	1818      	adds	r0, r3, r0
 80178aa:	231f      	movs	r3, #31
 80178ac:	4018      	ands	r0, r3
 80178ae:	d07e      	beq.n	80179ae <_dtoa_r+0x902>
 80178b0:	3301      	adds	r3, #1
 80178b2:	1a1b      	subs	r3, r3, r0
 80178b4:	2b04      	cmp	r3, #4
 80178b6:	dd70      	ble.n	801799a <_dtoa_r+0x8ee>
 80178b8:	231c      	movs	r3, #28
 80178ba:	1a18      	subs	r0, r3, r0
 80178bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80178be:	1824      	adds	r4, r4, r0
 80178c0:	181b      	adds	r3, r3, r0
 80178c2:	930a      	str	r3, [sp, #40]	; 0x28
 80178c4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80178c6:	181b      	adds	r3, r3, r0
 80178c8:	930b      	str	r3, [sp, #44]	; 0x2c
 80178ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80178cc:	2b00      	cmp	r3, #0
 80178ce:	dd05      	ble.n	80178dc <_dtoa_r+0x830>
 80178d0:	001a      	movs	r2, r3
 80178d2:	9903      	ldr	r1, [sp, #12]
 80178d4:	9802      	ldr	r0, [sp, #8]
 80178d6:	f001 f80f 	bl	80188f8 <__lshift>
 80178da:	9003      	str	r0, [sp, #12]
 80178dc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80178de:	2b00      	cmp	r3, #0
 80178e0:	dd05      	ble.n	80178ee <_dtoa_r+0x842>
 80178e2:	001a      	movs	r2, r3
 80178e4:	9904      	ldr	r1, [sp, #16]
 80178e6:	9802      	ldr	r0, [sp, #8]
 80178e8:	f001 f806 	bl	80188f8 <__lshift>
 80178ec:	9004      	str	r0, [sp, #16]
 80178ee:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80178f0:	2b00      	cmp	r3, #0
 80178f2:	d05e      	beq.n	80179b2 <_dtoa_r+0x906>
 80178f4:	9904      	ldr	r1, [sp, #16]
 80178f6:	9803      	ldr	r0, [sp, #12]
 80178f8:	f001 f850 	bl	801899c <__mcmp>
 80178fc:	2800      	cmp	r0, #0
 80178fe:	da58      	bge.n	80179b2 <_dtoa_r+0x906>
 8017900:	2300      	movs	r3, #0
 8017902:	220a      	movs	r2, #10
 8017904:	9903      	ldr	r1, [sp, #12]
 8017906:	9802      	ldr	r0, [sp, #8]
 8017908:	f000 fe56 	bl	80185b8 <__multadd>
 801790c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801790e:	3f01      	subs	r7, #1
 8017910:	9003      	str	r0, [sp, #12]
 8017912:	2b00      	cmp	r3, #0
 8017914:	d100      	bne.n	8017918 <_dtoa_r+0x86c>
 8017916:	e190      	b.n	8017c3a <_dtoa_r+0xb8e>
 8017918:	2300      	movs	r3, #0
 801791a:	0031      	movs	r1, r6
 801791c:	220a      	movs	r2, #10
 801791e:	9802      	ldr	r0, [sp, #8]
 8017920:	f000 fe4a 	bl	80185b8 <__multadd>
 8017924:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8017926:	0006      	movs	r6, r0
 8017928:	2b00      	cmp	r3, #0
 801792a:	dd00      	ble.n	801792e <_dtoa_r+0x882>
 801792c:	e088      	b.n	8017a40 <_dtoa_r+0x994>
 801792e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8017930:	2b02      	cmp	r3, #2
 8017932:	dc00      	bgt.n	8017936 <_dtoa_r+0x88a>
 8017934:	e084      	b.n	8017a40 <_dtoa_r+0x994>
 8017936:	e044      	b.n	80179c2 <_dtoa_r+0x916>
 8017938:	2336      	movs	r3, #54	; 0x36
 801793a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801793c:	1a9b      	subs	r3, r3, r2
 801793e:	e747      	b.n	80177d0 <_dtoa_r+0x724>
 8017940:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017942:	1e5d      	subs	r5, r3, #1
 8017944:	9b04      	ldr	r3, [sp, #16]
 8017946:	42ab      	cmp	r3, r5
 8017948:	db08      	blt.n	801795c <_dtoa_r+0x8b0>
 801794a:	1b5d      	subs	r5, r3, r5
 801794c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801794e:	2b00      	cmp	r3, #0
 8017950:	da0c      	bge.n	801796c <_dtoa_r+0x8c0>
 8017952:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017954:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8017956:	1a9c      	subs	r4, r3, r2
 8017958:	2300      	movs	r3, #0
 801795a:	e73b      	b.n	80177d4 <_dtoa_r+0x728>
 801795c:	9b04      	ldr	r3, [sp, #16]
 801795e:	9504      	str	r5, [sp, #16]
 8017960:	1aea      	subs	r2, r5, r3
 8017962:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8017964:	2500      	movs	r5, #0
 8017966:	189b      	adds	r3, r3, r2
 8017968:	9311      	str	r3, [sp, #68]	; 0x44
 801796a:	e7ef      	b.n	801794c <_dtoa_r+0x8a0>
 801796c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801796e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017970:	e730      	b.n	80177d4 <_dtoa_r+0x728>
 8017972:	9d04      	ldr	r5, [sp, #16]
 8017974:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8017976:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8017978:	e737      	b.n	80177ea <_dtoa_r+0x73e>
 801797a:	9a04      	ldr	r2, [sp, #16]
 801797c:	e764      	b.n	8017848 <_dtoa_r+0x79c>
 801797e:	2500      	movs	r5, #0
 8017980:	9b04      	ldr	r3, [sp, #16]
 8017982:	9a04      	ldr	r2, [sp, #16]
 8017984:	691b      	ldr	r3, [r3, #16]
 8017986:	9310      	str	r3, [sp, #64]	; 0x40
 8017988:	3303      	adds	r3, #3
 801798a:	009b      	lsls	r3, r3, #2
 801798c:	18d3      	adds	r3, r2, r3
 801798e:	6858      	ldr	r0, [r3, #4]
 8017990:	f000 fe8e 	bl	80186b0 <__hi0bits>
 8017994:	2320      	movs	r3, #32
 8017996:	1a18      	subs	r0, r3, r0
 8017998:	e785      	b.n	80178a6 <_dtoa_r+0x7fa>
 801799a:	2b04      	cmp	r3, #4
 801799c:	d095      	beq.n	80178ca <_dtoa_r+0x81e>
 801799e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80179a0:	331c      	adds	r3, #28
 80179a2:	18d2      	adds	r2, r2, r3
 80179a4:	920a      	str	r2, [sp, #40]	; 0x28
 80179a6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80179a8:	18e4      	adds	r4, r4, r3
 80179aa:	18d3      	adds	r3, r2, r3
 80179ac:	e78c      	b.n	80178c8 <_dtoa_r+0x81c>
 80179ae:	0003      	movs	r3, r0
 80179b0:	e7f5      	b.n	801799e <_dtoa_r+0x8f2>
 80179b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80179b4:	2b00      	cmp	r3, #0
 80179b6:	dc3d      	bgt.n	8017a34 <_dtoa_r+0x988>
 80179b8:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80179ba:	2b02      	cmp	r3, #2
 80179bc:	dd3a      	ble.n	8017a34 <_dtoa_r+0x988>
 80179be:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80179c0:	930c      	str	r3, [sp, #48]	; 0x30
 80179c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80179c4:	2b00      	cmp	r3, #0
 80179c6:	d10c      	bne.n	80179e2 <_dtoa_r+0x936>
 80179c8:	9904      	ldr	r1, [sp, #16]
 80179ca:	2205      	movs	r2, #5
 80179cc:	9802      	ldr	r0, [sp, #8]
 80179ce:	f000 fdf3 	bl	80185b8 <__multadd>
 80179d2:	9004      	str	r0, [sp, #16]
 80179d4:	0001      	movs	r1, r0
 80179d6:	9803      	ldr	r0, [sp, #12]
 80179d8:	f000 ffe0 	bl	801899c <__mcmp>
 80179dc:	2800      	cmp	r0, #0
 80179de:	dd00      	ble.n	80179e2 <_dtoa_r+0x936>
 80179e0:	e5ad      	b.n	801753e <_dtoa_r+0x492>
 80179e2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80179e4:	9d08      	ldr	r5, [sp, #32]
 80179e6:	43df      	mvns	r7, r3
 80179e8:	2300      	movs	r3, #0
 80179ea:	9309      	str	r3, [sp, #36]	; 0x24
 80179ec:	9904      	ldr	r1, [sp, #16]
 80179ee:	9802      	ldr	r0, [sp, #8]
 80179f0:	f000 fdd8 	bl	80185a4 <_Bfree>
 80179f4:	2e00      	cmp	r6, #0
 80179f6:	d100      	bne.n	80179fa <_dtoa_r+0x94e>
 80179f8:	e69b      	b.n	8017732 <_dtoa_r+0x686>
 80179fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80179fc:	2b00      	cmp	r3, #0
 80179fe:	d005      	beq.n	8017a0c <_dtoa_r+0x960>
 8017a00:	42b3      	cmp	r3, r6
 8017a02:	d003      	beq.n	8017a0c <_dtoa_r+0x960>
 8017a04:	0019      	movs	r1, r3
 8017a06:	9802      	ldr	r0, [sp, #8]
 8017a08:	f000 fdcc 	bl	80185a4 <_Bfree>
 8017a0c:	0031      	movs	r1, r6
 8017a0e:	9802      	ldr	r0, [sp, #8]
 8017a10:	f000 fdc8 	bl	80185a4 <_Bfree>
 8017a14:	e68d      	b.n	8017732 <_dtoa_r+0x686>
 8017a16:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8017a18:	9304      	str	r3, [sp, #16]
 8017a1a:	001e      	movs	r6, r3
 8017a1c:	e7e1      	b.n	80179e2 <_dtoa_r+0x936>
 8017a1e:	2300      	movs	r3, #0
 8017a20:	e7fa      	b.n	8017a18 <_dtoa_r+0x96c>
 8017a22:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8017a24:	0037      	movs	r7, r6
 8017a26:	9304      	str	r3, [sp, #16]
 8017a28:	001e      	movs	r6, r3
 8017a2a:	e588      	b.n	801753e <_dtoa_r+0x492>
 8017a2c:	40240000 	.word	0x40240000
 8017a30:	00000433 	.word	0x00000433
 8017a34:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8017a36:	2b00      	cmp	r3, #0
 8017a38:	d100      	bne.n	8017a3c <_dtoa_r+0x990>
 8017a3a:	e0b2      	b.n	8017ba2 <_dtoa_r+0xaf6>
 8017a3c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017a3e:	930c      	str	r3, [sp, #48]	; 0x30
 8017a40:	2c00      	cmp	r4, #0
 8017a42:	dd05      	ble.n	8017a50 <_dtoa_r+0x9a4>
 8017a44:	0031      	movs	r1, r6
 8017a46:	0022      	movs	r2, r4
 8017a48:	9802      	ldr	r0, [sp, #8]
 8017a4a:	f000 ff55 	bl	80188f8 <__lshift>
 8017a4e:	0006      	movs	r6, r0
 8017a50:	0030      	movs	r0, r6
 8017a52:	2d00      	cmp	r5, #0
 8017a54:	d011      	beq.n	8017a7a <_dtoa_r+0x9ce>
 8017a56:	6871      	ldr	r1, [r6, #4]
 8017a58:	9802      	ldr	r0, [sp, #8]
 8017a5a:	f000 fd7b 	bl	8018554 <_Balloc>
 8017a5e:	0031      	movs	r1, r6
 8017a60:	0004      	movs	r4, r0
 8017a62:	6933      	ldr	r3, [r6, #16]
 8017a64:	310c      	adds	r1, #12
 8017a66:	1c9a      	adds	r2, r3, #2
 8017a68:	0092      	lsls	r2, r2, #2
 8017a6a:	300c      	adds	r0, #12
 8017a6c:	f7fc fdf2 	bl	8014654 <memcpy>
 8017a70:	2201      	movs	r2, #1
 8017a72:	0021      	movs	r1, r4
 8017a74:	9802      	ldr	r0, [sp, #8]
 8017a76:	f000 ff3f 	bl	80188f8 <__lshift>
 8017a7a:	9609      	str	r6, [sp, #36]	; 0x24
 8017a7c:	0006      	movs	r6, r0
 8017a7e:	9b08      	ldr	r3, [sp, #32]
 8017a80:	930a      	str	r3, [sp, #40]	; 0x28
 8017a82:	9904      	ldr	r1, [sp, #16]
 8017a84:	9803      	ldr	r0, [sp, #12]
 8017a86:	f7ff fa8b 	bl	8016fa0 <quorem>
 8017a8a:	9909      	ldr	r1, [sp, #36]	; 0x24
 8017a8c:	900d      	str	r0, [sp, #52]	; 0x34
 8017a8e:	0004      	movs	r4, r0
 8017a90:	9803      	ldr	r0, [sp, #12]
 8017a92:	f000 ff83 	bl	801899c <__mcmp>
 8017a96:	0032      	movs	r2, r6
 8017a98:	9010      	str	r0, [sp, #64]	; 0x40
 8017a9a:	9904      	ldr	r1, [sp, #16]
 8017a9c:	9802      	ldr	r0, [sp, #8]
 8017a9e:	f000 ff97 	bl	80189d0 <__mdiff>
 8017aa2:	2301      	movs	r3, #1
 8017aa4:	930b      	str	r3, [sp, #44]	; 0x2c
 8017aa6:	68c3      	ldr	r3, [r0, #12]
 8017aa8:	3430      	adds	r4, #48	; 0x30
 8017aaa:	0005      	movs	r5, r0
 8017aac:	2b00      	cmp	r3, #0
 8017aae:	d104      	bne.n	8017aba <_dtoa_r+0xa0e>
 8017ab0:	0001      	movs	r1, r0
 8017ab2:	9803      	ldr	r0, [sp, #12]
 8017ab4:	f000 ff72 	bl	801899c <__mcmp>
 8017ab8:	900b      	str	r0, [sp, #44]	; 0x2c
 8017aba:	0029      	movs	r1, r5
 8017abc:	9802      	ldr	r0, [sp, #8]
 8017abe:	f000 fd71 	bl	80185a4 <_Bfree>
 8017ac2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8017ac4:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8017ac6:	4313      	orrs	r3, r2
 8017ac8:	d10e      	bne.n	8017ae8 <_dtoa_r+0xa3c>
 8017aca:	9a06      	ldr	r2, [sp, #24]
 8017acc:	3301      	adds	r3, #1
 8017ace:	4213      	tst	r3, r2
 8017ad0:	d10a      	bne.n	8017ae8 <_dtoa_r+0xa3c>
 8017ad2:	2c39      	cmp	r4, #57	; 0x39
 8017ad4:	d026      	beq.n	8017b24 <_dtoa_r+0xa78>
 8017ad6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8017ad8:	2b00      	cmp	r3, #0
 8017ada:	dd01      	ble.n	8017ae0 <_dtoa_r+0xa34>
 8017adc:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8017ade:	3431      	adds	r4, #49	; 0x31
 8017ae0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017ae2:	1c5d      	adds	r5, r3, #1
 8017ae4:	701c      	strb	r4, [r3, #0]
 8017ae6:	e781      	b.n	80179ec <_dtoa_r+0x940>
 8017ae8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8017aea:	2b00      	cmp	r3, #0
 8017aec:	db07      	blt.n	8017afe <_dtoa_r+0xa52>
 8017aee:	001d      	movs	r5, r3
 8017af0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8017af2:	431d      	orrs	r5, r3
 8017af4:	d122      	bne.n	8017b3c <_dtoa_r+0xa90>
 8017af6:	2301      	movs	r3, #1
 8017af8:	9a06      	ldr	r2, [sp, #24]
 8017afa:	4213      	tst	r3, r2
 8017afc:	d11e      	bne.n	8017b3c <_dtoa_r+0xa90>
 8017afe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8017b00:	2b00      	cmp	r3, #0
 8017b02:	dded      	ble.n	8017ae0 <_dtoa_r+0xa34>
 8017b04:	9903      	ldr	r1, [sp, #12]
 8017b06:	2201      	movs	r2, #1
 8017b08:	9802      	ldr	r0, [sp, #8]
 8017b0a:	f000 fef5 	bl	80188f8 <__lshift>
 8017b0e:	9904      	ldr	r1, [sp, #16]
 8017b10:	9003      	str	r0, [sp, #12]
 8017b12:	f000 ff43 	bl	801899c <__mcmp>
 8017b16:	2800      	cmp	r0, #0
 8017b18:	dc02      	bgt.n	8017b20 <_dtoa_r+0xa74>
 8017b1a:	d1e1      	bne.n	8017ae0 <_dtoa_r+0xa34>
 8017b1c:	07e3      	lsls	r3, r4, #31
 8017b1e:	d5df      	bpl.n	8017ae0 <_dtoa_r+0xa34>
 8017b20:	2c39      	cmp	r4, #57	; 0x39
 8017b22:	d1db      	bne.n	8017adc <_dtoa_r+0xa30>
 8017b24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017b26:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8017b28:	1c5d      	adds	r5, r3, #1
 8017b2a:	2339      	movs	r3, #57	; 0x39
 8017b2c:	7013      	strb	r3, [r2, #0]
 8017b2e:	1e6b      	subs	r3, r5, #1
 8017b30:	781a      	ldrb	r2, [r3, #0]
 8017b32:	2a39      	cmp	r2, #57	; 0x39
 8017b34:	d067      	beq.n	8017c06 <_dtoa_r+0xb5a>
 8017b36:	3201      	adds	r2, #1
 8017b38:	701a      	strb	r2, [r3, #0]
 8017b3a:	e757      	b.n	80179ec <_dtoa_r+0x940>
 8017b3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017b3e:	1c5d      	adds	r5, r3, #1
 8017b40:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8017b42:	2b00      	cmp	r3, #0
 8017b44:	dd04      	ble.n	8017b50 <_dtoa_r+0xaa4>
 8017b46:	2c39      	cmp	r4, #57	; 0x39
 8017b48:	d0ec      	beq.n	8017b24 <_dtoa_r+0xa78>
 8017b4a:	3401      	adds	r4, #1
 8017b4c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017b4e:	e7c9      	b.n	8017ae4 <_dtoa_r+0xa38>
 8017b50:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8017b52:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8017b54:	701c      	strb	r4, [r3, #0]
 8017b56:	9b08      	ldr	r3, [sp, #32]
 8017b58:	1aeb      	subs	r3, r5, r3
 8017b5a:	4293      	cmp	r3, r2
 8017b5c:	d03e      	beq.n	8017bdc <_dtoa_r+0xb30>
 8017b5e:	2300      	movs	r3, #0
 8017b60:	220a      	movs	r2, #10
 8017b62:	9903      	ldr	r1, [sp, #12]
 8017b64:	9802      	ldr	r0, [sp, #8]
 8017b66:	f000 fd27 	bl	80185b8 <__multadd>
 8017b6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017b6c:	9003      	str	r0, [sp, #12]
 8017b6e:	42b3      	cmp	r3, r6
 8017b70:	d109      	bne.n	8017b86 <_dtoa_r+0xada>
 8017b72:	2300      	movs	r3, #0
 8017b74:	220a      	movs	r2, #10
 8017b76:	9909      	ldr	r1, [sp, #36]	; 0x24
 8017b78:	9802      	ldr	r0, [sp, #8]
 8017b7a:	f000 fd1d 	bl	80185b8 <__multadd>
 8017b7e:	9009      	str	r0, [sp, #36]	; 0x24
 8017b80:	0006      	movs	r6, r0
 8017b82:	950a      	str	r5, [sp, #40]	; 0x28
 8017b84:	e77d      	b.n	8017a82 <_dtoa_r+0x9d6>
 8017b86:	9909      	ldr	r1, [sp, #36]	; 0x24
 8017b88:	2300      	movs	r3, #0
 8017b8a:	220a      	movs	r2, #10
 8017b8c:	9802      	ldr	r0, [sp, #8]
 8017b8e:	f000 fd13 	bl	80185b8 <__multadd>
 8017b92:	2300      	movs	r3, #0
 8017b94:	9009      	str	r0, [sp, #36]	; 0x24
 8017b96:	220a      	movs	r2, #10
 8017b98:	0031      	movs	r1, r6
 8017b9a:	9802      	ldr	r0, [sp, #8]
 8017b9c:	f000 fd0c 	bl	80185b8 <__multadd>
 8017ba0:	e7ee      	b.n	8017b80 <_dtoa_r+0xad4>
 8017ba2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017ba4:	930c      	str	r3, [sp, #48]	; 0x30
 8017ba6:	9b08      	ldr	r3, [sp, #32]
 8017ba8:	9306      	str	r3, [sp, #24]
 8017baa:	9904      	ldr	r1, [sp, #16]
 8017bac:	9803      	ldr	r0, [sp, #12]
 8017bae:	f7ff f9f7 	bl	8016fa0 <quorem>
 8017bb2:	9b06      	ldr	r3, [sp, #24]
 8017bb4:	3030      	adds	r0, #48	; 0x30
 8017bb6:	1c5d      	adds	r5, r3, #1
 8017bb8:	7018      	strb	r0, [r3, #0]
 8017bba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8017bbc:	9b08      	ldr	r3, [sp, #32]
 8017bbe:	0004      	movs	r4, r0
 8017bc0:	1aeb      	subs	r3, r5, r3
 8017bc2:	429a      	cmp	r2, r3
 8017bc4:	dd08      	ble.n	8017bd8 <_dtoa_r+0xb2c>
 8017bc6:	2300      	movs	r3, #0
 8017bc8:	220a      	movs	r2, #10
 8017bca:	9903      	ldr	r1, [sp, #12]
 8017bcc:	9802      	ldr	r0, [sp, #8]
 8017bce:	f000 fcf3 	bl	80185b8 <__multadd>
 8017bd2:	9506      	str	r5, [sp, #24]
 8017bd4:	9003      	str	r0, [sp, #12]
 8017bd6:	e7e8      	b.n	8017baa <_dtoa_r+0xafe>
 8017bd8:	2300      	movs	r3, #0
 8017bda:	9309      	str	r3, [sp, #36]	; 0x24
 8017bdc:	9903      	ldr	r1, [sp, #12]
 8017bde:	2201      	movs	r2, #1
 8017be0:	9802      	ldr	r0, [sp, #8]
 8017be2:	f000 fe89 	bl	80188f8 <__lshift>
 8017be6:	9904      	ldr	r1, [sp, #16]
 8017be8:	9003      	str	r0, [sp, #12]
 8017bea:	f000 fed7 	bl	801899c <__mcmp>
 8017bee:	2800      	cmp	r0, #0
 8017bf0:	dc9d      	bgt.n	8017b2e <_dtoa_r+0xa82>
 8017bf2:	d101      	bne.n	8017bf8 <_dtoa_r+0xb4c>
 8017bf4:	07e3      	lsls	r3, r4, #31
 8017bf6:	d49a      	bmi.n	8017b2e <_dtoa_r+0xa82>
 8017bf8:	1e6b      	subs	r3, r5, #1
 8017bfa:	781a      	ldrb	r2, [r3, #0]
 8017bfc:	2a30      	cmp	r2, #48	; 0x30
 8017bfe:	d000      	beq.n	8017c02 <_dtoa_r+0xb56>
 8017c00:	e6f4      	b.n	80179ec <_dtoa_r+0x940>
 8017c02:	001d      	movs	r5, r3
 8017c04:	e7f8      	b.n	8017bf8 <_dtoa_r+0xb4c>
 8017c06:	9a08      	ldr	r2, [sp, #32]
 8017c08:	429a      	cmp	r2, r3
 8017c0a:	d103      	bne.n	8017c14 <_dtoa_r+0xb68>
 8017c0c:	2331      	movs	r3, #49	; 0x31
 8017c0e:	3701      	adds	r7, #1
 8017c10:	7013      	strb	r3, [r2, #0]
 8017c12:	e6eb      	b.n	80179ec <_dtoa_r+0x940>
 8017c14:	001d      	movs	r5, r3
 8017c16:	e78a      	b.n	8017b2e <_dtoa_r+0xa82>
 8017c18:	4b0b      	ldr	r3, [pc, #44]	; (8017c48 <_dtoa_r+0xb9c>)
 8017c1a:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8017c1c:	9308      	str	r3, [sp, #32]
 8017c1e:	4b0b      	ldr	r3, [pc, #44]	; (8017c4c <_dtoa_r+0xba0>)
 8017c20:	2a00      	cmp	r2, #0
 8017c22:	d001      	beq.n	8017c28 <_dtoa_r+0xb7c>
 8017c24:	f7ff fa75 	bl	8017112 <_dtoa_r+0x66>
 8017c28:	f7ff fa75 	bl	8017116 <_dtoa_r+0x6a>
 8017c2c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8017c2e:	2b01      	cmp	r3, #1
 8017c30:	dc00      	bgt.n	8017c34 <_dtoa_r+0xb88>
 8017c32:	e621      	b.n	8017878 <_dtoa_r+0x7cc>
 8017c34:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8017c36:	2001      	movs	r0, #1
 8017c38:	e635      	b.n	80178a6 <_dtoa_r+0x7fa>
 8017c3a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8017c3c:	2b00      	cmp	r3, #0
 8017c3e:	dcb2      	bgt.n	8017ba6 <_dtoa_r+0xafa>
 8017c40:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8017c42:	2b02      	cmp	r3, #2
 8017c44:	ddaf      	ble.n	8017ba6 <_dtoa_r+0xafa>
 8017c46:	e6bc      	b.n	80179c2 <_dtoa_r+0x916>
 8017c48:	0801c72b 	.word	0x0801c72b
 8017c4c:	0801c733 	.word	0x0801c733

08017c50 <__errno>:
 8017c50:	4b01      	ldr	r3, [pc, #4]	; (8017c58 <__errno+0x8>)
 8017c52:	6818      	ldr	r0, [r3, #0]
 8017c54:	4770      	bx	lr
 8017c56:	46c0      	nop			; (mov r8, r8)
 8017c58:	200000d0 	.word	0x200000d0

08017c5c <__libc_fini_array>:
 8017c5c:	b570      	push	{r4, r5, r6, lr}
 8017c5e:	4d07      	ldr	r5, [pc, #28]	; (8017c7c <__libc_fini_array+0x20>)
 8017c60:	4c07      	ldr	r4, [pc, #28]	; (8017c80 <__libc_fini_array+0x24>)
 8017c62:	1b64      	subs	r4, r4, r5
 8017c64:	10a4      	asrs	r4, r4, #2
 8017c66:	2c00      	cmp	r4, #0
 8017c68:	d102      	bne.n	8017c70 <__libc_fini_array+0x14>
 8017c6a:	f001 f987 	bl	8018f7c <_fini>
 8017c6e:	bd70      	pop	{r4, r5, r6, pc}
 8017c70:	3c01      	subs	r4, #1
 8017c72:	00a3      	lsls	r3, r4, #2
 8017c74:	58eb      	ldr	r3, [r5, r3]
 8017c76:	4798      	blx	r3
 8017c78:	e7f5      	b.n	8017c66 <__libc_fini_array+0xa>
 8017c7a:	46c0      	nop			; (mov r8, r8)
 8017c7c:	0801c844 	.word	0x0801c844
 8017c80:	0801c848 	.word	0x0801c848

08017c84 <_malloc_trim_r>:
 8017c84:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8017c86:	0005      	movs	r5, r0
 8017c88:	2008      	movs	r0, #8
 8017c8a:	000c      	movs	r4, r1
 8017c8c:	f7ff f95c 	bl	8016f48 <sysconf>
 8017c90:	0007      	movs	r7, r0
 8017c92:	0028      	movs	r0, r5
 8017c94:	f7fc fcf0 	bl	8014678 <__malloc_lock>
 8017c98:	2203      	movs	r2, #3
 8017c9a:	4e21      	ldr	r6, [pc, #132]	; (8017d20 <_malloc_trim_r+0x9c>)
 8017c9c:	0039      	movs	r1, r7
 8017c9e:	68b3      	ldr	r3, [r6, #8]
 8017ca0:	685b      	ldr	r3, [r3, #4]
 8017ca2:	4393      	bics	r3, r2
 8017ca4:	1b18      	subs	r0, r3, r4
 8017ca6:	3811      	subs	r0, #17
 8017ca8:	19c0      	adds	r0, r0, r7
 8017caa:	9301      	str	r3, [sp, #4]
 8017cac:	f7e8 fa64 	bl	8000178 <__udivsi3>
 8017cb0:	1e44      	subs	r4, r0, #1
 8017cb2:	437c      	muls	r4, r7
 8017cb4:	42a7      	cmp	r7, r4
 8017cb6:	dd04      	ble.n	8017cc2 <_malloc_trim_r+0x3e>
 8017cb8:	0028      	movs	r0, r5
 8017cba:	f7fc fce5 	bl	8014688 <__malloc_unlock>
 8017cbe:	2000      	movs	r0, #0
 8017cc0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8017cc2:	2100      	movs	r1, #0
 8017cc4:	0028      	movs	r0, r5
 8017cc6:	f7fc feb7 	bl	8014a38 <_sbrk_r>
 8017cca:	68b3      	ldr	r3, [r6, #8]
 8017ccc:	9a01      	ldr	r2, [sp, #4]
 8017cce:	189b      	adds	r3, r3, r2
 8017cd0:	4298      	cmp	r0, r3
 8017cd2:	d1f1      	bne.n	8017cb8 <_malloc_trim_r+0x34>
 8017cd4:	4261      	negs	r1, r4
 8017cd6:	0028      	movs	r0, r5
 8017cd8:	f7fc feae 	bl	8014a38 <_sbrk_r>
 8017cdc:	1c43      	adds	r3, r0, #1
 8017cde:	d110      	bne.n	8017d02 <_malloc_trim_r+0x7e>
 8017ce0:	2100      	movs	r1, #0
 8017ce2:	0028      	movs	r0, r5
 8017ce4:	f7fc fea8 	bl	8014a38 <_sbrk_r>
 8017ce8:	68b2      	ldr	r2, [r6, #8]
 8017cea:	1a81      	subs	r1, r0, r2
 8017cec:	290f      	cmp	r1, #15
 8017cee:	dde3      	ble.n	8017cb8 <_malloc_trim_r+0x34>
 8017cf0:	4b0c      	ldr	r3, [pc, #48]	; (8017d24 <_malloc_trim_r+0xa0>)
 8017cf2:	681b      	ldr	r3, [r3, #0]
 8017cf4:	1ac0      	subs	r0, r0, r3
 8017cf6:	4b0c      	ldr	r3, [pc, #48]	; (8017d28 <_malloc_trim_r+0xa4>)
 8017cf8:	6018      	str	r0, [r3, #0]
 8017cfa:	2301      	movs	r3, #1
 8017cfc:	430b      	orrs	r3, r1
 8017cfe:	6053      	str	r3, [r2, #4]
 8017d00:	e7da      	b.n	8017cb8 <_malloc_trim_r+0x34>
 8017d02:	68b2      	ldr	r2, [r6, #8]
 8017d04:	2601      	movs	r6, #1
 8017d06:	9b01      	ldr	r3, [sp, #4]
 8017d08:	0028      	movs	r0, r5
 8017d0a:	1b1b      	subs	r3, r3, r4
 8017d0c:	4333      	orrs	r3, r6
 8017d0e:	6053      	str	r3, [r2, #4]
 8017d10:	4b05      	ldr	r3, [pc, #20]	; (8017d28 <_malloc_trim_r+0xa4>)
 8017d12:	681a      	ldr	r2, [r3, #0]
 8017d14:	1b14      	subs	r4, r2, r4
 8017d16:	601c      	str	r4, [r3, #0]
 8017d18:	f7fc fcb6 	bl	8014688 <__malloc_unlock>
 8017d1c:	0030      	movs	r0, r6
 8017d1e:	e7cf      	b.n	8017cc0 <_malloc_trim_r+0x3c>
 8017d20:	2000066c 	.word	0x2000066c
 8017d24:	20000a74 	.word	0x20000a74
 8017d28:	20006ebc 	.word	0x20006ebc

08017d2c <_free_r>:
 8017d2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8017d2e:	1e0d      	subs	r5, r1, #0
 8017d30:	9001      	str	r0, [sp, #4]
 8017d32:	d02d      	beq.n	8017d90 <_free_r+0x64>
 8017d34:	f7fc fca0 	bl	8014678 <__malloc_lock>
 8017d38:	2301      	movs	r3, #1
 8017d3a:	0029      	movs	r1, r5
 8017d3c:	469c      	mov	ip, r3
 8017d3e:	3908      	subs	r1, #8
 8017d40:	684f      	ldr	r7, [r1, #4]
 8017d42:	4662      	mov	r2, ip
 8017d44:	003b      	movs	r3, r7
 8017d46:	4666      	mov	r6, ip
 8017d48:	4393      	bics	r3, r2
 8017d4a:	18c8      	adds	r0, r1, r3
 8017d4c:	6845      	ldr	r5, [r0, #4]
 8017d4e:	3202      	adds	r2, #2
 8017d50:	4395      	bics	r5, r2
 8017d52:	4a4a      	ldr	r2, [pc, #296]	; (8017e7c <_free_r+0x150>)
 8017d54:	4037      	ands	r7, r6
 8017d56:	6896      	ldr	r6, [r2, #8]
 8017d58:	4286      	cmp	r6, r0
 8017d5a:	d11a      	bne.n	8017d92 <_free_r+0x66>
 8017d5c:	195b      	adds	r3, r3, r5
 8017d5e:	2f00      	cmp	r7, #0
 8017d60:	d106      	bne.n	8017d70 <_free_r+0x44>
 8017d62:	6808      	ldr	r0, [r1, #0]
 8017d64:	1a09      	subs	r1, r1, r0
 8017d66:	688d      	ldr	r5, [r1, #8]
 8017d68:	181b      	adds	r3, r3, r0
 8017d6a:	68c8      	ldr	r0, [r1, #12]
 8017d6c:	60e8      	str	r0, [r5, #12]
 8017d6e:	6085      	str	r5, [r0, #8]
 8017d70:	2001      	movs	r0, #1
 8017d72:	4318      	orrs	r0, r3
 8017d74:	6048      	str	r0, [r1, #4]
 8017d76:	6091      	str	r1, [r2, #8]
 8017d78:	4a41      	ldr	r2, [pc, #260]	; (8017e80 <_free_r+0x154>)
 8017d7a:	6812      	ldr	r2, [r2, #0]
 8017d7c:	429a      	cmp	r2, r3
 8017d7e:	d804      	bhi.n	8017d8a <_free_r+0x5e>
 8017d80:	4b40      	ldr	r3, [pc, #256]	; (8017e84 <_free_r+0x158>)
 8017d82:	9801      	ldr	r0, [sp, #4]
 8017d84:	6819      	ldr	r1, [r3, #0]
 8017d86:	f7ff ff7d 	bl	8017c84 <_malloc_trim_r>
 8017d8a:	9801      	ldr	r0, [sp, #4]
 8017d8c:	f7fc fc7c 	bl	8014688 <__malloc_unlock>
 8017d90:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8017d92:	2600      	movs	r6, #0
 8017d94:	6045      	str	r5, [r0, #4]
 8017d96:	42b7      	cmp	r7, r6
 8017d98:	d109      	bne.n	8017dae <_free_r+0x82>
 8017d9a:	680f      	ldr	r7, [r1, #0]
 8017d9c:	4c3a      	ldr	r4, [pc, #232]	; (8017e88 <_free_r+0x15c>)
 8017d9e:	1bc9      	subs	r1, r1, r7
 8017da0:	19db      	adds	r3, r3, r7
 8017da2:	688f      	ldr	r7, [r1, #8]
 8017da4:	42a7      	cmp	r7, r4
 8017da6:	d02b      	beq.n	8017e00 <_free_r+0xd4>
 8017da8:	68cc      	ldr	r4, [r1, #12]
 8017daa:	60fc      	str	r4, [r7, #12]
 8017dac:	60a7      	str	r7, [r4, #8]
 8017dae:	1947      	adds	r7, r0, r5
 8017db0:	687c      	ldr	r4, [r7, #4]
 8017db2:	2701      	movs	r7, #1
 8017db4:	423c      	tst	r4, r7
 8017db6:	d10b      	bne.n	8017dd0 <_free_r+0xa4>
 8017db8:	195b      	adds	r3, r3, r5
 8017dba:	6885      	ldr	r5, [r0, #8]
 8017dbc:	2e00      	cmp	r6, #0
 8017dbe:	d121      	bne.n	8017e04 <_free_r+0xd8>
 8017dc0:	4c31      	ldr	r4, [pc, #196]	; (8017e88 <_free_r+0x15c>)
 8017dc2:	42a5      	cmp	r5, r4
 8017dc4:	d11e      	bne.n	8017e04 <_free_r+0xd8>
 8017dc6:	003e      	movs	r6, r7
 8017dc8:	6151      	str	r1, [r2, #20]
 8017dca:	6111      	str	r1, [r2, #16]
 8017dcc:	60cd      	str	r5, [r1, #12]
 8017dce:	608d      	str	r5, [r1, #8]
 8017dd0:	2001      	movs	r0, #1
 8017dd2:	0005      	movs	r5, r0
 8017dd4:	431d      	orrs	r5, r3
 8017dd6:	604d      	str	r5, [r1, #4]
 8017dd8:	50cb      	str	r3, [r1, r3]
 8017dda:	2e00      	cmp	r6, #0
 8017ddc:	d1d5      	bne.n	8017d8a <_free_r+0x5e>
 8017dde:	4d2b      	ldr	r5, [pc, #172]	; (8017e8c <_free_r+0x160>)
 8017de0:	42ab      	cmp	r3, r5
 8017de2:	d813      	bhi.n	8017e0c <_free_r+0xe0>
 8017de4:	08db      	lsrs	r3, r3, #3
 8017de6:	109d      	asrs	r5, r3, #2
 8017de8:	40a8      	lsls	r0, r5
 8017dea:	6854      	ldr	r4, [r2, #4]
 8017dec:	00db      	lsls	r3, r3, #3
 8017dee:	4320      	orrs	r0, r4
 8017df0:	6050      	str	r0, [r2, #4]
 8017df2:	189a      	adds	r2, r3, r2
 8017df4:	6893      	ldr	r3, [r2, #8]
 8017df6:	60ca      	str	r2, [r1, #12]
 8017df8:	608b      	str	r3, [r1, #8]
 8017dfa:	6091      	str	r1, [r2, #8]
 8017dfc:	60d9      	str	r1, [r3, #12]
 8017dfe:	e7c4      	b.n	8017d8a <_free_r+0x5e>
 8017e00:	4666      	mov	r6, ip
 8017e02:	e7d4      	b.n	8017dae <_free_r+0x82>
 8017e04:	68c0      	ldr	r0, [r0, #12]
 8017e06:	60e8      	str	r0, [r5, #12]
 8017e08:	6085      	str	r5, [r0, #8]
 8017e0a:	e7e1      	b.n	8017dd0 <_free_r+0xa4>
 8017e0c:	0a5d      	lsrs	r5, r3, #9
 8017e0e:	2d04      	cmp	r5, #4
 8017e10:	d812      	bhi.n	8017e38 <_free_r+0x10c>
 8017e12:	0998      	lsrs	r0, r3, #6
 8017e14:	3038      	adds	r0, #56	; 0x38
 8017e16:	00c6      	lsls	r6, r0, #3
 8017e18:	18b6      	adds	r6, r6, r2
 8017e1a:	68b5      	ldr	r5, [r6, #8]
 8017e1c:	2703      	movs	r7, #3
 8017e1e:	42ae      	cmp	r6, r5
 8017e20:	d125      	bne.n	8017e6e <_free_r+0x142>
 8017e22:	2301      	movs	r3, #1
 8017e24:	1080      	asrs	r0, r0, #2
 8017e26:	4083      	lsls	r3, r0
 8017e28:	6850      	ldr	r0, [r2, #4]
 8017e2a:	4303      	orrs	r3, r0
 8017e2c:	6053      	str	r3, [r2, #4]
 8017e2e:	60ce      	str	r6, [r1, #12]
 8017e30:	608d      	str	r5, [r1, #8]
 8017e32:	60b1      	str	r1, [r6, #8]
 8017e34:	60e9      	str	r1, [r5, #12]
 8017e36:	e7a8      	b.n	8017d8a <_free_r+0x5e>
 8017e38:	2d14      	cmp	r5, #20
 8017e3a:	d802      	bhi.n	8017e42 <_free_r+0x116>
 8017e3c:	0028      	movs	r0, r5
 8017e3e:	305b      	adds	r0, #91	; 0x5b
 8017e40:	e7e9      	b.n	8017e16 <_free_r+0xea>
 8017e42:	2d54      	cmp	r5, #84	; 0x54
 8017e44:	d802      	bhi.n	8017e4c <_free_r+0x120>
 8017e46:	0b18      	lsrs	r0, r3, #12
 8017e48:	306e      	adds	r0, #110	; 0x6e
 8017e4a:	e7e4      	b.n	8017e16 <_free_r+0xea>
 8017e4c:	20aa      	movs	r0, #170	; 0xaa
 8017e4e:	0040      	lsls	r0, r0, #1
 8017e50:	4285      	cmp	r5, r0
 8017e52:	d802      	bhi.n	8017e5a <_free_r+0x12e>
 8017e54:	0bd8      	lsrs	r0, r3, #15
 8017e56:	3077      	adds	r0, #119	; 0x77
 8017e58:	e7dd      	b.n	8017e16 <_free_r+0xea>
 8017e5a:	4e0d      	ldr	r6, [pc, #52]	; (8017e90 <_free_r+0x164>)
 8017e5c:	207e      	movs	r0, #126	; 0x7e
 8017e5e:	42b5      	cmp	r5, r6
 8017e60:	d8d9      	bhi.n	8017e16 <_free_r+0xea>
 8017e62:	0c98      	lsrs	r0, r3, #18
 8017e64:	307c      	adds	r0, #124	; 0x7c
 8017e66:	e7d6      	b.n	8017e16 <_free_r+0xea>
 8017e68:	68ad      	ldr	r5, [r5, #8]
 8017e6a:	42ae      	cmp	r6, r5
 8017e6c:	d003      	beq.n	8017e76 <_free_r+0x14a>
 8017e6e:	686a      	ldr	r2, [r5, #4]
 8017e70:	43ba      	bics	r2, r7
 8017e72:	429a      	cmp	r2, r3
 8017e74:	d8f8      	bhi.n	8017e68 <_free_r+0x13c>
 8017e76:	68ee      	ldr	r6, [r5, #12]
 8017e78:	e7d9      	b.n	8017e2e <_free_r+0x102>
 8017e7a:	46c0      	nop			; (mov r8, r8)
 8017e7c:	2000066c 	.word	0x2000066c
 8017e80:	20000a78 	.word	0x20000a78
 8017e84:	20006eec 	.word	0x20006eec
 8017e88:	20000674 	.word	0x20000674
 8017e8c:	000001ff 	.word	0x000001ff
 8017e90:	00000554 	.word	0x00000554

08017e94 <rshift>:
 8017e94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017e96:	0004      	movs	r4, r0
 8017e98:	6905      	ldr	r5, [r0, #16]
 8017e9a:	3414      	adds	r4, #20
 8017e9c:	114b      	asrs	r3, r1, #5
 8017e9e:	0026      	movs	r6, r4
 8017ea0:	429d      	cmp	r5, r3
 8017ea2:	dd14      	ble.n	8017ece <rshift+0x3a>
 8017ea4:	221f      	movs	r2, #31
 8017ea6:	00ad      	lsls	r5, r5, #2
 8017ea8:	009b      	lsls	r3, r3, #2
 8017eaa:	4011      	ands	r1, r2
 8017eac:	1965      	adds	r5, r4, r5
 8017eae:	18e3      	adds	r3, r4, r3
 8017eb0:	0022      	movs	r2, r4
 8017eb2:	2900      	cmp	r1, #0
 8017eb4:	d01e      	beq.n	8017ef4 <rshift+0x60>
 8017eb6:	cb04      	ldmia	r3!, {r2}
 8017eb8:	2720      	movs	r7, #32
 8017eba:	40ca      	lsrs	r2, r1
 8017ebc:	46a4      	mov	ip, r4
 8017ebe:	1a7f      	subs	r7, r7, r1
 8017ec0:	4666      	mov	r6, ip
 8017ec2:	429d      	cmp	r5, r3
 8017ec4:	d80b      	bhi.n	8017ede <rshift+0x4a>
 8017ec6:	6032      	str	r2, [r6, #0]
 8017ec8:	2a00      	cmp	r2, #0
 8017eca:	d000      	beq.n	8017ece <rshift+0x3a>
 8017ecc:	3604      	adds	r6, #4
 8017ece:	1b33      	subs	r3, r6, r4
 8017ed0:	109b      	asrs	r3, r3, #2
 8017ed2:	6103      	str	r3, [r0, #16]
 8017ed4:	42a6      	cmp	r6, r4
 8017ed6:	d101      	bne.n	8017edc <rshift+0x48>
 8017ed8:	2300      	movs	r3, #0
 8017eda:	6143      	str	r3, [r0, #20]
 8017edc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017ede:	681e      	ldr	r6, [r3, #0]
 8017ee0:	40be      	lsls	r6, r7
 8017ee2:	4332      	orrs	r2, r6
 8017ee4:	4666      	mov	r6, ip
 8017ee6:	c604      	stmia	r6!, {r2}
 8017ee8:	cb04      	ldmia	r3!, {r2}
 8017eea:	46b4      	mov	ip, r6
 8017eec:	40ca      	lsrs	r2, r1
 8017eee:	e7e7      	b.n	8017ec0 <rshift+0x2c>
 8017ef0:	cb02      	ldmia	r3!, {r1}
 8017ef2:	c202      	stmia	r2!, {r1}
 8017ef4:	0016      	movs	r6, r2
 8017ef6:	429d      	cmp	r5, r3
 8017ef8:	d8fa      	bhi.n	8017ef0 <rshift+0x5c>
 8017efa:	e7e8      	b.n	8017ece <rshift+0x3a>

08017efc <__hexdig_fun>:
 8017efc:	0003      	movs	r3, r0
 8017efe:	3b30      	subs	r3, #48	; 0x30
 8017f00:	2b09      	cmp	r3, #9
 8017f02:	d803      	bhi.n	8017f0c <__hexdig_fun+0x10>
 8017f04:	3820      	subs	r0, #32
 8017f06:	b2c3      	uxtb	r3, r0
 8017f08:	0018      	movs	r0, r3
 8017f0a:	4770      	bx	lr
 8017f0c:	0003      	movs	r3, r0
 8017f0e:	3b61      	subs	r3, #97	; 0x61
 8017f10:	2b05      	cmp	r3, #5
 8017f12:	d801      	bhi.n	8017f18 <__hexdig_fun+0x1c>
 8017f14:	3847      	subs	r0, #71	; 0x47
 8017f16:	e7f6      	b.n	8017f06 <__hexdig_fun+0xa>
 8017f18:	0002      	movs	r2, r0
 8017f1a:	3a41      	subs	r2, #65	; 0x41
 8017f1c:	2300      	movs	r3, #0
 8017f1e:	2a05      	cmp	r2, #5
 8017f20:	d8f2      	bhi.n	8017f08 <__hexdig_fun+0xc>
 8017f22:	3827      	subs	r0, #39	; 0x27
 8017f24:	e7ef      	b.n	8017f06 <__hexdig_fun+0xa>

08017f26 <__gethex>:
 8017f26:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017f28:	b08d      	sub	sp, #52	; 0x34
 8017f2a:	9005      	str	r0, [sp, #20]
 8017f2c:	9814      	ldr	r0, [sp, #80]	; 0x50
 8017f2e:	9109      	str	r1, [sp, #36]	; 0x24
 8017f30:	9202      	str	r2, [sp, #8]
 8017f32:	930a      	str	r3, [sp, #40]	; 0x28
 8017f34:	f000 fadf 	bl	80184f6 <__localeconv_l>
 8017f38:	6803      	ldr	r3, [r0, #0]
 8017f3a:	0018      	movs	r0, r3
 8017f3c:	9307      	str	r3, [sp, #28]
 8017f3e:	f7e8 f8eb 	bl	8000118 <strlen>
 8017f42:	2202      	movs	r2, #2
 8017f44:	9b07      	ldr	r3, [sp, #28]
 8017f46:	4252      	negs	r2, r2
 8017f48:	181b      	adds	r3, r3, r0
 8017f4a:	3b01      	subs	r3, #1
 8017f4c:	781b      	ldrb	r3, [r3, #0]
 8017f4e:	9004      	str	r0, [sp, #16]
 8017f50:	930b      	str	r3, [sp, #44]	; 0x2c
 8017f52:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017f54:	6819      	ldr	r1, [r3, #0]
 8017f56:	1c8b      	adds	r3, r1, #2
 8017f58:	1a52      	subs	r2, r2, r1
 8017f5a:	18d1      	adds	r1, r2, r3
 8017f5c:	9301      	str	r3, [sp, #4]
 8017f5e:	9108      	str	r1, [sp, #32]
 8017f60:	9901      	ldr	r1, [sp, #4]
 8017f62:	3301      	adds	r3, #1
 8017f64:	7808      	ldrb	r0, [r1, #0]
 8017f66:	2830      	cmp	r0, #48	; 0x30
 8017f68:	d0f7      	beq.n	8017f5a <__gethex+0x34>
 8017f6a:	f7ff ffc7 	bl	8017efc <__hexdig_fun>
 8017f6e:	1e07      	subs	r7, r0, #0
 8017f70:	d000      	beq.n	8017f74 <__gethex+0x4e>
 8017f72:	e06f      	b.n	8018054 <__gethex+0x12e>
 8017f74:	9a04      	ldr	r2, [sp, #16]
 8017f76:	9907      	ldr	r1, [sp, #28]
 8017f78:	9801      	ldr	r0, [sp, #4]
 8017f7a:	f7fc fdb3 	bl	8014ae4 <strncmp>
 8017f7e:	2800      	cmp	r0, #0
 8017f80:	d000      	beq.n	8017f84 <__gethex+0x5e>
 8017f82:	e06d      	b.n	8018060 <__gethex+0x13a>
 8017f84:	9b01      	ldr	r3, [sp, #4]
 8017f86:	9a04      	ldr	r2, [sp, #16]
 8017f88:	189c      	adds	r4, r3, r2
 8017f8a:	7820      	ldrb	r0, [r4, #0]
 8017f8c:	f7ff ffb6 	bl	8017efc <__hexdig_fun>
 8017f90:	2800      	cmp	r0, #0
 8017f92:	d069      	beq.n	8018068 <__gethex+0x142>
 8017f94:	9401      	str	r4, [sp, #4]
 8017f96:	9b01      	ldr	r3, [sp, #4]
 8017f98:	7818      	ldrb	r0, [r3, #0]
 8017f9a:	2830      	cmp	r0, #48	; 0x30
 8017f9c:	d009      	beq.n	8017fb2 <__gethex+0x8c>
 8017f9e:	f7ff ffad 	bl	8017efc <__hexdig_fun>
 8017fa2:	4243      	negs	r3, r0
 8017fa4:	4143      	adcs	r3, r0
 8017fa6:	9303      	str	r3, [sp, #12]
 8017fa8:	2301      	movs	r3, #1
 8017faa:	0026      	movs	r6, r4
 8017fac:	9308      	str	r3, [sp, #32]
 8017fae:	9c01      	ldr	r4, [sp, #4]
 8017fb0:	e004      	b.n	8017fbc <__gethex+0x96>
 8017fb2:	9b01      	ldr	r3, [sp, #4]
 8017fb4:	3301      	adds	r3, #1
 8017fb6:	9301      	str	r3, [sp, #4]
 8017fb8:	e7ed      	b.n	8017f96 <__gethex+0x70>
 8017fba:	3401      	adds	r4, #1
 8017fbc:	7820      	ldrb	r0, [r4, #0]
 8017fbe:	f7ff ff9d 	bl	8017efc <__hexdig_fun>
 8017fc2:	2800      	cmp	r0, #0
 8017fc4:	d1f9      	bne.n	8017fba <__gethex+0x94>
 8017fc6:	9a04      	ldr	r2, [sp, #16]
 8017fc8:	9907      	ldr	r1, [sp, #28]
 8017fca:	0020      	movs	r0, r4
 8017fcc:	f7fc fd8a 	bl	8014ae4 <strncmp>
 8017fd0:	2800      	cmp	r0, #0
 8017fd2:	d109      	bne.n	8017fe8 <__gethex+0xc2>
 8017fd4:	2e00      	cmp	r6, #0
 8017fd6:	d10a      	bne.n	8017fee <__gethex+0xc8>
 8017fd8:	9b04      	ldr	r3, [sp, #16]
 8017fda:	18e4      	adds	r4, r4, r3
 8017fdc:	0026      	movs	r6, r4
 8017fde:	7820      	ldrb	r0, [r4, #0]
 8017fe0:	f7ff ff8c 	bl	8017efc <__hexdig_fun>
 8017fe4:	2800      	cmp	r0, #0
 8017fe6:	d139      	bne.n	801805c <__gethex+0x136>
 8017fe8:	2700      	movs	r7, #0
 8017fea:	42be      	cmp	r6, r7
 8017fec:	d001      	beq.n	8017ff2 <__gethex+0xcc>
 8017fee:	1b37      	subs	r7, r6, r4
 8017ff0:	00bf      	lsls	r7, r7, #2
 8017ff2:	7823      	ldrb	r3, [r4, #0]
 8017ff4:	2b50      	cmp	r3, #80	; 0x50
 8017ff6:	d001      	beq.n	8017ffc <__gethex+0xd6>
 8017ff8:	2b70      	cmp	r3, #112	; 0x70
 8017ffa:	d142      	bne.n	8018082 <__gethex+0x15c>
 8017ffc:	7863      	ldrb	r3, [r4, #1]
 8017ffe:	2b2b      	cmp	r3, #43	; 0x2b
 8018000:	d034      	beq.n	801806c <__gethex+0x146>
 8018002:	2b2d      	cmp	r3, #45	; 0x2d
 8018004:	d036      	beq.n	8018074 <__gethex+0x14e>
 8018006:	2300      	movs	r3, #0
 8018008:	1c66      	adds	r6, r4, #1
 801800a:	9306      	str	r3, [sp, #24]
 801800c:	7830      	ldrb	r0, [r6, #0]
 801800e:	f7ff ff75 	bl	8017efc <__hexdig_fun>
 8018012:	1e43      	subs	r3, r0, #1
 8018014:	b2db      	uxtb	r3, r3
 8018016:	2b18      	cmp	r3, #24
 8018018:	d833      	bhi.n	8018082 <__gethex+0x15c>
 801801a:	3810      	subs	r0, #16
 801801c:	0005      	movs	r5, r0
 801801e:	3601      	adds	r6, #1
 8018020:	7830      	ldrb	r0, [r6, #0]
 8018022:	f7ff ff6b 	bl	8017efc <__hexdig_fun>
 8018026:	1e43      	subs	r3, r0, #1
 8018028:	b2db      	uxtb	r3, r3
 801802a:	2b18      	cmp	r3, #24
 801802c:	d924      	bls.n	8018078 <__gethex+0x152>
 801802e:	9b06      	ldr	r3, [sp, #24]
 8018030:	2b00      	cmp	r3, #0
 8018032:	d000      	beq.n	8018036 <__gethex+0x110>
 8018034:	426d      	negs	r5, r5
 8018036:	197f      	adds	r7, r7, r5
 8018038:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801803a:	601e      	str	r6, [r3, #0]
 801803c:	9b03      	ldr	r3, [sp, #12]
 801803e:	2b00      	cmp	r3, #0
 8018040:	d021      	beq.n	8018086 <__gethex+0x160>
 8018042:	9b08      	ldr	r3, [sp, #32]
 8018044:	2606      	movs	r6, #6
 8018046:	425a      	negs	r2, r3
 8018048:	4153      	adcs	r3, r2
 801804a:	425b      	negs	r3, r3
 801804c:	401e      	ands	r6, r3
 801804e:	0030      	movs	r0, r6
 8018050:	b00d      	add	sp, #52	; 0x34
 8018052:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018054:	2300      	movs	r3, #0
 8018056:	9303      	str	r3, [sp, #12]
 8018058:	001e      	movs	r6, r3
 801805a:	e7a8      	b.n	8017fae <__gethex+0x88>
 801805c:	3401      	adds	r4, #1
 801805e:	e7be      	b.n	8017fde <__gethex+0xb8>
 8018060:	9c01      	ldr	r4, [sp, #4]
 8018062:	2301      	movs	r3, #1
 8018064:	9303      	str	r3, [sp, #12]
 8018066:	e7c4      	b.n	8017ff2 <__gethex+0xcc>
 8018068:	0007      	movs	r7, r0
 801806a:	e7fa      	b.n	8018062 <__gethex+0x13c>
 801806c:	2300      	movs	r3, #0
 801806e:	9306      	str	r3, [sp, #24]
 8018070:	1ca6      	adds	r6, r4, #2
 8018072:	e7cb      	b.n	801800c <__gethex+0xe6>
 8018074:	2301      	movs	r3, #1
 8018076:	e7fa      	b.n	801806e <__gethex+0x148>
 8018078:	230a      	movs	r3, #10
 801807a:	435d      	muls	r5, r3
 801807c:	182d      	adds	r5, r5, r0
 801807e:	3d10      	subs	r5, #16
 8018080:	e7cd      	b.n	801801e <__gethex+0xf8>
 8018082:	0026      	movs	r6, r4
 8018084:	e7d8      	b.n	8018038 <__gethex+0x112>
 8018086:	9b01      	ldr	r3, [sp, #4]
 8018088:	9903      	ldr	r1, [sp, #12]
 801808a:	1ae3      	subs	r3, r4, r3
 801808c:	3b01      	subs	r3, #1
 801808e:	2b07      	cmp	r3, #7
 8018090:	dc47      	bgt.n	8018122 <__gethex+0x1fc>
 8018092:	9805      	ldr	r0, [sp, #20]
 8018094:	f000 fa5e 	bl	8018554 <_Balloc>
 8018098:	0003      	movs	r3, r0
 801809a:	3314      	adds	r3, #20
 801809c:	9303      	str	r3, [sp, #12]
 801809e:	9308      	str	r3, [sp, #32]
 80180a0:	2300      	movs	r3, #0
 80180a2:	0005      	movs	r5, r0
 80180a4:	001e      	movs	r6, r3
 80180a6:	9306      	str	r3, [sp, #24]
 80180a8:	9b01      	ldr	r3, [sp, #4]
 80180aa:	42a3      	cmp	r3, r4
 80180ac:	d33c      	bcc.n	8018128 <__gethex+0x202>
 80180ae:	9c08      	ldr	r4, [sp, #32]
 80180b0:	9b03      	ldr	r3, [sp, #12]
 80180b2:	c440      	stmia	r4!, {r6}
 80180b4:	1ae4      	subs	r4, r4, r3
 80180b6:	10a4      	asrs	r4, r4, #2
 80180b8:	612c      	str	r4, [r5, #16]
 80180ba:	0030      	movs	r0, r6
 80180bc:	f000 faf8 	bl	80186b0 <__hi0bits>
 80180c0:	9b02      	ldr	r3, [sp, #8]
 80180c2:	0164      	lsls	r4, r4, #5
 80180c4:	681b      	ldr	r3, [r3, #0]
 80180c6:	1a26      	subs	r6, r4, r0
 80180c8:	9301      	str	r3, [sp, #4]
 80180ca:	429e      	cmp	r6, r3
 80180cc:	dd5f      	ble.n	801818e <__gethex+0x268>
 80180ce:	1af6      	subs	r6, r6, r3
 80180d0:	0031      	movs	r1, r6
 80180d2:	0028      	movs	r0, r5
 80180d4:	f000 fde3 	bl	8018c9e <__any_on>
 80180d8:	1e04      	subs	r4, r0, #0
 80180da:	d00f      	beq.n	80180fc <__gethex+0x1d6>
 80180dc:	2401      	movs	r4, #1
 80180de:	211f      	movs	r1, #31
 80180e0:	0020      	movs	r0, r4
 80180e2:	1e73      	subs	r3, r6, #1
 80180e4:	4019      	ands	r1, r3
 80180e6:	4088      	lsls	r0, r1
 80180e8:	0001      	movs	r1, r0
 80180ea:	115a      	asrs	r2, r3, #5
 80180ec:	9803      	ldr	r0, [sp, #12]
 80180ee:	0092      	lsls	r2, r2, #2
 80180f0:	5812      	ldr	r2, [r2, r0]
 80180f2:	420a      	tst	r2, r1
 80180f4:	d002      	beq.n	80180fc <__gethex+0x1d6>
 80180f6:	42a3      	cmp	r3, r4
 80180f8:	dc41      	bgt.n	801817e <__gethex+0x258>
 80180fa:	2402      	movs	r4, #2
 80180fc:	0031      	movs	r1, r6
 80180fe:	0028      	movs	r0, r5
 8018100:	f7ff fec8 	bl	8017e94 <rshift>
 8018104:	19bf      	adds	r7, r7, r6
 8018106:	9b02      	ldr	r3, [sp, #8]
 8018108:	689b      	ldr	r3, [r3, #8]
 801810a:	9304      	str	r3, [sp, #16]
 801810c:	42bb      	cmp	r3, r7
 801810e:	da4e      	bge.n	80181ae <__gethex+0x288>
 8018110:	0029      	movs	r1, r5
 8018112:	9805      	ldr	r0, [sp, #20]
 8018114:	f000 fa46 	bl	80185a4 <_Bfree>
 8018118:	2300      	movs	r3, #0
 801811a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801811c:	26a3      	movs	r6, #163	; 0xa3
 801811e:	6013      	str	r3, [r2, #0]
 8018120:	e795      	b.n	801804e <__gethex+0x128>
 8018122:	3101      	adds	r1, #1
 8018124:	105b      	asrs	r3, r3, #1
 8018126:	e7b2      	b.n	801808e <__gethex+0x168>
 8018128:	1e63      	subs	r3, r4, #1
 801812a:	9309      	str	r3, [sp, #36]	; 0x24
 801812c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801812e:	781b      	ldrb	r3, [r3, #0]
 8018130:	4293      	cmp	r3, r2
 8018132:	d015      	beq.n	8018160 <__gethex+0x23a>
 8018134:	9b06      	ldr	r3, [sp, #24]
 8018136:	2b20      	cmp	r3, #32
 8018138:	d105      	bne.n	8018146 <__gethex+0x220>
 801813a:	9b08      	ldr	r3, [sp, #32]
 801813c:	601e      	str	r6, [r3, #0]
 801813e:	2600      	movs	r6, #0
 8018140:	3304      	adds	r3, #4
 8018142:	9308      	str	r3, [sp, #32]
 8018144:	9606      	str	r6, [sp, #24]
 8018146:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8018148:	7818      	ldrb	r0, [r3, #0]
 801814a:	f7ff fed7 	bl	8017efc <__hexdig_fun>
 801814e:	230f      	movs	r3, #15
 8018150:	4018      	ands	r0, r3
 8018152:	9b06      	ldr	r3, [sp, #24]
 8018154:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8018156:	4098      	lsls	r0, r3
 8018158:	3304      	adds	r3, #4
 801815a:	4306      	orrs	r6, r0
 801815c:	9306      	str	r3, [sp, #24]
 801815e:	e7a3      	b.n	80180a8 <__gethex+0x182>
 8018160:	2301      	movs	r3, #1
 8018162:	9a04      	ldr	r2, [sp, #16]
 8018164:	1a9c      	subs	r4, r3, r2
 8018166:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8018168:	191c      	adds	r4, r3, r4
 801816a:	9b01      	ldr	r3, [sp, #4]
 801816c:	429c      	cmp	r4, r3
 801816e:	d3e1      	bcc.n	8018134 <__gethex+0x20e>
 8018170:	9907      	ldr	r1, [sp, #28]
 8018172:	0020      	movs	r0, r4
 8018174:	f7fc fcb6 	bl	8014ae4 <strncmp>
 8018178:	2800      	cmp	r0, #0
 801817a:	d1db      	bne.n	8018134 <__gethex+0x20e>
 801817c:	e794      	b.n	80180a8 <__gethex+0x182>
 801817e:	1eb1      	subs	r1, r6, #2
 8018180:	0028      	movs	r0, r5
 8018182:	f000 fd8c 	bl	8018c9e <__any_on>
 8018186:	2800      	cmp	r0, #0
 8018188:	d0b7      	beq.n	80180fa <__gethex+0x1d4>
 801818a:	2403      	movs	r4, #3
 801818c:	e7b6      	b.n	80180fc <__gethex+0x1d6>
 801818e:	9b01      	ldr	r3, [sp, #4]
 8018190:	2400      	movs	r4, #0
 8018192:	429e      	cmp	r6, r3
 8018194:	dab7      	bge.n	8018106 <__gethex+0x1e0>
 8018196:	1b9e      	subs	r6, r3, r6
 8018198:	0029      	movs	r1, r5
 801819a:	0032      	movs	r2, r6
 801819c:	9805      	ldr	r0, [sp, #20]
 801819e:	f000 fbab 	bl	80188f8 <__lshift>
 80181a2:	0003      	movs	r3, r0
 80181a4:	3314      	adds	r3, #20
 80181a6:	0005      	movs	r5, r0
 80181a8:	1bbf      	subs	r7, r7, r6
 80181aa:	9303      	str	r3, [sp, #12]
 80181ac:	e7ab      	b.n	8018106 <__gethex+0x1e0>
 80181ae:	9b02      	ldr	r3, [sp, #8]
 80181b0:	685e      	ldr	r6, [r3, #4]
 80181b2:	42be      	cmp	r6, r7
 80181b4:	dd6b      	ble.n	801828e <__gethex+0x368>
 80181b6:	9b01      	ldr	r3, [sp, #4]
 80181b8:	1bf6      	subs	r6, r6, r7
 80181ba:	42b3      	cmp	r3, r6
 80181bc:	dc32      	bgt.n	8018224 <__gethex+0x2fe>
 80181be:	9b02      	ldr	r3, [sp, #8]
 80181c0:	68db      	ldr	r3, [r3, #12]
 80181c2:	2b02      	cmp	r3, #2
 80181c4:	d026      	beq.n	8018214 <__gethex+0x2ee>
 80181c6:	2b03      	cmp	r3, #3
 80181c8:	d028      	beq.n	801821c <__gethex+0x2f6>
 80181ca:	2b01      	cmp	r3, #1
 80181cc:	d119      	bne.n	8018202 <__gethex+0x2dc>
 80181ce:	9b01      	ldr	r3, [sp, #4]
 80181d0:	42b3      	cmp	r3, r6
 80181d2:	d116      	bne.n	8018202 <__gethex+0x2dc>
 80181d4:	2b01      	cmp	r3, #1
 80181d6:	dc0d      	bgt.n	80181f4 <__gethex+0x2ce>
 80181d8:	9b02      	ldr	r3, [sp, #8]
 80181da:	2662      	movs	r6, #98	; 0x62
 80181dc:	685b      	ldr	r3, [r3, #4]
 80181de:	9301      	str	r3, [sp, #4]
 80181e0:	9a01      	ldr	r2, [sp, #4]
 80181e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80181e4:	601a      	str	r2, [r3, #0]
 80181e6:	2301      	movs	r3, #1
 80181e8:	9a03      	ldr	r2, [sp, #12]
 80181ea:	612b      	str	r3, [r5, #16]
 80181ec:	6013      	str	r3, [r2, #0]
 80181ee:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80181f0:	601d      	str	r5, [r3, #0]
 80181f2:	e72c      	b.n	801804e <__gethex+0x128>
 80181f4:	9901      	ldr	r1, [sp, #4]
 80181f6:	0028      	movs	r0, r5
 80181f8:	3901      	subs	r1, #1
 80181fa:	f000 fd50 	bl	8018c9e <__any_on>
 80181fe:	2800      	cmp	r0, #0
 8018200:	d1ea      	bne.n	80181d8 <__gethex+0x2b2>
 8018202:	0029      	movs	r1, r5
 8018204:	9805      	ldr	r0, [sp, #20]
 8018206:	f000 f9cd 	bl	80185a4 <_Bfree>
 801820a:	2300      	movs	r3, #0
 801820c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801820e:	2650      	movs	r6, #80	; 0x50
 8018210:	6013      	str	r3, [r2, #0]
 8018212:	e71c      	b.n	801804e <__gethex+0x128>
 8018214:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8018216:	2b00      	cmp	r3, #0
 8018218:	d0de      	beq.n	80181d8 <__gethex+0x2b2>
 801821a:	e7f2      	b.n	8018202 <__gethex+0x2dc>
 801821c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801821e:	2b00      	cmp	r3, #0
 8018220:	d1da      	bne.n	80181d8 <__gethex+0x2b2>
 8018222:	e7ee      	b.n	8018202 <__gethex+0x2dc>
 8018224:	1e77      	subs	r7, r6, #1
 8018226:	2c00      	cmp	r4, #0
 8018228:	d12f      	bne.n	801828a <__gethex+0x364>
 801822a:	2f00      	cmp	r7, #0
 801822c:	d004      	beq.n	8018238 <__gethex+0x312>
 801822e:	0039      	movs	r1, r7
 8018230:	0028      	movs	r0, r5
 8018232:	f000 fd34 	bl	8018c9e <__any_on>
 8018236:	0004      	movs	r4, r0
 8018238:	231f      	movs	r3, #31
 801823a:	117a      	asrs	r2, r7, #5
 801823c:	401f      	ands	r7, r3
 801823e:	3b1e      	subs	r3, #30
 8018240:	40bb      	lsls	r3, r7
 8018242:	9903      	ldr	r1, [sp, #12]
 8018244:	0092      	lsls	r2, r2, #2
 8018246:	5852      	ldr	r2, [r2, r1]
 8018248:	421a      	tst	r2, r3
 801824a:	d001      	beq.n	8018250 <__gethex+0x32a>
 801824c:	2302      	movs	r3, #2
 801824e:	431c      	orrs	r4, r3
 8018250:	9b01      	ldr	r3, [sp, #4]
 8018252:	0031      	movs	r1, r6
 8018254:	1b9b      	subs	r3, r3, r6
 8018256:	2602      	movs	r6, #2
 8018258:	0028      	movs	r0, r5
 801825a:	9301      	str	r3, [sp, #4]
 801825c:	f7ff fe1a 	bl	8017e94 <rshift>
 8018260:	9b02      	ldr	r3, [sp, #8]
 8018262:	685f      	ldr	r7, [r3, #4]
 8018264:	2c00      	cmp	r4, #0
 8018266:	d040      	beq.n	80182ea <__gethex+0x3c4>
 8018268:	9b02      	ldr	r3, [sp, #8]
 801826a:	68db      	ldr	r3, [r3, #12]
 801826c:	2b02      	cmp	r3, #2
 801826e:	d010      	beq.n	8018292 <__gethex+0x36c>
 8018270:	2b03      	cmp	r3, #3
 8018272:	d012      	beq.n	801829a <__gethex+0x374>
 8018274:	2b01      	cmp	r3, #1
 8018276:	d106      	bne.n	8018286 <__gethex+0x360>
 8018278:	07a2      	lsls	r2, r4, #30
 801827a:	d504      	bpl.n	8018286 <__gethex+0x360>
 801827c:	9a03      	ldr	r2, [sp, #12]
 801827e:	6812      	ldr	r2, [r2, #0]
 8018280:	4314      	orrs	r4, r2
 8018282:	421c      	tst	r4, r3
 8018284:	d10c      	bne.n	80182a0 <__gethex+0x37a>
 8018286:	2310      	movs	r3, #16
 8018288:	e02e      	b.n	80182e8 <__gethex+0x3c2>
 801828a:	2401      	movs	r4, #1
 801828c:	e7d4      	b.n	8018238 <__gethex+0x312>
 801828e:	2601      	movs	r6, #1
 8018290:	e7e8      	b.n	8018264 <__gethex+0x33e>
 8018292:	2301      	movs	r3, #1
 8018294:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8018296:	1a9b      	subs	r3, r3, r2
 8018298:	9313      	str	r3, [sp, #76]	; 0x4c
 801829a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801829c:	2b00      	cmp	r3, #0
 801829e:	d0f2      	beq.n	8018286 <__gethex+0x360>
 80182a0:	692c      	ldr	r4, [r5, #16]
 80182a2:	00a3      	lsls	r3, r4, #2
 80182a4:	9304      	str	r3, [sp, #16]
 80182a6:	002b      	movs	r3, r5
 80182a8:	00a2      	lsls	r2, r4, #2
 80182aa:	3314      	adds	r3, #20
 80182ac:	1899      	adds	r1, r3, r2
 80182ae:	2200      	movs	r2, #0
 80182b0:	4694      	mov	ip, r2
 80182b2:	681a      	ldr	r2, [r3, #0]
 80182b4:	1c50      	adds	r0, r2, #1
 80182b6:	d01d      	beq.n	80182f4 <__gethex+0x3ce>
 80182b8:	3201      	adds	r2, #1
 80182ba:	601a      	str	r2, [r3, #0]
 80182bc:	002b      	movs	r3, r5
 80182be:	3314      	adds	r3, #20
 80182c0:	2e02      	cmp	r6, #2
 80182c2:	d13a      	bne.n	801833a <__gethex+0x414>
 80182c4:	9a02      	ldr	r2, [sp, #8]
 80182c6:	9901      	ldr	r1, [sp, #4]
 80182c8:	6812      	ldr	r2, [r2, #0]
 80182ca:	3a01      	subs	r2, #1
 80182cc:	428a      	cmp	r2, r1
 80182ce:	d10a      	bne.n	80182e6 <__gethex+0x3c0>
 80182d0:	114a      	asrs	r2, r1, #5
 80182d2:	211f      	movs	r1, #31
 80182d4:	9801      	ldr	r0, [sp, #4]
 80182d6:	0092      	lsls	r2, r2, #2
 80182d8:	4001      	ands	r1, r0
 80182da:	2001      	movs	r0, #1
 80182dc:	0004      	movs	r4, r0
 80182de:	408c      	lsls	r4, r1
 80182e0:	58d3      	ldr	r3, [r2, r3]
 80182e2:	4223      	tst	r3, r4
 80182e4:	d148      	bne.n	8018378 <__gethex+0x452>
 80182e6:	2320      	movs	r3, #32
 80182e8:	431e      	orrs	r6, r3
 80182ea:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80182ec:	601d      	str	r5, [r3, #0]
 80182ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80182f0:	601f      	str	r7, [r3, #0]
 80182f2:	e6ac      	b.n	801804e <__gethex+0x128>
 80182f4:	4662      	mov	r2, ip
 80182f6:	c304      	stmia	r3!, {r2}
 80182f8:	4299      	cmp	r1, r3
 80182fa:	d8da      	bhi.n	80182b2 <__gethex+0x38c>
 80182fc:	68ab      	ldr	r3, [r5, #8]
 80182fe:	429c      	cmp	r4, r3
 8018300:	db12      	blt.n	8018328 <__gethex+0x402>
 8018302:	686b      	ldr	r3, [r5, #4]
 8018304:	9805      	ldr	r0, [sp, #20]
 8018306:	1c59      	adds	r1, r3, #1
 8018308:	f000 f924 	bl	8018554 <_Balloc>
 801830c:	0029      	movs	r1, r5
 801830e:	692b      	ldr	r3, [r5, #16]
 8018310:	9003      	str	r0, [sp, #12]
 8018312:	1c9a      	adds	r2, r3, #2
 8018314:	0092      	lsls	r2, r2, #2
 8018316:	310c      	adds	r1, #12
 8018318:	300c      	adds	r0, #12
 801831a:	f7fc f99b 	bl	8014654 <memcpy>
 801831e:	0029      	movs	r1, r5
 8018320:	9805      	ldr	r0, [sp, #20]
 8018322:	f000 f93f 	bl	80185a4 <_Bfree>
 8018326:	9d03      	ldr	r5, [sp, #12]
 8018328:	692b      	ldr	r3, [r5, #16]
 801832a:	1c5a      	adds	r2, r3, #1
 801832c:	612a      	str	r2, [r5, #16]
 801832e:	2201      	movs	r2, #1
 8018330:	3304      	adds	r3, #4
 8018332:	009b      	lsls	r3, r3, #2
 8018334:	18eb      	adds	r3, r5, r3
 8018336:	605a      	str	r2, [r3, #4]
 8018338:	e7c0      	b.n	80182bc <__gethex+0x396>
 801833a:	692a      	ldr	r2, [r5, #16]
 801833c:	42a2      	cmp	r2, r4
 801833e:	dd0a      	ble.n	8018356 <__gethex+0x430>
 8018340:	2101      	movs	r1, #1
 8018342:	0028      	movs	r0, r5
 8018344:	f7ff fda6 	bl	8017e94 <rshift>
 8018348:	9b02      	ldr	r3, [sp, #8]
 801834a:	3701      	adds	r7, #1
 801834c:	689b      	ldr	r3, [r3, #8]
 801834e:	2601      	movs	r6, #1
 8018350:	42bb      	cmp	r3, r7
 8018352:	dac8      	bge.n	80182e6 <__gethex+0x3c0>
 8018354:	e6dc      	b.n	8018110 <__gethex+0x1ea>
 8018356:	241f      	movs	r4, #31
 8018358:	9a01      	ldr	r2, [sp, #4]
 801835a:	2601      	movs	r6, #1
 801835c:	4022      	ands	r2, r4
 801835e:	1e14      	subs	r4, r2, #0
 8018360:	d0c1      	beq.n	80182e6 <__gethex+0x3c0>
 8018362:	9a04      	ldr	r2, [sp, #16]
 8018364:	189b      	adds	r3, r3, r2
 8018366:	3b04      	subs	r3, #4
 8018368:	6818      	ldr	r0, [r3, #0]
 801836a:	f000 f9a1 	bl	80186b0 <__hi0bits>
 801836e:	2120      	movs	r1, #32
 8018370:	1b0c      	subs	r4, r1, r4
 8018372:	42a0      	cmp	r0, r4
 8018374:	dbe4      	blt.n	8018340 <__gethex+0x41a>
 8018376:	e7b6      	b.n	80182e6 <__gethex+0x3c0>
 8018378:	0006      	movs	r6, r0
 801837a:	e7b4      	b.n	80182e6 <__gethex+0x3c0>

0801837c <L_shift>:
 801837c:	2308      	movs	r3, #8
 801837e:	b570      	push	{r4, r5, r6, lr}
 8018380:	2520      	movs	r5, #32
 8018382:	1a9a      	subs	r2, r3, r2
 8018384:	0092      	lsls	r2, r2, #2
 8018386:	1aad      	subs	r5, r5, r2
 8018388:	6843      	ldr	r3, [r0, #4]
 801838a:	6806      	ldr	r6, [r0, #0]
 801838c:	001c      	movs	r4, r3
 801838e:	40ac      	lsls	r4, r5
 8018390:	40d3      	lsrs	r3, r2
 8018392:	4334      	orrs	r4, r6
 8018394:	6004      	str	r4, [r0, #0]
 8018396:	6043      	str	r3, [r0, #4]
 8018398:	3004      	adds	r0, #4
 801839a:	4288      	cmp	r0, r1
 801839c:	d3f4      	bcc.n	8018388 <L_shift+0xc>
 801839e:	bd70      	pop	{r4, r5, r6, pc}

080183a0 <__match>:
 80183a0:	b530      	push	{r4, r5, lr}
 80183a2:	6803      	ldr	r3, [r0, #0]
 80183a4:	780c      	ldrb	r4, [r1, #0]
 80183a6:	3301      	adds	r3, #1
 80183a8:	2c00      	cmp	r4, #0
 80183aa:	d102      	bne.n	80183b2 <__match+0x12>
 80183ac:	6003      	str	r3, [r0, #0]
 80183ae:	2001      	movs	r0, #1
 80183b0:	bd30      	pop	{r4, r5, pc}
 80183b2:	781a      	ldrb	r2, [r3, #0]
 80183b4:	0015      	movs	r5, r2
 80183b6:	3d41      	subs	r5, #65	; 0x41
 80183b8:	2d19      	cmp	r5, #25
 80183ba:	d800      	bhi.n	80183be <__match+0x1e>
 80183bc:	3220      	adds	r2, #32
 80183be:	3101      	adds	r1, #1
 80183c0:	42a2      	cmp	r2, r4
 80183c2:	d0ef      	beq.n	80183a4 <__match+0x4>
 80183c4:	2000      	movs	r0, #0
 80183c6:	e7f3      	b.n	80183b0 <__match+0x10>

080183c8 <__hexnan>:
 80183c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80183ca:	b08b      	sub	sp, #44	; 0x2c
 80183cc:	9201      	str	r2, [sp, #4]
 80183ce:	680a      	ldr	r2, [r1, #0]
 80183d0:	9901      	ldr	r1, [sp, #4]
 80183d2:	1153      	asrs	r3, r2, #5
 80183d4:	009b      	lsls	r3, r3, #2
 80183d6:	18cb      	adds	r3, r1, r3
 80183d8:	9304      	str	r3, [sp, #16]
 80183da:	231f      	movs	r3, #31
 80183dc:	401a      	ands	r2, r3
 80183de:	9008      	str	r0, [sp, #32]
 80183e0:	9206      	str	r2, [sp, #24]
 80183e2:	d002      	beq.n	80183ea <__hexnan+0x22>
 80183e4:	9b04      	ldr	r3, [sp, #16]
 80183e6:	3304      	adds	r3, #4
 80183e8:	9304      	str	r3, [sp, #16]
 80183ea:	9b04      	ldr	r3, [sp, #16]
 80183ec:	2500      	movs	r5, #0
 80183ee:	1f1e      	subs	r6, r3, #4
 80183f0:	0037      	movs	r7, r6
 80183f2:	0034      	movs	r4, r6
 80183f4:	9b08      	ldr	r3, [sp, #32]
 80183f6:	6035      	str	r5, [r6, #0]
 80183f8:	681b      	ldr	r3, [r3, #0]
 80183fa:	9507      	str	r5, [sp, #28]
 80183fc:	9305      	str	r3, [sp, #20]
 80183fe:	9502      	str	r5, [sp, #8]
 8018400:	9b05      	ldr	r3, [sp, #20]
 8018402:	3301      	adds	r3, #1
 8018404:	9309      	str	r3, [sp, #36]	; 0x24
 8018406:	9b05      	ldr	r3, [sp, #20]
 8018408:	785b      	ldrb	r3, [r3, #1]
 801840a:	9303      	str	r3, [sp, #12]
 801840c:	2b00      	cmp	r3, #0
 801840e:	d028      	beq.n	8018462 <__hexnan+0x9a>
 8018410:	9803      	ldr	r0, [sp, #12]
 8018412:	f7ff fd73 	bl	8017efc <__hexdig_fun>
 8018416:	2800      	cmp	r0, #0
 8018418:	d145      	bne.n	80184a6 <__hexnan+0xde>
 801841a:	9b03      	ldr	r3, [sp, #12]
 801841c:	2b20      	cmp	r3, #32
 801841e:	d819      	bhi.n	8018454 <__hexnan+0x8c>
 8018420:	9b02      	ldr	r3, [sp, #8]
 8018422:	9a07      	ldr	r2, [sp, #28]
 8018424:	4293      	cmp	r3, r2
 8018426:	dd12      	ble.n	801844e <__hexnan+0x86>
 8018428:	42bc      	cmp	r4, r7
 801842a:	d206      	bcs.n	801843a <__hexnan+0x72>
 801842c:	2d07      	cmp	r5, #7
 801842e:	dc04      	bgt.n	801843a <__hexnan+0x72>
 8018430:	002a      	movs	r2, r5
 8018432:	0039      	movs	r1, r7
 8018434:	0020      	movs	r0, r4
 8018436:	f7ff ffa1 	bl	801837c <L_shift>
 801843a:	9b01      	ldr	r3, [sp, #4]
 801843c:	2508      	movs	r5, #8
 801843e:	429c      	cmp	r4, r3
 8018440:	d905      	bls.n	801844e <__hexnan+0x86>
 8018442:	1f27      	subs	r7, r4, #4
 8018444:	2500      	movs	r5, #0
 8018446:	003c      	movs	r4, r7
 8018448:	9b02      	ldr	r3, [sp, #8]
 801844a:	603d      	str	r5, [r7, #0]
 801844c:	9307      	str	r3, [sp, #28]
 801844e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8018450:	9305      	str	r3, [sp, #20]
 8018452:	e7d5      	b.n	8018400 <__hexnan+0x38>
 8018454:	9b03      	ldr	r3, [sp, #12]
 8018456:	2b29      	cmp	r3, #41	; 0x29
 8018458:	d14a      	bne.n	80184f0 <__hexnan+0x128>
 801845a:	9b05      	ldr	r3, [sp, #20]
 801845c:	9a08      	ldr	r2, [sp, #32]
 801845e:	3302      	adds	r3, #2
 8018460:	6013      	str	r3, [r2, #0]
 8018462:	9b02      	ldr	r3, [sp, #8]
 8018464:	2b00      	cmp	r3, #0
 8018466:	d043      	beq.n	80184f0 <__hexnan+0x128>
 8018468:	42bc      	cmp	r4, r7
 801846a:	d206      	bcs.n	801847a <__hexnan+0xb2>
 801846c:	2d07      	cmp	r5, #7
 801846e:	dc04      	bgt.n	801847a <__hexnan+0xb2>
 8018470:	002a      	movs	r2, r5
 8018472:	0039      	movs	r1, r7
 8018474:	0020      	movs	r0, r4
 8018476:	f7ff ff81 	bl	801837c <L_shift>
 801847a:	9b01      	ldr	r3, [sp, #4]
 801847c:	429c      	cmp	r4, r3
 801847e:	d926      	bls.n	80184ce <__hexnan+0x106>
 8018480:	cc04      	ldmia	r4!, {r2}
 8018482:	601a      	str	r2, [r3, #0]
 8018484:	3304      	adds	r3, #4
 8018486:	42a6      	cmp	r6, r4
 8018488:	d2fa      	bcs.n	8018480 <__hexnan+0xb8>
 801848a:	2200      	movs	r2, #0
 801848c:	c304      	stmia	r3!, {r2}
 801848e:	429e      	cmp	r6, r3
 8018490:	d2fc      	bcs.n	801848c <__hexnan+0xc4>
 8018492:	6833      	ldr	r3, [r6, #0]
 8018494:	2b00      	cmp	r3, #0
 8018496:	d104      	bne.n	80184a2 <__hexnan+0xda>
 8018498:	9b01      	ldr	r3, [sp, #4]
 801849a:	429e      	cmp	r6, r3
 801849c:	d126      	bne.n	80184ec <__hexnan+0x124>
 801849e:	2301      	movs	r3, #1
 80184a0:	6033      	str	r3, [r6, #0]
 80184a2:	2005      	movs	r0, #5
 80184a4:	e025      	b.n	80184f2 <__hexnan+0x12a>
 80184a6:	9b02      	ldr	r3, [sp, #8]
 80184a8:	3501      	adds	r5, #1
 80184aa:	3301      	adds	r3, #1
 80184ac:	9302      	str	r3, [sp, #8]
 80184ae:	2d08      	cmp	r5, #8
 80184b0:	dd06      	ble.n	80184c0 <__hexnan+0xf8>
 80184b2:	9b01      	ldr	r3, [sp, #4]
 80184b4:	429c      	cmp	r4, r3
 80184b6:	d9ca      	bls.n	801844e <__hexnan+0x86>
 80184b8:	2300      	movs	r3, #0
 80184ba:	2501      	movs	r5, #1
 80184bc:	3c04      	subs	r4, #4
 80184be:	6023      	str	r3, [r4, #0]
 80184c0:	220f      	movs	r2, #15
 80184c2:	6823      	ldr	r3, [r4, #0]
 80184c4:	4010      	ands	r0, r2
 80184c6:	011b      	lsls	r3, r3, #4
 80184c8:	4318      	orrs	r0, r3
 80184ca:	6020      	str	r0, [r4, #0]
 80184cc:	e7bf      	b.n	801844e <__hexnan+0x86>
 80184ce:	9b06      	ldr	r3, [sp, #24]
 80184d0:	2b00      	cmp	r3, #0
 80184d2:	d0de      	beq.n	8018492 <__hexnan+0xca>
 80184d4:	2120      	movs	r1, #32
 80184d6:	9a06      	ldr	r2, [sp, #24]
 80184d8:	9b04      	ldr	r3, [sp, #16]
 80184da:	1a89      	subs	r1, r1, r2
 80184dc:	2201      	movs	r2, #1
 80184de:	4252      	negs	r2, r2
 80184e0:	40ca      	lsrs	r2, r1
 80184e2:	3b04      	subs	r3, #4
 80184e4:	6819      	ldr	r1, [r3, #0]
 80184e6:	400a      	ands	r2, r1
 80184e8:	601a      	str	r2, [r3, #0]
 80184ea:	e7d2      	b.n	8018492 <__hexnan+0xca>
 80184ec:	3e04      	subs	r6, #4
 80184ee:	e7d0      	b.n	8018492 <__hexnan+0xca>
 80184f0:	2004      	movs	r0, #4
 80184f2:	b00b      	add	sp, #44	; 0x2c
 80184f4:	bdf0      	pop	{r4, r5, r6, r7, pc}

080184f6 <__localeconv_l>:
 80184f6:	30f0      	adds	r0, #240	; 0xf0
 80184f8:	4770      	bx	lr
	...

080184fc <_localeconv_r>:
 80184fc:	4b03      	ldr	r3, [pc, #12]	; (801850c <_localeconv_r+0x10>)
 80184fe:	681b      	ldr	r3, [r3, #0]
 8018500:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8018502:	2800      	cmp	r0, #0
 8018504:	d100      	bne.n	8018508 <_localeconv_r+0xc>
 8018506:	4802      	ldr	r0, [pc, #8]	; (8018510 <_localeconv_r+0x14>)
 8018508:	30f0      	adds	r0, #240	; 0xf0
 801850a:	4770      	bx	lr
 801850c:	200000d0 	.word	0x200000d0
 8018510:	20000500 	.word	0x20000500

08018514 <__retarget_lock_acquire_recursive>:
 8018514:	4770      	bx	lr

08018516 <__retarget_lock_release_recursive>:
 8018516:	4770      	bx	lr

08018518 <memchr>:
 8018518:	b2c9      	uxtb	r1, r1
 801851a:	1882      	adds	r2, r0, r2
 801851c:	4290      	cmp	r0, r2
 801851e:	d101      	bne.n	8018524 <memchr+0xc>
 8018520:	2000      	movs	r0, #0
 8018522:	4770      	bx	lr
 8018524:	7803      	ldrb	r3, [r0, #0]
 8018526:	428b      	cmp	r3, r1
 8018528:	d0fb      	beq.n	8018522 <memchr+0xa>
 801852a:	3001      	adds	r0, #1
 801852c:	e7f6      	b.n	801851c <memchr+0x4>

0801852e <memmove>:
 801852e:	b510      	push	{r4, lr}
 8018530:	4288      	cmp	r0, r1
 8018532:	d902      	bls.n	801853a <memmove+0xc>
 8018534:	188b      	adds	r3, r1, r2
 8018536:	4298      	cmp	r0, r3
 8018538:	d303      	bcc.n	8018542 <memmove+0x14>
 801853a:	2300      	movs	r3, #0
 801853c:	e007      	b.n	801854e <memmove+0x20>
 801853e:	5c8b      	ldrb	r3, [r1, r2]
 8018540:	5483      	strb	r3, [r0, r2]
 8018542:	3a01      	subs	r2, #1
 8018544:	d2fb      	bcs.n	801853e <memmove+0x10>
 8018546:	bd10      	pop	{r4, pc}
 8018548:	5ccc      	ldrb	r4, [r1, r3]
 801854a:	54c4      	strb	r4, [r0, r3]
 801854c:	3301      	adds	r3, #1
 801854e:	429a      	cmp	r2, r3
 8018550:	d1fa      	bne.n	8018548 <memmove+0x1a>
 8018552:	e7f8      	b.n	8018546 <memmove+0x18>

08018554 <_Balloc>:
 8018554:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8018556:	b570      	push	{r4, r5, r6, lr}
 8018558:	0004      	movs	r4, r0
 801855a:	000d      	movs	r5, r1
 801855c:	2b00      	cmp	r3, #0
 801855e:	d012      	beq.n	8018586 <_Balloc+0x32>
 8018560:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8018562:	00ab      	lsls	r3, r5, #2
 8018564:	18d3      	adds	r3, r2, r3
 8018566:	6818      	ldr	r0, [r3, #0]
 8018568:	2800      	cmp	r0, #0
 801856a:	d115      	bne.n	8018598 <_Balloc+0x44>
 801856c:	2101      	movs	r1, #1
 801856e:	000e      	movs	r6, r1
 8018570:	40ae      	lsls	r6, r5
 8018572:	1d72      	adds	r2, r6, #5
 8018574:	0092      	lsls	r2, r2, #2
 8018576:	0020      	movs	r0, r4
 8018578:	f000 fcbe 	bl	8018ef8 <_calloc_r>
 801857c:	2800      	cmp	r0, #0
 801857e:	d009      	beq.n	8018594 <_Balloc+0x40>
 8018580:	6045      	str	r5, [r0, #4]
 8018582:	6086      	str	r6, [r0, #8]
 8018584:	e00a      	b.n	801859c <_Balloc+0x48>
 8018586:	2221      	movs	r2, #33	; 0x21
 8018588:	2104      	movs	r1, #4
 801858a:	f000 fcb5 	bl	8018ef8 <_calloc_r>
 801858e:	64e0      	str	r0, [r4, #76]	; 0x4c
 8018590:	2800      	cmp	r0, #0
 8018592:	d1e5      	bne.n	8018560 <_Balloc+0xc>
 8018594:	2000      	movs	r0, #0
 8018596:	bd70      	pop	{r4, r5, r6, pc}
 8018598:	6802      	ldr	r2, [r0, #0]
 801859a:	601a      	str	r2, [r3, #0]
 801859c:	2300      	movs	r3, #0
 801859e:	6103      	str	r3, [r0, #16]
 80185a0:	60c3      	str	r3, [r0, #12]
 80185a2:	e7f8      	b.n	8018596 <_Balloc+0x42>

080185a4 <_Bfree>:
 80185a4:	2900      	cmp	r1, #0
 80185a6:	d006      	beq.n	80185b6 <_Bfree+0x12>
 80185a8:	684b      	ldr	r3, [r1, #4]
 80185aa:	009a      	lsls	r2, r3, #2
 80185ac:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80185ae:	189b      	adds	r3, r3, r2
 80185b0:	681a      	ldr	r2, [r3, #0]
 80185b2:	600a      	str	r2, [r1, #0]
 80185b4:	6019      	str	r1, [r3, #0]
 80185b6:	4770      	bx	lr

080185b8 <__multadd>:
 80185b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80185ba:	001e      	movs	r6, r3
 80185bc:	2314      	movs	r3, #20
 80185be:	469c      	mov	ip, r3
 80185c0:	0007      	movs	r7, r0
 80185c2:	000c      	movs	r4, r1
 80185c4:	2000      	movs	r0, #0
 80185c6:	690d      	ldr	r5, [r1, #16]
 80185c8:	448c      	add	ip, r1
 80185ca:	4663      	mov	r3, ip
 80185cc:	681b      	ldr	r3, [r3, #0]
 80185ce:	3001      	adds	r0, #1
 80185d0:	b299      	uxth	r1, r3
 80185d2:	4663      	mov	r3, ip
 80185d4:	681b      	ldr	r3, [r3, #0]
 80185d6:	4351      	muls	r1, r2
 80185d8:	0c1b      	lsrs	r3, r3, #16
 80185da:	4353      	muls	r3, r2
 80185dc:	1989      	adds	r1, r1, r6
 80185de:	0c0e      	lsrs	r6, r1, #16
 80185e0:	199b      	adds	r3, r3, r6
 80185e2:	b289      	uxth	r1, r1
 80185e4:	0c1e      	lsrs	r6, r3, #16
 80185e6:	041b      	lsls	r3, r3, #16
 80185e8:	185b      	adds	r3, r3, r1
 80185ea:	4661      	mov	r1, ip
 80185ec:	c108      	stmia	r1!, {r3}
 80185ee:	468c      	mov	ip, r1
 80185f0:	4285      	cmp	r5, r0
 80185f2:	dcea      	bgt.n	80185ca <__multadd+0x12>
 80185f4:	2e00      	cmp	r6, #0
 80185f6:	d01b      	beq.n	8018630 <__multadd+0x78>
 80185f8:	68a3      	ldr	r3, [r4, #8]
 80185fa:	42ab      	cmp	r3, r5
 80185fc:	dc12      	bgt.n	8018624 <__multadd+0x6c>
 80185fe:	6863      	ldr	r3, [r4, #4]
 8018600:	0038      	movs	r0, r7
 8018602:	1c59      	adds	r1, r3, #1
 8018604:	f7ff ffa6 	bl	8018554 <_Balloc>
 8018608:	0021      	movs	r1, r4
 801860a:	6923      	ldr	r3, [r4, #16]
 801860c:	9001      	str	r0, [sp, #4]
 801860e:	1c9a      	adds	r2, r3, #2
 8018610:	0092      	lsls	r2, r2, #2
 8018612:	310c      	adds	r1, #12
 8018614:	300c      	adds	r0, #12
 8018616:	f7fc f81d 	bl	8014654 <memcpy>
 801861a:	0021      	movs	r1, r4
 801861c:	0038      	movs	r0, r7
 801861e:	f7ff ffc1 	bl	80185a4 <_Bfree>
 8018622:	9c01      	ldr	r4, [sp, #4]
 8018624:	1d2b      	adds	r3, r5, #4
 8018626:	009b      	lsls	r3, r3, #2
 8018628:	18e3      	adds	r3, r4, r3
 801862a:	3501      	adds	r5, #1
 801862c:	605e      	str	r6, [r3, #4]
 801862e:	6125      	str	r5, [r4, #16]
 8018630:	0020      	movs	r0, r4
 8018632:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08018634 <__s2b>:
 8018634:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8018636:	0006      	movs	r6, r0
 8018638:	0018      	movs	r0, r3
 801863a:	000c      	movs	r4, r1
 801863c:	3008      	adds	r0, #8
 801863e:	2109      	movs	r1, #9
 8018640:	9301      	str	r3, [sp, #4]
 8018642:	0015      	movs	r5, r2
 8018644:	f7e7 fe22 	bl	800028c <__divsi3>
 8018648:	2301      	movs	r3, #1
 801864a:	2100      	movs	r1, #0
 801864c:	4283      	cmp	r3, r0
 801864e:	db1f      	blt.n	8018690 <__s2b+0x5c>
 8018650:	0030      	movs	r0, r6
 8018652:	f7ff ff7f 	bl	8018554 <_Balloc>
 8018656:	9b08      	ldr	r3, [sp, #32]
 8018658:	6143      	str	r3, [r0, #20]
 801865a:	2301      	movs	r3, #1
 801865c:	6103      	str	r3, [r0, #16]
 801865e:	2d09      	cmp	r5, #9
 8018660:	dd19      	ble.n	8018696 <__s2b+0x62>
 8018662:	0023      	movs	r3, r4
 8018664:	3309      	adds	r3, #9
 8018666:	001f      	movs	r7, r3
 8018668:	9300      	str	r3, [sp, #0]
 801866a:	1964      	adds	r4, r4, r5
 801866c:	783b      	ldrb	r3, [r7, #0]
 801866e:	0001      	movs	r1, r0
 8018670:	3b30      	subs	r3, #48	; 0x30
 8018672:	220a      	movs	r2, #10
 8018674:	0030      	movs	r0, r6
 8018676:	3701      	adds	r7, #1
 8018678:	f7ff ff9e 	bl	80185b8 <__multadd>
 801867c:	42a7      	cmp	r7, r4
 801867e:	d1f5      	bne.n	801866c <__s2b+0x38>
 8018680:	9b00      	ldr	r3, [sp, #0]
 8018682:	195c      	adds	r4, r3, r5
 8018684:	3c08      	subs	r4, #8
 8018686:	002f      	movs	r7, r5
 8018688:	9b01      	ldr	r3, [sp, #4]
 801868a:	429f      	cmp	r7, r3
 801868c:	db06      	blt.n	801869c <__s2b+0x68>
 801868e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8018690:	005b      	lsls	r3, r3, #1
 8018692:	3101      	adds	r1, #1
 8018694:	e7da      	b.n	801864c <__s2b+0x18>
 8018696:	340a      	adds	r4, #10
 8018698:	2509      	movs	r5, #9
 801869a:	e7f4      	b.n	8018686 <__s2b+0x52>
 801869c:	1b63      	subs	r3, r4, r5
 801869e:	5ddb      	ldrb	r3, [r3, r7]
 80186a0:	0001      	movs	r1, r0
 80186a2:	3b30      	subs	r3, #48	; 0x30
 80186a4:	220a      	movs	r2, #10
 80186a6:	0030      	movs	r0, r6
 80186a8:	f7ff ff86 	bl	80185b8 <__multadd>
 80186ac:	3701      	adds	r7, #1
 80186ae:	e7eb      	b.n	8018688 <__s2b+0x54>

080186b0 <__hi0bits>:
 80186b0:	0003      	movs	r3, r0
 80186b2:	0c02      	lsrs	r2, r0, #16
 80186b4:	2000      	movs	r0, #0
 80186b6:	4282      	cmp	r2, r0
 80186b8:	d101      	bne.n	80186be <__hi0bits+0xe>
 80186ba:	041b      	lsls	r3, r3, #16
 80186bc:	3010      	adds	r0, #16
 80186be:	0e1a      	lsrs	r2, r3, #24
 80186c0:	d101      	bne.n	80186c6 <__hi0bits+0x16>
 80186c2:	3008      	adds	r0, #8
 80186c4:	021b      	lsls	r3, r3, #8
 80186c6:	0f1a      	lsrs	r2, r3, #28
 80186c8:	d101      	bne.n	80186ce <__hi0bits+0x1e>
 80186ca:	3004      	adds	r0, #4
 80186cc:	011b      	lsls	r3, r3, #4
 80186ce:	0f9a      	lsrs	r2, r3, #30
 80186d0:	d101      	bne.n	80186d6 <__hi0bits+0x26>
 80186d2:	3002      	adds	r0, #2
 80186d4:	009b      	lsls	r3, r3, #2
 80186d6:	2b00      	cmp	r3, #0
 80186d8:	db03      	blt.n	80186e2 <__hi0bits+0x32>
 80186da:	3001      	adds	r0, #1
 80186dc:	005b      	lsls	r3, r3, #1
 80186de:	d400      	bmi.n	80186e2 <__hi0bits+0x32>
 80186e0:	2020      	movs	r0, #32
 80186e2:	4770      	bx	lr

080186e4 <__lo0bits>:
 80186e4:	2207      	movs	r2, #7
 80186e6:	6803      	ldr	r3, [r0, #0]
 80186e8:	b510      	push	{r4, lr}
 80186ea:	0001      	movs	r1, r0
 80186ec:	401a      	ands	r2, r3
 80186ee:	d00d      	beq.n	801870c <__lo0bits+0x28>
 80186f0:	2401      	movs	r4, #1
 80186f2:	2000      	movs	r0, #0
 80186f4:	4223      	tst	r3, r4
 80186f6:	d105      	bne.n	8018704 <__lo0bits+0x20>
 80186f8:	3002      	adds	r0, #2
 80186fa:	4203      	tst	r3, r0
 80186fc:	d003      	beq.n	8018706 <__lo0bits+0x22>
 80186fe:	40e3      	lsrs	r3, r4
 8018700:	0020      	movs	r0, r4
 8018702:	600b      	str	r3, [r1, #0]
 8018704:	bd10      	pop	{r4, pc}
 8018706:	089b      	lsrs	r3, r3, #2
 8018708:	600b      	str	r3, [r1, #0]
 801870a:	e7fb      	b.n	8018704 <__lo0bits+0x20>
 801870c:	b29c      	uxth	r4, r3
 801870e:	0010      	movs	r0, r2
 8018710:	2c00      	cmp	r4, #0
 8018712:	d101      	bne.n	8018718 <__lo0bits+0x34>
 8018714:	2010      	movs	r0, #16
 8018716:	0c1b      	lsrs	r3, r3, #16
 8018718:	b2da      	uxtb	r2, r3
 801871a:	2a00      	cmp	r2, #0
 801871c:	d101      	bne.n	8018722 <__lo0bits+0x3e>
 801871e:	3008      	adds	r0, #8
 8018720:	0a1b      	lsrs	r3, r3, #8
 8018722:	071a      	lsls	r2, r3, #28
 8018724:	d101      	bne.n	801872a <__lo0bits+0x46>
 8018726:	3004      	adds	r0, #4
 8018728:	091b      	lsrs	r3, r3, #4
 801872a:	079a      	lsls	r2, r3, #30
 801872c:	d101      	bne.n	8018732 <__lo0bits+0x4e>
 801872e:	3002      	adds	r0, #2
 8018730:	089b      	lsrs	r3, r3, #2
 8018732:	07da      	lsls	r2, r3, #31
 8018734:	d4e8      	bmi.n	8018708 <__lo0bits+0x24>
 8018736:	085b      	lsrs	r3, r3, #1
 8018738:	d001      	beq.n	801873e <__lo0bits+0x5a>
 801873a:	3001      	adds	r0, #1
 801873c:	e7e4      	b.n	8018708 <__lo0bits+0x24>
 801873e:	2020      	movs	r0, #32
 8018740:	e7e0      	b.n	8018704 <__lo0bits+0x20>

08018742 <__i2b>:
 8018742:	b510      	push	{r4, lr}
 8018744:	000c      	movs	r4, r1
 8018746:	2101      	movs	r1, #1
 8018748:	f7ff ff04 	bl	8018554 <_Balloc>
 801874c:	2301      	movs	r3, #1
 801874e:	6144      	str	r4, [r0, #20]
 8018750:	6103      	str	r3, [r0, #16]
 8018752:	bd10      	pop	{r4, pc}

08018754 <__multiply>:
 8018754:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018756:	690b      	ldr	r3, [r1, #16]
 8018758:	0014      	movs	r4, r2
 801875a:	6912      	ldr	r2, [r2, #16]
 801875c:	b089      	sub	sp, #36	; 0x24
 801875e:	000d      	movs	r5, r1
 8018760:	4293      	cmp	r3, r2
 8018762:	da01      	bge.n	8018768 <__multiply+0x14>
 8018764:	0025      	movs	r5, r4
 8018766:	000c      	movs	r4, r1
 8018768:	692f      	ldr	r7, [r5, #16]
 801876a:	6926      	ldr	r6, [r4, #16]
 801876c:	6869      	ldr	r1, [r5, #4]
 801876e:	19bb      	adds	r3, r7, r6
 8018770:	9302      	str	r3, [sp, #8]
 8018772:	68ab      	ldr	r3, [r5, #8]
 8018774:	19ba      	adds	r2, r7, r6
 8018776:	4293      	cmp	r3, r2
 8018778:	da00      	bge.n	801877c <__multiply+0x28>
 801877a:	3101      	adds	r1, #1
 801877c:	f7ff feea 	bl	8018554 <_Balloc>
 8018780:	0002      	movs	r2, r0
 8018782:	19bb      	adds	r3, r7, r6
 8018784:	3214      	adds	r2, #20
 8018786:	009b      	lsls	r3, r3, #2
 8018788:	18d3      	adds	r3, r2, r3
 801878a:	469c      	mov	ip, r3
 801878c:	2100      	movs	r1, #0
 801878e:	0013      	movs	r3, r2
 8018790:	9004      	str	r0, [sp, #16]
 8018792:	4563      	cmp	r3, ip
 8018794:	d31d      	bcc.n	80187d2 <__multiply+0x7e>
 8018796:	3514      	adds	r5, #20
 8018798:	00bf      	lsls	r7, r7, #2
 801879a:	19eb      	adds	r3, r5, r7
 801879c:	3414      	adds	r4, #20
 801879e:	00b6      	lsls	r6, r6, #2
 80187a0:	9305      	str	r3, [sp, #20]
 80187a2:	19a3      	adds	r3, r4, r6
 80187a4:	9503      	str	r5, [sp, #12]
 80187a6:	9401      	str	r4, [sp, #4]
 80187a8:	9307      	str	r3, [sp, #28]
 80187aa:	9b07      	ldr	r3, [sp, #28]
 80187ac:	9901      	ldr	r1, [sp, #4]
 80187ae:	4299      	cmp	r1, r3
 80187b0:	d311      	bcc.n	80187d6 <__multiply+0x82>
 80187b2:	9b02      	ldr	r3, [sp, #8]
 80187b4:	2b00      	cmp	r3, #0
 80187b6:	dd06      	ble.n	80187c6 <__multiply+0x72>
 80187b8:	2304      	movs	r3, #4
 80187ba:	425b      	negs	r3, r3
 80187bc:	449c      	add	ip, r3
 80187be:	4663      	mov	r3, ip
 80187c0:	681b      	ldr	r3, [r3, #0]
 80187c2:	2b00      	cmp	r3, #0
 80187c4:	d051      	beq.n	801886a <__multiply+0x116>
 80187c6:	9b04      	ldr	r3, [sp, #16]
 80187c8:	9a02      	ldr	r2, [sp, #8]
 80187ca:	0018      	movs	r0, r3
 80187cc:	611a      	str	r2, [r3, #16]
 80187ce:	b009      	add	sp, #36	; 0x24
 80187d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80187d2:	c302      	stmia	r3!, {r1}
 80187d4:	e7dd      	b.n	8018792 <__multiply+0x3e>
 80187d6:	9b01      	ldr	r3, [sp, #4]
 80187d8:	681b      	ldr	r3, [r3, #0]
 80187da:	b298      	uxth	r0, r3
 80187dc:	2800      	cmp	r0, #0
 80187de:	d01c      	beq.n	801881a <__multiply+0xc6>
 80187e0:	0015      	movs	r5, r2
 80187e2:	2600      	movs	r6, #0
 80187e4:	9f03      	ldr	r7, [sp, #12]
 80187e6:	cf02      	ldmia	r7!, {r1}
 80187e8:	682c      	ldr	r4, [r5, #0]
 80187ea:	b28b      	uxth	r3, r1
 80187ec:	4343      	muls	r3, r0
 80187ee:	0c09      	lsrs	r1, r1, #16
 80187f0:	4341      	muls	r1, r0
 80187f2:	b2a4      	uxth	r4, r4
 80187f4:	191b      	adds	r3, r3, r4
 80187f6:	199b      	adds	r3, r3, r6
 80187f8:	000e      	movs	r6, r1
 80187fa:	6829      	ldr	r1, [r5, #0]
 80187fc:	9506      	str	r5, [sp, #24]
 80187fe:	0c09      	lsrs	r1, r1, #16
 8018800:	1871      	adds	r1, r6, r1
 8018802:	0c1e      	lsrs	r6, r3, #16
 8018804:	1989      	adds	r1, r1, r6
 8018806:	0c0e      	lsrs	r6, r1, #16
 8018808:	b29b      	uxth	r3, r3
 801880a:	0409      	lsls	r1, r1, #16
 801880c:	430b      	orrs	r3, r1
 801880e:	c508      	stmia	r5!, {r3}
 8018810:	9b05      	ldr	r3, [sp, #20]
 8018812:	42bb      	cmp	r3, r7
 8018814:	d8e7      	bhi.n	80187e6 <__multiply+0x92>
 8018816:	9b06      	ldr	r3, [sp, #24]
 8018818:	605e      	str	r6, [r3, #4]
 801881a:	9b01      	ldr	r3, [sp, #4]
 801881c:	681b      	ldr	r3, [r3, #0]
 801881e:	0c1d      	lsrs	r5, r3, #16
 8018820:	d01e      	beq.n	8018860 <__multiply+0x10c>
 8018822:	0010      	movs	r0, r2
 8018824:	2700      	movs	r7, #0
 8018826:	6813      	ldr	r3, [r2, #0]
 8018828:	9e03      	ldr	r6, [sp, #12]
 801882a:	6831      	ldr	r1, [r6, #0]
 801882c:	6804      	ldr	r4, [r0, #0]
 801882e:	b289      	uxth	r1, r1
 8018830:	4369      	muls	r1, r5
 8018832:	0c24      	lsrs	r4, r4, #16
 8018834:	1909      	adds	r1, r1, r4
 8018836:	19c9      	adds	r1, r1, r7
 8018838:	040f      	lsls	r7, r1, #16
 801883a:	b29b      	uxth	r3, r3
 801883c:	433b      	orrs	r3, r7
 801883e:	6003      	str	r3, [r0, #0]
 8018840:	ce80      	ldmia	r6!, {r7}
 8018842:	6843      	ldr	r3, [r0, #4]
 8018844:	0c3f      	lsrs	r7, r7, #16
 8018846:	436f      	muls	r7, r5
 8018848:	b29b      	uxth	r3, r3
 801884a:	18fb      	adds	r3, r7, r3
 801884c:	0c09      	lsrs	r1, r1, #16
 801884e:	185b      	adds	r3, r3, r1
 8018850:	9905      	ldr	r1, [sp, #20]
 8018852:	9006      	str	r0, [sp, #24]
 8018854:	0c1f      	lsrs	r7, r3, #16
 8018856:	3004      	adds	r0, #4
 8018858:	42b1      	cmp	r1, r6
 801885a:	d8e6      	bhi.n	801882a <__multiply+0xd6>
 801885c:	9906      	ldr	r1, [sp, #24]
 801885e:	604b      	str	r3, [r1, #4]
 8018860:	9b01      	ldr	r3, [sp, #4]
 8018862:	3204      	adds	r2, #4
 8018864:	3304      	adds	r3, #4
 8018866:	9301      	str	r3, [sp, #4]
 8018868:	e79f      	b.n	80187aa <__multiply+0x56>
 801886a:	9b02      	ldr	r3, [sp, #8]
 801886c:	3b01      	subs	r3, #1
 801886e:	9302      	str	r3, [sp, #8]
 8018870:	e79f      	b.n	80187b2 <__multiply+0x5e>
	...

08018874 <__pow5mult>:
 8018874:	2303      	movs	r3, #3
 8018876:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8018878:	4013      	ands	r3, r2
 801887a:	0006      	movs	r6, r0
 801887c:	000f      	movs	r7, r1
 801887e:	0015      	movs	r5, r2
 8018880:	2b00      	cmp	r3, #0
 8018882:	d008      	beq.n	8018896 <__pow5mult+0x22>
 8018884:	491a      	ldr	r1, [pc, #104]	; (80188f0 <__pow5mult+0x7c>)
 8018886:	3b01      	subs	r3, #1
 8018888:	009a      	lsls	r2, r3, #2
 801888a:	5852      	ldr	r2, [r2, r1]
 801888c:	2300      	movs	r3, #0
 801888e:	0039      	movs	r1, r7
 8018890:	f7ff fe92 	bl	80185b8 <__multadd>
 8018894:	0007      	movs	r7, r0
 8018896:	10ad      	asrs	r5, r5, #2
 8018898:	d027      	beq.n	80188ea <__pow5mult+0x76>
 801889a:	6cb4      	ldr	r4, [r6, #72]	; 0x48
 801889c:	2c00      	cmp	r4, #0
 801889e:	d107      	bne.n	80188b0 <__pow5mult+0x3c>
 80188a0:	4914      	ldr	r1, [pc, #80]	; (80188f4 <__pow5mult+0x80>)
 80188a2:	0030      	movs	r0, r6
 80188a4:	f7ff ff4d 	bl	8018742 <__i2b>
 80188a8:	2300      	movs	r3, #0
 80188aa:	0004      	movs	r4, r0
 80188ac:	64b0      	str	r0, [r6, #72]	; 0x48
 80188ae:	6003      	str	r3, [r0, #0]
 80188b0:	2301      	movs	r3, #1
 80188b2:	421d      	tst	r5, r3
 80188b4:	d00a      	beq.n	80188cc <__pow5mult+0x58>
 80188b6:	0039      	movs	r1, r7
 80188b8:	0022      	movs	r2, r4
 80188ba:	0030      	movs	r0, r6
 80188bc:	f7ff ff4a 	bl	8018754 <__multiply>
 80188c0:	0039      	movs	r1, r7
 80188c2:	9001      	str	r0, [sp, #4]
 80188c4:	0030      	movs	r0, r6
 80188c6:	f7ff fe6d 	bl	80185a4 <_Bfree>
 80188ca:	9f01      	ldr	r7, [sp, #4]
 80188cc:	106d      	asrs	r5, r5, #1
 80188ce:	d00c      	beq.n	80188ea <__pow5mult+0x76>
 80188d0:	6820      	ldr	r0, [r4, #0]
 80188d2:	2800      	cmp	r0, #0
 80188d4:	d107      	bne.n	80188e6 <__pow5mult+0x72>
 80188d6:	0022      	movs	r2, r4
 80188d8:	0021      	movs	r1, r4
 80188da:	0030      	movs	r0, r6
 80188dc:	f7ff ff3a 	bl	8018754 <__multiply>
 80188e0:	2300      	movs	r3, #0
 80188e2:	6020      	str	r0, [r4, #0]
 80188e4:	6003      	str	r3, [r0, #0]
 80188e6:	0004      	movs	r4, r0
 80188e8:	e7e2      	b.n	80188b0 <__pow5mult+0x3c>
 80188ea:	0038      	movs	r0, r7
 80188ec:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80188ee:	46c0      	nop			; (mov r8, r8)
 80188f0:	0801c828 	.word	0x0801c828
 80188f4:	00000271 	.word	0x00000271

080188f8 <__lshift>:
 80188f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80188fa:	000d      	movs	r5, r1
 80188fc:	0017      	movs	r7, r2
 80188fe:	692b      	ldr	r3, [r5, #16]
 8018900:	1154      	asrs	r4, r2, #5
 8018902:	b085      	sub	sp, #20
 8018904:	18e3      	adds	r3, r4, r3
 8018906:	9301      	str	r3, [sp, #4]
 8018908:	3301      	adds	r3, #1
 801890a:	9300      	str	r3, [sp, #0]
 801890c:	6849      	ldr	r1, [r1, #4]
 801890e:	68ab      	ldr	r3, [r5, #8]
 8018910:	9002      	str	r0, [sp, #8]
 8018912:	9a00      	ldr	r2, [sp, #0]
 8018914:	4293      	cmp	r3, r2
 8018916:	db35      	blt.n	8018984 <__lshift+0x8c>
 8018918:	9802      	ldr	r0, [sp, #8]
 801891a:	f7ff fe1b 	bl	8018554 <_Balloc>
 801891e:	2300      	movs	r3, #0
 8018920:	0002      	movs	r2, r0
 8018922:	0006      	movs	r6, r0
 8018924:	0019      	movs	r1, r3
 8018926:	3214      	adds	r2, #20
 8018928:	42a3      	cmp	r3, r4
 801892a:	db2e      	blt.n	801898a <__lshift+0x92>
 801892c:	43e3      	mvns	r3, r4
 801892e:	17db      	asrs	r3, r3, #31
 8018930:	401c      	ands	r4, r3
 8018932:	002b      	movs	r3, r5
 8018934:	00a4      	lsls	r4, r4, #2
 8018936:	1914      	adds	r4, r2, r4
 8018938:	692a      	ldr	r2, [r5, #16]
 801893a:	3314      	adds	r3, #20
 801893c:	0092      	lsls	r2, r2, #2
 801893e:	189a      	adds	r2, r3, r2
 8018940:	4694      	mov	ip, r2
 8018942:	221f      	movs	r2, #31
 8018944:	4017      	ands	r7, r2
 8018946:	d024      	beq.n	8018992 <__lshift+0x9a>
 8018948:	3201      	adds	r2, #1
 801894a:	1bd2      	subs	r2, r2, r7
 801894c:	9203      	str	r2, [sp, #12]
 801894e:	2200      	movs	r2, #0
 8018950:	6819      	ldr	r1, [r3, #0]
 8018952:	0020      	movs	r0, r4
 8018954:	40b9      	lsls	r1, r7
 8018956:	430a      	orrs	r2, r1
 8018958:	c404      	stmia	r4!, {r2}
 801895a:	cb04      	ldmia	r3!, {r2}
 801895c:	9903      	ldr	r1, [sp, #12]
 801895e:	40ca      	lsrs	r2, r1
 8018960:	459c      	cmp	ip, r3
 8018962:	d8f5      	bhi.n	8018950 <__lshift+0x58>
 8018964:	6042      	str	r2, [r0, #4]
 8018966:	2a00      	cmp	r2, #0
 8018968:	d002      	beq.n	8018970 <__lshift+0x78>
 801896a:	9b01      	ldr	r3, [sp, #4]
 801896c:	3302      	adds	r3, #2
 801896e:	9300      	str	r3, [sp, #0]
 8018970:	9b00      	ldr	r3, [sp, #0]
 8018972:	9802      	ldr	r0, [sp, #8]
 8018974:	3b01      	subs	r3, #1
 8018976:	6133      	str	r3, [r6, #16]
 8018978:	0029      	movs	r1, r5
 801897a:	f7ff fe13 	bl	80185a4 <_Bfree>
 801897e:	0030      	movs	r0, r6
 8018980:	b005      	add	sp, #20
 8018982:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018984:	3101      	adds	r1, #1
 8018986:	005b      	lsls	r3, r3, #1
 8018988:	e7c3      	b.n	8018912 <__lshift+0x1a>
 801898a:	0098      	lsls	r0, r3, #2
 801898c:	5011      	str	r1, [r2, r0]
 801898e:	3301      	adds	r3, #1
 8018990:	e7ca      	b.n	8018928 <__lshift+0x30>
 8018992:	cb04      	ldmia	r3!, {r2}
 8018994:	c404      	stmia	r4!, {r2}
 8018996:	459c      	cmp	ip, r3
 8018998:	d8fb      	bhi.n	8018992 <__lshift+0x9a>
 801899a:	e7e9      	b.n	8018970 <__lshift+0x78>

0801899c <__mcmp>:
 801899c:	690a      	ldr	r2, [r1, #16]
 801899e:	6903      	ldr	r3, [r0, #16]
 80189a0:	b530      	push	{r4, r5, lr}
 80189a2:	1a9b      	subs	r3, r3, r2
 80189a4:	d10d      	bne.n	80189c2 <__mcmp+0x26>
 80189a6:	0092      	lsls	r2, r2, #2
 80189a8:	3014      	adds	r0, #20
 80189aa:	3114      	adds	r1, #20
 80189ac:	1884      	adds	r4, r0, r2
 80189ae:	1889      	adds	r1, r1, r2
 80189b0:	3c04      	subs	r4, #4
 80189b2:	3904      	subs	r1, #4
 80189b4:	6825      	ldr	r5, [r4, #0]
 80189b6:	680a      	ldr	r2, [r1, #0]
 80189b8:	4295      	cmp	r5, r2
 80189ba:	d004      	beq.n	80189c6 <__mcmp+0x2a>
 80189bc:	2301      	movs	r3, #1
 80189be:	4295      	cmp	r5, r2
 80189c0:	d304      	bcc.n	80189cc <__mcmp+0x30>
 80189c2:	0018      	movs	r0, r3
 80189c4:	bd30      	pop	{r4, r5, pc}
 80189c6:	42a0      	cmp	r0, r4
 80189c8:	d3f2      	bcc.n	80189b0 <__mcmp+0x14>
 80189ca:	e7fa      	b.n	80189c2 <__mcmp+0x26>
 80189cc:	425b      	negs	r3, r3
 80189ce:	e7f8      	b.n	80189c2 <__mcmp+0x26>

080189d0 <__mdiff>:
 80189d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80189d2:	000d      	movs	r5, r1
 80189d4:	b085      	sub	sp, #20
 80189d6:	0007      	movs	r7, r0
 80189d8:	0011      	movs	r1, r2
 80189da:	0028      	movs	r0, r5
 80189dc:	0014      	movs	r4, r2
 80189de:	f7ff ffdd 	bl	801899c <__mcmp>
 80189e2:	1e06      	subs	r6, r0, #0
 80189e4:	d108      	bne.n	80189f8 <__mdiff+0x28>
 80189e6:	0001      	movs	r1, r0
 80189e8:	0038      	movs	r0, r7
 80189ea:	f7ff fdb3 	bl	8018554 <_Balloc>
 80189ee:	2301      	movs	r3, #1
 80189f0:	6146      	str	r6, [r0, #20]
 80189f2:	6103      	str	r3, [r0, #16]
 80189f4:	b005      	add	sp, #20
 80189f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80189f8:	2301      	movs	r3, #1
 80189fa:	9301      	str	r3, [sp, #4]
 80189fc:	2800      	cmp	r0, #0
 80189fe:	db04      	blt.n	8018a0a <__mdiff+0x3a>
 8018a00:	0023      	movs	r3, r4
 8018a02:	002c      	movs	r4, r5
 8018a04:	001d      	movs	r5, r3
 8018a06:	2300      	movs	r3, #0
 8018a08:	9301      	str	r3, [sp, #4]
 8018a0a:	6861      	ldr	r1, [r4, #4]
 8018a0c:	0038      	movs	r0, r7
 8018a0e:	f7ff fda1 	bl	8018554 <_Balloc>
 8018a12:	002f      	movs	r7, r5
 8018a14:	2200      	movs	r2, #0
 8018a16:	9b01      	ldr	r3, [sp, #4]
 8018a18:	6926      	ldr	r6, [r4, #16]
 8018a1a:	60c3      	str	r3, [r0, #12]
 8018a1c:	3414      	adds	r4, #20
 8018a1e:	00b3      	lsls	r3, r6, #2
 8018a20:	18e3      	adds	r3, r4, r3
 8018a22:	9302      	str	r3, [sp, #8]
 8018a24:	692b      	ldr	r3, [r5, #16]
 8018a26:	3714      	adds	r7, #20
 8018a28:	009b      	lsls	r3, r3, #2
 8018a2a:	18fb      	adds	r3, r7, r3
 8018a2c:	9303      	str	r3, [sp, #12]
 8018a2e:	0003      	movs	r3, r0
 8018a30:	4694      	mov	ip, r2
 8018a32:	3314      	adds	r3, #20
 8018a34:	cc20      	ldmia	r4!, {r5}
 8018a36:	cf04      	ldmia	r7!, {r2}
 8018a38:	9201      	str	r2, [sp, #4]
 8018a3a:	b2aa      	uxth	r2, r5
 8018a3c:	4494      	add	ip, r2
 8018a3e:	466a      	mov	r2, sp
 8018a40:	4661      	mov	r1, ip
 8018a42:	8892      	ldrh	r2, [r2, #4]
 8018a44:	0c2d      	lsrs	r5, r5, #16
 8018a46:	1a8a      	subs	r2, r1, r2
 8018a48:	9901      	ldr	r1, [sp, #4]
 8018a4a:	0c09      	lsrs	r1, r1, #16
 8018a4c:	1a69      	subs	r1, r5, r1
 8018a4e:	1415      	asrs	r5, r2, #16
 8018a50:	1949      	adds	r1, r1, r5
 8018a52:	140d      	asrs	r5, r1, #16
 8018a54:	b292      	uxth	r2, r2
 8018a56:	0409      	lsls	r1, r1, #16
 8018a58:	430a      	orrs	r2, r1
 8018a5a:	601a      	str	r2, [r3, #0]
 8018a5c:	9a03      	ldr	r2, [sp, #12]
 8018a5e:	46ac      	mov	ip, r5
 8018a60:	3304      	adds	r3, #4
 8018a62:	42ba      	cmp	r2, r7
 8018a64:	d8e6      	bhi.n	8018a34 <__mdiff+0x64>
 8018a66:	9902      	ldr	r1, [sp, #8]
 8018a68:	001a      	movs	r2, r3
 8018a6a:	428c      	cmp	r4, r1
 8018a6c:	d305      	bcc.n	8018a7a <__mdiff+0xaa>
 8018a6e:	3a04      	subs	r2, #4
 8018a70:	6813      	ldr	r3, [r2, #0]
 8018a72:	2b00      	cmp	r3, #0
 8018a74:	d00e      	beq.n	8018a94 <__mdiff+0xc4>
 8018a76:	6106      	str	r6, [r0, #16]
 8018a78:	e7bc      	b.n	80189f4 <__mdiff+0x24>
 8018a7a:	cc04      	ldmia	r4!, {r2}
 8018a7c:	b291      	uxth	r1, r2
 8018a7e:	4461      	add	r1, ip
 8018a80:	140d      	asrs	r5, r1, #16
 8018a82:	0c12      	lsrs	r2, r2, #16
 8018a84:	1952      	adds	r2, r2, r5
 8018a86:	1415      	asrs	r5, r2, #16
 8018a88:	b289      	uxth	r1, r1
 8018a8a:	0412      	lsls	r2, r2, #16
 8018a8c:	430a      	orrs	r2, r1
 8018a8e:	46ac      	mov	ip, r5
 8018a90:	c304      	stmia	r3!, {r2}
 8018a92:	e7e8      	b.n	8018a66 <__mdiff+0x96>
 8018a94:	3e01      	subs	r6, #1
 8018a96:	e7ea      	b.n	8018a6e <__mdiff+0x9e>

08018a98 <__ulp>:
 8018a98:	000b      	movs	r3, r1
 8018a9a:	4910      	ldr	r1, [pc, #64]	; (8018adc <__ulp+0x44>)
 8018a9c:	b510      	push	{r4, lr}
 8018a9e:	4019      	ands	r1, r3
 8018aa0:	4b0f      	ldr	r3, [pc, #60]	; (8018ae0 <__ulp+0x48>)
 8018aa2:	18c9      	adds	r1, r1, r3
 8018aa4:	2900      	cmp	r1, #0
 8018aa6:	dd04      	ble.n	8018ab2 <__ulp+0x1a>
 8018aa8:	2200      	movs	r2, #0
 8018aaa:	000b      	movs	r3, r1
 8018aac:	0010      	movs	r0, r2
 8018aae:	0019      	movs	r1, r3
 8018ab0:	bd10      	pop	{r4, pc}
 8018ab2:	4249      	negs	r1, r1
 8018ab4:	1509      	asrs	r1, r1, #20
 8018ab6:	2200      	movs	r2, #0
 8018ab8:	2300      	movs	r3, #0
 8018aba:	2913      	cmp	r1, #19
 8018abc:	dc04      	bgt.n	8018ac8 <__ulp+0x30>
 8018abe:	2080      	movs	r0, #128	; 0x80
 8018ac0:	0300      	lsls	r0, r0, #12
 8018ac2:	4108      	asrs	r0, r1
 8018ac4:	0003      	movs	r3, r0
 8018ac6:	e7f1      	b.n	8018aac <__ulp+0x14>
 8018ac8:	3914      	subs	r1, #20
 8018aca:	2001      	movs	r0, #1
 8018acc:	291e      	cmp	r1, #30
 8018ace:	dc02      	bgt.n	8018ad6 <__ulp+0x3e>
 8018ad0:	241f      	movs	r4, #31
 8018ad2:	1a61      	subs	r1, r4, r1
 8018ad4:	4088      	lsls	r0, r1
 8018ad6:	0002      	movs	r2, r0
 8018ad8:	e7e8      	b.n	8018aac <__ulp+0x14>
 8018ada:	46c0      	nop			; (mov r8, r8)
 8018adc:	7ff00000 	.word	0x7ff00000
 8018ae0:	fcc00000 	.word	0xfcc00000

08018ae4 <__b2d>:
 8018ae4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8018ae6:	0006      	movs	r6, r0
 8018ae8:	6903      	ldr	r3, [r0, #16]
 8018aea:	3614      	adds	r6, #20
 8018aec:	009b      	lsls	r3, r3, #2
 8018aee:	18f3      	adds	r3, r6, r3
 8018af0:	1f1d      	subs	r5, r3, #4
 8018af2:	682c      	ldr	r4, [r5, #0]
 8018af4:	000f      	movs	r7, r1
 8018af6:	0020      	movs	r0, r4
 8018af8:	9301      	str	r3, [sp, #4]
 8018afa:	f7ff fdd9 	bl	80186b0 <__hi0bits>
 8018afe:	2320      	movs	r3, #32
 8018b00:	1a1b      	subs	r3, r3, r0
 8018b02:	603b      	str	r3, [r7, #0]
 8018b04:	491c      	ldr	r1, [pc, #112]	; (8018b78 <__b2d+0x94>)
 8018b06:	280a      	cmp	r0, #10
 8018b08:	dc16      	bgt.n	8018b38 <__b2d+0x54>
 8018b0a:	230b      	movs	r3, #11
 8018b0c:	0027      	movs	r7, r4
 8018b0e:	1a1b      	subs	r3, r3, r0
 8018b10:	40df      	lsrs	r7, r3
 8018b12:	4339      	orrs	r1, r7
 8018b14:	469c      	mov	ip, r3
 8018b16:	000b      	movs	r3, r1
 8018b18:	2100      	movs	r1, #0
 8018b1a:	42ae      	cmp	r6, r5
 8018b1c:	d202      	bcs.n	8018b24 <__b2d+0x40>
 8018b1e:	9901      	ldr	r1, [sp, #4]
 8018b20:	3908      	subs	r1, #8
 8018b22:	6809      	ldr	r1, [r1, #0]
 8018b24:	3015      	adds	r0, #21
 8018b26:	4084      	lsls	r4, r0
 8018b28:	4660      	mov	r0, ip
 8018b2a:	40c1      	lsrs	r1, r0
 8018b2c:	430c      	orrs	r4, r1
 8018b2e:	0022      	movs	r2, r4
 8018b30:	0010      	movs	r0, r2
 8018b32:	0019      	movs	r1, r3
 8018b34:	b003      	add	sp, #12
 8018b36:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018b38:	2700      	movs	r7, #0
 8018b3a:	42ae      	cmp	r6, r5
 8018b3c:	d202      	bcs.n	8018b44 <__b2d+0x60>
 8018b3e:	9d01      	ldr	r5, [sp, #4]
 8018b40:	3d08      	subs	r5, #8
 8018b42:	682f      	ldr	r7, [r5, #0]
 8018b44:	380b      	subs	r0, #11
 8018b46:	4684      	mov	ip, r0
 8018b48:	1e03      	subs	r3, r0, #0
 8018b4a:	d012      	beq.n	8018b72 <__b2d+0x8e>
 8018b4c:	409c      	lsls	r4, r3
 8018b4e:	2020      	movs	r0, #32
 8018b50:	4321      	orrs	r1, r4
 8018b52:	003c      	movs	r4, r7
 8018b54:	1ac0      	subs	r0, r0, r3
 8018b56:	40c4      	lsrs	r4, r0
 8018b58:	4321      	orrs	r1, r4
 8018b5a:	000b      	movs	r3, r1
 8018b5c:	2100      	movs	r1, #0
 8018b5e:	42b5      	cmp	r5, r6
 8018b60:	d901      	bls.n	8018b66 <__b2d+0x82>
 8018b62:	3d04      	subs	r5, #4
 8018b64:	6829      	ldr	r1, [r5, #0]
 8018b66:	4664      	mov	r4, ip
 8018b68:	40c1      	lsrs	r1, r0
 8018b6a:	40a7      	lsls	r7, r4
 8018b6c:	430f      	orrs	r7, r1
 8018b6e:	003a      	movs	r2, r7
 8018b70:	e7de      	b.n	8018b30 <__b2d+0x4c>
 8018b72:	4321      	orrs	r1, r4
 8018b74:	000b      	movs	r3, r1
 8018b76:	e7fa      	b.n	8018b6e <__b2d+0x8a>
 8018b78:	3ff00000 	.word	0x3ff00000

08018b7c <__d2b>:
 8018b7c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8018b7e:	001d      	movs	r5, r3
 8018b80:	2101      	movs	r1, #1
 8018b82:	0014      	movs	r4, r2
 8018b84:	9f08      	ldr	r7, [sp, #32]
 8018b86:	f7ff fce5 	bl	8018554 <_Balloc>
 8018b8a:	032b      	lsls	r3, r5, #12
 8018b8c:	006d      	lsls	r5, r5, #1
 8018b8e:	0006      	movs	r6, r0
 8018b90:	0b1b      	lsrs	r3, r3, #12
 8018b92:	0d6d      	lsrs	r5, r5, #21
 8018b94:	d124      	bne.n	8018be0 <__d2b+0x64>
 8018b96:	9301      	str	r3, [sp, #4]
 8018b98:	2c00      	cmp	r4, #0
 8018b9a:	d027      	beq.n	8018bec <__d2b+0x70>
 8018b9c:	4668      	mov	r0, sp
 8018b9e:	9400      	str	r4, [sp, #0]
 8018ba0:	f7ff fda0 	bl	80186e4 <__lo0bits>
 8018ba4:	9c00      	ldr	r4, [sp, #0]
 8018ba6:	2800      	cmp	r0, #0
 8018ba8:	d01e      	beq.n	8018be8 <__d2b+0x6c>
 8018baa:	9b01      	ldr	r3, [sp, #4]
 8018bac:	2120      	movs	r1, #32
 8018bae:	001a      	movs	r2, r3
 8018bb0:	1a09      	subs	r1, r1, r0
 8018bb2:	408a      	lsls	r2, r1
 8018bb4:	40c3      	lsrs	r3, r0
 8018bb6:	4322      	orrs	r2, r4
 8018bb8:	6172      	str	r2, [r6, #20]
 8018bba:	9301      	str	r3, [sp, #4]
 8018bbc:	9c01      	ldr	r4, [sp, #4]
 8018bbe:	61b4      	str	r4, [r6, #24]
 8018bc0:	1e63      	subs	r3, r4, #1
 8018bc2:	419c      	sbcs	r4, r3
 8018bc4:	3401      	adds	r4, #1
 8018bc6:	6134      	str	r4, [r6, #16]
 8018bc8:	2d00      	cmp	r5, #0
 8018bca:	d018      	beq.n	8018bfe <__d2b+0x82>
 8018bcc:	4b12      	ldr	r3, [pc, #72]	; (8018c18 <__d2b+0x9c>)
 8018bce:	18ed      	adds	r5, r5, r3
 8018bd0:	2335      	movs	r3, #53	; 0x35
 8018bd2:	182d      	adds	r5, r5, r0
 8018bd4:	603d      	str	r5, [r7, #0]
 8018bd6:	1a18      	subs	r0, r3, r0
 8018bd8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8018bda:	6018      	str	r0, [r3, #0]
 8018bdc:	0030      	movs	r0, r6
 8018bde:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8018be0:	2280      	movs	r2, #128	; 0x80
 8018be2:	0352      	lsls	r2, r2, #13
 8018be4:	4313      	orrs	r3, r2
 8018be6:	e7d6      	b.n	8018b96 <__d2b+0x1a>
 8018be8:	6174      	str	r4, [r6, #20]
 8018bea:	e7e7      	b.n	8018bbc <__d2b+0x40>
 8018bec:	a801      	add	r0, sp, #4
 8018bee:	f7ff fd79 	bl	80186e4 <__lo0bits>
 8018bf2:	2401      	movs	r4, #1
 8018bf4:	9b01      	ldr	r3, [sp, #4]
 8018bf6:	6134      	str	r4, [r6, #16]
 8018bf8:	6173      	str	r3, [r6, #20]
 8018bfa:	3020      	adds	r0, #32
 8018bfc:	e7e4      	b.n	8018bc8 <__d2b+0x4c>
 8018bfe:	4b07      	ldr	r3, [pc, #28]	; (8018c1c <__d2b+0xa0>)
 8018c00:	18c0      	adds	r0, r0, r3
 8018c02:	4b07      	ldr	r3, [pc, #28]	; (8018c20 <__d2b+0xa4>)
 8018c04:	6038      	str	r0, [r7, #0]
 8018c06:	18e3      	adds	r3, r4, r3
 8018c08:	009b      	lsls	r3, r3, #2
 8018c0a:	18f3      	adds	r3, r6, r3
 8018c0c:	6958      	ldr	r0, [r3, #20]
 8018c0e:	f7ff fd4f 	bl	80186b0 <__hi0bits>
 8018c12:	0164      	lsls	r4, r4, #5
 8018c14:	1a20      	subs	r0, r4, r0
 8018c16:	e7df      	b.n	8018bd8 <__d2b+0x5c>
 8018c18:	fffffbcd 	.word	0xfffffbcd
 8018c1c:	fffffbce 	.word	0xfffffbce
 8018c20:	3fffffff 	.word	0x3fffffff

08018c24 <__ratio>:
 8018c24:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018c26:	b085      	sub	sp, #20
 8018c28:	000f      	movs	r7, r1
 8018c2a:	a902      	add	r1, sp, #8
 8018c2c:	0006      	movs	r6, r0
 8018c2e:	f7ff ff59 	bl	8018ae4 <__b2d>
 8018c32:	0004      	movs	r4, r0
 8018c34:	000d      	movs	r5, r1
 8018c36:	0038      	movs	r0, r7
 8018c38:	a903      	add	r1, sp, #12
 8018c3a:	9400      	str	r4, [sp, #0]
 8018c3c:	9501      	str	r5, [sp, #4]
 8018c3e:	f7ff ff51 	bl	8018ae4 <__b2d>
 8018c42:	6936      	ldr	r6, [r6, #16]
 8018c44:	693f      	ldr	r7, [r7, #16]
 8018c46:	0002      	movs	r2, r0
 8018c48:	1bf7      	subs	r7, r6, r7
 8018c4a:	017e      	lsls	r6, r7, #5
 8018c4c:	46b4      	mov	ip, r6
 8018c4e:	9f03      	ldr	r7, [sp, #12]
 8018c50:	9e02      	ldr	r6, [sp, #8]
 8018c52:	000b      	movs	r3, r1
 8018c54:	1bf6      	subs	r6, r6, r7
 8018c56:	4466      	add	r6, ip
 8018c58:	0537      	lsls	r7, r6, #20
 8018c5a:	2e00      	cmp	r6, #0
 8018c5c:	dd07      	ble.n	8018c6e <__ratio+0x4a>
 8018c5e:	1979      	adds	r1, r7, r5
 8018c60:	9101      	str	r1, [sp, #4]
 8018c62:	9800      	ldr	r0, [sp, #0]
 8018c64:	9901      	ldr	r1, [sp, #4]
 8018c66:	f7e8 fc9b 	bl	80015a0 <__aeabi_ddiv>
 8018c6a:	b005      	add	sp, #20
 8018c6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018c6e:	1bcb      	subs	r3, r1, r7
 8018c70:	e7f7      	b.n	8018c62 <__ratio+0x3e>

08018c72 <__copybits>:
 8018c72:	0013      	movs	r3, r2
 8018c74:	3901      	subs	r1, #1
 8018c76:	b510      	push	{r4, lr}
 8018c78:	1149      	asrs	r1, r1, #5
 8018c7a:	6912      	ldr	r2, [r2, #16]
 8018c7c:	3101      	adds	r1, #1
 8018c7e:	0089      	lsls	r1, r1, #2
 8018c80:	3314      	adds	r3, #20
 8018c82:	0092      	lsls	r2, r2, #2
 8018c84:	1841      	adds	r1, r0, r1
 8018c86:	189a      	adds	r2, r3, r2
 8018c88:	429a      	cmp	r2, r3
 8018c8a:	d803      	bhi.n	8018c94 <__copybits+0x22>
 8018c8c:	2300      	movs	r3, #0
 8018c8e:	4281      	cmp	r1, r0
 8018c90:	d803      	bhi.n	8018c9a <__copybits+0x28>
 8018c92:	bd10      	pop	{r4, pc}
 8018c94:	cb10      	ldmia	r3!, {r4}
 8018c96:	c010      	stmia	r0!, {r4}
 8018c98:	e7f6      	b.n	8018c88 <__copybits+0x16>
 8018c9a:	c008      	stmia	r0!, {r3}
 8018c9c:	e7f7      	b.n	8018c8e <__copybits+0x1c>

08018c9e <__any_on>:
 8018c9e:	0002      	movs	r2, r0
 8018ca0:	6900      	ldr	r0, [r0, #16]
 8018ca2:	b510      	push	{r4, lr}
 8018ca4:	3214      	adds	r2, #20
 8018ca6:	114b      	asrs	r3, r1, #5
 8018ca8:	4298      	cmp	r0, r3
 8018caa:	db12      	blt.n	8018cd2 <__any_on+0x34>
 8018cac:	dd0b      	ble.n	8018cc6 <__any_on+0x28>
 8018cae:	201f      	movs	r0, #31
 8018cb0:	4001      	ands	r1, r0
 8018cb2:	d008      	beq.n	8018cc6 <__any_on+0x28>
 8018cb4:	0098      	lsls	r0, r3, #2
 8018cb6:	5884      	ldr	r4, [r0, r2]
 8018cb8:	0020      	movs	r0, r4
 8018cba:	40c8      	lsrs	r0, r1
 8018cbc:	4088      	lsls	r0, r1
 8018cbe:	0001      	movs	r1, r0
 8018cc0:	2001      	movs	r0, #1
 8018cc2:	428c      	cmp	r4, r1
 8018cc4:	d104      	bne.n	8018cd0 <__any_on+0x32>
 8018cc6:	009b      	lsls	r3, r3, #2
 8018cc8:	18d3      	adds	r3, r2, r3
 8018cca:	4293      	cmp	r3, r2
 8018ccc:	d803      	bhi.n	8018cd6 <__any_on+0x38>
 8018cce:	2000      	movs	r0, #0
 8018cd0:	bd10      	pop	{r4, pc}
 8018cd2:	0003      	movs	r3, r0
 8018cd4:	e7f7      	b.n	8018cc6 <__any_on+0x28>
 8018cd6:	3b04      	subs	r3, #4
 8018cd8:	6819      	ldr	r1, [r3, #0]
 8018cda:	2900      	cmp	r1, #0
 8018cdc:	d0f5      	beq.n	8018cca <__any_on+0x2c>
 8018cde:	2001      	movs	r0, #1
 8018ce0:	e7f6      	b.n	8018cd0 <__any_on+0x32>
	...

08018ce4 <frexp>:
 8018ce4:	b570      	push	{r4, r5, r6, lr}
 8018ce6:	0014      	movs	r4, r2
 8018ce8:	2500      	movs	r5, #0
 8018cea:	6025      	str	r5, [r4, #0]
 8018cec:	4d10      	ldr	r5, [pc, #64]	; (8018d30 <frexp+0x4c>)
 8018cee:	004b      	lsls	r3, r1, #1
 8018cf0:	000a      	movs	r2, r1
 8018cf2:	085b      	lsrs	r3, r3, #1
 8018cf4:	42ab      	cmp	r3, r5
 8018cf6:	dc1a      	bgt.n	8018d2e <frexp+0x4a>
 8018cf8:	001d      	movs	r5, r3
 8018cfa:	4305      	orrs	r5, r0
 8018cfc:	d017      	beq.n	8018d2e <frexp+0x4a>
 8018cfe:	4d0d      	ldr	r5, [pc, #52]	; (8018d34 <frexp+0x50>)
 8018d00:	42ab      	cmp	r3, r5
 8018d02:	dc09      	bgt.n	8018d18 <frexp+0x34>
 8018d04:	2200      	movs	r2, #0
 8018d06:	4b0c      	ldr	r3, [pc, #48]	; (8018d38 <frexp+0x54>)
 8018d08:	f7e9 f854 	bl	8001db4 <__aeabi_dmul>
 8018d0c:	2536      	movs	r5, #54	; 0x36
 8018d0e:	000a      	movs	r2, r1
 8018d10:	004b      	lsls	r3, r1, #1
 8018d12:	426d      	negs	r5, r5
 8018d14:	085b      	lsrs	r3, r3, #1
 8018d16:	6025      	str	r5, [r4, #0]
 8018d18:	4d08      	ldr	r5, [pc, #32]	; (8018d3c <frexp+0x58>)
 8018d1a:	151b      	asrs	r3, r3, #20
 8018d1c:	195b      	adds	r3, r3, r5
 8018d1e:	6825      	ldr	r5, [r4, #0]
 8018d20:	18eb      	adds	r3, r5, r3
 8018d22:	6023      	str	r3, [r4, #0]
 8018d24:	4b06      	ldr	r3, [pc, #24]	; (8018d40 <frexp+0x5c>)
 8018d26:	401a      	ands	r2, r3
 8018d28:	4b06      	ldr	r3, [pc, #24]	; (8018d44 <frexp+0x60>)
 8018d2a:	4313      	orrs	r3, r2
 8018d2c:	0019      	movs	r1, r3
 8018d2e:	bd70      	pop	{r4, r5, r6, pc}
 8018d30:	7fefffff 	.word	0x7fefffff
 8018d34:	000fffff 	.word	0x000fffff
 8018d38:	43500000 	.word	0x43500000
 8018d3c:	fffffc02 	.word	0xfffffc02
 8018d40:	800fffff 	.word	0x800fffff
 8018d44:	3fe00000 	.word	0x3fe00000

08018d48 <__ssprint_r>:
 8018d48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018d4a:	6893      	ldr	r3, [r2, #8]
 8018d4c:	b087      	sub	sp, #28
 8018d4e:	9002      	str	r0, [sp, #8]
 8018d50:	000c      	movs	r4, r1
 8018d52:	0016      	movs	r6, r2
 8018d54:	2b00      	cmp	r3, #0
 8018d56:	d063      	beq.n	8018e20 <__ssprint_r+0xd8>
 8018d58:	6813      	ldr	r3, [r2, #0]
 8018d5a:	9303      	str	r3, [sp, #12]
 8018d5c:	2300      	movs	r3, #0
 8018d5e:	001f      	movs	r7, r3
 8018d60:	9305      	str	r3, [sp, #20]
 8018d62:	2f00      	cmp	r7, #0
 8018d64:	d02e      	beq.n	8018dc4 <__ssprint_r+0x7c>
 8018d66:	68a5      	ldr	r5, [r4, #8]
 8018d68:	42af      	cmp	r7, r5
 8018d6a:	d347      	bcc.n	8018dfc <__ssprint_r+0xb4>
 8018d6c:	2390      	movs	r3, #144	; 0x90
 8018d6e:	89a2      	ldrh	r2, [r4, #12]
 8018d70:	00db      	lsls	r3, r3, #3
 8018d72:	421a      	tst	r2, r3
 8018d74:	d042      	beq.n	8018dfc <__ssprint_r+0xb4>
 8018d76:	2003      	movs	r0, #3
 8018d78:	6921      	ldr	r1, [r4, #16]
 8018d7a:	6823      	ldr	r3, [r4, #0]
 8018d7c:	1a5b      	subs	r3, r3, r1
 8018d7e:	9304      	str	r3, [sp, #16]
 8018d80:	6963      	ldr	r3, [r4, #20]
 8018d82:	4343      	muls	r3, r0
 8018d84:	0fd8      	lsrs	r0, r3, #31
 8018d86:	18c3      	adds	r3, r0, r3
 8018d88:	105b      	asrs	r3, r3, #1
 8018d8a:	9301      	str	r3, [sp, #4]
 8018d8c:	9b04      	ldr	r3, [sp, #16]
 8018d8e:	9801      	ldr	r0, [sp, #4]
 8018d90:	3301      	adds	r3, #1
 8018d92:	19db      	adds	r3, r3, r7
 8018d94:	4283      	cmp	r3, r0
 8018d96:	d900      	bls.n	8018d9a <__ssprint_r+0x52>
 8018d98:	9301      	str	r3, [sp, #4]
 8018d9a:	0553      	lsls	r3, r2, #21
 8018d9c:	d544      	bpl.n	8018e28 <__ssprint_r+0xe0>
 8018d9e:	9901      	ldr	r1, [sp, #4]
 8018da0:	9802      	ldr	r0, [sp, #8]
 8018da2:	f7fb fa2d 	bl	8014200 <_malloc_r>
 8018da6:	1e05      	subs	r5, r0, #0
 8018da8:	d114      	bne.n	8018dd4 <__ssprint_r+0x8c>
 8018daa:	230c      	movs	r3, #12
 8018dac:	9a02      	ldr	r2, [sp, #8]
 8018dae:	2001      	movs	r0, #1
 8018db0:	6013      	str	r3, [r2, #0]
 8018db2:	2340      	movs	r3, #64	; 0x40
 8018db4:	89a2      	ldrh	r2, [r4, #12]
 8018db6:	4240      	negs	r0, r0
 8018db8:	4313      	orrs	r3, r2
 8018dba:	81a3      	strh	r3, [r4, #12]
 8018dbc:	2300      	movs	r3, #0
 8018dbe:	60b3      	str	r3, [r6, #8]
 8018dc0:	6073      	str	r3, [r6, #4]
 8018dc2:	e02f      	b.n	8018e24 <__ssprint_r+0xdc>
 8018dc4:	9b03      	ldr	r3, [sp, #12]
 8018dc6:	681b      	ldr	r3, [r3, #0]
 8018dc8:	9305      	str	r3, [sp, #20]
 8018dca:	9b03      	ldr	r3, [sp, #12]
 8018dcc:	685f      	ldr	r7, [r3, #4]
 8018dce:	3308      	adds	r3, #8
 8018dd0:	9303      	str	r3, [sp, #12]
 8018dd2:	e7c6      	b.n	8018d62 <__ssprint_r+0x1a>
 8018dd4:	9a04      	ldr	r2, [sp, #16]
 8018dd6:	6921      	ldr	r1, [r4, #16]
 8018dd8:	f7fb fc3c 	bl	8014654 <memcpy>
 8018ddc:	89a3      	ldrh	r3, [r4, #12]
 8018dde:	4a18      	ldr	r2, [pc, #96]	; (8018e40 <__ssprint_r+0xf8>)
 8018de0:	401a      	ands	r2, r3
 8018de2:	2380      	movs	r3, #128	; 0x80
 8018de4:	4313      	orrs	r3, r2
 8018de6:	81a3      	strh	r3, [r4, #12]
 8018de8:	9b04      	ldr	r3, [sp, #16]
 8018dea:	6125      	str	r5, [r4, #16]
 8018dec:	18ed      	adds	r5, r5, r3
 8018dee:	6025      	str	r5, [r4, #0]
 8018df0:	003d      	movs	r5, r7
 8018df2:	9b01      	ldr	r3, [sp, #4]
 8018df4:	9a04      	ldr	r2, [sp, #16]
 8018df6:	6163      	str	r3, [r4, #20]
 8018df8:	1a9b      	subs	r3, r3, r2
 8018dfa:	60a3      	str	r3, [r4, #8]
 8018dfc:	42bd      	cmp	r5, r7
 8018dfe:	d900      	bls.n	8018e02 <__ssprint_r+0xba>
 8018e00:	003d      	movs	r5, r7
 8018e02:	002a      	movs	r2, r5
 8018e04:	9905      	ldr	r1, [sp, #20]
 8018e06:	6820      	ldr	r0, [r4, #0]
 8018e08:	f7ff fb91 	bl	801852e <memmove>
 8018e0c:	68a3      	ldr	r3, [r4, #8]
 8018e0e:	1b5b      	subs	r3, r3, r5
 8018e10:	60a3      	str	r3, [r4, #8]
 8018e12:	6823      	ldr	r3, [r4, #0]
 8018e14:	195d      	adds	r5, r3, r5
 8018e16:	68b3      	ldr	r3, [r6, #8]
 8018e18:	6025      	str	r5, [r4, #0]
 8018e1a:	1bdb      	subs	r3, r3, r7
 8018e1c:	60b3      	str	r3, [r6, #8]
 8018e1e:	d1d1      	bne.n	8018dc4 <__ssprint_r+0x7c>
 8018e20:	2000      	movs	r0, #0
 8018e22:	6070      	str	r0, [r6, #4]
 8018e24:	b007      	add	sp, #28
 8018e26:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018e28:	9a01      	ldr	r2, [sp, #4]
 8018e2a:	9802      	ldr	r0, [sp, #8]
 8018e2c:	f7fb fc58 	bl	80146e0 <_realloc_r>
 8018e30:	1e05      	subs	r5, r0, #0
 8018e32:	d1d9      	bne.n	8018de8 <__ssprint_r+0xa0>
 8018e34:	6921      	ldr	r1, [r4, #16]
 8018e36:	9802      	ldr	r0, [sp, #8]
 8018e38:	f7fe ff78 	bl	8017d2c <_free_r>
 8018e3c:	e7b5      	b.n	8018daa <__ssprint_r+0x62>
 8018e3e:	46c0      	nop			; (mov r8, r8)
 8018e40:	fffffb7f 	.word	0xfffffb7f

08018e44 <__register_exitproc>:
 8018e44:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8018e46:	4d29      	ldr	r5, [pc, #164]	; (8018eec <__register_exitproc+0xa8>)
 8018e48:	0006      	movs	r6, r0
 8018e4a:	6828      	ldr	r0, [r5, #0]
 8018e4c:	9301      	str	r3, [sp, #4]
 8018e4e:	9100      	str	r1, [sp, #0]
 8018e50:	0017      	movs	r7, r2
 8018e52:	f7ff fb5f 	bl	8018514 <__retarget_lock_acquire_recursive>
 8018e56:	4b26      	ldr	r3, [pc, #152]	; (8018ef0 <__register_exitproc+0xac>)
 8018e58:	681b      	ldr	r3, [r3, #0]
 8018e5a:	001c      	movs	r4, r3
 8018e5c:	34fc      	adds	r4, #252	; 0xfc
 8018e5e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8018e60:	2800      	cmp	r0, #0
 8018e62:	d103      	bne.n	8018e6c <__register_exitproc+0x28>
 8018e64:	334d      	adds	r3, #77	; 0x4d
 8018e66:	33ff      	adds	r3, #255	; 0xff
 8018e68:	0018      	movs	r0, r3
 8018e6a:	64e3      	str	r3, [r4, #76]	; 0x4c
 8018e6c:	6843      	ldr	r3, [r0, #4]
 8018e6e:	2b1f      	cmp	r3, #31
 8018e70:	dd18      	ble.n	8018ea4 <__register_exitproc+0x60>
 8018e72:	4b20      	ldr	r3, [pc, #128]	; (8018ef4 <__register_exitproc+0xb0>)
 8018e74:	2b00      	cmp	r3, #0
 8018e76:	d105      	bne.n	8018e84 <__register_exitproc+0x40>
 8018e78:	6828      	ldr	r0, [r5, #0]
 8018e7a:	f7ff fb4c 	bl	8018516 <__retarget_lock_release_recursive>
 8018e7e:	2001      	movs	r0, #1
 8018e80:	4240      	negs	r0, r0
 8018e82:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8018e84:	20c8      	movs	r0, #200	; 0xc8
 8018e86:	0040      	lsls	r0, r0, #1
 8018e88:	f7fb f9a6 	bl	80141d8 <malloc>
 8018e8c:	2800      	cmp	r0, #0
 8018e8e:	d0f3      	beq.n	8018e78 <__register_exitproc+0x34>
 8018e90:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8018e92:	2300      	movs	r3, #0
 8018e94:	6002      	str	r2, [r0, #0]
 8018e96:	22c4      	movs	r2, #196	; 0xc4
 8018e98:	0052      	lsls	r2, r2, #1
 8018e9a:	6043      	str	r3, [r0, #4]
 8018e9c:	64e0      	str	r0, [r4, #76]	; 0x4c
 8018e9e:	5083      	str	r3, [r0, r2]
 8018ea0:	3204      	adds	r2, #4
 8018ea2:	5083      	str	r3, [r0, r2]
 8018ea4:	6843      	ldr	r3, [r0, #4]
 8018ea6:	2e00      	cmp	r6, #0
 8018ea8:	d014      	beq.n	8018ed4 <__register_exitproc+0x90>
 8018eaa:	009a      	lsls	r2, r3, #2
 8018eac:	1882      	adds	r2, r0, r2
 8018eae:	0011      	movs	r1, r2
 8018eb0:	3188      	adds	r1, #136	; 0x88
 8018eb2:	600f      	str	r7, [r1, #0]
 8018eb4:	2101      	movs	r1, #1
 8018eb6:	0004      	movs	r4, r0
 8018eb8:	4099      	lsls	r1, r3
 8018eba:	3485      	adds	r4, #133	; 0x85
 8018ebc:	34ff      	adds	r4, #255	; 0xff
 8018ebe:	6865      	ldr	r5, [r4, #4]
 8018ec0:	32fc      	adds	r2, #252	; 0xfc
 8018ec2:	430d      	orrs	r5, r1
 8018ec4:	6065      	str	r5, [r4, #4]
 8018ec6:	9d01      	ldr	r5, [sp, #4]
 8018ec8:	60d5      	str	r5, [r2, #12]
 8018eca:	2e02      	cmp	r6, #2
 8018ecc:	d102      	bne.n	8018ed4 <__register_exitproc+0x90>
 8018ece:	68a2      	ldr	r2, [r4, #8]
 8018ed0:	4311      	orrs	r1, r2
 8018ed2:	60a1      	str	r1, [r4, #8]
 8018ed4:	1c5a      	adds	r2, r3, #1
 8018ed6:	6042      	str	r2, [r0, #4]
 8018ed8:	3302      	adds	r3, #2
 8018eda:	9a00      	ldr	r2, [sp, #0]
 8018edc:	009b      	lsls	r3, r3, #2
 8018ede:	501a      	str	r2, [r3, r0]
 8018ee0:	4b02      	ldr	r3, [pc, #8]	; (8018eec <__register_exitproc+0xa8>)
 8018ee2:	6818      	ldr	r0, [r3, #0]
 8018ee4:	f7ff fb17 	bl	8018516 <__retarget_lock_release_recursive>
 8018ee8:	2000      	movs	r0, #0
 8018eea:	e7ca      	b.n	8018e82 <__register_exitproc+0x3e>
 8018eec:	20000a7c 	.word	0x20000a7c
 8018ef0:	0801c57c 	.word	0x0801c57c
 8018ef4:	080141d9 	.word	0x080141d9

08018ef8 <_calloc_r>:
 8018ef8:	b510      	push	{r4, lr}
 8018efa:	4351      	muls	r1, r2
 8018efc:	f7fb f980 	bl	8014200 <_malloc_r>
 8018f00:	1e04      	subs	r4, r0, #0
 8018f02:	d01a      	beq.n	8018f3a <_calloc_r+0x42>
 8018f04:	0003      	movs	r3, r0
 8018f06:	3b08      	subs	r3, #8
 8018f08:	685a      	ldr	r2, [r3, #4]
 8018f0a:	2303      	movs	r3, #3
 8018f0c:	439a      	bics	r2, r3
 8018f0e:	3a04      	subs	r2, #4
 8018f10:	2a24      	cmp	r2, #36	; 0x24
 8018f12:	d819      	bhi.n	8018f48 <_calloc_r+0x50>
 8018f14:	0003      	movs	r3, r0
 8018f16:	2a13      	cmp	r2, #19
 8018f18:	d90b      	bls.n	8018f32 <_calloc_r+0x3a>
 8018f1a:	2100      	movs	r1, #0
 8018f1c:	3308      	adds	r3, #8
 8018f1e:	6001      	str	r1, [r0, #0]
 8018f20:	6041      	str	r1, [r0, #4]
 8018f22:	2a1b      	cmp	r2, #27
 8018f24:	d905      	bls.n	8018f32 <_calloc_r+0x3a>
 8018f26:	6081      	str	r1, [r0, #8]
 8018f28:	60c1      	str	r1, [r0, #12]
 8018f2a:	2a24      	cmp	r2, #36	; 0x24
 8018f2c:	d007      	beq.n	8018f3e <_calloc_r+0x46>
 8018f2e:	0003      	movs	r3, r0
 8018f30:	3310      	adds	r3, #16
 8018f32:	2200      	movs	r2, #0
 8018f34:	601a      	str	r2, [r3, #0]
 8018f36:	605a      	str	r2, [r3, #4]
 8018f38:	609a      	str	r2, [r3, #8]
 8018f3a:	0020      	movs	r0, r4
 8018f3c:	bd10      	pop	{r4, pc}
 8018f3e:	0003      	movs	r3, r0
 8018f40:	6101      	str	r1, [r0, #16]
 8018f42:	3318      	adds	r3, #24
 8018f44:	6141      	str	r1, [r0, #20]
 8018f46:	e7f4      	b.n	8018f32 <_calloc_r+0x3a>
 8018f48:	2100      	movs	r1, #0
 8018f4a:	f7fb fb8c 	bl	8014666 <memset>
 8018f4e:	e7f4      	b.n	8018f3a <_calloc_r+0x42>

08018f50 <_sbrk>:
 8018f50:	4b05      	ldr	r3, [pc, #20]	; (8018f68 <_sbrk+0x18>)
 8018f52:	0002      	movs	r2, r0
 8018f54:	6819      	ldr	r1, [r3, #0]
 8018f56:	2900      	cmp	r1, #0
 8018f58:	d101      	bne.n	8018f5e <_sbrk+0xe>
 8018f5a:	4904      	ldr	r1, [pc, #16]	; (8018f6c <_sbrk+0x1c>)
 8018f5c:	6019      	str	r1, [r3, #0]
 8018f5e:	6818      	ldr	r0, [r3, #0]
 8018f60:	1882      	adds	r2, r0, r2
 8018f62:	601a      	str	r2, [r3, #0]
 8018f64:	4770      	bx	lr
 8018f66:	46c0      	nop			; (mov r8, r8)
 8018f68:	20006ef0 	.word	0x20006ef0
 8018f6c:	20007ae8 	.word	0x20007ae8

08018f70 <_init>:
 8018f70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018f72:	46c0      	nop			; (mov r8, r8)
 8018f74:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8018f76:	bc08      	pop	{r3}
 8018f78:	469e      	mov	lr, r3
 8018f7a:	4770      	bx	lr

08018f7c <_fini>:
 8018f7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018f7e:	46c0      	nop			; (mov r8, r8)
 8018f80:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8018f82:	bc08      	pop	{r3}
 8018f84:	469e      	mov	lr, r3
 8018f86:	4770      	bx	lr
